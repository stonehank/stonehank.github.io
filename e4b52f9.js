(window.webpackJsonp=window.webpackJsonp||[]).push([[875],{1673:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s2</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n2</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> getMaxRepetitions = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s1, n1, s2, n2</span>) </span>{\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">findLast</span>(<span class=\\"hljs-params\\">s,p</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> result=[]\\n    <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>,j=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(;i&lt;s.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(s[i]===p[j])j++\\n      <span class=\\"hljs-keyword\\">if</span>(j===p.length){\\n        count++\\n        p=s2\\n        result=[i,j,count]\\n        j=<span class=\\"hljs-number\\">0</span>\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(result.length&gt;<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> result\\n    <span class=\\"hljs-keyword\\">return</span> [i,j,count]\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> mem={}\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcRep</span>(<span class=\\"hljs-params\\">s,p,sNum,pNum</span>)</span>{\\n    <span class=\\"hljs-comment\\">// 刚好尾端对齐的情况，s=\'abab\',p=\'ab\'</span>\\n    <span class=\\"hljs-keyword\\">if</span>(s===<span class=\\"hljs-string\\">\'\'</span>){\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.floor(pNum/sNum*n1/n2)\\n    }\\n    <span class=\\"hljs-comment\\">// 找不到匹配值的情况，s=\'abcd\',p=\'efg\'</span>\\n    <span class=\\"hljs-keyword\\">if</span>(sNum&gt;n1 &amp;&amp; pNum===<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>    \\n    }\\n    <span class=\\"hljs-comment\\">// 返回从s中找到p的最后一个位置</span>\\n    <span class=\\"hljs-keyword\\">let</span> [si,pi,count]=findLast(s,p)\\n    <span class=\\"hljs-comment\\">// 当前模板值全部都匹配了</span>\\n    <span class=\\"hljs-keyword\\">if</span>(pi&gt;=p.length){\\n      <span class=\\"hljs-keyword\\">let</span> nxtSI=si+<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">let</span> newPnum=pNum+count\\n      <span class=\\"hljs-keyword\\">let</span> nxtS=s.substring(nxtSI)\\n      <span class=\\"hljs-comment\\">// 查看是否进入循环</span>\\n      <span class=\\"hljs-keyword\\">if</span>(mem[nxtS]){\\n        <span class=\\"hljs-keyword\\">let</span> [prevSnum,prevPnum]=mem[nxtS]\\n        <span class=\\"hljs-keyword\\">let</span> multi=(newPnum-prevPnum)/(sNum-prevSnum)\\n        <span class=\\"hljs-keyword\\">return</span> prevPnum+<span class=\\"hljs-built_in\\">Math</span>.floor((n1-prevSnum*n2) / n2* multi)\\n      }\\n      <span class=\\"hljs-comment\\">// 未进入循环，则补充模板 s2，进行新的匹配</span>\\n      mem[nxtS]=[sNum,newPnum]\\n      <span class=\\"hljs-keyword\\">return</span> calcRep(nxtS,s2,sNum,newPnum)\\n    <span class=\\"hljs-comment\\">// 当前模板只能匹配部分---&gt;补充 s1</span>\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(si===s.length){\\n      <span class=\\"hljs-keyword\\">return</span> calcRep(s1,p.substring(pi),sNum+<span class=\\"hljs-number\\">1</span>,pNum)\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> calcRep(s1,s2,<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">0</span>)\\n};\\n</code></pre>\\n"],"querySlug":"count-the-repetitions","created_at":"2019-03-04","timeArr":[2019,2,4,10,29,14,0],"hasThinking":false,"content":"<p>定义 <code>str = [s, n]</code> 表示 <code>str</code> 由 <code>n</code> 个字符串 <code>s</code> 连接构成。</p>\\n\\n<ul>\\n\\t<li>例如，<code>str == [\\"abc\\", 3] ==\\"abcabcabc\\"</code> 。</li>\\n</ul>\\n\\n<p>如果可以从 <code>s2</code><sub> </sub>中删除某些字符使其变为 <code>s1</code>，则称字符串 <code>s1</code><sub> </sub>可以从字符串 <code>s2</code> 获得。</p>\\n\\n<ul>\\n\\t<li>例如，根据定义，<code>s1 = \\"abc\\"</code> 可以从 <code>s2 = \\"ab<em><strong>dbe</strong></em>c\\"</code> 获得，仅需要删除加粗且用斜体标识的字符。</li>\\n</ul>\\n\\n<p>现在给你两个字符串 <code>s1</code> 和 <code>s2</code> 和两个整数 <code>n1</code> 和 <code>n2</code> 。由此构造得到两个字符串，其中 <code>str1 = [s1, n1]</code>、<code>str2 = [s2, n2]</code> 。</p>\\n\\n<p>请你找出一个最大整数 <code>m</code> ，以满足 <code>str = [str2, m]</code> 可以从 <code>str1</code> 获得。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s1 = \\"acb\\", n1 = 4, s2 = \\"ab\\", n2 = 2\\n<strong>输出：</strong>2\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s1 = \\"acb\\", n1 = 1, s2 = \\"acb\\", n2 = 1\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= s1.length, s2.length <= 100</code></li>\\n\\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>\\n\\t<li><code>1 <= n1, n2 <= 10<sup>6</sup></code></li>\\n</ul>\\n","title":"466. 统计重复个数","relatedTags":["字符串","动态规划"],"difficult":"Hard","lang":["javascript"],"uniqueID":"466","slug":"466-Count-The-Repetitions"}')}}]);