(window.webpackJsonp=window.webpackJsonp||[]).push([[805],{1603:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">data</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> validUtf8 = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">data</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> need_10=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;data.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> str=data[i].toString(<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">if</span>(str.length&gt;<span class=\\"hljs-number\\">8</span>){\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(str.length&lt;<span class=\\"hljs-number\\">8</span>){\\n      <span class=\\"hljs-keyword\\">if</span>(need_10&gt;<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(need_10&gt;<span class=\\"hljs-number\\">0</span>){\\n        <span class=\\"hljs-keyword\\">if</span>(!str.startsWith(<span class=\\"hljs-string\\">\'10\'</span>))<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n        need_10--\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-keyword\\">let</span> id=<span class=\\"hljs-number\\">0</span>\\n        <span class=\\"hljs-keyword\\">while</span>(str[id++]===<span class=\\"hljs-string\\">\\"1\\"</span>)need_10++\\n        <span class=\\"hljs-keyword\\">if</span>(need_10===<span class=\\"hljs-number\\">1</span> || need_10&gt;<span class=\\"hljs-number\\">4</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n        need_10--\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">if</span>(need_10&gt;<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n};\\n</code></pre>\\n"],"querySlug":"utf-8-validation","created_at":"2019-04-21","timeArr":[2019,3,21,23,24,52,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>对<code>data</code>逐个分析，并且定义一个变量<code>need_10</code>，表示需要<code>10</code>开头的次数。</p>\\n<p>首先将当前<code>data[i]</code>，转成二进制字符串；</p>\\n<p>如果此字符串的长度<code>&lt;8</code>，说明它开头一定为<code>0</code>，表示<code>1字节</code>，只要检查当前的<code>need_10</code>是否为<code>0</code>，如果不为<code>0</code>，返回<code>false</code>；</p>\\n<p>如果此字符串长度<code>&gt;8</code>，直接返回<code>false</code>；</p>\\n<p>此字符串长度<code>===8</code>的情况；</p>\\n<p>如果<code>need_10&gt;0</code>并且当前并不是以<code>10</code>开头的，返回<code>false</code>；</p>\\n<p>如果当前开头的<code>1</code>只有1个或者<code>大于4</code>个(无效的格式)，返回false；</p>\\n<p>就以上几种情况，最后再检查是否还存在<code>need_10</code>没有处理的。</p>\\n","content":"<p>UTF-8 中的一个字符可能的长度为 <strong>1 到 4 字节</strong>，遵循以下的规则：</p>\\n\\n<ol>\\n\\t<li>对于 1 字节的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。</li>\\n\\t<li>对于 n 字节的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li>\\n</ol>\\n\\n<p>这是 UTF-8 编码的工作方式：</p>\\n\\n<pre>\\n<code>   Char. number range  |        UTF-8 octet sequence\\n      (hexadecimal)    |              (binary)\\n   --------------------+---------------------------------------------\\n   0000 0000-0000 007F | 0xxxxxxx\\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n</code></pre>\\n\\n<p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p>\\n\\n<p><strong>注意：</strong><br />\\n输入是整数数组。只有每个整数的 <strong>最低 8 个有效位</strong> 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\ndata = [197, 130, 1], 表示 8 位的序列: <strong>11000101 10000010 00000001</strong>.\\n\\n返回 <strong>true </strong>。\\n这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\ndata = [235, 140, 4], 表示 8 位的序列: <strong>11101011 10001100 00000100</strong>.\\n\\n返回<strong> false</strong> 。\\n前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。\\n下一个字节是开头为 10 的延续字节，这是正确的。\\n但第二个延续字节不以 10 开头，所以是不符合规则的。\\n</pre>\\n","title":"393. UTF-8 编码验证","relatedTags":["位运算","数组"],"difficult":"Middle","lang":["javascript"],"uniqueID":"393","slug":"393-UTF-8-Validation"}')}}]);