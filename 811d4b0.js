(window.webpackJsonp=window.webpackJsonp||[]).push([[1346],{2144:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">points</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">K</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[][]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> kClosest = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">points, K</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> aux=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;points.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [a,b]=points[i]\\n    <span class=\\"hljs-keyword\\">let</span> v=<span class=\\"hljs-built_in\\">Math</span>.sqrt(a*a+b*b)\\n    aux.push([v,points[i]])\\n  }\\n\\n  aux.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a[<span class=\\"hljs-number\\">0</span>]-b[<span class=\\"hljs-number\\">0</span>])\\n  <span class=\\"hljs-comment\\">// console.log(aux)</span>\\n  <span class=\\"hljs-keyword\\">let</span> res=aux.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">o</span>=&gt;</span>o[<span class=\\"hljs-number\\">1</span>])\\n  <span class=\\"hljs-keyword\\">return</span> res.slice(<span class=\\"hljs-number\\">0</span>,K)\\n};\\n</code></pre>\\n"],"querySlug":"k-closest-points-to-origin","created_at":"2019-01-13","timeArr":[2019,0,13,10,36,45,0],"hasThinking":false,"content":"<p>我们有一个由平面上的点组成的列表 <code>points</code>。需要从中找出 <code>K</code> 个距离原点 <code>(0, 0)</code> 最近的点。</p>\\n\\n<p>（这里，平面上两点之间的距离是欧几里德距离。）</p>\\n\\n<p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>points = [[1,3],[-2,2]], K = 1\\n<strong>输出：</strong>[[-2,2]]\\n<strong>解释： </strong>\\n(1, 3) 和原点之间的距离为 sqrt(10)，\\n(-2, 2) 和原点之间的距离为 sqrt(8)，\\n由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。\\n我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>points = [[3,3],[5,-1],[-2,4]], K = 2\\n<strong>输出：</strong>[[3,3],[-2,4]]\\n（答案 [[-2,4],[3,3]] 也会被接受。）\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>\\n\\t<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>\\n\\t<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>\\n</ol>\\n","title":"973. 最接近原点的 K 个点","relatedTags":["几何","数组","数学","分治","快速选择","排序","堆（优先队列）"],"difficult":"Middle","lang":["javascript"],"uniqueID":"973","slug":"973-K-Closest-Points-to-Origin"}')}}]);