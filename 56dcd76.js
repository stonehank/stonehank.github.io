(window.webpackJsonp=window.webpackJsonp||[]).push([[419],{1217:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">ranges</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> minTaps = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">n, ranges</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> inter=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;ranges.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> s=i-ranges[i]\\n    <span class=\\"hljs-keyword\\">let</span> e=ranges[i]+i\\n    <span class=\\"hljs-keyword\\">if</span>(e===<span class=\\"hljs-number\\">0</span>)inter.push([<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>])\\n    inter.push([<span class=\\"hljs-built_in\\">Math</span>.max(<span class=\\"hljs-number\\">0</span>,s),<span class=\\"hljs-built_in\\">Math</span>.min(n,e)])\\n  }\\n  inter.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a[<span class=\\"hljs-number\\">0</span>]===b[<span class=\\"hljs-number\\">0</span>] ? b[<span class=\\"hljs-number\\">1</span>]-a[<span class=\\"hljs-number\\">1</span>] : a[<span class=\\"hljs-number\\">0</span>]-b[<span class=\\"hljs-number\\">0</span>])\\n  <span class=\\"hljs-keyword\\">let</span> slimInter=uniq(inter)\\n  \\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">let</span> allS=slimInter[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-keyword\\">let</span> allE=slimInter[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">1</span>]\\n  <span class=\\"hljs-keyword\\">if</span>(allS&gt;<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-keyword\\">if</span>(allS===<span class=\\"hljs-number\\">0</span> &amp;&amp; allE===n)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>\\n  \\n  <span class=\\"hljs-keyword\\">while</span>(allE!==n){\\n    <span class=\\"hljs-keyword\\">let</span> newAllE=filt(slimInter,allE)\\n    res++\\n    <span class=\\"hljs-keyword\\">if</span>(allE===newAllE)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    allE=newAllE\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">filt</span>(<span class=\\"hljs-params\\">arr,limit</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> maxEnd=<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(arr[i][<span class=\\"hljs-number\\">0</span>]&lt;=limit){\\n        maxEnd=<span class=\\"hljs-built_in\\">Math</span>.max(maxEnd,arr[i][<span class=\\"hljs-number\\">1</span>])\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> maxEnd\\n  }\\n  \\n\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">uniq</span>(<span class=\\"hljs-params\\">inter</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> slimInter=[]\\n    <span class=\\"hljs-keyword\\">let</span> lastS=inter[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">0</span>]\\n    <span class=\\"hljs-keyword\\">let</span> lastE=inter[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">1</span>]\\n    slimInter.push([lastS,lastE])\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;inter.length;i++){\\n      <span class=\\"hljs-keyword\\">let</span> [curS,curE]=inter[i]\\n      <span class=\\"hljs-keyword\\">if</span>(include([lastS,lastE],inter[i]))<span class=\\"hljs-keyword\\">continue</span>\\n      slimInter.push([curS,curE])\\n      lastS=curS\\n      lastE=curE\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> slimInter\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">include</span>(<span class=\\"hljs-params\\">[ls,le],[cs,ce]</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(ls&lt;=cs &amp;&amp; le&gt;=ce)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"minimum-number-of-taps-to-open-to-water-a-garden","created_at":"2020-01-19","timeArr":[2020,0,19,12,8,29,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<ol>\\n<li>\\n<p>算出每一个水龙头的范围，组成一个数组<code>arr</code></p>\\n</li>\\n<li>\\n<p>对这个数组进行排序，并且去重，保证每一个范围都不会包含任意另一个范围</p>\\n</li>\\n<li>\\n<p>从第一个范围<code>arr[0]</code>开始(因为只可能有第一个范围包括<code>0</code>)，筛选出后续的每一个范围<code>inter</code>中，符合<code>inter[0]&lt;=arr[0][1]</code>条件的<code>inter[1]</code>的最大值。</p>\\n<p>例如：一组<code>arr=[[0,4],[1,5],[2,6],[3,7]]</code></p>\\n<p>那么第一个范围是<code>[0,4]</code>，而后续筛选出最大的结果则是<code>[3,7]</code>，因为<code>3</code>能满足<code>3&lt;=4</code>，并且<code>7</code>是能满足这些条件中的最大值。</p>\\n</li>\\n<li>\\n<p>将第一个范围更新为上一次的并集，重复第3步(更优化的做法是记录之前检查过的范围，不再次检查<code>O(N)</code>)，直到范围不能再次更新。</p>\\n</li>\\n</ol>\\n","content":"<p>在 x 轴上有一个一维的花园。花园长度为&nbsp;<code>n</code>，从点&nbsp;<code>0</code>&nbsp;开始，到点&nbsp;<code>n</code>&nbsp;结束。</p>\\n\\n<p>花园里总共有&nbsp;<code>n + 1</code> 个水龙头，分别位于&nbsp;<code>[0, 1, ..., n]</code> 。</p>\\n\\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为&nbsp;<code>n + 1</code> 的整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i]</code> （下标从 0 开始）表示：如果打开点&nbsp;<code>i</code>&nbsp;处的水龙头，可以灌溉的区域为&nbsp;<code>[i -&nbsp; ranges[i], i + ranges[i]]</code>&nbsp;。</p>\\n\\n<p>请你返回可以灌溉整个花园的&nbsp;<strong>最少水龙头数目</strong>&nbsp;。如果花园始终存在无法灌溉到的地方，请你返回&nbsp;<strong>-1</strong>&nbsp;。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png\\" style=\\"width: 530px;\\"></p>\\n\\n<pre><strong>输入：</strong>n = 5, ranges = [3,4,1,1,0,0]\\n<strong>输出：</strong>1\\n<strong>解释：\\n</strong>点 0 处的水龙头可以灌溉区间 [-3,3]\\n点 1 处的水龙头可以灌溉区间 [-3,5]\\n点 2 处的水龙头可以灌溉区间 [1,3]\\n点 3 处的水龙头可以灌溉区间 [2,4]\\n点 4 处的水龙头可以灌溉区间 [4,4]\\n点 5 处的水龙头可以灌溉区间 [5,5]\\n只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>n = 3, ranges = [0,0,0,0]\\n<strong>输出：</strong>-1\\n<strong>解释：</strong>即使打开所有水龙头，你也无法灌溉整个花园。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>n = 7, ranges = [1,2,1,0,2,1,0,1]\\n<strong>输出：</strong>3\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre><strong>输入：</strong>n = 8, ranges = [4,0,0,0,0,0,0,0,4]\\n<strong>输出：</strong>2\\n</pre>\\n\\n<p><strong>示例 5：</strong></p>\\n\\n<pre><strong>输入：</strong>n = 8, ranges = [4,0,0,0,4,0,0,0,4]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\\n\\t<li><code>ranges.length == n + 1</code></li>\\n\\t<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>\\n</ul>\\n","title":"1326. 灌溉花园的最少水龙头数目","relatedTags":["贪心","数组","动态规划"],"difficult":"Hard","lang":["javascript"],"uniqueID":"1326","slug":"1326-Minimum-Number-of-Taps-to-Open-to-Water-a-Garden"}')}}]);