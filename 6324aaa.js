(window.webpackJsonp=window.webpackJsonp||[]).push([[784],{1582:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums2</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[][]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> kSmallestPairs = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums1, nums2, k</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> result=[]\\n  <span class=\\"hljs-keyword\\">let</span> index=<span class=\\"hljs-built_in\\">Array</span>(nums1.length).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;k;i++){\\n    <span class=\\"hljs-keyword\\">let</span> start=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">let</span> min=<span class=\\"hljs-literal\\">Infinity</span>,minIdx=<span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-comment\\">// 从0开始，开始计算本次最小值</span>\\n    <span class=\\"hljs-keyword\\">while</span>(start&lt;nums1.length){\\n      <span class=\\"hljs-comment\\">// 指针指到最后，跳过</span>\\n      <span class=\\"hljs-keyword\\">if</span>(index[start]&gt;=nums2.length){\\n        start++\\n        <span class=\\"hljs-keyword\\">continue</span>\\n      }\\n      <span class=\\"hljs-comment\\">// 获取当前的2个指针</span>\\n      <span class=\\"hljs-keyword\\">let</span> id1=start,id2=index[start]\\n      <span class=\\"hljs-comment\\">// 判断是否更小</span>\\n      <span class=\\"hljs-keyword\\">if</span>(nums1[id1]+nums2[id2]&lt;min){\\n        min=nums1[id1]+nums2[id2]\\n        minIdx=start\\n      }\\n      start++\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(minIdx===<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">break</span>\\n    result.push([nums1[minIdx],nums2[index[minIdx]]])\\n    index[minIdx]+=<span class=\\"hljs-number\\">1</span>\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> result\\n};\\n</code></pre>\\n"],"querySlug":"find-k-pairs-with-smallest-sums","created_at":"2019-04-23","timeArr":[2019,3,23,11,16,33,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>2种方法；</p>\\n<ul>\\n<li>多指针计算，我们给<code>nums1[i]</code>每一个索引分配一个指针，从<code>0</code>开始，这个指针指的是它们当前对应在<code>nums2</code>中的数字，遍历<code>k</code>次，\\n每一次都去找出当前每一个<code>nums1[i]</code>和它对应指针<code>nums2[j]</code>的和，筛选出最小值，时间复杂度是<code>O(N*K)</code>。</li>\\n</ul>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums2</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[][]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> kSmallestPairs = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums1, nums2, k</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> result=[]\\n  <span class=\\"hljs-keyword\\">let</span> index=<span class=\\"hljs-built_in\\">Array</span>(nums1.length).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;k;i++){\\n    <span class=\\"hljs-keyword\\">let</span> start=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">let</span> min=<span class=\\"hljs-literal\\">Infinity</span>,minIdx=<span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-comment\\">// 从0开始，开始计算本次最小值</span>\\n    <span class=\\"hljs-keyword\\">while</span>(start&lt;nums1.length){\\n      <span class=\\"hljs-comment\\">// 指针指到最后，跳过</span>\\n      <span class=\\"hljs-keyword\\">if</span>(index[start]&gt;=nums2.length){\\n        start++\\n        <span class=\\"hljs-keyword\\">continue</span>\\n      }\\n      <span class=\\"hljs-comment\\">// 获取当前的2个指针</span>\\n      <span class=\\"hljs-keyword\\">let</span> id1=start,id2=index[start]\\n      <span class=\\"hljs-comment\\">// 判断是否更小</span>\\n      <span class=\\"hljs-keyword\\">if</span>(nums1[id1]+nums2[id2]&lt;min){\\n        min=nums1[id1]+nums2[id2]\\n        minIdx=start\\n      }\\n      start++\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(minIdx===<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">break</span>\\n    result.push([nums1[minIdx],nums2[index[minIdx]]])\\n    index[minIdx]+=<span class=\\"hljs-number\\">1</span>\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> result\\n};\\n</code></pre>\\n<ul>\\n<li>\\n<p>优先队列，可以说着是上面指针的优化版。</p>\\n<p>同样也给<code>nums1[i]</code>每一个索引分配一个指针，但是我们用<code>pq</code>保存当前每一个<code>nums1[i]</code>和对应指针的<code>nums2[j]</code>的和。</p>\\n<p>然后遍历<code>k</code>次，每一次不需要重新检查，只需要将当前优先队列中最小的取出，再放入当前<code>nums1[i]</code>对应的指针的下一个指针对应的数<code>nums2[++j]</code>和<code>nums1[i]</code>的和。</p>\\n</li>\\n</ul>\\n","content":"<p>给定两个以升序排列的整数数组 <code>nums1</code> 和<strong> </strong><code>nums2</code><strong> </strong>, 以及一个整数 <code>k</code><strong> </strong>。</p>\\n\\n<p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code><strong> </strong>。</p>\\n\\n<p>请找到和最小的 <code>k</code> 个数对 <code>(u<sub>1</sub>,v<sub>1</sub>)</code>, <code> (u<sub>2</sub>,v<sub>2</sub>)</code>  ...  <code>(u<sub>k</sub>,v<sub>k</sub>)</code> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\\n<strong>输出:</strong> [1,2],[1,4],[1,6]\\n<strong>解释: </strong>返回序列中的前 3 对数：\\n     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>nums1 = [1,1,2], nums2 = [1,2,3], k = 2\\n<strong>输出: </strong>[1,1],[1,1]\\n<strong>解释: </strong>返回序列中的前 2 对数：\\n     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n</pre>\\n\\n<p><strong>示例 3:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>nums1 = [1,2], nums2 = [3], k = 3 \\n<strong>输出:</strong> [1,3],[2,3]\\n<strong>解释: </strong>也可能序列中所有的数对都被返回:[1,3],[2,3]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= nums1.length, nums2.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>-10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup></code></li>\\n\\t<li><code>nums1</code>, <code>nums2</code> 均为升序排列</li>\\n\\t<li><code>1 <= k <= 1000</code></li>\\n</ul>\\n","title":"373. 查找和最小的K对数字","relatedTags":["数组","堆（优先队列）"],"difficult":"Middle","lang":["javascript"],"uniqueID":"373","slug":"373-Find-K-Pairs-with-Smallest-Sums"}')}}]);