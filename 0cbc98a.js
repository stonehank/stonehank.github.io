(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{673:function(e){e.exports=JSON.parse('{"content":"<ol>\\n<li><p><code>offsetParent</code></p>\\n<p> <code>offsetParent</code>返回一个指向最近的包含该元素的定位元素.</p>\\n<p> <code>offsetParent</code>很有用，因为计算<code>offsetTop</code>和<code>offsetLeft</code>都是相对于<code>offsetParent</code>边界的。</p>\\n<p> <code>offsetParent</code>为 null 的几种情况:</p>\\n<ul>\\n<li><p>ele 为 body</p>\\n</li>\\n<li><p>ele 的 position 为 fixed</p>\\n</li>\\n<li><p>ele 的 display 为 none</p>\\n<p>源码中<code>offsetParent</code>处理了2种情况</p>\\n</li>\\n</ul>\\n<ol>\\n<li><p>在<code>useWindow</code>的情况下(即事件绑定在window，滚动作用在body)</p>\\n<p> 通过递归获取<code>offsetParent</code>到达顶端的高度(<code>offsetTop</code>)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>calculateTopPosition(el) {\\n  <span class=\\"hljs-keyword\\">if</span> (!el) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;   \\n  }\\n  <span class=\\"hljs-keyword\\">return</span> el.offsetTop + <span class=\\"hljs-keyword\\">this</span>.calculateTopPosition(el.offsetParent);   \\n }</code></pre></code></pre>\\n</li>\\n<li><p>通过判断<code>offsetParent</code>不为null的情况，确保滚动组件正常显示</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (\\n offset &lt; <span class=\\"hljs-built_in\\">Number</span>(<span class=\\"hljs-keyword\\">this</span>.props.threshold) &amp;&amp;\\n (el &amp;&amp; el.offsetParent !== <span class=\\"hljs-literal\\">null</span>)\\n) {<span class=\\"hljs-comment\\">/* ... */</span> }</code></pre></code></pre>\\n</li>\\n</ol>\\n</li>\\n<li><p><code>scrollHeight</code>和<code>clientHeight</code></p>\\n<p> 在无滚动的情况下，<code>scrollHeight</code>和<code>clientHeight</code>相等，都为<code>width</code>+<code>padding</code>*2</p>\\n<p> 在有滚动的情况下，<code>scrollHeight</code>表示实际内容高度，<code>clientHeight</code>表示视口高度。</p>\\n</li>\\n<li><p>每次执行<code>loadMore</code>前卸载事件。</p>\\n<p> 确保不会重复(过多)执行<code>loadMore</code>，因为先卸载事件再执行<code>loadMore</code>，可以确保在执行过程中，<code>scroll</code>事件是无效的。</p>\\n<p> 然后再每次<code>didUpdate</code>的时候重新绑定事件。</p>\\n</li>\\n<li><p>mousewheel解决chrome的等待bug</p>\\n<p>源码中订阅<code>mousewheel</code>事件是为了处理<code>chrome</code>浏览器的一个特性(不知道是否是一种bug)。</p>\\n<p><a href=\\"https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\\">stackoverflow:Chrome的滚动等待问题</a></p>\\n<p>上面这个问题主要描述，当在使用滚轮加载时，而且加载会触发<code>ajax请求</code>，当滚轮到达底部，会出现一个漫长而且无任何动作的等待(长达2-3s)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-built_in\\">window</span>.addEventListener(<span class=\\"hljs-string\\">\\"mousewheel\\"</span>, (e) =&gt; {\\n    <span class=\\"hljs-keyword\\">if</span> (e.deltaY === <span class=\\"hljs-number\\">1</span>) {\\n        e.preventDefault()\\n    }\\n})</code></pre></code></pre>\\n<p>以上绑定可以消除这个&quot;bug&quot;。</p>\\n</li>\\n</ol>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-25","timeArr":[2018,10,25,0,0,0,0],"title":"源码阅读-react-infinite-scroller-笔记","uuid":"e4ce5c4bef01302a0d060390b3bb12ae149f583f","summary":"<ol>\\n<li>\\n<p><code>offsetParent</code></p>\\n<p><code>offsetParent</code>返回一个指向最近的包含该元素的定位元素.</p>\\n<p><code>offsetParent</code>很有用，因为计算<code>offsetTop</code>和<code>offsetLeft</code>都是相对于<code>offsetParent</code>边界的。</p>\\n<p><code>offsetParent</code>...</p>\\n</li>\\n</ol>","slug":"yuan-ma-yue-du-react-infinite-scroller-bi-ji","sha":"ca1df5a51761dd3bb612a4ab486576a8102d2d1b"}')}}]);