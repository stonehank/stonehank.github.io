(window.webpackJsonp=window.webpackJsonp||[]).push([[768],{1566:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> topKFrequent = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums, k</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(hash[nums[i]]==<span class=\\"hljs-literal\\">null</span>)hash[nums[i]]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> hash[nums[i]]++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> aux=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k <span class=\\"hljs-keyword\\">in</span> hash){\\n    aux.push([k,hash[k]])\\n  }\\n  <span class=\\"hljs-comment\\">// console.log(hash,aux)</span>\\n  aux.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>b[<span class=\\"hljs-number\\">1</span>]-a[<span class=\\"hljs-number\\">1</span>])\\n  <span class=\\"hljs-keyword\\">let</span> res=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;k;i++){\\n    res.push(aux[i][<span class=\\"hljs-number\\">0</span>])\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n  \\n};\\n</code></pre>\\n"],"querySlug":"top-k-frequent-elements","created_at":"2019-04-05","timeArr":[2019,3,5,11,15,49,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p><code>O(logN)</code>解法： <code>hash</code>保存每一个数字的频率，然后对该频率排序，最后输出前<code>k</code>位的<code>key</code>。</p>\\n<p><code>O(N)</code>解法：<code>桶排序</code>，将每一个数字的频率作为一个数组的索引，这个索引对应的是另一个数组，包含了这些频率的数字。</p>\\n<pre class=\\"hljs\\"><code>[\\n  1(频率):[1,4,6,8](数字),\\n  3:[5,7],\\n  ...\\n]\\n</code></pre>\\n<p>然后反向遍历，将所有前<code>k</code>个数字添加进结果。</p>\\n","content":"<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\\n<strong>输出: </strong>[1,2]\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>nums = [1], k = 1\\n<strong>输出: </strong>[1]</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\\n\\t<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\\n\\t<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code><em> </em>是数组大小。</p>\\n","title":"347. 前 K 个高频元素","relatedTags":["数组","哈希表","分治","桶排序","计数","快速选择","排序","堆（优先队列）"],"difficult":"Middle","lang":["javascript"],"uniqueID":"347","slug":"347-Top-K-Frequent-Elements"}')}}]);