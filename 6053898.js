(window.webpackJsonp=window.webpackJsonp||[]).push([[933],{1731:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{character[][]}</span> <span class=\\"hljs-variable\\">board</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">click</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{character[][]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> updateBoard = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">board, click</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> m=board.length,n=board[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">let</span> visited=<span class=\\"hljs-built_in\\">Array</span>(m).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(n).fill(<span class=\\"hljs-literal\\">false</span>))\\n  <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-built_in\\">Array</span>(m).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(n).fill(<span class=\\"hljs-number\\">0</span>))\\n  <span class=\\"hljs-keyword\\">let</span> moves=[[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">-1</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>]]\\n  \\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;m;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;n;j++){\\n      <span class=\\"hljs-keyword\\">if</span>(board[i][j]===<span class=\\"hljs-string\\">\\"M\\"</span>){\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> x=<span class=\\"hljs-number\\">-1</span>;x&lt;=<span class=\\"hljs-number\\">1</span>;x++){\\n          <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> y=<span class=\\"hljs-number\\">-1</span>;y&lt;=<span class=\\"hljs-number\\">1</span>;y++){\\n            <span class=\\"hljs-keyword\\">if</span>(x===<span class=\\"hljs-number\\">0</span> &amp;&amp; y===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>\\n            <span class=\\"hljs-keyword\\">let</span> nx=x+i,ny=y+j\\n            <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || ny&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n            count[nx][ny]++\\n          }\\n        }\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// console.log(count)</span>\\n  <span class=\\"hljs-keyword\\">let</span> [x,y]=click\\n  <span class=\\"hljs-keyword\\">if</span>(board[x][y]===<span class=\\"hljs-string\\">\\"M\\"</span>){\\n    board[x][y]=<span class=\\"hljs-string\\">\\"X\\"</span>\\n    <span class=\\"hljs-keyword\\">return</span> board\\n  }\\n  <span class=\\"hljs-keyword\\">if</span>(board[x][y]!==<span class=\\"hljs-string\\">\\"E\\"</span>){\\n    <span class=\\"hljs-keyword\\">return</span> board\\n  }\\n  <span class=\\"hljs-keyword\\">if</span>(count[x][y]!==<span class=\\"hljs-number\\">0</span>){\\n    board[x][y]=count[x][y]+<span class=\\"hljs-string\\">\'\'</span>\\n    <span class=\\"hljs-keyword\\">return</span> board\\n  }\\n  board[x][y]=<span class=\\"hljs-string\\">\\"B\\"</span>\\n  dfs([x,y])\\n  <span class=\\"hljs-keyword\\">return</span> board\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">[x,y]</span>)</span>{\\n    visited[x][y]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">-1</span>;i&lt;=<span class=\\"hljs-number\\">1</span>;i++){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">-1</span>;j&lt;=<span class=\\"hljs-number\\">1</span>;j++){\\n        <span class=\\"hljs-keyword\\">if</span>(i===<span class=\\"hljs-number\\">0</span> &amp;&amp; j===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> nx=x+i,ny=y+j\\n        <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || ny&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">if</span>(visited[nx][ny])<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">if</span>(count[nx][ny]===<span class=\\"hljs-number\\">0</span>){\\n          board[nx][ny]=<span class=\\"hljs-string\\">\\"B\\"</span>\\n          dfs([nx,ny])\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n          board[nx][ny]=count[nx][ny]+<span class=\\"hljs-string\\">\\"\\"</span>\\n        }\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"minesweeper","created_at":"2019-04-09","timeArr":[2019,3,9,22,2,25,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>如果<code>click</code>的点是<code>M</code>，变为<code>X</code>，结束</p>\\n<p>如果<code>click</code>的点是<code>E</code>，<code>dfs</code></p>\\n<ul>\\n<li>\\n<p>找出当前点是否数字点(通过周围是否有雷来判断)，是数字电直接显示数字；</p>\\n</li>\\n<li>\\n<p>如果不是数字点，那么就递归周边所有的点。</p>\\n</li>\\n</ul>\\n<p>如果<code>click</code>的点是其他，直接返回即可。</p>\\n","content":"<p>让我们一起来玩扫雷游戏！</p>\\n\\n<p>给定一个代表游戏板的二维字符矩阵。&nbsp;<strong>&#39;M&#39;</strong>&nbsp;代表一个<strong>未挖出的</strong>地雷，<strong>&#39;E&#39;</strong>&nbsp;代表一个<strong>未挖出的</strong>空方块，<strong>&#39;B&#39;&nbsp;</strong>代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（&#39;1&#39; 到 &#39;8&#39;）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>&#39;X&#39;</strong>&nbsp;则表示一个<strong>已挖出的</strong>地雷。</p>\\n\\n<p>现在给出在所有<strong>未挖出的</strong>方块中（&#39;M&#39;或者&#39;E&#39;）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>\\n\\n<ol>\\n\\t<li>如果一个地雷（&#39;M&#39;）被挖出，游戏就结束了- 把它改为&nbsp;<strong>&#39;X&#39;</strong>。</li>\\n\\t<li>如果一个<strong>没有相邻地雷</strong>的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;），并且所有和其相邻的<strong>未挖出</strong>方块都应该被递归地揭露。</li>\\n\\t<li>如果一个<strong>至少与一个地雷相邻</strong>的空方块（&#39;E&#39;）被挖出，修改它为数字（&#39;1&#39;到&#39;8&#39;），表示相邻地雷的数量。</li>\\n\\t<li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li>\\n</ol>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入:</strong> \\n\\n[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],\\n [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],\\n [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],\\n [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]\\n\\nClick : [3,0]\\n\\n<strong>输出:</strong> \\n\\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\\n\\n<strong>解释:</strong>\\n<img src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_1.png\\" style=\\"width: 100%;\\">\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入:</strong> \\n\\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\\n\\nClick : [1,2]\\n\\n<strong>输出:</strong> \\n\\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\\n\\n<strong>解释:</strong>\\n<img src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_2.png\\" style=\\"width: 100%;\\">\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>注意：</strong></p>\\n\\n<ol>\\n\\t<li>输入矩阵的宽和高的范围为 [1,50]。</li>\\n\\t<li>点击的位置只能是未被挖出的方块 (&#39;M&#39; 或者 &#39;E&#39;)，这也意味着面板至少包含一个可点击的方块。</li>\\n\\t<li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li>\\n\\t<li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li>\\n</ol>\\n","title":"529. 扫雷游戏","relatedTags":["深度优先搜索","广度优先搜索","数组","矩阵"],"difficult":"Middle","lang":["javascript"],"uniqueID":"529","slug":"529-Minesweeper"}')}}]);