(window.webpackJsonp=window.webpackJsonp||[]).push([[1413],{700:function(e){e.exports=JSON.parse('{"content":"<p><code>react-snapshot</code>一个服务端渲染组件，由于内部依赖库和相关<code>API</code>较老，而且有1年没更新了，\\n就不去太详细解释，有兴趣可以自行看源码内容<code>src目录</code>(带详细注释)。</p>\\n<p>读了这个库，要了解<code>服务端渲染</code>是什么流程，因此这里主要讲<code>执行流程</code>。</p>\\n<h3 id=\\"pei-zhi\\">配置</h3>\\n<p>这个库需要更改<code>package.json</code>的<code>build</code>，更改如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>- &quot;build&quot;: &quot;react-scripts build&quot;\\n+ &quot;build&quot;: &quot;react-scripts build &amp;&amp; react-snapshot&quot;</code></pre>\\n</code></pre>\\n<p>然后改变<code>render</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>- import ReactDOM from \'react-dom\';\\n+ import { render } from \'react-snapshot\';\\n\\n- ReactDOM.render(\\n+ render(\\n    &lt;App/&gt;,\\n    document.getElementById(\'root\')\\n  );</code></pre>\\n</code></pre>\\n<h3 id=\\"zhi-xing-liu-cheng\\">执行流程</h3>\\n<ol>\\n<li><p>输入<code>npm run build</code>，先执行<code>react-scripts build</code>，再执行<code>react-snapshot</code></p>\\n</li>\\n<li><p>通过<code>bin</code>内部文件执行<code>cli</code> </p>\\n</li>\\n<li><p>执行<code>cli</code>，处理相关配置(目的是转换路径，确认需要快照的页面路径)</p>\\n<ol>\\n<li>获取<code>package.json</code>内部的<code>homepage</code>，确保以<code>/</code>结尾，如果不存在则用<code>/</code>表示。</li>\\n<li>将路径转换为绝对路径。</li>\\n<li>将<code>homepage</code>加入<code>include</code>，后面将会不断<code>.shift()</code>处理内部的路径。</li>\\n</ol>\\n</li>\\n<li><p>重命名之前的<code>index.html</code>为<code>200.html</code></p>\\n</li>\\n<li><p>定义服务器<code>Server</code></p>\\n<ol>\\n<li>在<code>build</code>内部使用了<code>historyApiFallback</code>(防止SPA应用404)。</li>\\n<li>托管静态<code>build</code>内资源到用户定义的<code>outputFile</code>中，默认也是<code>build</code>。</li>\\n<li>处理了存在<code>proxy</code>(<code>package.json</code>内部的<code>proxy</code>)的情况。</li>\\n</ol>\\n</li>\\n<li><p>开启服务器（使用任意未占用端口）</p>\\n</li>\\n<li><p>在上面端口中开启爬虫<code>Crawler</code></p>\\n<ol>\\n<li>对参数<code>include</code>(数组)执行<code>.shift()</code>，开始爬行<code>snapshot</code><ol>\\n<li>使用<code>jsdom</code>，创建虚拟dom。</li>\\n<li>监听<code>window</code>创建，定义<code>window.reactSnapshotRender</code>，它的作用是改变一个<code>flag</code>。 这个<code>flag</code>的改变说明了当前<code>path</code>已经成功获取到<code>js</code>文件，并且执行了定义在客户端的<code>render</code>，已经将<code>React</code>\\n 首页的<code>document</code>结构放到了虚拟<code>document</code>内部。</li>\\n<li>拦截当前<code>path</code>上的外部资源请求，查看是否相同的<code>host</code>，并且符合<code>jsdom.feature</code>的配置。 当资源符合要求，便会请求并且执行(也就是<code>build</code>中<code>xxx.main.js</code>的代码)，执行它便会触发<code>render</code>，\\n 结果就回到第1步中说的改变<code>flag</code></li>\\n</ol>\\n</li>\\n<li>此时虚拟<code>document</code>结构已经生成，经过<code>scriptJS</code>检查(匹配则删除)和<code>window.react_snapshot_state</code>，\\n它的作用是定义一个数据，客户端运行时，能从<code>window.react_snapshot_state</code>获取到这个数据。</li>\\n<li>序列化这个<code>document</code>，检查<code>document</code>内部的<code>&lt;a&gt;</code>和<code>&lt;iframe</code>是否有链接到其他页面或者目录，如果有，添加到<code>include</code>中，\\n后续执行快照。</li>\\n</ol>\\n</li>\\n<li><p>给<code>path</code>添加<code>.html</code>后缀或者(如果是目录添加)<code>index.html</code>，创建并且写入文件。</p>\\n</li>\\n<li><p>递归到<code>第7步</code>继续执行其他路径的快照。</p>\\n</li>\\n</ol>\\n<h4 id=\\"dao-tu\\">导图</h4>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-snapshot/react-snapshot.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"pei-zhi","level":3,"text":"配置"},{"anchor":"zhi-xing-liu-cheng","level":3,"text":"执行流程"},{"anchor":"dao-tu","level":4,"text":"导图"}],"relatedTags":["react","源码","npm"],"created_at":"2018-12-04","timeArr":[2018,11,4,8,28,32,0],"title":"源码阅读-react-snapshot","uuid":"a1837b08e3c7d440f06a453b4a0a19e1078abcfa","summary":"<p><code>react-snapshot</code>一个服务端渲染组件，由于内部依赖库和相关<code>API</code>较老，而且有1年没更新了，\\n就不去太详细解释，有兴趣可以自行看源码内容<code>src目录</code>(带详细注释)。</p>\\n<p>读了这个库，要了解<code>服务端渲染</code>是什么流程，因此这里主要讲<code>执行流程</code>。</p>\\n<h4>配置</h4>\\n<p>这个库需要更改<code>package.json</code>...</p>","slug":"source-code-react-snapshot","sha":"eee62b3fcb60e43c2db14c27b02e523dc16d5be4"}')}}]);