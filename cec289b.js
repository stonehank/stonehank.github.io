(window.webpackJsonp=window.webpackJsonp||[]).push([[1054],{1852:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">words</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> topKFrequent = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">words, k</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;words.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(hash[words[i]]==<span class=\\"hljs-literal\\">null</span>)hash[words[i]]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> hash[words[i]]++\\n  }\\n  \\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Object</span>.keys(hash).sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(hash[a]&lt;hash[b])<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(hash[a]&gt;hash[b])<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(a&lt;b)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n      <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>\\n    }\\n  }).slice(<span class=\\"hljs-number\\">0</span>,k)\\n};\\n</code></pre>\\n"],"querySlug":"top-k-frequent-words","created_at":"2019-04-06","timeArr":[2019,3,6,15,43,17,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>以<code>words[i]</code>为<code>key</code>，出现频率为<code>val</code>，构建<code>hash</code>后，对<code>hash</code>进行排序即可。</p>\\n","content":"<p>给一非空的单词列表，返回前&nbsp;<em>k&nbsp;</em>个出现次数最多的单词。</p>\\n\\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2\\n<strong>输出:</strong> [&quot;i&quot;, &quot;love&quot;]\\n<strong>解析:</strong> &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。\\n    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4\\n<strong>输出:</strong> [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]\\n<strong>解析:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，\\n    出现次数依次为 4, 3, 2 和 1 次。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>注意：</strong></p>\\n\\n<ol>\\n\\t<li>假定 <em>k</em> 总为有效值， 1 &le; <em>k</em> &le; 集合元素数。</li>\\n\\t<li>输入的单词均由小写字母组成。</li>\\n</ol>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>扩展练习：</strong></p>\\n\\n<ol>\\n\\t<li>尝试以&nbsp;<em>O</em>(<em>n</em> log <em>k</em>) 时间复杂度和&nbsp;<em>O</em>(<em>n</em>) 空间复杂度解决。</li>\\n</ol>\\n","title":"692. 前K个高频单词","relatedTags":["字典树","哈希表","字符串","桶排序","计数","排序","堆（优先队列）"],"difficult":"Middle","lang":["javascript"],"uniqueID":"692","slug":"692-Top-K-Frequent-Words"}')}}]);