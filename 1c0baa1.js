(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{1040:function(e){e.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">words</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> StreamChecker = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">words</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> tire={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> word <span class=\\"hljs-keyword\\">of</span> words){\\n    <span class=\\"hljs-keyword\\">let</span> t=tire\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;word.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(t[word[i]]==<span class=\\"hljs-literal\\">null</span>)t[word[i]]={}\\n      <span class=\\"hljs-keyword\\">if</span>(i===word.length<span class=\\"hljs-number\\">-1</span>)t[word[i]].exact=<span class=\\"hljs-literal\\">true</span>\\n      t[word[i]].has=<span class=\\"hljs-literal\\">false</span>\\n      t=t[word[i]]\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.tire=tire\\n  <span class=\\"hljs-keyword\\">this</span>.waiting=[]\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {character} letter\\n * @return {boolean}\\n */</span>\\nStreamChecker.prototype.query = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">letter</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-literal\\">false</span>,aux=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-keyword\\">this</span>.waiting.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> t=<span class=\\"hljs-keyword\\">this</span>.waiting[i]\\n    <span class=\\"hljs-keyword\\">if</span>(t[letter]!=<span class=\\"hljs-literal\\">null</span>){\\n      <span class=\\"hljs-keyword\\">if</span>(t[letter].exact)res=<span class=\\"hljs-literal\\">true</span>\\n      aux.push(t[letter])\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.tire[letter]!=<span class=\\"hljs-literal\\">null</span>){\\n    <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.tire[letter].exact)res=<span class=\\"hljs-literal\\">true</span> \\n    aux.push(<span class=\\"hljs-keyword\\">this</span>.tire[letter])\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.waiting=aux\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */</span>\\n</code></pre>\\n"],"querySlug":"stream-of-characters","created_at":"2019-04-21","timeArr":[2019,3,21,12,58,27,0],"hasThinking":false,"content":"<p>按下述要求实现 <code>StreamChecker</code> 类：</p>\\n\\n<ul>\\n\\t<li><code>StreamChecker(words)</code>：构造函数，用给定的字词初始化数据结构。</li>\\n\\t<li><code>query(letter)</code>：如果存在某些 <code>k &gt;= 1</code>，可以用查询的最后 <code>k</code>个字符（按从旧到新顺序，包括刚刚查询的字母）拼写出给定字词表中的某一字词时，返回 <code>true</code>。否则，返回 <code>false</code>。</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>StreamChecker streamChecker = new StreamChecker([&quot;cd&quot;,&quot;f&quot;,&quot;kl&quot;]); // 初始化字典\\nstreamChecker.query(&#39;a&#39;);          // 返回 false\\nstreamChecker.query(&#39;b&#39;);          // 返回 false\\nstreamChecker.query(&#39;c&#39;);          // 返回 false\\nstreamChecker.query(&#39;d&#39;);          // 返回 true，因为 &#39;cd&#39; 在字词表中\\nstreamChecker.query(&#39;e&#39;);          // 返回 false\\nstreamChecker.query(&#39;f&#39;);          // 返回 true，因为 &#39;f&#39; 在字词表中\\nstreamChecker.query(&#39;g&#39;);          // 返回 false\\nstreamChecker.query(&#39;h&#39;);          // 返回 false\\nstreamChecker.query(&#39;i&#39;);          // 返回 false\\nstreamChecker.query(&#39;j&#39;);          // 返回 false\\nstreamChecker.query(&#39;k&#39;);          // 返回 false\\nstreamChecker.query(&#39;l&#39;);          // 返回 true，因为 &#39;kl&#39; 在字词表中。</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= words.length &lt;= 2000</code></li>\\n\\t<li><code>1 &lt;= words[i].length &lt;= 2000</code></li>\\n\\t<li>字词只包含小写英文字母。</li>\\n\\t<li>待查项只包含小写英文字母。</li>\\n\\t<li>待查项最多 40000 个。</li>\\n</ul>\\n","title":"1032. 字符流","relatedTags":["设计","字典树","数组","字符串","数据流"],"difficult":"Hard","lang":["javascript"],"uniqueID":"1032","slug":"1032-Stream-of-Characters"}')}}]);