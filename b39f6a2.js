(window.webpackJsonp=window.webpackJsonp||[]).push([[772],{1570:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for an interval.\\n * function Interval(start, end) {\\n *     this.start = start;\\n *     this.end = end;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * Initialize your data structure here.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> SummaryRanges = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.interval=[]\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {number} val\\n * @return {void}\\n */</span>\\nSummaryRanges.prototype.addNum = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">val</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> itv=[]\\n  <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>,len=<span class=\\"hljs-keyword\\">this</span>.interval.length\\n  <span class=\\"hljs-keyword\\">let</span> left=val,right=val\\n  <span class=\\"hljs-keyword\\">for</span>(;i&lt;len;i++){\\n    <span class=\\"hljs-keyword\\">let</span> cur=<span class=\\"hljs-keyword\\">this</span>.interval[i]\\n    <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">1</span>]&lt;left<span class=\\"hljs-number\\">-1</span>){\\n      itv.push(cur)\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">0</span>]&gt;right+<span class=\\"hljs-number\\">1</span>){\\n      <span class=\\"hljs-keyword\\">break</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      left=<span class=\\"hljs-built_in\\">Math</span>.min(left,cur[<span class=\\"hljs-number\\">0</span>])\\n      right=<span class=\\"hljs-built_in\\">Math</span>.max(right,cur[<span class=\\"hljs-number\\">1</span>])\\n    }\\n  }\\n  \\n  itv.push([left,right])\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=i;j&lt;len;j++)itv.push(<span class=\\"hljs-keyword\\">this</span>.interval[j])\\n  <span class=\\"hljs-keyword\\">this</span>.interval=itv\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * @return {Interval[]}\\n */</span>\\nSummaryRanges.prototype.getIntervals = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.interval\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your SummaryRanges object will be instantiated and called as such:\\n * var obj = Object.create(SummaryRanges).createNew()\\n * obj.addNum(val)\\n * var param_2 = obj.getIntervals()\\n */</span>\\n</code></pre>\\n"],"querySlug":"data-stream-as-disjoint-intervals","created_at":"2019-04-26","timeArr":[2019,3,26,12,58,25,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>和<code>NO.715</code>或者<code>NO.57</code>基本一致，每次<code>addNum</code>的时候将<code>val</code>看成一个区间<code>[val,val]</code>，然后就是区间插入问题了。</p>\\n","content":"<p>给定一个非负整数的数据流输入 a<sub>1</sub>，a<sub>2</sub>，&hellip;，a<sub>n，</sub>&hellip;，将到目前为止看到的数字总结为不相交的区间列表。</p>\\n\\n<p>例如，假设数据流中的整数为 1，3，7，2，6，&hellip;，每次的总结为：</p>\\n\\n<pre>[1, 1]\\n[1, 1], [3, 3]\\n[1, 1], [3, 3], [7, 7]\\n[1, 3], [7, 7]\\n[1, 3], [6, 7]\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>进阶：</strong><br>\\n如果有很多合并，并且与数据流的大小相比，不相交区间的数量很小，该怎么办?</p>\\n\\n<p><strong>提示：</strong><br>\\n特别感谢 <a href=\\"https://discuss.leetcode.com/user/yunhong\\">@yunhong</a> 提供了本问题和其测试用例。</p>\\n","title":"352. 将数据流变为多个不相交区间","relatedTags":["设计","二分查找","有序集合"],"difficult":"Hard","lang":["javascript"],"uniqueID":"352","slug":"352-Data-Stream-as-Disjoint-Intervals"}')}}]);