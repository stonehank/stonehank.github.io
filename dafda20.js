(window.webpackJsonp=window.webpackJsonp||[]).push([[983],{1781:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> getPermutation = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">n, k</span>) </span>{\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">factorial</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(n===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">let</span> m=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=n;i&gt;=<span class=\\"hljs-number\\">1</span>;i--){\\n      m*=i\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> m\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> cache=<span class=\\"hljs-built_in\\">Array</span>(n).fill().map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">n,i</span>)=&gt;</span>i+<span class=\\"hljs-number\\">1</span>)\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-string\\">\'\'</span>\\n  k-=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=n<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n    <span class=\\"hljs-keyword\\">let</span> f=factorial(i)\\n    <span class=\\"hljs-keyword\\">let</span> chooseID=f===<span class=\\"hljs-number\\">0</span>? <span class=\\"hljs-number\\">0</span> : <span class=\\"hljs-built_in\\">Math</span>.floor(k/f)\\n    res+=cache[chooseID]\\n    cache.splice(chooseID,<span class=\\"hljs-number\\">1</span>)\\n    k=k % f\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"permutation-sequence","created_at":"2019-03-29","timeArr":[2019,2,29,11,18,47,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>因为题目给出了<code>n&lt;=9</code>，在这个范围内可以使用暴力解(回溯)，但肯定不是最优解，一旦<code>n&gt;=12</code>耗时就很可怕了。</p>\\n<p>这里最优解使用的是<code>Cantor expansion 康拓逆展开</code>。</p>\\n<p>什么是<code>康拓展开</code>和<code>康拓逆展开</code>呢，维基百科写的很清楚，这里也简单说一下。</p>\\n<p>例如，<code>2431</code>有多少种排列方式会比它小的，那么我们的计算方式是：</p>\\n<p><code>1 * 3! + 2 * 2! + 1 * 1! + 0 * 0! = 11</code></p>\\n<p>解释：</p>\\n<p>第一个数<code>2</code>，比它小的有1个，后续能排列数量有<code>3!</code></p>\\n<p>第二个数<code>4</code>，减去它之前的<code>2</code>，比它小的还有2个，后续能排列数量有<code>2!</code></p>\\n<p>第三个数<code>3</code>，减去它之前的<code>2</code>，比它小的还有1个，后续能排列数量有<code>1!</code></p>\\n<p>...</p>\\n<p>这就是康拓展开，那么康拓逆展开就是反过来。</p>\\n<p>例如 <code>n=4, k=12</code></p>\\n<p>那么首先前面有<code>k-1=11</code>个排序是比当前小的。</p>\\n<p>第一个数字，<code>11 除以 3!</code>，结果为<code>1</code>余<code>5</code>，说明有1个比它小，因此第一个数字是<code>2</code>；</p>\\n<p>第二个数字，<code>5 除以 2!</code>，结果为<code>2</code>余<code>1</code>，说明有2个比它小，因为上面<code>2</code>已经使用了，因此这里是<code>4</code>；</p>\\n<p>第三个数字，<code>1 除以 1!</code>，结果为<code>1</code>余<code>0</code>，说明有1个比它小，上面<code>2</code>已经使用了，因此这里是<code>3</code>；</p>\\n<p>第四个数字，<code>0 除以 0!</code>，<code>0</code>为分母无法计算，这里是最后一个数字<code>1</code>。</p>\\n<p>时间复杂度是<code>O(n)</code>。</p>\\n","content":"<p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p>\\n\\n<p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>\\n\\n<ol>\\n\\t<li><code>\\"123\\"</code></li>\\n\\t<li><code>\\"132\\"</code></li>\\n\\t<li><code>\\"213\\"</code></li>\\n\\t<li><code>\\"231\\"</code></li>\\n\\t<li><code>\\"312\\"</code></li>\\n\\t<li><code>\\"321\\"</code></li>\\n</ol>\\n\\n<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>n = 3, k = 3\\n<strong>输出：</strong>\\"213\\"\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>n = 4, k = 9\\n<strong>输出：</strong>\\"2314\\"\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>n = 3, k = 1\\n<strong>输出：</strong>\\"123\\"\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= n <= 9</code></li>\\n\\t<li><code>1 <= k <= n!</code></li>\\n</ul>\\n","title":"60. 排列序列","relatedTags":["递归","数学"],"difficult":"Hard","lang":["javascript"],"uniqueID":"60","slug":"60-Permutation-Sequence"}')}}]);