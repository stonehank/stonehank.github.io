(window.webpackJsonp=window.webpackJsonp||[]).push([[1122],{1920:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">arr</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> maxChunksToSorted = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">arr</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> max=[],dp=[]\\n  max[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">0</span>\\n  dp[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(arr[i]&gt;max[i]){\\n      dp[i+<span class=\\"hljs-number\\">1</span>]=dp[i]+<span class=\\"hljs-number\\">1</span>\\n      max[i+<span class=\\"hljs-number\\">1</span>]=arr[i]\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">let</span> id=i\\n      <span class=\\"hljs-keyword\\">while</span>(arr[i]&lt;max[id]){\\n        max[id]=max[i]\\n        id--\\n      }\\n      dp[i+<span class=\\"hljs-number\\">1</span>]=dp[id]+<span class=\\"hljs-number\\">1</span>\\n      max[i+<span class=\\"hljs-number\\">1</span>]=max[i]\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> dp[dp.length<span class=\\"hljs-number\\">-1</span>]    \\n};\\n</code></pre>\\n"],"querySlug":"max-chunks-to-make-sorted-ii","created_at":"2019-03-15","timeArr":[2019,2,15,13,24,1,0],"hasThinking":false,"content":"<p><em>这个问题和&ldquo;最多能完成排序的块&rdquo;相似，但给定数组中的元素可以重复，输入数组最大长度为<code>2000</code>，其中的元素最大为<code>10**8</code>。</em></p>\\n\\n<p><code>arr</code>是一个可能包含<strong>重复元素</strong>的整数数组，我们将这个数组分割成几个&ldquo;块&rdquo;，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>\\n\\n<p>我们最多能将数组分成多少块？</p>\\n\\n<p><strong>示例&nbsp;1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> arr = [5,4,3,2,1]\\n<strong>输出:</strong> 1\\n<strong>解释:</strong>\\n将数组分成2块或者更多块，都无法得到所需的结果。\\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> arr = [2,1,3,4,4]\\n<strong>输出:</strong> 4\\n<strong>解释:</strong>\\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \\n</pre>\\n\\n<p><strong>注意:</strong></p>\\n\\n<ul>\\n\\t<li><code>arr</code>的长度在<code>[1, 2000]</code>之间。</li>\\n\\t<li><code>arr[i]</code>的大小在<code>[0, 10**8]</code>之间。</li>\\n</ul>\\n","title":"768. 最多能完成排序的块 II","relatedTags":["栈","贪心","数组","排序","单调栈"],"difficult":"Hard","lang":["javascript"],"uniqueID":"768","slug":"768-Max-Chunks-To-Make-Sorted-II"}')}}]);