(window.webpackJsonp=window.webpackJsonp||[]).push([[505],{1303:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> pseudoPalindromicPaths  = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> pathObj={\\n    [root.val]:<span class=\\"hljs-number\\">1</span>\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">0</span>\\n  dfs(root,pathObj)\\n  <span class=\\"hljs-keyword\\">return</span> res\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">root,pathObj</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(root.left){\\n      <span class=\\"hljs-keyword\\">let</span> lVal=root.left.val\\n      <span class=\\"hljs-keyword\\">if</span>(!pathObj[lVal])pathObj[lVal]=<span class=\\"hljs-number\\">0</span>\\n      pathObj[lVal]++\\n      dfs(root.left,pathObj)\\n      pathObj[lVal]--\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(root.right){\\n      <span class=\\"hljs-keyword\\">let</span> rVal=root.right.val\\n      <span class=\\"hljs-keyword\\">if</span>(!pathObj[rVal])pathObj[rVal]=<span class=\\"hljs-number\\">0</span>\\n      pathObj[rVal]++\\n      dfs(root.right,pathObj)\\n      pathObj[rVal]--    \\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(!root.left &amp;&amp; !root.right){\\n      <span class=\\"hljs-keyword\\">let</span> single=<span class=\\"hljs-number\\">0</span>\\n      <span class=\\"hljs-keyword\\">let</span> valid=<span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-comment\\">// console.log(pathObj)</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k <span class=\\"hljs-keyword\\">in</span> pathObj){\\n        <span class=\\"hljs-keyword\\">if</span>(pathObj[k] % <span class=\\"hljs-number\\">2</span>===<span class=\\"hljs-number\\">1</span>){\\n          <span class=\\"hljs-keyword\\">if</span>(single&gt;<span class=\\"hljs-number\\">0</span>){\\n            valid=<span class=\\"hljs-literal\\">false</span>\\n            <span class=\\"hljs-keyword\\">break</span>\\n          }<span class=\\"hljs-keyword\\">else</span>{\\n            single=<span class=\\"hljs-number\\">1</span>\\n          }\\n        }\\n      }\\n      <span class=\\"hljs-keyword\\">if</span>(valid){\\n        res++\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"pseudo-palindromic-paths-in-a-binary-tree","created_at":"2020-05-24","timeArr":[2020,4,24,10,57,54,0],"hasThinking":false,"content":"<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>\\n\\n<p>请你返回从根到叶子节点的所有路径中&nbsp;<strong>伪回文&nbsp;</strong>路径的数目。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png\\" style=\\"height: 201px; width: 300px;\\"></p>\\n\\n<pre><strong>输入：</strong>root = [2,3,1,3,1,null,1]\\n<strong>输出：</strong>2 \\n<strong>解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。\\n     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png\\" style=\\"height: 314px; width: 300px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]\\n<strong>输出：</strong>1 \\n<strong>解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。\\n     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>root = [9]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>给定二叉树的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>10^5</code>&nbsp;之间。</li>\\n\\t<li>节点值在&nbsp;<code>1</code> 到&nbsp;<code>9</code>&nbsp;之间。</li>\\n</ul>\\n","title":"1457. 二叉树中的伪回文路径","relatedTags":["位运算","树","深度优先搜索","广度优先搜索","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1457","slug":"1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree"}')}}]);