(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{575:function(n){n.exports=JSON.parse('{"content":"<p><a href=\\"https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/\\">原文阅读</a></p>\\n<p><img src=\\"/article/img/js_obfuscation.png\\" alt=\\"js_obfuscation\\"></p>\\n<p><a href=\\"#%E7%BC%96%E7%A0%81\\">编码</a></p>\\n<p><a href=\\"#%E5%8A%A0%E5%AF%86\\">加密</a></p>\\n<p><a href=\\"#%E6%95%A3%E5%88%97%E6%B3%95(%E5%93%88%E5%B8%8C)\\">散列法</a></p>\\n<p><a href=\\"#%E6%B7%B7%E6%B7%86\\">混淆</a></p>\\n<p>很多人都对编码，加密，哈希，混淆的不同点感到<a href=\\"http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=what%27s+the+difference+between+encoding+and+encryption%3F\\">疑惑</a>，我们一个一个解释：</p>\\n<h3 id=\\"bian-ma\\">编码</h3>\\n<p> <img src=\\"/article/img/ascii-image.png\\" alt=\\"ascii\\"></p>\\n<p>编码的目的是将数据转换，使其能被各类不同的系统正确(安全)的解析。例如：email发送的是二进制数据，在web上查看特殊字符。\\n它的目的<em>不是</em>为了让数据更安全，而是能让数据被正确的解析。</p>\\n<p>编码通过一些公开可用的方案将数据转换成另一种格式，因此它是可逆的。对编码进行解码不需要密钥，仅仅需要生成这个编码的算法。</p>\\n<p>例子：<a href=\\"http://www.asciitable.com/\\">ASCII</a>, <a href=\\"https://danielmiessler.com/study/encoding/#unicode\\">UNICODE</a>, <a href=\\"http://www.eskimo.com/~bloo/indexdot/html/topics/urlencoding.htm\\">URL ENCODING</a>, <a href=\\"https://en.wikipedia.org/wiki/Base64\\">BASE64</a></p>\\n<p>加密</p>\\n<p><img src=\\"/article/img/ciphertext.png\\" alt=\\"ciphertext\\"></p>\\n<p>加密的目的是转换数据以使其对其他人保密，例如:通过互联网向某人发送一封只有他们才能阅读的秘密信件，或者安全地发送密码。\\n比起关注适用和易用性，加密的目的是确保除了预期接收者之外的任何人都不能解读数据。</p>\\n<p>加密将数据通过某种方式转换为另一种格式，使得只有特定的个人可以解密。 它通过私有密钥，结合数据内容和算法执行加密操作。\\n因此，对加密内容的解密需要密文，算法和密钥缺一不可。</p>\\n<p>例子：<a href=\\"http://www.aes.org/\\">AES</a>, <a href=\\"https://en.wikipedia.org/wiki/Blowfish_(cipher)\\">BLOWFISH</a>, <a href=\\"http://www.rsa.com/\\">RSA</a></p>\\n<h3 id=\\"san-lie-fa-ha-xi\\">散列法(哈希)</h3>\\n<p><img src=\\"/article/img/sha512.gif\\" alt=\\"sha512\\"></p>\\n<p>散列法的目的是确保完整性，也就是说，当数据内容发生变化时你可以知道它已被更改。\\n从技术上讲，散列对任意输入都会生成固定长度字符串，它符合以下特性：</p>\\n<ol>\\n<li>输入相同，输出一定相同</li>\\n<li>绝大部分不同的输入不应该产生相同的输出</li>\\n<li>输入到输出行为不可逆</li>\\n<li>对输入值的修改会导致输出产生巨大的改变</li>\\n</ol>\\n<p>散列法与认证结合使用，确保某个特定的消息未被修改。 它的实现通过对需要传送的消息进行散列处理，然后使用发送方的密钥对这个散列值加密。</p>\\n<p>当接收方收到消息时，他们可以使用发送方的公钥解密出散列值，然后自己对邮件进行散列处理，并将自己处理得出的散列值与发送方传来的的散列值进行比较。 如果能匹配则是一个未修改的消息。</p>\\n<p>例子：<a href=\\"https://en.wikipedia.org/wiki/SHA-3\\">SHA-3</a>, <a href=\\"https://en.wikipedia.org/wiki/MD5\\">MD5 (已经废弃)</a>, 等等。</p>\\n<h3 id=\\"hun-xiao\\">混淆</h3>\\n<p><img src=\\"/article/img/obfuscated-e1454498907454.png\\" alt=\\"obfuscated\\"></p>\\n<p>混淆的目的是使某些东西更难理解，通常是为了使攻击或复制更加困难。</p>\\n<p>一个常见的用途是混淆源代码，使得这个项目难以被逆向工程。</p>\\n<p>重要的一点，混淆并不是一个安全的保护措施(例如加密），而是一个干扰。\\n它与编码一样，通常可以通过使用对数据混淆的算法来逆转，或者通过一个耗时的人工处理。</p>\\n<p>关于混淆的另一个关键点，根据对要进行混淆的内容不同，混淆代码的程度是有限制的。\\n例如，如果你要对代码进行混淆，必须要保证混淆的结果仍然可以被计算机解析，否则程序将停止运行。</p>\\n<p>例子: <a href=\\"https://javascriptobfuscator.com/\\">JAVASCRIPT OBFUSCATOR</a>, <a href=\\"http://proguard.sourceforge.net/\\">PROGUARD</a></p>\\n<h3 id=\\"zong-jie\\">总结</h3>\\n<p>编码用于维持数据能合适的使用，并且可以通过采用对内容进行编码的相同算法来逆转，不需要密钥。</p>\\n<p>加密用于维护数据机密性，并且需要使用密钥（保密）才能获取原数据。</p>\\n<p>散列法用于通过检测数据散列值是否有明显改变，来验证数据内容的完整性。</p>\\n<p>混淆用于防止人们理解某些内容，经常用于混淆代码以防止逆向工程和盗窃产品的功能。</p>\\n<hr>\\n<p><em>注意</em>：</p>\\n<p>有人可能会问，何时使用混淆而不是加密，答案是混淆后的内容能使一个实体（如人类）更难理解，但其他一些东西（如计算机）能轻易解析。\\n而通过加密后的内容，人和计算机都无法在没有密钥的情况下解析内容。</p>\\n","toc":[{"anchor":"bian-ma","level":3,"text":"编码"},{"anchor":"san-lie-fa-ha-xi","level":3,"text":"散列法(哈希)"},{"anchor":"hun-xiao","level":3,"text":"混淆"},{"anchor":"zong-jie","level":3,"text":"总结"}],"relatedTags":null,"created_at":"2018-07-04","timeArr":[2018,6,4,0,0,0,0],"title":"编码-加密-哈希-混淆不同点-文章翻译","uuid":"e3c935001e875147dac6c7b68d6d86f7cfb78754","summary":"<p><a href=\\"https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/\\">原文阅读</a></p>\\n<p><img src=\\"/article/img/js_obfuscation.png\\" alt=\\"js_obfuscation\\"></p>\\n<p><a href=\\"#%E7%BC%96%E7%A0%81\\">编码</a></p>\\n<p><a href=\\"#%E5%8A%A0%E5%AF%86\\">加密</a></p>\\n<p>[散列...</p>","slug":"bian-ma-jia-mi-ha-xi-hun-xiao-bu-tong-dian-wen-zhang-fan-yi","sha":"e315fbb406b0f3100dfcf4ec5b7ebb7fc1f41a83"}')}}]);