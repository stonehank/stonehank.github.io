(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{637:function(n){n.exports=JSON.parse('{"content":"<p>通常海明距离的计算使用 <code>^</code>，再计算1的次数</p>\\n<p>但如果遇到大量数据，并且需要计算相互的海明距离，这种方法就不合适了，因为每次计算1的次数相对消耗是巨大的</p>\\n<p>另一种计算海明距离的方法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n* <span class=\\"hljs-doctag\\">@param </span>nums {Array}\\n* <span class=\\"hljs-doctag\\">@returns <span class=\\"hljs-type\\">{number}</span></span>\\n*/</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcHam</span>(<span class=\\"hljs-params\\">nums</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> total=<span class=\\"hljs-number\\">0</span>,binCount\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">32</span>;i++){\\n    binCount=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;nums.length;j++){\\n          binCount+=(nums[j] &gt;&gt; i) &amp; <span class=\\"hljs-number\\">1</span>\\n    }\\n    total+=binCount*(nums.length-binCount)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> total\\n}</code></pre></code></pre>\\n<p>这里主要是 <code>&gt;&gt;</code> 和 <code>&amp;</code>，实现对每一个数据进行位数处理</p>\\n<p>思路是：</p>\\n<p>1、对每一个数据进行右移 i位<code>nums[j] &gt;&gt; i</code> ，得出 k</p>\\n<p>2、对 k 进行 <code>k &amp; 1</code>， 1 的二进制是<code>...00001</code>，因此可以判断出 k 的最后1位是 1 还是 0，所以<code>binCount</code>就是最后一位为1的数量</p>\\n<p>3、<code>binCount*(nums.length-binCount)</code> ，其中<code>nums.length-binCount</code>指最后一位是0的数量，因此<code>1的数量*0的数量</code>，也就是它们能组合的海明距离</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-23","timeArr":[2018,7,23,0,0,0,0],"title":"深入海明距离","uuid":"a5bed495fbfaa670dcb632ac350bfa5c527e6eca","summary":"<p>通常海明距离的计算使用 <code>^</code>，再计算1的次数</p>\\n<p>但如果遇到大量数据，并且需要计算相互的海明距离，这种方法就不合适了，因为每次计算1的次数相对消耗是巨大的</p>\\n<p>另一种计算海明距离的方法：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n* <span class=\\"hljs-doctag\\">@param </span>nums {Array}\\n* <span class=\\"hljs-doctag\\">@returns <span class=\\"hljs-type\\">{number}</span></span>\\n*/</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">cal</span>...</span></code></pre>","slug":"shen-ru-hai-ming-ju-li","sha":"4a3568d093ea0316f644a973e4b91143b8563bd4"}')}}]);