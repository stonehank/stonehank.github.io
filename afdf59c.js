(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{678:function(e){e.exports=JSON.parse('{"content":"<p>流程：</p>\\n<ol>\\n<li><p>子元素获取</p>\\n<p> 通过<code>ref</code>获取子元素的<code>DOM</code></p>\\n<ul>\\n<li><p>子元素是<code>DOM</code>（最容易获取）</p>\\n</li>\\n<li><p>子元素是组件，尝试通过<code>ForwardRef</code>获取，如果子组件不是<code>ForwardRef</code>，通过<code>innerRef</code>获取</p>\\n<p>如果<code>ref</code>获取不到值，将返回（不执行）</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>父元素获取</p>\\n<p> 通过子元素的<code>parentNode</code>向上遍历，直到找到<code>overflow</code>为<code>auto</code>或者<code>scroll</code>，否则设置为<code>window</code></p>\\n<p> 通过<code>getComputedStyle</code>去获取<code>overflow</code>的值。（此处并不完美，依赖用户自觉）</p>\\n</li>\\n<li><p>判断子元素是否出现在规定范围内</p>\\n<p> 用户定义2个属性：<code>topOffset</code>和<code>bottomOffset</code>，可以理解为<code>上边线</code>和<code>下边线</code></p>\\n<p> 通过<code>getBoundingClientRect</code>，计算出<code>子元素</code>顶端和底端到<code>视口</code>顶端的距离</p>\\n<p> 通过<code>上/下边线</code>和<code>父元素</code>的高度和<code>父元素</code>顶端到视口顶端的距离，计算出<code>上/下边线</code>分别距离视口顶端的距离</p>\\n<p> 对比以上2个数据，分别赋予当前<code>子元素</code>的4种位置状态：<code>invisible</code>，<code>inside</code>，<code>below</code>，<code>above</code></p>\\n</li>\\n</ol>\\n<p>亮点：</p>\\n<ol>\\n<li><p>onNextTick ： 一个将任务加入队列执行的方案，通过<code>setTimeout(()=&gt;{},0)</code>的使用：</p>\\n<ol>\\n<li>可以在任务开始前停止。</li>\\n<li>确保<code>ref</code>能完全获取。</li>\\n<li>任务之间不会冲突。</li>\\n</ol>\\n</li>\\n<li><p>fireOnRapidScroll ： 如果<code>scroll</code>执行过快，有可能子元素上一次事件还在<code>below</code>，这一次已经是<code>above</code>，\\n 当出现这样的情况，会强制执行<code>enter</code>和<code>leave</code>事件。</p>\\n</li>\\n<li><p>使用<code>React.cloneElement</code>配置<code>this.props.children</code></p>\\n</li>\\n</ol>\\n<p>可能存在的缺陷：</p>\\n<p>当存在一个很长的<code>ul</code>列表，而给<code>ul</code>添加了<code>overflow:auto</code>，但并未设置<code>height</code>，这时<code>ul</code>并不是一个滚动组件，\\n真正的滚动还是触发在<code>window</code>，但<code>waypoint</code>会因为存在属性<code>overflow:auto</code>，而将<code>ul</code>认为是滚动组件父元素。</p>\\n<p><a href=\\"https://codesandbox.io/s/ly9y4v9m5m\\">例子</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-12-28","timeArr":[2018,11,28,0,0,0,0],"title":"源码阅读-react-waypoint","uuid":"125d2f3de95fae020f190d4c57a5cc55e26a84fd","summary":"<p>流程：</p>\\n<ol>\\n<li>\\n<p>子元素获取</p>\\n<p>通过<code>ref</code>获取子元素的<code>DOM</code></p>\\n<ul>\\n<li>子元素是<code>DOM</code>（最容易获取）</li>\\n<li>子元素是组件，尝试通过<code>ForwardRef</code>获取，如果子组件不是<code>ForwardRef</code>，通过<code>innerRef</code>获取</li>\\n</ul>\\n<p>如果<code>ref</code>获取不到值，将返回（...</p>\\n</li>\\n</ol>","slug":"yuan-ma-yue-du-react-waypoint","sha":"4b00e3a197c088451f6327743beded39e4aaad11"}')}}]);