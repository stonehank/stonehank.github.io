(window.webpackJsonp=window.webpackJsonp||[]).push([[908],{1706:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findMode = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span> []\\n  <span class=\\"hljs-keyword\\">let</span> last=<span class=\\"hljs-literal\\">null</span>,maxfreq=<span class=\\"hljs-number\\">0</span>,curfreq=<span class=\\"hljs-number\\">0</span>,mode=[]\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">if</span>(root.left)dfs(root.left)\\n    <span class=\\"hljs-keyword\\">if</span>(root.val!==last){\\n      <span class=\\"hljs-keyword\\">if</span>(maxfreq&lt;curfreq){\\n        mode=[last]\\n        maxfreq=curfreq\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(maxfreq===curfreq){\\n        mode.push(last)\\n      }\\n      curfreq=<span class=\\"hljs-number\\">1</span>\\n      last=root.val\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      curfreq++\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(root.right)dfs(root.right)\\n  }\\n  dfs(root)\\n  <span class=\\"hljs-keyword\\">if</span>(maxfreq&lt;curfreq)mode=[last]\\n  <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(maxfreq===curfreq)mode.push(last)\\n  <span class=\\"hljs-keyword\\">return</span> mode\\n};\\n</code></pre>\\n"],"querySlug":"find-mode-in-binary-search-tree","created_at":"2019-03-19","timeArr":[2019,2,19,10,32,31,0],"hasThinking":false,"content":"<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>\\n\\n<p>假定 BST 有如下定义：</p>\\n\\n<ul>\\n\\t<li>结点左子树中所含结点的值小于等于当前结点的值</li>\\n\\t<li>结点右子树中所含结点的值大于等于当前结点的值</li>\\n\\t<li>左子树和右子树都是二叉搜索树</li>\\n</ul>\\n\\n<p>例如：<br>\\n给定 BST <code>[1,null,2,2]</code>,</p>\\n\\n<pre>   1\\n    \\\\\\n     2\\n    /\\n   2\\n</pre>\\n\\n<p><code>返回[2]</code>.</p>\\n\\n<p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p>\\n\\n<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>\\n","title":"501. 二叉搜索树中的众数","relatedTags":["树","深度优先搜索","二叉搜索树","二叉树"],"difficult":"Easy","lang":["javascript"],"uniqueID":"501","slug":"501-Find-Mode-in-Binary-Search-Tree"}')}}]);