(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{640:function(n){n.exports=JSON.parse('{"content":"<p>思路：利用对称思想</p>\\n<ol>\\n<li><p>先将原字符串转换成转换成 <code>#x$x$x$</code> 的形式(一定是奇数)</p>\\n</li>\\n<li><p>p为一个数组，储存每一个值的最大回文数量的一半+1，例如：&#39;ababa&#39; 对应的p 就是<code>[1,2,3,2,1]</code></p>\\n</li>\\n<li><p><code>max</code>为当前已经计算过得最大回文量<code>p[id]</code>+对应的位置<code>id</code>，默认为0或者-infinity，可以保证最后的max和id不为0</p>\\n</li>\\n<li><p>遍历变形的字符串，指针为<code>i</code></p>\\n<p> <code>i</code>在当前<code>max</code>所涵盖的范围内，如下图，<code>i</code>在<code>max</code>范围内，<code>j</code>是对称的点</p>\\n<pre><code><pre class=\\"hljs\\"><code>   j        i\\n ------id------</code></pre></code></pre><p> 分4种情况:</p>\\n<ol>\\n<li><p><code>j</code>超出范围，那么<code>i</code>只取范围内</p>\\n<pre><code><pre class=\\"hljs\\"><code> ---j---      -i-\\n   ------id------              </code></pre></code></pre></li>\\n<li><p><code>j</code>边界刚好在范围上，不仅将<code>i</code>设置，并且还要继续扩展<code>i</code>，因为虽然<code>j</code>左边不存在，但<code>i</code>的右边不确定</p>\\n<pre><code><pre class=\\"hljs\\"><code>  --j--    --i--\\n  ------id------   =&gt;  继续扩展i</code></pre></code></pre></li>\\n<li><p><code>j</code>边界在范围内，只需要简单赋值给<code>i</code>即可，因为此时<code>j</code>和<code>i</code>的值完全相等</p>\\n<pre><code><pre class=\\"hljs\\"><code>  -j-      -i-\\n ------id------</code></pre></code></pre></li>\\n<li><p><code>i</code>不在当前<code>max</code>所涵盖的范围内，需要扩展</p>\\n<pre><code><pre class=\\"hljs\\"><code>               i\\n------id------     =&gt; 需要扩展i</code></pre></code></pre></li>\\n</ol>\\n</li>\\n<li><p>最后扩展完后重新定义<code>p[i]</code>和<code>max</code>，<code>id</code>，最终<code>2*(max-id)-1</code>就是最大子回文字符串长度</p>\\n</li>\\n</ol>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>  <span class=\\"hljs-title\\">manacher</span>(<span class=\\"hljs-params\\">s</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 这里不论奇偶，都将s转换成 \'#x$x$x$\' 的形式</span>\\n  <span class=\\"hljs-keyword\\">let</span> str=<span class=\\"hljs-string\\">\'#\'</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;s.length;i++) str+=s[i]+<span class=\\"hljs-string\\">\'$\'</span>\\n  <span class=\\"hljs-comment\\">// p为一个数组，储存每一个值的最大回文数量的一半+1，例如：\'ababa\' 对应的p 就是[1,2,3,2,1]</span>\\n  <span class=\\"hljs-keyword\\">let</span> p=[<span class=\\"hljs-number\\">1</span>]\\n  <span class=\\"hljs-comment\\">// max为当前已经计算过得最大回文量(p[id])+对应的位置(id)，默认为0或者-infinity，可以保证最后的max和id不为0</span>\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">0</span>,id=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 暴力计算时，从左右什么位置开始进行对比</span>\\n  <span class=\\"hljs-keyword\\">let</span> temp=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-comment\\">// newCenter是目前需要重新暴力计算的位置</span>\\n  <span class=\\"hljs-keyword\\">let</span> newCenter=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 从第一个开始遍历，第0个不用管，是\'#\'</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;str.length;i++){\\n    <span class=\\"hljs-comment\\">// i在当前max所涵盖的范围内，如下图，i在max范围内，j是对称的点</span>\\n    <span class=\\"hljs-comment\\">/*\\n      *        j        i\\n      *      ------id------\\n    * */</span>\\n    <span class=\\"hljs-keyword\\">if</span>(max&gt;i){\\n      <span class=\\"hljs-comment\\">// 在范围内对称的位置</span>\\n      <span class=\\"hljs-keyword\\">let</span> j=id-(i-id)\\n      <span class=\\"hljs-comment\\">// 通过boundary判断对称位置那个是否会超出范围</span>\\n      <span class=\\"hljs-keyword\\">let</span> boundary=p[j]+i\\n      <span class=\\"hljs-comment\\">// j超出范围，那么i只取范围内，如下图</span>\\n      <span class=\\"hljs-comment\\">/*\\n      *    ---j---      -i-\\n      *      ------id------\\n      * */</span>\\n      <span class=\\"hljs-keyword\\">if</span>(boundary&gt;max){\\n        p[i]=p[j]-(boundary-max)\\n        <span class=\\"hljs-keyword\\">continue</span>;\\n      <span class=\\"hljs-comment\\">// j边界刚好在范围上，不仅将i设置，并且还要继续扩展i，即设置newCenter和temp</span>\\n        <span class=\\"hljs-comment\\">/*\\n        *      --j--    --i--\\n        *      ------id------   =&gt;  继续扩展i\\n        * */</span>\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(boundary===max){\\n        temp=p[j]\\n        newCenter=i\\n      <span class=\\"hljs-comment\\">// j边界在范围内，只需要简单赋值给i即可，因为此时j和i的值完全相等</span>\\n        <span class=\\"hljs-comment\\">/*\\n        *       -j-      -i-\\n        *      ------id------\\n        * */</span>\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        p[i]=p[j]\\n        <span class=\\"hljs-keyword\\">continue</span>;\\n      }\\n      <span class=\\"hljs-comment\\">// i不在当前max所涵盖的范围内，需要暴力计算，如下图</span>\\n      <span class=\\"hljs-comment\\">/*\\n        *                     i\\n        *      ------id------     =&gt; 需要扩展i\\n      * */</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      temp=<span class=\\"hljs-number\\">1</span>\\n      newCenter=i\\n    }\\n    <span class=\\"hljs-comment\\">// 暴力计算</span>\\n    <span class=\\"hljs-keyword\\">while</span>(newCenter-temp&gt;=<span class=\\"hljs-number\\">0</span> &amp;&amp; newCenter+temp &lt;str.length &amp;&amp; str[newCenter-temp]===str[newCenter+temp]){\\n      temp++\\n    }\\n    <span class=\\"hljs-comment\\">// 暴力计算完后重新定义p[i]和max，id</span>\\n    p[i]=temp\\n    <span class=\\"hljs-keyword\\">if</span>(p[i]&gt;max-id){\\n      max=p[i]+i\\n      id=i\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 此时2*(max-id)-1就是最大回文字符串的length</span>\\n\\n  <span class=\\"hljs-comment\\">// 去掉# 和 $符号</span>\\n  <span class=\\"hljs-keyword\\">let</span> res=str[id],realRes=<span class=\\"hljs-string\\">\'\'</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;max-id;i++){\\n    res=str[id-i]+res+str[id+i]\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;res.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(res[i]===<span class=\\"hljs-string\\">\'$\'</span> || res[i]===<span class=\\"hljs-string\\">\'#\'</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    realRes+=res[i]\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> realRes\\n}</code></pre></code></pre>\\n<p>测试：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> test=[<span class=\\"hljs-string\\">\\"abb\\"</span>,<span class=\\"hljs-string\\">\\"a\\"</span>,<span class=\\"hljs-string\\">\\"aaaabaaa\\"</span>,<span class=\\"hljs-string\\">\\"bb\\"</span>,<span class=\\"hljs-string\\">\\"ccc\\"</span>,<span class=\\"hljs-string\\">\'abbxz\'</span>,<span class=\\"hljs-string\\">\'accbcca\'</span>,<span class=\\"hljs-string\\">\'\'</span>,<span class=\\"hljs-string\\">\'abaxabaxabybaxabyb\'</span>]\\n<span class=\\"hljs-keyword\\">let</span> answer=[<span class=\\"hljs-string\\">\'bb\'</span>,<span class=\\"hljs-string\\">\'a\'</span>,<span class=\\"hljs-string\\">\'aaabaaa\'</span>,<span class=\\"hljs-string\\">\'bb\'</span>,<span class=\\"hljs-string\\">\'ccc\'</span>,<span class=\\"hljs-string\\">\'bb\'</span>,<span class=\\"hljs-string\\">\'accbcca\'</span>,<span class=\\"hljs-string\\">\'\'</span>,<span class=\\"hljs-string\\">\'baxabybaxab\'</span>]\\n<span class=\\"hljs-keyword\\">let</span> res\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;test.length;i++){\\nres=manacher(test[i])\\n  <span class=\\"hljs-built_in\\">console</span>.log(res===answer[i])\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-27","timeArr":[2018,7,27,0,0,0,0],"title":"算法记录-最长回文子字符串","uuid":"af105b2df12bc15528a731d149193b4aa9927533","summary":"<p>思路：利用对称思想</p>\\n<ol>\\n<li>先将原字符串转换成转换成 <code>#x$x$x$</code> 的形式(一定是奇数)</li>\\n<li>p为一个数组，储存每一个值的最大回文数量的一半+1，例如：\'ababa\' 对应的p 就是<code>[1,2,3,2,1]</code></li>\\n<li><code>max</code>为当前已经计算过得最大回文量<code>p[id]</code>+对应的位置<code>id</code>，默认为0或者-infi...</li>\\n</ol>","slug":"suan-fa-ji-lu-zui-chang-hui-wen-zi-zi-fu-chuan","sha":"b43da9771d20a5bb5e735c832af36f85b932df54"}')}}]);