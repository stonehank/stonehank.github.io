(window.webpackJsonp=window.webpackJsonp||[]).push([[870],{1668:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">DoubleLink</span>(<span class=\\"hljs-params\\">val,freq</span>)</span>{\\n  <span class=\\"hljs-keyword\\">this</span>.val=val\\n  <span class=\\"hljs-keyword\\">this</span>.next=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">this</span>.prev=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">this</span>.freqCount=freq\\n}\\nDoubleLink.prototype.append=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">node</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> nxt=<span class=\\"hljs-keyword\\">this</span>.next\\n  <span class=\\"hljs-keyword\\">this</span>.next=node\\n  node.prev=<span class=\\"hljs-keyword\\">this</span>\\n  node.next=nxt\\n  nxt.prev=node\\n}\\nDoubleLink.prototype.remove=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> nxt=<span class=\\"hljs-keyword\\">this</span>.next,\\n      pre=<span class=\\"hljs-keyword\\">this</span>.prev\\n  pre.next=nxt\\n  nxt.prev=pre\\n  <span class=\\"hljs-keyword\\">this</span>.next=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">this</span>.prev=<span class=\\"hljs-literal\\">null</span>\\n}\\n\\n<span class=\\"hljs-comment\\">// 双向链表内部为Map，双向链表删除添加都是O(1)，内部的Map查找添加删除是O(1)</span>\\n<span class=\\"hljs-comment\\">// key2Node管理了key对应的双向链表</span>\\n<span class=\\"hljs-comment\\">// 双向链表管理了key对应的freq的位置，内部的Map管理了key对应的value</span>\\n\\n\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">capacity</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> LFUCache = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">capacity</span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.key2Node=<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Map</span>()\\n  <span class=\\"hljs-keyword\\">this</span>.head=<span class=\\"hljs-keyword\\">new</span> DoubleLink(<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">this</span>.tail=<span class=\\"hljs-keyword\\">new</span> DoubleLink(<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">this</span>.head.next=<span class=\\"hljs-keyword\\">this</span>.tail\\n  <span class=\\"hljs-keyword\\">this</span>.tail.prev=<span class=\\"hljs-keyword\\">this</span>.head\\n  <span class=\\"hljs-keyword\\">this</span>.limitSize=capacity\\n  <span class=\\"hljs-keyword\\">this</span>.curSize=<span class=\\"hljs-number\\">0</span>\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {number} key\\n * @return {number}\\n */</span>\\nLFUCache.prototype.get = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">key</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!<span class=\\"hljs-keyword\\">this</span>.key2Node.has(key)) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-keyword\\">let</span> curNode=<span class=\\"hljs-keyword\\">this</span>.key2Node.get(key)\\n  <span class=\\"hljs-keyword\\">let</span> curMap=curNode.val\\n  <span class=\\"hljs-keyword\\">let</span> value=curMap.get(key)\\n  <span class=\\"hljs-keyword\\">if</span>(curNode.next.freqCount===curNode.freqCount+<span class=\\"hljs-number\\">1</span>){\\n    <span class=\\"hljs-keyword\\">let</span> nxtMap=curNode.next.val\\n    <span class=\\"hljs-keyword\\">let</span> nxtFreqKey=nxtMap.keys().next().value\\n      nxtMap.set(key,value)\\n      curMap.delete(key)\\n      <span class=\\"hljs-keyword\\">this</span>.key2Node.set(key,curNode.next)\\n  }<span class=\\"hljs-keyword\\">else</span>{\\n    <span class=\\"hljs-keyword\\">let</span> newNode=<span class=\\"hljs-keyword\\">new</span> DoubleLink(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Map</span>(),curNode.freqCount+<span class=\\"hljs-number\\">1</span>)\\n    curNode.append(newNode)\\n    newNode.val.set(key,value)\\n    curMap.delete(key)\\n    <span class=\\"hljs-keyword\\">this</span>.key2Node.set(key,newNode)\\n  }\\n  <span class=\\"hljs-keyword\\">if</span>(curMap.size===<span class=\\"hljs-number\\">0</span>)curNode.remove()\\n  <span class=\\"hljs-keyword\\">return</span> value\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */</span>\\nLFUCache.prototype.put = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">key, value</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.key2Node.has(key)){\\n    <span class=\\"hljs-keyword\\">this</span>.get(key)\\n    <span class=\\"hljs-keyword\\">let</span> curMap=<span class=\\"hljs-keyword\\">this</span>.key2Node.get(key).val\\n    curMap.delete(key)\\n    curMap.set(key,value)\\n    <span class=\\"hljs-keyword\\">return</span>\\n  }\\n  \\n  <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.curSize===<span class=\\"hljs-keyword\\">this</span>.limitSize){\\n    <span class=\\"hljs-keyword\\">let</span> delMapSet=<span class=\\"hljs-keyword\\">this</span>.head.next.val\\n    <span class=\\"hljs-keyword\\">if</span>(!delMapSet)<span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">let</span> delKey=delMapSet.keys().next().value\\n    delMapSet.delete(delKey)\\n    <span class=\\"hljs-keyword\\">this</span>.key2Node.delete(delKey)\\n    <span class=\\"hljs-keyword\\">this</span>.curSize--\\n    <span class=\\"hljs-keyword\\">if</span>(delMapSet.size===<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">this</span>.head.next.remove()\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> insertNode=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">let</span> headNode=<span class=\\"hljs-keyword\\">this</span>.head.next\\n  <span class=\\"hljs-keyword\\">let</span> headMap=headNode.val\\n  <span class=\\"hljs-keyword\\">if</span>(headNode.freqCount===<span class=\\"hljs-number\\">1</span>){\\n    <span class=\\"hljs-keyword\\">let</span> headMap=headNode.val\\n    headMap.set(key,value)\\n    insertNode=headNode      \\n  }<span class=\\"hljs-keyword\\">else</span>{\\n    <span class=\\"hljs-keyword\\">let</span> newNode= <span class=\\"hljs-keyword\\">new</span> DoubleLink(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Map</span>(),<span class=\\"hljs-number\\">1</span>)\\n    <span class=\\"hljs-keyword\\">this</span>.head.append(newNode)\\n    newNode.val.set(key,value)\\n    insertNode=newNode\\n  }\\n\\n  <span class=\\"hljs-keyword\\">this</span>.curSize++\\n  <span class=\\"hljs-keyword\\">this</span>.key2Node.set(key,insertNode)\\n\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your LFUCache object will be instantiated and called as such:\\n * var obj = Object.create(LFUCache).createNew(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */</span>\\n</code></pre>\\n"],"querySlug":"lfu-cache","created_at":"2019-04-19","timeArr":[2019,3,19,14,41,13,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>与<code>NO.432</code>比较像。</p>\\n<p>要求使用<code>O(1)</code>，需要对当前频率的集合<code>增加</code>，<code>删除</code>，同时对集合内部的结构<code>查找</code>，<code>增加</code>，<code>删除</code>，这些操作都要是<code>O(1)</code>。</p>\\n<p>其中频率的集合，可以使用<code>双向链表</code>，而双向链表内部，可以使用<code>Map</code>。</p>\\n<p>数据结构如下：</p>\\n<pre class=\\"hljs\\"><code>key2Node: { \'a\':DoubleLink,\'b\':DoubleLink,... }\\nDoubleLink&lt;Head&gt; &lt;===&gt; DoubleLink&lt;freq:1,val:Map&gt; &lt;===&gt; ... &lt;===&gt; DoubleLink&lt;count:5,val:Map&gt; &lt;===&gt; DoubleLink&lt;Tail&gt;\\n</code></pre>\\n<p>此处的<code>DoubleLink</code>的<code>Head</code>和<code>Tail</code>是虚拟的一个头部和尾部，定义<code>双向链表</code>的<code>删除</code>和<code>增加</code>方法是不需要额外处理边界问题。</p>\\n","content":"<p>请你为 <a href=\\"https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95\\">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p>\\n\\n<p>实现 <code>LFUCache</code> 类：</p>\\n\\n<ul>\\n\\t<li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li>\\n\\t<li><code>int get(int key)</code> - 如果键存在于缓存中，则获取键的值，否则返回 -1。</li>\\n\\t<li><code>void put(int key, int value)</code> - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li>\\n</ul>\\n\\n<p><strong>注意</strong>「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p>\\n\\n<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p>\\n\\n<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>\\n[\\"LFUCache\\", \\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\", \\"get\\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\\n<strong>输出：</strong>\\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\\n\\n<strong>解释：</strong>\\n// cnt(x) = 键 x 的使用计数\\n// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）\\nLFUCache lFUCache = new LFUCache(2);\\nlFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1\\nlFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\\nlFUCache.get(1);      // 返回 1\\n                      // cache=[1,2], cnt(2)=1, cnt(1)=2\\nlFUCache.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小\\n                      // cache=[3,1], cnt(3)=1, cnt(1)=2\\nlFUCache.get(2);      // 返回 -1（未找到）\\nlFUCache.get(3);      // 返回 3\\n                      // cache=[3,1], cnt(3)=2, cnt(1)=2\\nlFUCache.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用\\n                      // cache=[4,3], cnt(4)=1, cnt(3)=2\\nlFUCache.get(1);      // 返回 -1（未找到）\\nlFUCache.get(3);      // 返回 3\\n                      // cache=[3,4], cnt(4)=1, cnt(3)=3\\nlFUCache.get(4);      // 返回 4\\n                      // cache=[3,4], cnt(4)=2, cnt(3)=3</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>0 <= capacity, key, value <= 10<sup>4</sup></code></li>\\n\\t<li>最多调用 <code>10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code> 方法</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶：</strong>你可以为这两种操作设计时间复杂度为 <code>O(1)</code> 的实现吗？</p>\\n","title":"460. LFU 缓存","relatedTags":["设计","哈希表","链表","双向链表"],"difficult":"Hard","lang":["javascript"],"uniqueID":"460","slug":"460-LFU-Cache"}')}}]);