(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{655:function(e){e.exports=JSON.parse('{"content":"<h2 id=\\"yue-du-lodash-zhong-yi-duan-chang-zheng-ze-li-jie-bi-ji\\">阅读lodash中一段长正则理解笔记</h2>\\n<p>在lodash源码<code>/.internal/stringToPath.js</code>中：</p>\\n<p>这里英文是原注释，中文是简单的翻译下，后面会详细解释：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> rePropName = <span class=\\"hljs-built_in\\">RegExp</span>(\\n  <span class=\\"hljs-comment\\">// Match anything that isn\'t a dot or bracket.</span>\\n  <span class=\\"hljs-comment\\">// 匹配任意 非.和非[]的任意值(1个以上)</span>\\n  <span class=\\"hljs-string\\">\'[^.[\\\\\\\\]]+\'</span> + <span class=\\"hljs-string\\">\'|\'</span> +\\n  <span class=\\"hljs-comment\\">// Or match property names within brackets.</span>\\n  <span class=\\"hljs-comment\\">// 匹配 [</span>\\n  <span class=\\"hljs-string\\">\'\\\\\\\\[(?:\'</span> +\\n    <span class=\\"hljs-comment\\">// Match a non-string expression.</span>\\n    <span class=\\"hljs-comment\\">// 匹配(非\\" 或者 \')和后面任意数量值，即非字符串</span>\\n    <span class=\\"hljs-string\\">\'([^\\"\\\\\'].*)\'</span> + <span class=\\"hljs-string\\">\'|\'</span> +\\n    <span class=\\"hljs-comment\\">// Or match strings (supports escaping characters).</span>\\n    <span class=\\"hljs-comment\\">// 匹配字符串(支持转义字符)</span>\\n    <span class=\\"hljs-string\\">\'([\\"\\\\\'])((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*?)\\\\\\\\2\'</span> +\\n  <span class=\\"hljs-string\\">\')\\\\\\\\]\'</span>+ <span class=\\"hljs-string\\">\'|\'</span> +\\n  <span class=\\"hljs-comment\\">// Or match \\"\\" as the space between consecutive dots or empty brackets.</span>\\n  <span class=\\"hljs-comment\\">// 匹配连续的点或者中括号，然后匹配值为\\"\\"</span>\\n  <span class=\\"hljs-string\\">\'(?=(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\])(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\]|$))\'</span>\\n, <span class=\\"hljs-string\\">\'g\'</span>)</code></pre></code></pre>\\n<h2 id=\\"li-jie\\">理解</h2>\\n<ul>\\n<li>第一行</li>\\n</ul>\\n<p><code>&#39;[^.[\\\\\\\\]]+&#39; + &#39;|&#39; +</code></p>\\n<p>一个兜底的匹配，意思是匹配除了<code>.</code>和<code>[]</code>的任意值，后面的如果能匹配则会覆盖这个(因为后面的匹配字符更多)；</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-string\\">\'abc\'</span>.match(<span class=\\"hljs-regexp\\">/([^a]+|a(.)c)/</span>)\\n\\n<span class=\\"hljs-comment\\">// 这里两个都能匹配，前面匹配值为\'bc\'，后面的匹配值为\'abc\'，因此后面的优先匹配</span></code></pre></code></pre>\\n<p>这里要注意的就是在字符串中转义需要写两次<code>\\\\\\\\</code>，而且这里<code>.</code>是不需要转义，后面那个<code>]</code>需要转义因为构成了歧义。</p>\\n<ul>\\n<li>第二行</li>\\n</ul>\\n<p><code>&#39;\\\\\\\\[(?:&#39; +</code></p>\\n<p>这里有一个<code>?:</code>，意思是在这个括号内，匹配值但不需要储存匹配结果</p>\\n<ul>\\n<li>第三行</li>\\n</ul>\\n<p><code>&#39;([^&quot;\\\\&#39;].*)&#39; + &#39;|&#39; +</code></p>\\n<p>没有什么特别的...</p>\\n<ul>\\n<li>第四行</li>\\n</ul>\\n<p><code>&#39;([&quot;\\\\&#39;])((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*?)\\\\\\\\2&#39; +</code></p>\\n<p>先看<code>([&quot;\\\\&#39;])</code></p>\\n<p>也就是匹配双|单引号；</p>\\n<p>接着分两种匹配：</p>\\n<h5 id=\\"4-1\\">4-1</h5>\\n<p><code>((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]</code></p>\\n<p>这里首先是<code>?!</code>，正向否定预查，意思是只有(同一个括号内)后面的不满足，才能去匹配前面的值；</p>\\n<p>后面是<code>\\\\\\\\2</code>，转义后就是<code>\\\\2</code>，意思就是反向引用第二个括号储存的结果，就是<code>([&quot;\\\\&#39;])</code>；</p>\\n<p>因此<code>(?!\\\\\\\\2)</code>这里就是只要不是双|单引号，因为第四行最后有<code>*</code>，因此这里会抓取任意多个不是引号的字符，然后储存到括号匹配内（后面使用时的<a href=\\"#%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89\\">第四个参数</a>)）；</p>\\n<p>能抓取到这些值后，就去匹配前面的值，前面的值就是<code>([&quot;\\\\&#39;])</code>，还是双|单引号，如果不能抓取这些值(例如连续多个引号)，则无法匹配；</p>\\n<p><code>\\\\\\\\\\\\\\\\</code>转义后就是<code>\\\\\\\\</code>，意思就是匹配一个斜杠<code>\\\\</code>，这里就是不匹配<code>\\\\</code>；</p>\\n<p>所以这句的意思就是：匹配单个引号后面的非引号值，并且它后面不能是斜杠<code>\\\\</code></p>\\n<h5 id=\\"4-2\\">4-2</h5>\\n<p><code>|\\\\\\\\\\\\\\\\.</code></p>\\n<p>转义后就是<code>\\\\\\\\.</code>，意思就是匹配一个斜杠<code>\\\\</code>后面可以是任意值（<em>其实就是匹配转义字符</em>，例如\\\\a）</p>\\n<p>最后<code>*?)\\\\\\\\2</code></p>\\n<p>这里用了非贪婪模式，量词后面加<code>?</code>，再搭配后面的<code>\\\\\\\\2</code>（前面说了，也就是引号）。</p>\\n<p>整体的意思就是：<strong><em>前面2种匹配(<a href=\\"#4-1\\">4-1</a>,<a href=\\"#4-2\\">4-2</a>)，任何一种匹配后，匹配任意位数，直到出现第一个引号</em></strong>。</p>\\n<ul>\\n<li>第五行</li>\\n</ul>\\n<p><code>&#39;)\\\\\\\\]&#39;+ &#39;|&#39; +</code></p>\\n<p>这里匹配了<code>]</code>，就是补充了第二行匹配的<code>[</code>；因此我们知道从第二行到第五行的匹配，都是对在中括号<code>[]</code>内匹配类型的处理。</p>\\n<ul>\\n<li>第六行</li>\\n</ul>\\n<p><code>&#39;(?=(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\])(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\]|$))&#39;</code></p>\\n<p><code>?=</code>是正向肯定预查，即符后面匹配的，去匹配前面的值，但它前面没有值，就会匹配为空<code>&quot;&quot;</code>；</p>\\n<p>因此这行含义就是：出现了<code>..</code>或者<code>[][]</code>或者单独的<code>.</code>和单独的<code>[]</code>会转换成<code>&quot;&quot;</code></p>\\n<ul>\\n<li>第七行</li>\\n</ul>\\n<p><code>, &#39;g&#39;)</code></p>\\n<p>全局匹配</p>\\n<h2 id=\\"shi-yong\\">使用</h2>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>string.replace(rePropName, (match, expression, quote, subString) =&gt; {\\n<span class=\\"hljs-keyword\\">let</span> key = match\\n<span class=\\"hljs-keyword\\">if</span> (quote) {\\n  <span class=\\"hljs-comment\\">// 将 \\\\\\\\ 转换成 \\\\</span>\\n  key = subString.replace(reEscapeChar, <span class=\\"hljs-string\\">\'$1\'</span>)\\n}\\n<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (expression) {\\n  <span class=\\"hljs-comment\\">// 去两端空格</span>\\n  key = expression.trim()\\n}\\nresult.push(key)\\n})</code></pre></code></pre>\\n<p>这里<code>replace</code>第二个参数是函数，因此函数的参数按以下顺序排列：</p>\\n<ol>\\n<li><p>匹配值</p>\\n</li>\\n<li><p>匹配过程中括号内储存(匹配)的值，有多个则占用多个参数位置</p>\\n<p> ...</p>\\n</li>\\n<li><p>匹配值对应的索引</p>\\n</li>\\n<li><p>输入的字符串</p>\\n</li>\\n</ol>\\n<h5 id=\\"can-shu-han-yi\\">参数含义</h5>\\n<p><code>match</code>是整个表达式匹配的值</p>\\n<p><code>expression</code>匹配<em>中括号内</em>非字符串 </p>\\n<p><code>quote</code>匹配<em>中括号内</em>第一个引号(后面不能也是引号，就是不能重复) </p>\\n<p><code>subString</code>是<em>中括号内</em>具体字符串的值(无引号)</p>\\n<p>因此：</p>\\n<p><code>if (quote)</code>说明中括号内是字符串，有可能有转义，要进行处理。</p>\\n<p><code>if (expression)</code>说明中括号内是非字符串，是属性值，需要去空格处理。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p>通过这个正则，学到了：</p>\\n<ol>\\n<li>正则匹配以匹配字符多的优先。</li>\\n<li><code>\\\\1</code>, <code>\\\\2</code>, <code>?!</code>, <code>?=</code>, <code>?:</code>, 在字符串中<code>\\\\\\\\\\\\\\\\</code>的使用。</li>\\n<li>使用 <code>?!</code>，遇到重复值，取消后面部分匹配(从而减少匹配优先权)。<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 这里a设定不能为重复值</span>\\n</code></pre></code></pre>\\n</li>\\n</ol>\\n<p>&quot;abc&quot;.match(/a((?!a).)<em>/)\\n// 匹配值：abc\\n&quot;aabc&quot;.match(/a((?!a).)</em>/)\\n// 匹配值：a</p>\\n<pre><code><pre class=\\"hljs\\"><code>4. 使用`?=`置空匹配值\\n```js\\n// 只要连续出现abcd 则匹配为空\\n\\n\'abced\'.match(/(?=.*abcd.*)|.*/)\\n// 匹配值：abced\\n\'eabcdd\'.match(/(?=.*abcd.*)|.*/)\\n// 匹配值：\'\'</code></pre></code></pre><ol start=\\"5\\">\\n<li>replace第二参数函数的使用，括号的匹配有值会增加函数参数的数量。</li>\\n</ol>\\n","toc":[{"anchor":"yue-du-lodash-zhong-yi-duan-chang-zheng-ze-li-jie-bi-ji","level":2,"text":"阅读lodash中一段长正则理解笔记"},{"anchor":"li-jie","level":2,"text":"理解"},{"anchor":"4-1","level":5,"text":"4-1"},{"anchor":"4-2","level":5,"text":"4-2"},{"anchor":"shi-yong","level":2,"text":"使用"},{"anchor":"can-shu-han-yi","level":5,"text":"参数含义"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":null,"created_at":"2018-07-18","timeArr":[2018,6,18,0,0,0,0],"title":"一个长正则的深入理解","uuid":"cdf39a26b776d98ab203524d376b062840672373","summary":"<h4>阅读lodash中一段长正则理解笔记</h4>\\n<p>在lodash源码<code>/.internal/stringToPath.js</code>中：</p>\\n<p>这里英文是原注释，中文是简单的翻译下，后面会详细解释：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> rePropName = <span class=\\"hljs-built_in\\">RegExp</span>(\\n  <span class=\\"hljs-comment\\">// Match anything that isn\'t a do...</span></code></pre>","slug":"yi-ge-chang-zheng-ze-de-shen-ru-li-jie","sha":"784356b84252e1f80acd38952d47176e1e4a8836"}')}}]);