(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{569:function(e){e.exports=JSON.parse('{"content":"<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>React.cloneElement(\\n  element,\\n  [props],\\n  [...children]\\n)</code></pre></code></pre>\\n<h2 id=\\"di-yi-ge-can-shu-element\\">第一个参数：element</h2>\\n<p>必须是一个存在的React组件或者原生DOM，以下都可以</p>\\n<p><code>React.cloneElement(&lt;div /&gt;)</code>\\n<code>React.cloneElement(&lt;Child /&gt;)</code></p>\\n<p>但我们通常发现用的最多的是搭配React.Children.map和this.props.children使用，如下：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>React.Children.map(<span class=\\"hljs-keyword\\">this</span>.props.children,child=&gt;{\\n    React.cloneElement(child,{...props},children)\\n})</code></pre></code></pre>\\n<p>首先不能直接和this.props.children使用，一旦子元素数量大于1，type为undefined的React对象</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 子元素数量大于1,返回空\\nrender(){\\n    return React.cloneElement(this.props.children,...)\\n}</code></pre></code></pre><p>其次，这个方法的作用是为了给子组件进行自定义属性配置，这用到了第二个和第三个参数</p>\\n<h2 id=\\"di-er-ge-can-shu-props\\">第二个参数：props</h2>\\n<p>配置当前element的props</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 我们的意图是希望每个child组件都继承父组件props</span>\\nReact.Children.map(<span class=\\"hljs-keyword\\">this</span>.props.children,child=&gt;{\\n    React.cloneElement(child,<span class=\\"hljs-keyword\\">this</span>.props)\\n})</code></pre></code></pre>\\n<p>但上面的写法一旦遇到嵌套组件，则会触发<code>maximum call stack size is exceeded</code>，因为\\n<code>this.props</code>包含了<code>children</code>属性，因此将一直迭代执行.</p>\\n<p>这么写能安全的继承父组件props</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> {children,...otherPorps}=<span class=\\"hljs-keyword\\">this</span>.porps\\nReact.Children.map(children,child=&gt;{\\n    React.cloneElement(child,otherPorps)\\n})</code></pre></code></pre>\\n<p>当然，props参数还可以自行配置新的属性，最终都能分别传递给每一个子组件</p>\\n<h2 id=\\"di-san-ge-can-shu-children\\">第三个参数：children</h2>\\n<p>配置当前element的children，用的频率比起第二个参数相对较少</p>\\n<p>和第二个参数一样，这里也不能使用this.props.children，否则也将进入死循环</p>\\n","toc":[{"anchor":"di-yi-ge-can-shu-element","level":2,"text":"第一个参数：element"},{"anchor":"di-er-ge-can-shu-props","level":2,"text":"第二个参数：props"},{"anchor":"di-san-ge-can-shu-children","level":2,"text":"第三个参数：children"}],"relatedTags":null,"created_at":"2018-06-11","timeArr":[2018,5,11,0,0,0,0],"title":"React.cloneElement","uuid":"9fc02f51e144eb4dc14889a72398e5a21ee05145","summary":"<pre class=\\"hljs\\"><code>React.cloneElement(\\n  element,\\n  [props],\\n  [...children]\\n)\\n</code></pre>\\n<h4>第一个参数：element</h4>\\n<p>必须是一个存在的React组件或者原生DOM，以下都可以</p>\\n<p><code>React.cloneElement(&lt;div /&gt;)</code>\\n`React.clon...</p>","slug":"React.cloneElement","sha":"f758381282764ccf2eeb5e222145b6ab40de7d78"}')}}]);