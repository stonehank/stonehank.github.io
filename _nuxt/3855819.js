(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{710:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p>注意：文章很长，只想了解逻辑而不深入的，可以直接跳到最后的<a href=\\"#zong-jie\\">总结部分</a>。</p>\\n</blockquote>\\n<hr>\\n<h2 id=\\"chu-shi\\">初识</h2>\\n<p>首先，从它暴露对外的<code>API</code>开始</p>\\n<pre><code><pre class=\\"hljs\\"><code>ReactReduxContext\\n/*\\n提供了 React.createContext(null)\\n*/\\n\\nProvider  \\n/*\\n一个储存数据的组件，渲染了ContextProvider，内部调用redux中store.subscribe\\n订阅数据，每当redux中的数据变动，比较新值与旧值，判断是否重新渲染\\n*/ \\n\\nconnect\\n/* \\n一个高阶组件，第一阶传入对数据处理方法，第二阶传入要渲染的组件\\n内部处理了：\\n1. 对参数的检查\\n2. 对传入的数据处理方法进行处理\\n(没传怎么处理，传了提供什么参数，传的类型不同怎么处理，结果如何比较等等)\\n3. 静态方法转移\\n4. 对渲染组件的传递(传递给connectAdvanced)\\n*/\\n\\nconnectAdvanced\\n/*\\n保存每一次执行的数据，执行connect定义的方案和逻辑，新旧数据对比(全等对比)，渲染组件\\n这里作为公开API，如果我们去使用，那么connect里面的逻辑就需要我们自定义了。\\n*/</code></pre>\\n</code></pre>\\n<p>现在对它的大概工作范围有了解后，我们可以开始沿着执行顺序分析。</p>\\n<hr>\\n<h2 id=\\"chou-si\\">抽丝</h2>\\n<h3 id=\\"provider\\">Provider</h3>\\n<p>我们使用时，当写完了redux的<code>reducer</code>, <code>action</code>, <code>bindActionCreators</code>, <code>combineReducers</code>, <code>createStore</code>这一系列内容后，\\n我们得到了一个<code>store</code></p>\\n<p>会先使用<code>&lt;Provider store={store}</code>包裹住根组件。</p>\\n<p>这时，<code>Provider</code>组件开始工作</p>\\n<pre><code><pre class=\\"hljs\\"><code>componentDidMount() {\\n  this._isMounted = true\\n  this.subscribe()\\n}</code></pre>\\n</code></pre>\\n<p>第一次加载，需要执行<code>subscribe</code></p>\\n<p><code>subscribe</code>是什么呢，就是对<code>redux</code>的<code>store</code>执行<code>subscribe</code>一个自定义函数，\\n这样，每当数据变动，这个函数便会执行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>subscribe() {\\n  <span class=\\"hljs-keyword\\">const</span> { store } = <span class=\\"hljs-keyword\\">this</span>.props\\n  <span class=\\"hljs-comment\\">// redux 的 store 订阅</span>\\n  <span class=\\"hljs-comment\\">// 订阅后，每当state改变 则自动执行这个函数</span>\\n  <span class=\\"hljs-keyword\\">this</span>.unsubscribe = store.subscribe(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// store.getState() 获取最新的 state</span>\\n    <span class=\\"hljs-keyword\\">const</span> newStoreState = store.getState()\\n    <span class=\\"hljs-comment\\">// 组件未加载，取消</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>._isMounted) {\\n      <span class=\\"hljs-keyword\\">return</span>\\n    }\\n    <span class=\\"hljs-comment\\">// 比较state是否相等，全等的不更新</span>\\n    <span class=\\"hljs-keyword\\">this</span>.setState(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">providerState</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">if</span> (providerState.storeState === newStoreState) {\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>\\n      }\\n      <span class=\\"hljs-keyword\\">return</span> { <span class=\\"hljs-attr\\">storeState</span>: newStoreState }\\n    })\\n  })\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>看到吗，这个自定义函数非常简单，每次收到数据，进行全等比较，不等则更新数据。</p>\\n<p>这个组件的另2个生命周期函数：</p>\\n<pre><code><pre class=\\"hljs\\"><code>componentWillUnmount() {\\n  if (this.unsubscribe) this.unsubscribe()\\n  this._isMounted = false\\n}\\n\\ncomponentDidUpdate(prevProps) {\\n  // 比较store是否相等,如果相等则跳过\\n  if (this.props.store !== prevProps.store) {\\n    // 取消订阅之前的，再订阅现在的(因为数据(store)不同了)\\n    if (this.unsubscribe) this.unsubscribe()\\n    this.subscribe()\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这2段的意思就是，每当数据变了，就取消上一次数据的订阅，在订阅本次的数据，\\n当要销毁组件，取消订阅。</p>\\n<blockquote>\\n<p>一段题外话(可跳过)：</p>\\n<p>这个逻辑用<code>Hooks</code>的<code>useEffect</code>简直完美匹配！</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>useEffect(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n  subscribe()\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    unSubscribe()\\n  }\\n},props.data)</code></pre>\\n</code></pre>\\n<p>这段的意思就是，当<code>props.data</code>发生改变，执行<code>unSubscribe()</code>，再执行<code>subscribe()</code>。</p>\\n<p>逻辑完全一致有没有！</p>\\n</blockquote>\\n<p>最后的<code>render</code>：</p>\\n<p>这里<code>Context</code>就是<code>React.createContext(null)</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>&lt;Context.Provider value={<span class=\\"hljs-keyword\\">this</span>.state}&gt;\\n  {<span class=\\"hljs-keyword\\">this</span>.props.children}\\n&lt;<span class=\\"hljs-regexp\\">/Context.Provider&gt;</span></code></pre>\\n</code></pre>\\n<p>到这里我称为<code>react-redux</code>的第一阶段。</p>\\n<p>一个小总结，第一阶段就做了1件事：</p>\\n<p>定义了<code>Provider</code>组件，内部订阅了<code>store</code>。</p>\\n<hr>\\n<h3 id=\\"connect\\">connect</h3>\\n<p>到主菜了，先看它的<code>export</code></p>\\n<p><code>export default createConnect()</code></p>\\n<p>一看，我们应该有个猜测，这货<code>createConnect</code>是个高阶函数。</p>\\n<p>看看它的参数吧。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createConnect</span>(<span class=\\"hljs-params\\">{\\n  connectHOC = connectAdvanced,\\n  mapStateToPropsFactories = defaultMapStateToPropsFactories,\\n  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,\\n  mergePropsFactories = defaultMergePropsFactories,\\n  selectorFactory = defaultSelectorFactory\\n} = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<blockquote>\\n<p>题外话：一个编写默认对象内部含有默认值的方法</p>\\n<pre><code><pre class=\\"hljs\\"><code>function a({x=1,y=2}={}){}\\n\\na()      // x:1,y:2\\na({})    // x:1,y:2\\na({x:2,z:5}) //x:2,y:2</code></pre>\\n</code></pre>\\n</blockquote>\\n<p>这里先说明一下它的参数，后面读起来会很顺。</p>\\n<pre><code><pre class=\\"hljs\\"><code>connectHOC: 一个重要组件，用于执行已确定的逻辑，渲染最终组件，后面会详细说。\\nmapStateToPropsFactories: 对 mapStateToProps 这个传入的参数的类型选择一个合适的方法。\\nmapDispatchToPropsFactories: 对 mapDispatchToProps 这个传入的参数的类型选择一个合适的方法。\\nmergePropsFactories: 对 mergeProps 这个传入的参数的类型选择一个合适的方法。 \\nselectorFactory: 以上3个只是简单的返回另一个合适的处理方法，它则执行这些处理方法，并且对结果定义了如何比较的逻辑。</code></pre>\\n</code></pre>\\n<p>可能有点绕，但<code>react-redux</code>就是这么一个个高阶函数组成的，<code>selectorFactory</code>后面会详细说。</p>\\n<p>首先我们再次确定这3个名字很长，实际很简单的函数(源码这里不放了)</p>\\n<p><code>mapStateToPropsFactories</code></p>\\n<p> <code>mapDispatchToPropsFactories</code></p>\\n<p> <code>mergePropsFactories</code></p>\\n<p>它们只是判断了参数是否存在，是什么类型，并且返回一个合适的处理方法，它们并没有任何处理逻辑。</p>\\n<ul>\\n<li><p>举个例子：</p>\\n<p>  <code>const MyComponent=connect((state)=&gt;state.articles})</code></p>\\n<p>  这里我只定义了<code>mapStateToProps</code>，并且是个<code>function</code>，那么<code>mapStateToPropsFactories</code>就会返回一个\\n  处理<code>function</code>的方法。</p>\\n<p>  我没有定义<code>mapDispatchToProps</code>，那么<code>mapDispatchToPropsFactories</code>检测不到参数，\\n  则会提供一个默认值<code>dispatch =&gt; ({ dispatch })</code>，返回一个处理<code>非function</code>(object)的方法。</p>\\n</li>\\n</ul>\\n<p>那么处理逻辑是谁定义呢？</p>\\n<h4 id=\\"wrapmaptoprops\\">wrapMapToProps</h4>\\n<p><code>wrapMapToProps.js</code>这个文件内部做了以下事情：</p>\\n<ol>\\n<li>定义了一个处理<code>object</code>的方法(简单的返回即可，因为最终目的就是要object)。</li>\\n<li>定义了一个处理<code>函数</code>和<code>高阶函数</code>(执行2次)的方法，这个方法比上面的复杂在于它需要检测参数是否订阅了<code>ownProps</code>。</li>\\n</ol>\\n<p>检测方法很简单，就是检查参数的<code>length</code>（这里<code>dependsOnOwnProps</code>是上一次检查的结果，如果存在则不需要再次检查）</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getDependsOnOwnProps</span>(<span class=\\"hljs-params\\">mapToProps</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> mapToProps.dependsOnOwnProps !== <span class=\\"hljs-literal\\">null</span> &amp;&amp;\\n    mapToProps.dependsOnOwnProps !== <span class=\\"hljs-literal\\">undefined</span>\\n    ? <span class=\\"hljs-built_in\\">Boolean</span>(mapToProps.dependsOnOwnProps)\\n    : mapToProps.length !== <span class=\\"hljs-number\\">1</span>\\n}</code></pre>\\n</code></pre>\\n<p>回到connect，继续往下看</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createConnect</span>(<span class=\\"hljs-params\\">{\\n  <span class=\\"hljs-regexp\\">/* 上面所讲的参数 */</span>\\n} = {}</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">connect</span>(<span class=\\"hljs-params\\">\\n    mapStateToProps,\\n    mapDispatchToProps,\\n    mergeProps,\\n    {\\n      pure = true,\\n      areStatesEqual = strictEqual,\\n      areOwnPropsEqual = shallowEqual,\\n      areStatePropsEqual = shallowEqual,\\n      areMergedPropsEqual = shallowEqual,\\n      ...extraOptions\\n    } = {}\\n  </span>) </span>{\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>已经到了我们传递参数的地方，前3个参数意思就不解释了，最后的参数<code>options</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>areStatesEqual = strictEqual,           // ===比较\\nareOwnPropsEqual = shallowEqual,        // 浅比较\\nareStatePropsEqual = shallowEqual,      // 浅比较\\nareMergedPropsEqual = shallowEqual,     // 浅比较</code></pre>\\n</code></pre>\\n<p>它们用在<code>selectorFactory</code>这个比较数据结果的方法内部。</p>\\n<p>继续往下看</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createConnect</span>(<span class=\\"hljs-params\\">{\\n  <span class=\\"hljs-regexp\\">/* 上面已讲 */</span>\\n} = {}</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">connect</span>(<span class=\\"hljs-params\\">\\n    <span class=\\"hljs-regexp\\">/* 上面已讲 */</span>\\n  </span>) </span>{\\n    <span class=\\"hljs-keyword\\">const</span> initMapStateToProps = match(\\n      mapStateToProps,\\n      mapStateToPropsFactories,\\n      <span class=\\"hljs-string\\">\'mapStateToProps\'</span>\\n    )\\n    <span class=\\"hljs-keyword\\">const</span> initMapDispatchToProps = match(\\n      mapDispatchToProps,\\n      mapDispatchToPropsFactories,\\n      <span class=\\"hljs-string\\">\'mapDispatchToProps\'</span>\\n    )\\n    <span class=\\"hljs-keyword\\">const</span> initMergeProps = match(mergeProps, mergePropsFactories, <span class=\\"hljs-string\\">\'mergeProps\'</span>)</code></pre>\\n</code></pre>\\n<p>这里定义了3个变量(函数)，<code>match</code>的作用是什么？</p>\\n<p>以<code>mapStateToProps</code>举例来说，</p>\\n<p>因为上面也说了，<code>mapStateToPropsFactories</code>里面有多个方法，需要找到一个适合<code>mapStateToProps</code>的，\\n<code>match</code>就是干这事了。</p>\\n<p><code>match</code>方法内部遍历<code>mapStateToPropsFactories</code>所有的处理方法，任何一个方法能够匹配参数<code>mapStateToProps</code>，便被<code>match</code>捕获返回，\\n如果一个都找不到则报错提示参数配置错误。</p>\\n<p>现在这3个变量定义明确了，都是对应的参数的合适的处理方法。</p>\\n<p>至此，我们已经完成了第二阶段，</p>\\n<p>做个小总结，第二阶段做了哪些事：</p>\\n<ol>\\n<li><code>connect</code>接收了对参数处理方案(3个<code>...Factories</code>)。</li>\\n<li><code>connect</code>接收了参数的结果比较方案(<code>selectFactory</code>)</li>\\n<li><code>connect</code>接收了参数(<code>mapStateToProps</code>,<code>mapDispatchToProps</code>,<code>mergeProps</code>,<code>options</code>)。</li>\\n<li>定义了比较方案(4个<code>are...Equal</code>，其实就是<code>全等比较</code>和<code>浅比较</code>)。</li>\\n</ol>\\n<p>前2个阶段都是定义阶段，接下来需要我们传入自定义组件，也就是最后一个阶段</p>\\n<p><code>connect(...)(Component)</code></p>\\n<hr>\\n<p>接着看<code>connect</code>源码</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createConnect</span>(<span class=\\"hljs-params\\">{\\n  <span class=\\"hljs-regexp\\">/* 上面已讲 */</span>\\n} = {}</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">connect</span>(<span class=\\"hljs-params\\">\\n    <span class=\\"hljs-regexp\\">/* 上面已讲 */</span>\\n  </span>) </span>{\\n    <span class=\\"hljs-comment\\">/* 上面已讲 */</span>\\n    <span class=\\"hljs-keyword\\">return</span> connectHOC(selectorFactory, {\\n      <span class=\\"hljs-comment\\">// 方法名称，用在错误提示信息</span>\\n      <span class=\\"hljs-attr\\">methodName</span>: <span class=\\"hljs-string\\">\'connect\'</span>,\\n      <span class=\\"hljs-comment\\">// 最终渲染的组件名称</span>\\n      <span class=\\"hljs-attr\\">getDisplayName</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">name</span> =&gt;</span> <span class=\\"hljs-string\\">`Connect(<span class=\\"hljs-subst\\">${name}</span>)`</span>,\\n      <span class=\\"hljs-attr\\">shouldHandleStateChanges</span>: <span class=\\"hljs-built_in\\">Boolean</span>(mapStateToProps),\\n      <span class=\\"hljs-comment\\">// 以下是传递给 selectFactory</span>\\n      initMapStateToProps,\\n      initMapDispatchToProps,\\n      initMergeProps,\\n      pure,\\n      areStatesEqual,\\n      areOwnPropsEqual,\\n      areStatePropsEqual,\\n      areMergedPropsEqual,\\n\\n      <span class=\\"hljs-comment\\">// any extra options args can override defaults of connect or connectAdvanced</span>\\n      ...extraOptions\\n    })\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这里执行了<code>connectHOC()</code>，传递了上面已经讲过的参数，而<code>connectHOC = connectAdvanced</code></p>\\n<p>因此我们进入最后一个对外<code>API</code>，<code>connectAdvanced</code></p>\\n<h3 id=\\"connectadvanced\\">connectAdvanced</h3>\\n<p><code>connectAdvanced</code>函数，之前也提过，就是一个执行、组件渲染和组件更新的地方。</p>\\n<p>它里面没有什么新概念，都是将我们上面讲到的参数进行调用，最后根据结果进行渲染新组件。</p>\\n<p>还是从源码开始</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">connectAdvanced</span>(<span class=\\"hljs-params\\">\\n  selectorFactory,\\n  {\\n    <span class=\\"hljs-regexp\\">//</span> 执行后作用于connect这个HOC组件名称\\n    getDisplayName = name =&gt; <span class=\\"hljs-string\\">`ConnectAdvanced(<span class=\\"hljs-subst\\">${name}</span>)`</span>,\\n    <span class=\\"hljs-regexp\\">//</span> 用于错误提示\\n    methodName = <span class=\\"hljs-string\\">\'connectAdvanced\'</span>,\\n    <span class=\\"hljs-regexp\\">//</span> 有REMOVED标志，这里不关注\\n    renderCountProp = undefined,\\n    <span class=\\"hljs-regexp\\">//</span> 确定connect这个HOC是否订阅state变动，好像已经没有用到了\\n    shouldHandleStateChanges = true,\\n    <span class=\\"hljs-regexp\\">//</span> 有REMOVED标志，这里不关注\\n    storeKey = <span class=\\"hljs-string\\">\'store\'</span>,\\n    <span class=\\"hljs-regexp\\">//</span> 有REMOVED标志，这里不关注\\n    withRef = false,\\n    <span class=\\"hljs-regexp\\">//</span> 是否通过 forwardRef 暴露出传入的Component的DOM\\n    forwardRef = false,\\n    <span class=\\"hljs-regexp\\">//</span> React的createContext\\n    context = ReactReduxContext,\\n\\n    <span class=\\"hljs-regexp\\">//</span> 其余的(比较方法，参数处理方法等</span>)将会传递给上面的 <span class=\\"hljs-title\\">selectFactory</span>\\n    ...<span class=\\"hljs-title\\">connectOptions</span>\\n  } = </span>{}\\n) {\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>参数也没什么特别的，有一个<code>forwardRef</code>作用就是能获取到我们传入的<code>Component</code>的DOM。\\n这里也不深入。</p>\\n<p>接着看</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">connectAdvanced</span>(<span class=\\"hljs-params\\">\\n  <span class=\\"hljs-regexp\\">/* 上面已讲 */</span>\\n</span>) </span>{\\n  <span class=\\"hljs-comment\\">/* ...对参数的一些验证和提示哪些参数已经作废... */</span>\\n  \\n  <span class=\\"hljs-comment\\">// 定义Context</span>\\n  <span class=\\"hljs-keyword\\">const</span> Context = context\\n\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">wrapWithConnect</span>(<span class=\\"hljs-params\\">WrappedComponent</span>) </span>{\\n    <span class=\\"hljs-comment\\">/* ...检查 WrappedComponent 是否符合要求... */</span>\\n   \\n    <span class=\\"hljs-comment\\">/* ...获取传入的WrappedComponent的名称... */</span>\\n   \\n    <span class=\\"hljs-comment\\">/* ...通过WrappedComponent的名称计算出当前HOC的名称... */</span>\\n\\n    <span class=\\"hljs-comment\\">/* ...获取一些上面的参数(没有新的参数,都是之前见过的)... */</span>\\n\\n    <span class=\\"hljs-comment\\">// Component就是React.Component</span>\\n    <span class=\\"hljs-keyword\\">let</span> OuterBaseComponent = Component\\n    <span class=\\"hljs-keyword\\">let</span> FinalWrappedComponent = WrappedComponent\\n\\n    <span class=\\"hljs-comment\\">// 是否纯组件</span>\\n    <span class=\\"hljs-keyword\\">if</span> (pure) {\\n      OuterBaseComponent = PureComponent\\n    }\\n\\n    <span class=\\"hljs-comment\\">/* 定义 makeDerivedPropsSelector 方法，作用后面讲 */</span>\\n\\n    <span class=\\"hljs-comment\\">/* 定义 makeChildElementSelector 方法，作用后面讲 */</span>\\n\\n    <span class=\\"hljs-comment\\">/* 定义 Connect 组件，作用后面讲 */</span>\\n\\n    Connect.WrappedComponent = WrappedComponent\\n    Connect.displayName = displayName\\n\\n    <span class=\\"hljs-comment\\">/* ...如果是forWardRef 为true的情况，此处不深入... */</span>\\n    \\n    <span class=\\"hljs-comment\\">// 静态方法转换</span>\\n    <span class=\\"hljs-keyword\\">return</span> hoistStatics(Connect, WrappedComponent)\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这一段特别长，因此我将不太重要的直接用注释说明了它们在做什么，具体代码就不放了(不重要)。</p>\\n<p>并且定义了3个新东西，<code>makeDerivedPropsSelector</code>，<code>makeChildElementSelector</code>,<code>Connect</code>。</p>\\n<p>先看最后一句<code>hoistStatics</code>就是<code>hoist-non-react-statics</code>，它的作用是将组件<code>WrappedComponent</code>的所有非<code>React</code>\\n静态方法传递到<code>Connect</code>内部。</p>\\n<p>那么最终它还是返回了一个<code>Connect</code>组件。</p>\\n<h4 id=\\"connect-zu-jian\\">Connect组件</h4>\\n<p>这个组件已经是我们写了完整<code>connect(...)(Component)</code>的返回值了，所以能确定，只要调用<code>&lt;Connect /&gt;</code>，就能渲染出一个新的组件出来。</p>\\n<p>因此它的功能就是确定是否重复更新组件和确定到底更新什么？</p>\\n<p>看一个组件，从<code>constructor</code>看起</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Connect</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">OuterBaseComponent</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(props) {\\n    <span class=\\"hljs-keyword\\">super</span>(props)\\n   \\n    <span class=\\"hljs-comment\\">/* ...提示一些无用的参数...*/</span>\\n    \\n    <span class=\\"hljs-keyword\\">this</span>.selectDerivedProps = makeDerivedPropsSelector()\\n    <span class=\\"hljs-keyword\\">this</span>.selectChildElement = makeChildElementSelector()\\n    <span class=\\"hljs-keyword\\">this</span>.renderWrappedComponent = <span class=\\"hljs-keyword\\">this</span>.renderWrappedComponent.bind(<span class=\\"hljs-keyword\\">this</span>)\\n  }\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>绑定了一个方法，看名字是render的意思，先不管它。</p>\\n<p>执行了2个函数。</p>\\n<p><code>Connect</code>组件还没完，这里先放着，我们先看<code>makeDerivedPropsSelector</code>和<code>makeChildElementSelector</code></p>\\n<h4 id=\\"makederivedpropsselector\\">makeDerivedPropsSelector</h4>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">makeDerivedPropsSelector</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-comment\\">// 闭包储存上一次的执行结果</span>\\n  <span class=\\"hljs-keyword\\">let</span> lastProps\\n  <span class=\\"hljs-keyword\\">let</span> lastState\\n  <span class=\\"hljs-keyword\\">let</span> lastDerivedProps\\n  <span class=\\"hljs-keyword\\">let</span> lastStore\\n  <span class=\\"hljs-keyword\\">let</span> sourceSelector\\n\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">selectDerivedProps</span>(<span class=\\"hljs-params\\">state, props, store</span>) </span>{\\n    <span class=\\"hljs-comment\\">// props和state都和之前相等 直接返回上一次的结果</span>\\n    <span class=\\"hljs-keyword\\">if</span> (pure &amp;&amp; lastProps === props &amp;&amp; lastState === state) {\\n      <span class=\\"hljs-keyword\\">return</span> lastDerivedProps\\n    }\\n\\n    <span class=\\"hljs-comment\\">// 当前store和lastStore不等，更新lastStore</span>\\n    <span class=\\"hljs-keyword\\">if</span> (store !== lastStore) {\\n      lastStore = store\\n      \\n      <span class=\\"hljs-comment\\">// 终于调用 selectorFactory 了</span>\\n      sourceSelector = selectorFactory(\\n        store.dispatch,\\n        selectorFactoryOptions\\n      )\\n    }\\n\\n    <span class=\\"hljs-comment\\">// 更新数据</span>\\n    lastProps = props\\n    lastState = state\\n\\n    <span class=\\"hljs-comment\\">// 返回的就是最终的包含所有相应的 state 和 props 的结果</span>\\n    <span class=\\"hljs-keyword\\">const</span> nextProps = sourceSelector(state, props)\\n\\n    <span class=\\"hljs-comment\\">// 最终的比较</span>\\n    <span class=\\"hljs-keyword\\">if</span> (lastDerivedProps === nextProps) {\\n      <span class=\\"hljs-keyword\\">return</span> lastDerivedProps\\n    }\\n    lastDerivedProps = nextProps\\n    <span class=\\"hljs-keyword\\">return</span> lastDerivedProps\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>大概的说，<code>makeDerivedPropsSelector</code>的执行，先判断了当前传入的<code>props(组件的props)</code>和<code>state(redux传入的state)</code>\\n跟以前的是否全等，如果全等就不需要更新了；</p>\\n<p>如果不等，则调用了高阶函数<code>selectFactory</code>，并且获得最终数据，最后再判断最终数据和之前的最终数据是否全等。</p>\\n<p>为什么第一次判断了，还要判断第二次，而且都是<code>===</code>判断？</p>\\n<p>因为第一次获取的<code>state</code>是<code>redux</code>传入的，是整个APP的所有数据，它们不等说明有组件更新了，但不确定是否是当前组件；</p>\\n<p>第二次比较的是当前组件的最新数据和以前数据对比。</p>\\n<p>现在，我们知道<code>selectFactory</code>的作用是获取当前组件的的最新数据，深入源码看看。</p>\\n<h4 id=\\"selectfactory\\">selectFactory</h4>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">finalPropsSelectorFactory</span>(<span class=\\"hljs-params\\">\\n  <span class=\\"hljs-regexp\\">//</span> redux store的store.dispatch\\n  dispatch,\\n  <span class=\\"hljs-regexp\\">//</span> <span class=\\"hljs-number\\">3</span>种已经确定了的处理方法\\n  { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }\\n</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 返回一个针对用户传入的类型的解析函数</span>\\n  <span class=\\"hljs-comment\\">// 例如 mapStateToProps 如果是function，那么就返回proxy，proxy可以判断是否需要ownProps，并且对高阶函数的 mapStateToProps 进行2次处理，</span>\\n  <span class=\\"hljs-comment\\">// 最终确保返回一个plainObject，否则报错</span>\\n  <span class=\\"hljs-keyword\\">const</span> mapStateToProps = initMapStateToProps(dispatch, options)\\n  <span class=\\"hljs-keyword\\">const</span> mapDispatchToProps = initMapDispatchToProps(dispatch, options)\\n  <span class=\\"hljs-keyword\\">const</span> mergeProps = initMergeProps(dispatch, options)\\n\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span>) {\\n    verifySubselectors(\\n      mapStateToProps,\\n      mapDispatchToProps,\\n      mergeProps,\\n      options.displayName\\n    )\\n  }\\n\\n  <span class=\\"hljs-keyword\\">const</span> selectorFactory = options.pure\\n    ? pureFinalPropsSelectorFactory\\n    : impureFinalPropsSelectorFactory\\n\\n  <span class=\\"hljs-comment\\">// 默认pure问题true，因此执行 pureFinalPropsSelectorFactory(...)</span>\\n  <span class=\\"hljs-keyword\\">return</span> selectorFactory(\\n    mapStateToProps,\\n    mapDispatchToProps,\\n    mergeProps,\\n    dispatch,\\n    options\\n  )\\n}</code></pre>\\n</code></pre>\\n<p>参数就不说了，看注释。</p>\\n<p>以下3个，到底返回了什么，源码在<code>wrapMapToProps.js</code>，<a href=\\"#wrapMapToProps\\">上面</a>也说过这个文件内部做了什么事情。</p>\\n<pre><code><pre class=\\"hljs\\"><code>const mapStateToProps = initMapStateToProps(dispatch, options)\\nconst mapDispatchToProps = initMapDispatchToProps(dispatch, options)\\nconst mergeProps = initMergeProps(dispatch, options)</code></pre>\\n</code></pre>\\n<p>这3个调用返回的一个函数，名字叫<code>proxy</code>，这个<code>proxy</code>一旦调用，\\n就能返回经过<code>mapStateToProps</code>, <code>mapDispatchToProps</code>, <code>mergeProps</code>这3个参数处理过后的数据(<code>plainObject</code>)。</p>\\n<p>接下来：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> selectorFactory = options.pure\\n    ? pureFinalPropsSelectorFactory\\n    : impureFinalPropsSelectorFactory\\n\\n  <span class=\\"hljs-comment\\">// 默认pure问题true，因此执行 pureFinalPropsSelectorFactory(...)</span>\\n  <span class=\\"hljs-keyword\\">return</span> selectorFactory(\\n    mapStateToProps,\\n    mapDispatchToProps,\\n    mergeProps,\\n    dispatch,\\n    options\\n  )</code></pre>\\n</code></pre>\\n<p>返回了<code>selectorFactory</code>的调用值，也就是<code>pureFinalPropsSelectorFactory</code>(pure默认为true)。</p>\\n<p>看<code>pureFinalPropsSelectorFactory</code>，它的代码不少，但逻辑很明了，大方向就是对比数据。</p>\\n<p>这里关键的如何比较不列代码，只用注释讲明白它的逻辑。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">pureFinalPropsSelectorFactory</span>(<span class=\\"hljs-params\\">\\n  <span class=\\"hljs-regexp\\">//</span> 接受<span class=\\"hljs-number\\">3</span>个proxy方法\\n  mapStateToProps,\\n  mapDispatchToProps,\\n  mergeProps,\\n  dispatch,\\n  <span class=\\"hljs-regexp\\">//</span> 接受<span class=\\"hljs-number\\">3</span>个比较方法\\n  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }\\n</span>) </span>{\\n  \\n  <span class=\\"hljs-comment\\">/* ...定义变量保存之前的数据(闭包)... */</span>\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">handleFirstCall</span>(<span class=\\"hljs-params\\">firstState, firstOwnProps</span>) </span>{\\n    <span class=\\"hljs-comment\\">/* ...定义第一次执行数据比较的方法，也就是简单的赋值给上面定义的闭包变量... */</span>\\n  }\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">handleNewPropsAndNewState</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-comment\\">/* 当state和props都有变动时的处理方法 */</span>\\n  }\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">handleNewProps</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-comment\\">/* 当state无变动，props有变动时的处理方法 */</span>\\n  }\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">handleNewState</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-comment\\">/* 当state有变动，props无变动时的处理方法 */</span>\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 后续数据比较的方法</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">handleSubsequentCalls</span>(<span class=\\"hljs-params\\">nextState, nextOwnProps</span>) </span>{\\n    <span class=\\"hljs-comment\\">// 浅比较</span>\\n    <span class=\\"hljs-keyword\\">const</span> propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\\n    <span class=\\"hljs-comment\\">// 全等比较</span>\\n    <span class=\\"hljs-keyword\\">const</span> stateChanged = !areStatesEqual(nextState, state)\\n    <span class=\\"hljs-comment\\">// 更新数据</span>\\n    state = nextState\\n    ownProps = nextOwnProps\\n    <span class=\\"hljs-comment\\">// 当发生不相等的3种情况(关键)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (propsChanged &amp;&amp; stateChanged) <span class=\\"hljs-keyword\\">return</span> handleNewPropsAndNewState()\\n    <span class=\\"hljs-keyword\\">if</span> (propsChanged) <span class=\\"hljs-keyword\\">return</span> handleNewProps()\\n    <span class=\\"hljs-keyword\\">if</span> (stateChanged) <span class=\\"hljs-keyword\\">return</span> handleNewState()\\n    <span class=\\"hljs-comment\\">// 比较都相等，直接返回旧值</span>\\n    <span class=\\"hljs-keyword\\">return</span> mergedProps\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">pureFinalPropsSelector</span>(<span class=\\"hljs-params\\">nextState, nextOwnProps</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> hasRunAtLeastOnce\\n      ? handleSubsequentCalls(nextState, nextOwnProps)\\n      : handleFirstCall(nextState, nextOwnProps)\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>上面的闭包变量储存了上一次的数据，关键点就是当和这一次的数据比较后，如果处理更新。</p>\\n<p><code>react-redux</code>将它分为3种情况</p>\\n<ul>\\n<li><code>state</code>和<code>props</code>都相等。</li>\\n<li><code>state</code>相等，<code>props</code>不等。</li>\\n<li><code>state</code>不等，<code>props</code>相等。</li>\\n</ul>\\n<hr>\\n<ul>\\n<li><p>第一种：<code>state</code>和<code>props</code>都相等</p>\\n<ul>\\n<li>mapStateToProps(proxy)：不管是否订阅<code>ownProps</code>，执行<code>mapStateToProps</code>， 因为<code>state</code>有变动。</li>\\n<li>mapDispatchToProps(proxy)：  只有订阅了<code>ownProps</code>，才会执行<code>mapDispatchToProps</code>，因为<code>state</code>变动与<code>mapDispatchToProps</code>无影响。</li>\\n<li>mergedProps(proxy)：  必定执行，将所有结果合并。</li>\\n</ul>\\n</li>\\n<li><p>第二种：<code>state</code>相等，<code>props</code>不等</p>\\n<ul>\\n<li>mapStateToProps(proxy)：只有订阅了<code>ownProps</code>，才会执行<code>mapStateToProps</code>， 因为<code>state</code>无变动。</li>\\n<li>mapDispatchToProps(proxy)：  只有订阅了<code>ownProps</code>，才会执行<code>mapDispatchToProps</code>，因为<code>state</code>变动与<code>mapDispatchToProps</code>无影响。</li>\\n<li>mergedProps(proxy)：  必定执行，将所有结果合并。</li>\\n</ul>\\n</li>\\n<li><p>第三种：<code>state</code>不等，<code>props</code>相等</p>\\n<ul>\\n<li>mapStateToProps(proxy)：  不管是否订阅<code>ownProps</code>，执行<code>mapStateToProps</code>， 因为<code>state</code>有变动。  注意，这里结果需要<code>浅比较</code>判断  因为如果没有<code>浅比较</code>检查，而两者刚好<code>浅比较相等</code>，\\n  那么最后也会认为返回一个新的props，也就是相当于重复更新了。  之所以第一个<code>state</code>和<code>props</code>都有变动的不需要浅比较检查，\\n  是因为如果<code>props</code>变了，则必须要更新组件。</li>\\n<li>mapDispatchToProps(proxy)：  不会执行，因为它只关注<code>props</code>。</li>\\n<li>mergedProps(proxy)：  只有上面浅比较不等，才会执行。</li>\\n</ul>\\n</li>\\n</ul>\\n<p><code>makeDerivedPropsSelector</code>的总结：</p>\\n<p>通过闭包管理数据，并且通过浅比较和全等比较判断是否需要更新组件数据。</p>\\n<h4 id=\\"makechildelementselector\\">makeChildElementSelector</h4>\\n<p><code>makeChildElementSelector</code>也是一个高阶函数，储存了之前的<code>数据</code>和<code>组件</code>，并且判断与当前的判断。</p>\\n<p>这里是最终渲染组件的地方，因为需要判断一下刚才最终给出的数据是否需要去更新组件。</p>\\n<p>2个逻辑：</p>\\n<ol>\\n<li>数据与之前不等(<code>===</code>)，更新组件。</li>\\n<li><code>forWardRef</code>属性值与之前不等，更新组件。</li>\\n</ol>\\n<p>否则，返回旧组件(不更新)。</p>\\n<p>继续回到<code>Connect</code>组件。</p>\\n<p>之后就是<code>render</code>了</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>render() {\\n  <span class=\\"hljs-comment\\">// React的createContext</span>\\n  <span class=\\"hljs-keyword\\">const</span> ContextToUse = <span class=\\"hljs-keyword\\">this</span>.props.context || Context\\n\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;ContextToUse.Consumer&gt;\\n      {this.renderWrappedComponent}\\n    &lt;/ContextToUse.Consumer&gt;\\n  )\\n}</code></pre>\\n</code></pre>\\n<p><code>Context.Consumer</code>内部必须是一个函数，这个函数的参数就是<code>Context.Provider</code>的<code>value</code>，也就是<code>redux</code>的<code>store</code>。</p>\\n<h4 id=\\"renderwrappedcomponent\\">renderWrappedComponent</h4>\\n<p>最后一个函数：<code>renderWrappedComponent</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>renderWrappedComponent(value) {\\n  <span class=\\"hljs-comment\\">/* ...验证参数有效性... */</span>\\n  \\n  <span class=\\"hljs-comment\\">// 这里 storeState=store.getState()</span>\\n  <span class=\\"hljs-keyword\\">const</span> { storeState, store } = value\\n\\n  <span class=\\"hljs-comment\\">// 传入自定义组件的props</span>\\n  <span class=\\"hljs-keyword\\">let</span> wrapperProps = <span class=\\"hljs-keyword\\">this</span>.props\\n  \\n  <span class=\\"hljs-keyword\\">let</span> forwardedRef\\n  <span class=\\"hljs-keyword\\">if</span> (forwardRef) {\\n    wrapperProps = <span class=\\"hljs-keyword\\">this</span>.props.wrapperProps\\n    forwardedRef = <span class=\\"hljs-keyword\\">this</span>.props.forwardedRef\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 上面已经讲了，返回最终数据</span>\\n  <span class=\\"hljs-keyword\\">let</span> derivedProps = <span class=\\"hljs-keyword\\">this</span>.selectDerivedProps(\\n    storeState,\\n    wrapperProps,\\n    store\\n  )\\n\\n  <span class=\\"hljs-comment\\">// 返回最终渲染的自定义组件</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.selectChildElement(derivedProps, forwardedRef)\\n}</code></pre>\\n</code></pre>\\n<p>总算结束了，可能有点混乱，做个总结吧。</p>\\n<hr>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p>我把<code>react-redux</code>的执行流程分为3个阶段，分别对应我们的代码编写(搭配导图阅读)</p>\\n<hr>\\n<p>一张导图：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-redux/React-Redux.png\\" alt=\\"react-redux导图 by stonehank\\"></p>\\n<hr>\\n<p>第一阶段：</p>\\n<p>对应的用户代码：</p>\\n<pre><code><pre class=\\"hljs\\"><code>&lt;Provider store={store}&gt;\\n  &lt;App /&gt;\\n&lt;/Provider&gt;</code></pre>\\n</code></pre>\\n<p>执行内容有：</p>\\n<ol>\\n<li>定义了<code>Provider</code>组件，这个组件内部订阅了<code>redux</code>的<code>store</code>，保证当<code>store</code>发生变动，会立刻执行更新。</li>\\n</ol>\\n<hr>\\n<p>第二阶段：</p>\\n<p>对应的用户代码：</p>\\n<pre><code><pre class=\\"hljs\\"><code>connect(mapStateToProps,mapDispatchToProps,mergeProps,options)</code></pre>\\n</code></pre>\\n<p>执行内容有：</p>\\n<ol>\\n<li><code>connect</code>接收了参数(<code>mapStateToProps</code>,<code>mapDispatchToProps</code>,<code>mergeProps</code>,<code>options</code>)。</li>\\n<li><code>connect</code>接收了对参数如何处理方案(3个<code>...Factories</code>)。</li>\\n<li><code>connect</code>接收了参数的结果比较方案(<code>selectFactory</code>)</li>\\n<li>定义了比较方案(4个<code>are...Equal</code>，其实就是<code>全等比较</code>和<code>浅比较</code>)。</li>\\n</ol>\\n<hr>\\n<p>第三阶段：</p>\\n<p>对应的用户代码：</p>\\n<pre><code><pre class=\\"hljs\\"><code>let newComponent=connect(...)(Component)\\n\\n&lt;newComponent /&gt;</code></pre>\\n</code></pre>\\n<p>执行内容有：</p>\\n<ol>\\n<li>接受自定义组件(<code>Component</code>)。</li>\\n<li>创建一个<code>Connect</code>组件。</li>\\n<li>将<code>Component</code>的非<code>React</code>静态方法转移到<code>Connect</code>。</li>\\n<li>获取<code>Provider</code>传入的<code>数据</code>(<code>redux</code>的整个数据)，利用闭包保存数据，用于和未来数据做比较。</li>\\n<li>当比较(<code>===</code>)有变动，执行上一阶段传入的参数，获取当前组件真正的数据。</li>\\n<li>利用闭包保存当前组件真正的数据，用于和未来作比较。</li>\\n<li>通过全等和浅比较，处理<code>state</code>变动和<code>props</code>变动的逻辑，判断返回新数据还是旧数据。</li>\\n<li>利用闭包保存渲染的组件，通过上面返回的最终数据，判断需要返回新组件还是就组件。</li>\\n</ol>\\n<p>逻辑理顺了，还是很好理解的。</p>\\n<p>其中第三阶段就是对外API<code>connectAdvanced</code>的执行内容。</p>\\n<hr>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis\\">此处</a>查看更多前端源码阅读内容。</p>\\n<p>或许哪一天，我们需要设计一个专用的数据管理系统，那么就利用好<code>connectAdvanced</code>，\\n我们要做的就是编写一个自定义<code>第二阶段</code>的逻辑体系。</p>\\n<p>感谢阅读！</p>\\n","toc":[{"anchor":"chu-shi","level":2,"text":"初识"},{"anchor":"chou-si","level":2,"text":"抽丝"},{"anchor":"provider","level":3,"text":"Provider"},{"anchor":"connect","level":3,"text":"connect"},{"anchor":"wrapmaptoprops","level":4,"text":"wrapMapToProps"},{"anchor":"connectadvanced","level":3,"text":"connectAdvanced"},{"anchor":"connect-zu-jian","level":4,"text":"Connect组件"},{"anchor":"makederivedpropsselector","level":4,"text":"makeDerivedPropsSelector"},{"anchor":"selectfactory","level":4,"text":"selectFactory"},{"anchor":"makechildelementselector","level":4,"text":"makeChildElementSelector"},{"anchor":"renderwrappedcomponent","level":4,"text":"renderWrappedComponent"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":["源码","react","redux"],"created_at":"2018-11-19","timeArr":[2018,10,19,15,39,31,0],"title":"源码阅读-react-redux","uuid":"61fc5f70332f76ba26036558a7f1f43790ca025b","summary":"<p>注意：文章很长，只想了解逻辑而不深入的，可以直接跳到最后的<a href=\\"#zong-jie\\">总结部分</a>。</p>","slug":"source-code-react-redux","sha":"53f1636d897b807f6392f3fa5cdce56274193679"}')}}]);