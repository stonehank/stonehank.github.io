(window.webpackJsonp=window.webpackJsonp||[]).push([[1178],{1976:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{character}</span> <span class=\\"hljs-variable\\">C</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> shortestToChar = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S, C</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> prev=-<span class=\\"hljs-literal\\">Infinity</span>\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-built_in\\">Array</span>(S.length).fill(<span class=\\"hljs-literal\\">Infinity</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;S.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(S[i]===C)prev=i\\n    res[i]=i-prev\\n  }\\n  prev=<span class=\\"hljs-literal\\">Infinity</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=S.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n    <span class=\\"hljs-keyword\\">if</span>(S[i]===C)prev=i\\n    res[i]=<span class=\\"hljs-built_in\\">Math</span>.min(res[i],prev-i)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"shortest-distance-to-a-character","created_at":"2019-04-26","timeArr":[2019,3,26,16,11,52,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>正向遍历一次，将每一个<code>C</code>所在位置后面的数处理，再反向遍历一次，将每一个<code>C</code>所在位置前面的数处理。</p>\\n","content":"<p>给你一个字符串 <code>s</code> 和一个字符 <code>c</code> ，且 <code>c</code> 是 <code>s</code> 中出现过的字符。</p>\\n\\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer.length == s.length</code> 且 <code>answer[i]</code> 是 <code>s</code> 中从下标 <code>i</code> 到离它 <strong>最近</strong> 的字符 <code>c</code> 的 <strong>距离</strong> 。</p>\\n\\n<p>两个下标&nbsp;<code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>abs(i - j)</code> ，其中 <code>abs</code> 是绝对值函数。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"loveleetcode\\", c = \\"e\\"\\n<strong>输出：</strong>[3,2,1,0,1,0,0,1,2,2,1,0]\\n<strong>解释：</strong>字符 \'e\' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\\n距下标 0 最近的 \'e\' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\\n距下标 1 最近的 \'e\' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\\n对于下标 4 ，出现在下标 3 和下标 5 处的 \'e\' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\\n距下标 8 最近的 \'e\' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"aaab\\", c = \\"b\\"\\n<strong>输出：</strong>[3,2,1,0]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<strong>提示：</strong>\\n\\n<ul>\\n\\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\\n\\t<li><code>s[i]</code> 和 <code>c</code> 均为小写英文字母</li>\\n\\t<li>题目数据保证 <code>c</code> 在 <code>s</code> 中至少出现一次</li>\\n</ul>\\n","title":"821. 字符的最短距离","relatedTags":["数组","双指针","字符串"],"difficult":"Easy","lang":["javascript"],"uniqueID":"821","slug":"821-Shortest-Distance-to-a-Character"}')}}]);