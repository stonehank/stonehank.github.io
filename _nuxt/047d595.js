(window.webpackJsonp=window.webpackJsonp||[]).push([[1193],{1991:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">A</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">B</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> largestOverlap = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">A, B</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> m=A.length,n=A[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> l=<span class=\\"hljs-number\\">0</span>;l&lt;n;l++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> u=<span class=\\"hljs-number\\">0</span>;u&lt;m;u++){\\n      <span class=\\"hljs-keyword\\">let</span> same=<span class=\\"hljs-number\\">0</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;m;i++){\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;n;j++){\\n          <span class=\\"hljs-keyword\\">let</span> ai=i+u,aj=j+l\\n          <span class=\\"hljs-keyword\\">if</span>(ai&gt;=m || aj&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n          <span class=\\"hljs-keyword\\">if</span>(A[ai][aj]===B[i][j] &amp;&amp; B[i][j]===<span class=\\"hljs-number\\">1</span>)same++\\n        }\\n      }\\n      res=<span class=\\"hljs-built_in\\">Math</span>.max(res,same)\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> r=<span class=\\"hljs-number\\">0</span>;r&lt;n;r++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> d=<span class=\\"hljs-number\\">0</span>;d&lt;m;d++){\\n      <span class=\\"hljs-keyword\\">let</span> same=<span class=\\"hljs-number\\">0</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;m;i++){\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;n;j++){\\n          <span class=\\"hljs-keyword\\">let</span> bi=i+r,bj=j+d\\n          <span class=\\"hljs-keyword\\">if</span>(bi&gt;=m || bj&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n          <span class=\\"hljs-keyword\\">if</span>(A[i][j]===B[bi][bj] &amp;&amp; A[i][j]===<span class=\\"hljs-number\\">1</span>)same++\\n        }\\n      }\\n      res=<span class=\\"hljs-built_in\\">Math</span>.max(res,same)\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"image-overlap","created_at":"2019-03-15","timeArr":[2019,2,15,22,30,17,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>因为转换不能是旋转，因此我们可以选中<code>A</code>进行分析，要么是<code>A</code>上移<code>x</code>步，左移<code>y</code>步；要么是<code>A</code>下移<code>x</code>步，然后右移<code>y</code>步，\\n反正上移和下移(左移和右移)不可能同时出现。</p>\\n<p>那么我们就可以分别计算<code>上移左移</code>和<code>下移右移</code>的情况，其中上(下)移动存在<code>N</code>步，左(右)移动存在<code>N</code>步。</p>\\n<p>每次移动后，再去对比当前相同<code>1</code>的次数，最后返回最多的一次，最终时间复杂度是<code>O(N^4)</code>。</p>\\n","content":"<p>给你两个图像 <code>img1</code> 和 <code>img2</code> ，两个图像的大小都是 <code>n x n</code> ，用大小相同的二维正方形矩阵表示。（并且为二进制矩阵，只包含若干 <code>0</code> 和若干 <code>1</code> ）</p>\\n\\n<p>转换其中一个图像，向左，右，上，或下滑动任何数量的单位，并把它放在另一个图像的上面。之后，该转换的 <strong>重叠</strong> 是指两个图像都具有 <code>1</code> 的位置的数目。</p>\\n\\n<div class=\\"original__bRMd\\">\\n<div>\\n<p>（请注意，转换 <strong>不包括</strong> 向任何方向旋转。）</p>\\n\\n<p>最大可能的重叠是多少？</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg\\" style=\\"width: 450px; height: 231px;\\" />\\n<pre>\\n<strong>输入：</strong>img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\\n<strong>输出：</strong>3\\n<strong>解释：</strong>将 img1 向右移动 1 个单位，再向下移动 1 个单位。\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg\\" style=\\"width: 450px; height: 105px;\\" />\\n两个图像都具有 <code>1</code> 的位置的数目是 3（用红色标识）。\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg\\" style=\\"width: 450px; height: 231px;\\" />\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>img1 = [[1]], img2 = [[1]]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>img1 = [[0]], img2 = [[0]]\\n<strong>输出：</strong>0\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>n == img1.length</code></li>\\n\\t<li><code>n == img1[i].length</code></li>\\n\\t<li><code>n == img2.length </code></li>\\n\\t<li><code>n == img2[i].length</code></li>\\n\\t<li><code>1 <= n <= 30</code></li>\\n\\t<li><code>img1[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\\n\\t<li><code>img2[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\\n</ul>\\n</div>\\n</div>\\n","title":"835. 图像重叠","relatedTags":["数组","矩阵"],"difficult":"Middle","lang":["javascript"],"uniqueID":"835","slug":"835-Image-Overlap"}')}}]);