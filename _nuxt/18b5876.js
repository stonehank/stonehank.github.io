(window.webpackJsonp=window.webpackJsonp||[]).push([[308],{1106:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">arr</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> mctFromLeafValues = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">arr</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(arr.length===<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> arr[<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> arr)sum+=n\\n  <span class=\\"hljs-keyword\\">let</span> memo={}\\n  <span class=\\"hljs-keyword\\">return</span> dfs(arr)-sum\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">arr</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> str=arr.toString()\\n    <span class=\\"hljs-keyword\\">if</span>(memo[str])<span class=\\"hljs-keyword\\">return</span> memo[str]\\n    <span class=\\"hljs-comment\\">// console.log(arr)</span>\\n    <span class=\\"hljs-keyword\\">if</span>(arr.length===<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> arr[<span class=\\"hljs-number\\">0</span>]\\n    <span class=\\"hljs-keyword\\">let</span> m1=-<span class=\\"hljs-literal\\">Infinity</span>,m2=-<span class=\\"hljs-literal\\">Infinity</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(arr[i]&gt;m1){\\n        m2=m1\\n        m1=arr[i]\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(arr[i]&gt;m2){\\n        m2=arr[i]\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> val=m1*m2\\n    <span class=\\"hljs-comment\\">// console.log(arr,val)</span>\\n    <span class=\\"hljs-keyword\\">let</span> min=<span class=\\"hljs-literal\\">Infinity</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;arr.length;i++){\\n      <span class=\\"hljs-keyword\\">let</span> left=arr.slice(<span class=\\"hljs-number\\">0</span>,i)\\n      <span class=\\"hljs-keyword\\">let</span> right=arr.slice(i)\\n      min=<span class=\\"hljs-built_in\\">Math</span>.min(min,dfs(left)+dfs(right))\\n    }\\n    memo[str]=val+min\\n    <span class=\\"hljs-keyword\\">return</span> val+min\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"minimum-cost-tree-from-leaf-values","created_at":"2019-07-21","timeArr":[2019,6,21,11,27,14,0],"hasThinking":false,"content":"<p>给你一个正整数数组&nbsp;<code>arr</code>，考虑所有满足以下条件的二叉树：</p>\\n\\n<ul>\\n\\t<li>每个节点都有 0 个或是 2 个子节点。</li>\\n\\t<li>数组&nbsp;<code>arr</code>&nbsp;中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）</li>\\n\\t<li>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。</li>\\n</ul>\\n\\n<p>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个&nbsp;32 位整数。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre><strong>输入：</strong>arr = [6,2,4]\\n<strong>输出：</strong>32\\n<strong>解释：</strong>\\n有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。\\n\\n    24            24\\n   /  \\\\          /  \\\\\\n  12   4        6    8\\n /  \\\\               / \\\\\\n6    2             2   4</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= arr.length &lt;= 40</code></li>\\n\\t<li><code>1 &lt;= arr[i] &lt;= 15</code></li>\\n\\t<li>答案保证是一个 32 位带符号整数，即小于&nbsp;<code>2^31</code>。</li>\\n</ul>\\n","title":"1130. 叶值的最小代价生成树","relatedTags":["栈","贪心","动态规划","单调栈"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1130","slug":"1130-Minimum-Cost-Tree-From-Leaf-Values"}')}}]);