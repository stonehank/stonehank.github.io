(window.webpackJsonp=window.webpackJsonp||[]).push([[1185],{1983:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> uniqueLetterString = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(S===<span class=\\"hljs-string\\">\'\'</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> MOD=<span class=\\"hljs-number\\">1e9</span>+<span class=\\"hljs-number\\">7</span>,\\n      idxes=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">-1</span>]),\\n      dp=<span class=\\"hljs-built_in\\">Array</span>(S.length).fill(<span class=\\"hljs-number\\">0</span>)\\n  dp[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">1</span>\\n  idxes[S.charCodeAt(<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-number\\">-65</span>]=[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;S.length;i++){\\n\\n    <span class=\\"hljs-keyword\\">let</span> code=S.charCodeAt(i)<span class=\\"hljs-number\\">-65</span>\\n\\n    <span class=\\"hljs-keyword\\">let</span> minus=<span class=\\"hljs-number\\">0</span>\\n    minus+=(idxes[code][<span class=\\"hljs-number\\">1</span>]-idxes[code][<span class=\\"hljs-number\\">0</span>])*<span class=\\"hljs-number\\">2</span>\\n    minus+=(idxes[code][<span class=\\"hljs-number\\">0</span>]-(<span class=\\"hljs-number\\">-1</span>))*<span class=\\"hljs-number\\">1</span>\\n    \\n    updateIdxes(i,code)\\n    \\n    <span class=\\"hljs-keyword\\">let</span> prePre=dp[i<span class=\\"hljs-number\\">-2</span>] || <span class=\\"hljs-number\\">0</span>\\n    dp[i]=(dp[i<span class=\\"hljs-number\\">-1</span>]+dp[i<span class=\\"hljs-number\\">-1</span>]-prePre+i+<span class=\\"hljs-number\\">1</span>-minus) % MOD\\n\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> dp[dp.length<span class=\\"hljs-number\\">-1</span>]\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">updateIdxes</span>(<span class=\\"hljs-params\\">i,code</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> t=idxes[code][<span class=\\"hljs-number\\">1</span>]\\n    idxes[code][<span class=\\"hljs-number\\">1</span>]=i\\n    idxes[code][<span class=\\"hljs-number\\">0</span>]=t    \\n  }\\n};\\n</code></pre>\\n"],"querySlug":"count-unique-characters-of-all-substrings-of-a-given-string","created_at":"2019-04-12","timeArr":[2019,3,12,13,17,33,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>我们使用一个<code>idxes</code>保存每个字母的前2个索引，为什么要前2个索引呢？</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code>A B C A B C A\\n0 1 2 3 4 5 6\\n</code></pre>\\n<p>在最后一个(索引为6)的<code>A</code>时，它的前两个索引分别是<code>0</code>和<code>3</code>，写成<code>[0,3]</code>，那么当检查它的子数组时，\\n我们首先将最理想的状态，即每个子数组都增加<code>1</code>，因此<code>+7</code>，因为带有索引<code>6</code>的子数组有<code>7</code>个。</p>\\n<p>再看：</p>\\n<ul>\\n<li>\\n<p>从索引<code>6</code>到<code>3</code>之间这3个数，<code>A</code>是没有重复值的，每个子数组可以增加<code>1</code>个独特字符，因此不变(因为之前<code>+7</code>包括了)。</p>\\n</li>\\n<li>\\n<p>从索引<code>3</code>到<code>0</code>之间这3个数，<code>A</code>有了重复值，每个子数组要减少<code>n</code>个独特字符，这<code>n</code>是多少呢？</p>\\n<p>因为在上一次，即索引<code>5</code>时，那时候从索引<code>3</code>到<code>0</code>之间这3个数，<code>A</code>是没有重复值，他们的独特字符都增加<code>1</code>。</p>\\n<p>而这次(索引<code>6</code>)，这几个数突然有了重复值，那么他们的独特字符则需要<code>-1</code>，因为我们之间<code>+7</code>里面这里每个相当于<code>+1</code>，\\n因此最终需要<code>-2</code>。</p>\\n</li>\\n<li>\\n<p>从索引<code>0</code>之前，<code>A</code>在之前就已经有了重复值，再来一个重复值也没有影响，因此这之前的不需要变化，但我们之前<code>+7</code>的时候，\\n里面每个值都<code>+1</code>，因此这里需要<code>-1</code>。</p>\\n</li>\\n</ul>\\n<p>因此递推公式为<code>dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])+(i+1)-(idxes[code][1]-idxes[code][0])*2-(idxes[code][0]-(-1))</code></p>\\n<p>这里<code>dp[i-1]-dp[i-2]</code>指的是上一次的独特字符增加的数量；</p>\\n<p><code>i+1</code>指这一次独特字符最理想的增加数量；</p>\\n<p><code>(idxes[code][1]-idxes[code][0])*2</code>即上面介绍的第一阶段需要减去的。</p>\\n<p><code>(idxes[code][0]-(-1))</code>即上面介绍第二阶段需要减去的。</p>\\n<p>最后我们需要更新<code>idex</code>，只需要保存最近的2个索引。</p>\\n","content":"<p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>\\n\\n<p>例如：<code>s = \\"LEETCODE\\"</code> ，则其中 <code>\\"L\\"</code>, <code>\\"T\\"</code>,<code>\\"C\\"</code>,<code>\\"O\\"</code>,<code>\\"D\\"</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>\\n\\n<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>\\n\\n<p>由于答案可能非常大，请将结果 <strong>mod 10 ^ 9 + 7</strong> 后再返回。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>s = \\"ABC\\"\\n<strong>输出: </strong>10\\n<strong>解释:</strong> 所有可能的子串为：\\"A\\",\\"B\\",\\"C\\",\\"AB\\",\\"BC\\" 和 \\"ABC\\"。\\n     其中，每一个子串都由独特字符构成。\\n     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>s = \\"ABA\\"\\n<strong>输出: </strong>8\\n<strong>解释: </strong>除<code>了 countUniqueChars</code>(\\"ABA\\") = 1 之外，其余与示例 1 相同。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"LEETCODE\\"\\n<strong>输出：</strong>92\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>0 <= s.length <= 10^4</code></li>\\n\\t<li><code>s</code> 只包含大写英文字符</li>\\n</ul>\\n","title":"828. 统计子串中的唯一字符","relatedTags":["字符串","动态规划"],"difficult":"Hard","lang":["javascript"],"uniqueID":"828","slug":"828-Count-Unique-Characters-of-All-Substrings-of-a-Given-String"}')}}]);