(window.webpackJsonp=window.webpackJsonp||[]).push([[374],{1172:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">let</span> hash={}\\n<span class=\\"hljs-keyword\\">var</span> FindElements = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root</span>) </span>{\\n  hash={}\\n  root.val=<span class=\\"hljs-number\\">0</span>\\n  hash[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-literal\\">true</span>\\n  dfs(root)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> val=root.val\\n    <span class=\\"hljs-keyword\\">if</span>(root.left){\\n      root.left.val=val*<span class=\\"hljs-number\\">2</span>+<span class=\\"hljs-number\\">1</span>\\n      hash[root.left.val]=<span class=\\"hljs-literal\\">true</span>\\n      dfs(root.left)\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(root.right){\\n      root.right.val=val*<span class=\\"hljs-number\\">2</span>+<span class=\\"hljs-number\\">2</span>\\n      hash[root.right.val]=<span class=\\"hljs-literal\\">true</span>\\n      dfs(root.right)\\n    }\\n  }\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {number} target\\n * @return {boolean}\\n */</span>\\nFindElements.prototype.find = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">target</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> !!hash[target]\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your FindElements object will be instantiated and called as such:\\n * var obj = new FindElements(root)\\n * var param_1 = obj.find(target)\\n */</span>\\n</code></pre>\\n"],"querySlug":"find-elements-in-a-contaminated-binary-tree","created_at":"2019-11-17","timeArr":[2019,10,17,11,3,19,0],"hasThinking":false,"content":"<p>给出一个满足下述规则的二叉树：</p>\\n\\n<ol>\\n\\t<li><code>root.val == 0</code></li>\\n\\t<li>如果 <code>treeNode.val == x</code> 且&nbsp;<code>treeNode.left != null</code>，那么&nbsp;<code>treeNode.left.val == 2 * x + 1</code></li>\\n\\t<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.right != null</code>，那么&nbsp;<code>treeNode.right.val == 2 * x + 2</code></li>\\n</ol>\\n\\n<p>现在这个二叉树受到「污染」，所有的&nbsp;<code>treeNode.val</code>&nbsp;都变成了&nbsp;<code>-1</code>。</p>\\n\\n<p>请你先还原二叉树，然后实现&nbsp;<code>FindElements</code>&nbsp;类：</p>\\n\\n<ul>\\n\\t<li><code>FindElements(TreeNode* root)</code>&nbsp;用受污染的二叉树初始化对象，你需要先把它还原。</li>\\n\\t<li><code>bool find(int target)</code>&nbsp;判断目标值&nbsp;<code>target</code>&nbsp;是否存在于还原后的二叉树中并返回结果。</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1.jpg\\" style=\\"height: 119px; width: 320px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>\\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]\\n[[[-1,null,-1]],[1],[2]]\\n<strong>输出：</strong>\\n[null,false,true]\\n<strong>解释：</strong>\\nFindElements findElements = new FindElements([-1,null,-1]); \\nfindElements.find(1); // return False \\nfindElements.find(2); // return True </pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4.jpg\\" style=\\"height: 198px; width: 400px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>\\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\\n<strong>输出：</strong>\\n[null,true,true,false]\\n<strong>解释：</strong>\\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\\nfindElements.find(1); // return True\\nfindElements.find(3); // return True\\nfindElements.find(5); // return False</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1-1.jpg\\" style=\\"height: 274px; width: 306px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>\\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\\n<strong>输出：</strong>\\n[null,true,false,false,true]\\n<strong>解释：</strong>\\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\\nfindElements.find(2); // return True\\nfindElements.find(3); // return False\\nfindElements.find(4); // return False\\nfindElements.find(5); // return True\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>TreeNode.val == -1</code></li>\\n\\t<li>二叉树的高度不超过&nbsp;<code>20</code></li>\\n\\t<li>节点的总数在&nbsp;<code>[1,&nbsp;10^4]</code>&nbsp;之间</li>\\n\\t<li>调用&nbsp;<code>find()</code>&nbsp;的总次数在&nbsp;<code>[1,&nbsp;10^4]</code>&nbsp;之间</li>\\n\\t<li><code>0 &lt;= target &lt;= 10^6</code></li>\\n</ul>\\n","title":"1261. 在受污染的二叉树中查找元素","relatedTags":["树","深度优先搜索","广度优先搜索","设计","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1261","slug":"1261-Find-Elements-in-a-Contaminated-Binary-Tree"}')}}]);