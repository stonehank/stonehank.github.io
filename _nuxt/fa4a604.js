(window.webpackJsonp=window.webpackJsonp||[]).push([[57,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420],{686:function(n){n.exports=JSON.parse('{"content":"<p>为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\\n地址在<a href=\\"https://github.com/stonehank/simplify-anime\\">这里</a></p>\\n<hr>\\n<h2 id=\\"jie-shao\\">介绍</h2>\\n<p><a href=\\"http://animejs.com/\\">anime</a>一个动画库，摒弃了常规的<code>left,top</code>属性，全面采用<code>requestAnimateFrame+CSS3属性</code>能充分调用设备进行GPU渲染。</p>\\n<p>它的亮点有以下(直接引用官网)：</p>\\n<blockquote>\\n<ul>\\n<li>Keyframes(帧动画): Chain multiple animation properties.</li>\\n<li>Timeline(同步动画): Synchronize multiple instances together.</li>\\n<li>Playback controls(暂停回放功能): Play, pause, restart, seek animations or timelines.</li>\\n<li>CSS transforms(CSS动画): Animate CSS transforms individually.</li>\\n<li>Function based values(函数定义配置(注入了内部属性)): Multiple animated targets can have individual value.</li>\\n<li>SVG Animations(SVG动画): Motion path, line drawing and morphing animations.</li>\\n<li>Easing functions(自定义贝塞尔函数): Use the built in functions or create your own Cubic Bézier curve easing.</li>\\n</ul>\\n</blockquote>\\n<p>这么多亮点，其实关键函数就3~4个。</p>\\n<p>因为这里都是使用缓动函数算法，也就是通过 <code>初始位置</code>, <code>结束位置</code>, <code>持续时间</code>,<code>已消耗的时间</code> 计算出当前所在位置。</p>\\n<p><code>初始位置</code>、<code>结束位置</code>和<code>持续时间</code>是作为参数传入配置的，因此计算<code>已消耗时间</code>就是完成动画的核心。  </p>\\n<p>下面就深入了解下它的核心。</p>\\n<h2 id=\\"shen-ru-li-jie\\">深入理解</h2>\\n<p>先了解几个时间的变量，动画都是<code>算法+时间=位置</code>这么算出来的：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 记录当前位置所对应的时间，根据lastTime计算</span>\\ninstance.cuurentTime\\n<span class=\\"hljs-comment\\">// 记录当前位置所消耗的时间</span>\\nengineTime\\n<span class=\\"hljs-comment\\">// 记录上一次计算完毕赋值后的位置对应时间</span>\\nlastTime\\n<span class=\\"hljs-comment\\">// 上一次调用raf的时间</span>\\nstartTime\\n<span class=\\"hljs-comment\\">// 当前位置所消耗时间(能匹配反转状态)，根据engineTime计算</span>\\ninsTime\\n<span class=\\"hljs-comment\\">// 动画持续时间</span>\\ninsDuration\\n<span class=\\"hljs-comment\\">// 延迟时间</span>\\ndelay\\n<span class=\\"hljs-comment\\">// 从什么时间点开始动画</span>\\ninsOffset</code></pre>\\n</code></pre>\\n<p>接着看几个关键函数，这里先不放具体代码，只是先知道是做什么的(按一个正常动画顺序排放)：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// anime的核心机制, 递归调用raf执行(关键)</span>\\n<span class=\\"hljs-keyword\\">const</span> engine = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(</span>) =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// ...requestAnimateFrame</span>\\n})();\\n\\n<span class=\\"hljs-comment\\">// anime主体</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">anime</span>(<span class=\\"hljs-params\\">params</span>)</span>{\\n  \\n  <span class=\\"hljs-comment\\">// 定义instance 也是最终返回值</span>\\n  <span class=\\"hljs-keyword\\">let</span> instance = createNewInstance(params);\\n  \\n  <span class=\\"hljs-comment\\">// 外部API 从当前位置开始执行动画</span>\\n  instance.play = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  \\n  <span class=\\"hljs-comment\\">// 配置 startTime 和 engineTime(关键)</span>\\n   instance.tick = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">t</span>) </span>{}\\n   \\n  <span class=\\"hljs-comment\\">// 对当前engineTime进行判断，确定动画方案(关键)</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setInstanceProgress</span>(<span class=\\"hljs-params\\">engineTime</span>) </span>{}\\n  \\n  <span class=\\"hljs-comment\\">// 计算动画当前位置 并且赋值(关键)</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setAnimationsProgress</span>(<span class=\\"hljs-params\\">insTime</span>)</span>{}\\n\\n  <span class=\\"hljs-comment\\">// 直接跳到参数time的时间所在的位置</span>\\n  instance.seek = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">time</span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 暂停</span>\\n  instance.pause = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 反转</span>\\n  instance.reverse = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API reset</span>\\n  instance.reset = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 重新开始</span>\\n  instance.restart = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">return</span> instance\\n}</code></pre>\\n</code></pre>\\n<p>关键函数就4个，其他都是一些对关键函数的具体使用</p>\\n<p>接着一个个解析：</p>\\n<ul>\\n<li>createNewInstance</li>\\n</ul>\\n<p>其实就是对属性和方法合并成一个整体对象，这个对象是贯穿全局的，因此里面什么都有...</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createNewInstance</span>(<span class=\\"hljs-params\\">params</span>) </span>{\\n  \\n    <span class=\\"hljs-comment\\">/* 对params进行处理 */</span>\\n    <span class=\\"hljs-keyword\\">const</span> instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\\n    <span class=\\"hljs-keyword\\">const</span> tweenSettings = replaceObjectProps(defaultTweenSettings, params);\\n    <span class=\\"hljs-keyword\\">const</span> animatables = getAnimatables(params.targets);\\n    <span class=\\"hljs-keyword\\">const</span> properties = getProperties(instanceSettings, tweenSettings, params);\\n    <span class=\\"hljs-keyword\\">const</span> animations = getAnimations(animatables, properties);\\n        \\n    <span class=\\"hljs-comment\\">// mergeObjects(o1,o2)相当于 Object.assing({},o2,o1)</span>\\n    <span class=\\"hljs-keyword\\">return</span> mergeObjects(instanceSettings, {\\n      <span class=\\"hljs-attr\\">children</span>: [],\\n      <span class=\\"hljs-attr\\">animatables</span>: animatables,\\n      <span class=\\"hljs-attr\\">animations</span>: animations,\\n      <span class=\\"hljs-attr\\">duration</span>: getInstanceTimings(<span class=\\"hljs-string\\">\'duration\'</span>, animations, instanceSettings, tweenSettings),\\n      <span class=\\"hljs-attr\\">delay</span>: getInstanceTimings(<span class=\\"hljs-string\\">\'delay\'</span>, animations, instanceSettings, tweenSettings)\\n    });\\n  }</code></pre>\\n</code></pre>\\n<ul>\\n<li>instance.play</li>\\n</ul>\\n<p>此处先做了防护，只有paused状态下才会执行，<code>lastTime</code>这里是调取当前动画的位置对应的时间，因此才可以实现从任意位置开始动画。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-comment\\">// 外部API 从当前位置开始执行动画</span>\\ninstance.play = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (!instance.paused) <span class=\\"hljs-keyword\\">return</span>;\\n  instance.paused = <span class=\\"hljs-literal\\">false</span>;\\n  <span class=\\"hljs-comment\\">// 从0 开始</span>\\n  startTime = <span class=\\"hljs-number\\">0</span>;\\n  <span class=\\"hljs-comment\\">// 调取当前动画当前位置所对应的时间</span>\\n  lastTime = adjustTime(instance.currentTime);\\n  <span class=\\"hljs-comment\\">// 给 activeInstances 添加当前实例，说明这是一个正在运行的动画</span>\\n  activeInstances.push(instance);\\n  <span class=\\"hljs-comment\\">// raf未启动，调用engine</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!raf) engine();\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li>engine</li>\\n</ul>\\n<p>anime的核心机制，通过递归调用<code>requestAnimateFrame</code>，当检测到需要执行动画的集合<code>activeInstances</code>有值，调用instance.tick。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-comment\\">// IIFE 之后调用engine相当于执行内部的play</span>\\n  <span class=\\"hljs-keyword\\">const</span> engine = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(</span>) =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// step收到一个参数，</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">play</span>(<span class=\\"hljs-params\\"></span>) </span>{ raf = requestAnimationFrame(step); };\\n    <span class=\\"hljs-comment\\">// 这里的参数t是 raf的参数中可以接受的一个时间戳，表示触发调用的时间</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">step</span>(<span class=\\"hljs-params\\">t</span>) </span>{\\n      <span class=\\"hljs-comment\\">// activeInstances指正在被执行的动画集合</span>\\n      <span class=\\"hljs-keyword\\">const</span> activeLength = activeInstances.length;\\n      <span class=\\"hljs-comment\\">// 存在正在运行的动画</span>\\n      <span class=\\"hljs-keyword\\">if</span> (activeLength) {\\n        <span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">while</span> (i &lt; activeLength) {\\n          <span class=\\"hljs-comment\\">// 调用tick执行</span>\\n          <span class=\\"hljs-keyword\\">if</span> (activeInstances[i]) activeInstances[i].tick(t);\\n          i++;\\n        }\\n        play();\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 不存在正在运行的动画 cancel</span>\\n        cancelAnimationFrame(raf);\\n        raf = <span class=\\"hljs-number\\">0</span>;\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> play;\\n  })();</code></pre>\\n</code></pre>\\n<ul>\\n<li>instance.tick</li>\\n</ul>\\n<p>tick的作用通过参数<code>t</code>，<code>raf</code>的一个时间戳概念，计算出距离上一次调用实际消耗的时间<code>engineTime</code>。</p>\\n<p>例如：上一次调用时间戳是<code>1000</code>，也就是1秒，中途突然执行一个巨大的任务，等任务结束，时间戳是<code>20000</code>，\\n那么这次的<code>engineTime</code>就是<code>lastTime+20000-1000</code>，也就是计算这次动画从上次位置再加上19秒的位置...\\n那么anime对于这种情况是怎么处理呢?继续看下一个<code>setInstanceProgress</code>。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 配置 startTime 和 engineTime</span>\\ninstance.tick = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">t</span>) </span>{\\n  now = t;\\n  <span class=\\"hljs-comment\\">// startTime 如果首次执行 就是now，否则就是上一次tick的时间</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!startTime) startTime = now;\\n  <span class=\\"hljs-comment\\">// lastTime 是上一次执行结束后动画对应位置的时间戳</span>\\n  <span class=\\"hljs-comment\\">// engineTime 是到动画目前为止消耗的总时间，一般理论上讲是lastTime+16.6667</span>\\n  <span class=\\"hljs-keyword\\">const</span> engineTime = (lastTime + now - startTime) * anime.speed;\\n  setInstanceProgress(engineTime);\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li>setInstanceProgress</li>\\n</ul>\\n<p>这个函数接受一个消耗的时间值，在内部对其进行适配和定义了各种情况的动画起始点，传递给<code>setAnimationsProgress</code>。</p>\\n<p>例如，上面那个例子，如果消耗了19秒，就如进入这个判断:从结束点开始动画(考虑reverse的情况)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 消耗的时间超出了持续时间 并且当前位置不在终点  或者 未设定持续时间</span>\\n<span class=\\"hljs-keyword\\">if</span> ((insTime &gt;= insDuration &amp;&amp; insCurrentTime !== insDuration) || !insDuration){\\n  <span class=\\"hljs-keyword\\">if</span> ((insTime &gt;= insDuration &amp;&amp; insCurrentTime !== insDuration) || !insDuration) {\\n    <span class=\\"hljs-comment\\">// 从结束点开始</span>\\n    setAnimationsProgress(insDuration);\\n    <span class=\\"hljs-keyword\\">if</span> (!insReversed) countIteration();\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>setInstanceProgress(省略了一些配置的定义)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 对当前engineTime进行判断，确定动画方案</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setInstanceProgress</span>(<span class=\\"hljs-params\\">engineTime</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 动画持续时间</span>\\n  <span class=\\"hljs-keyword\\">const</span> insDuration = instance.duration;\\n  <span class=\\"hljs-comment\\">// 从什么时间点开始动画</span>\\n  <span class=\\"hljs-keyword\\">const</span> insOffset = instance.offset;\\n  <span class=\\"hljs-comment\\">// 加上延迟后的开始时间</span>\\n  <span class=\\"hljs-keyword\\">const</span> insStart = insOffset + instance.delay;\\n  <span class=\\"hljs-comment\\">// 记录当前位置所对应的时间</span>\\n  <span class=\\"hljs-keyword\\">const</span> insCurrentTime = instance.currentTime;\\n  <span class=\\"hljs-comment\\">// 是否是反转状态</span>\\n  <span class=\\"hljs-keyword\\">const</span> insReversed = instance.reversed;\\n  <span class=\\"hljs-comment\\">// 当前位置所消耗时间(能匹配反转状态)</span>\\n  <span class=\\"hljs-comment\\">// 这里adjustTime就是如果是反转状态，则返回 insDuration-engineTime</span>\\n  <span class=\\"hljs-keyword\\">const</span> insTime = adjustTime(engineTime);\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n  <span class=\\"hljs-comment\\">// 消耗的时间大于应该开始的时间 并且 消耗的时间在持续时间范围内</span>\\n  <span class=\\"hljs-keyword\\">if</span> (insTime &gt; insOffset &amp;&amp; insTime &lt; insDuration) {\\n    setAnimationsProgress(insTime);\\n  } <span class=\\"hljs-keyword\\">else</span> {\\n    <span class=\\"hljs-comment\\">// 消耗的时间小于应该开始的时间 并且 当前位置不在起点</span>\\n    <span class=\\"hljs-keyword\\">if</span> (insTime &lt;= insOffset &amp;&amp; insCurrentTime !== <span class=\\"hljs-number\\">0</span>) {\\n      <span class=\\"hljs-comment\\">// 从头开始</span>\\n      setAnimationsProgress(<span class=\\"hljs-number\\">0</span>);\\n      <span class=\\"hljs-keyword\\">if</span> (insReversed) countIteration();\\n    }\\n    <span class=\\"hljs-comment\\">// 消耗的时间超出了持续时间 并且当前位置不在终点  或者 未设定持续时间</span>\\n    <span class=\\"hljs-keyword\\">if</span> ((insTime &gt;= insDuration &amp;&amp; insCurrentTime !== insDuration) || !insDuration) {\\n      <span class=\\"hljs-comment\\">// 从结束点开始</span>\\n      setAnimationsProgress(insDuration);\\n      <span class=\\"hljs-keyword\\">if</span> (!insReversed) countIteration();\\n    }\\n  }\\n  setCallback(<span class=\\"hljs-string\\">\'update\'</span>);\\n  <span class=\\"hljs-comment\\">// 消耗时间大于持续时间 并且在终点(不在终点的上面已经判断了)</span>\\n  <span class=\\"hljs-keyword\\">if</span> (engineTime &gt;= insDuration) {\\n    <span class=\\"hljs-keyword\\">if</span> (instance.remaining) {\\n      startTime = now;\\n      <span class=\\"hljs-keyword\\">if</span> (instance.direction === <span class=\\"hljs-string\\">\'alternate\'</span>) toggleInstanceDirection();\\n      <span class=\\"hljs-comment\\">// remaining为false，remaining&gt;0说明还需要继续动画</span>\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 完成动画的执行</span>\\n      instance.pause();\\n      <span class=\\"hljs-keyword\\">if</span> (!instance.completed) {\\n        instance.completed = <span class=\\"hljs-literal\\">true</span>;\\n        setCallback(<span class=\\"hljs-string\\">\'complete\'</span>);\\n        <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-string\\">\'Promise\'</span> <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-built_in\\">window</span>) {\\n          resolve();\\n          promise = makePromise();\\n        }\\n      }\\n    }\\n    lastTime = <span class=\\"hljs-number\\">0</span>;\\n  }\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li>setAnimationsProgress(省略了一些配置的定义)</li>\\n</ul>\\n<p>这个函数接受一个参数，就是当前位置所消耗时间(动画起始点)，然后在里面计算出每一个动画目标的位置，并且赋值</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 计算动画当前位置 并且赋值</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setAnimationsProgress</span>(<span class=\\"hljs-params\\">insTime</span>) </span>{\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n  <span class=\\"hljs-comment\\">// 这个while逐个计算当前实例中的每个动画的当前位置(通过时间和算法)</span>\\n  <span class=\\"hljs-keyword\\">while</span> (i &lt; animationsLength) {\\n      <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-comment\\">// 消耗的时间占总持续时间的比例 在起点终点之间</span>\\n    <span class=\\"hljs-keyword\\">const</span> elapsed = minMaxValue(insTime - tween.start - tween.delay, <span class=\\"hljs-number\\">0</span>, tween.duration) / tween.duration;\\n    <span class=\\"hljs-comment\\">// 通过算法计算当前进度</span>\\n    <span class=\\"hljs-keyword\\">const</span> eased = <span class=\\"hljs-built_in\\">isNaN</span>(elapsed) ? <span class=\\"hljs-number\\">1</span> : tween.easing(elapsed, tween.elasticity);\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-comment\\">// 遍历每一个到达点执行</span>\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> n = <span class=\\"hljs-number\\">0</span>; n &lt; toNumbersLength; n++) {\\n      <span class=\\"hljs-keyword\\">let</span> value;\\n      <span class=\\"hljs-keyword\\">const</span> toNumber = tween.to.numbers[n];\\n      <span class=\\"hljs-keyword\\">const</span> fromNumber = tween.from.numbers[n];\\n      <span class=\\"hljs-keyword\\">if</span> (!tween.isPath) {\\n        <span class=\\"hljs-comment\\">// 计算当前具体位置</span>\\n        value = fromNumber + (eased * (toNumber - fromNumber));\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 进行SVG path计算</span>\\n        value = getPathProgress(tween.value, eased * toNumber);\\n      }\\n      <span class=\\"hljs-comment\\">/* ... */</span>\\n      numbers.push(value);\\n    }\\n         <span class=\\"hljs-comment\\">/* ... */</span>\\n        <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">isNaN</span>(n)) {\\n          <span class=\\"hljs-comment\\">// 组合单位 \'135.546\'+\'px\'</span>\\n          <span class=\\"hljs-keyword\\">if</span> (!b) {\\n            progress += n + <span class=\\"hljs-string\\">\' \'</span>;\\n          } <span class=\\"hljs-keyword\\">else</span> {\\n            progress += n + b;\\n          }\\n        }\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-comment\\">// 组合结果 \'translateX(\'+\'135.546px\'+\')`</span>\\n    setTweenProgress[anim.type](https:<span class=\\"hljs-comment\\">//github.com/stonehank/sourcecode-analysis/blob/master/source-code.anime/animatable.target, anim.property, progress, transforms, animatable.id);</span>\\n    anim.currentValue = progress;\\n    i++;\\n  }\\n  <span class=\\"hljs-comment\\">// 遍历结果，逐个target赋值</span>\\n  <span class=\\"hljs-keyword\\">const</span> transformsLength = <span class=\\"hljs-built_in\\">Object</span>.keys(transforms).length;\\n  <span class=\\"hljs-keyword\\">if</span> (transformsLength) {\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> id = <span class=\\"hljs-number\\">0</span>; id &lt; transformsLength; id++) {\\n      <span class=\\"hljs-keyword\\">if</span> (!transformString) {\\n        <span class=\\"hljs-keyword\\">const</span> t = <span class=\\"hljs-string\\">\'transform\'</span>;\\n        <span class=\\"hljs-comment\\">// 配置兼容性</span>\\n        transformString = (getCSSValue(<span class=\\"hljs-built_in\\">document</span>.body, t) ? t : <span class=\\"hljs-string\\">`-webkit-<span class=\\"hljs-subst\\">${t}</span>`</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 设置style</span>\\n      instance.animatables[id].target.style[transformString] = transforms[id].join(<span class=\\"hljs-string\\">\' \'</span>);\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 记录当前位置所对应的时间</span>\\n  instance.currentTime = insTime;\\n  <span class=\\"hljs-comment\\">// 设置进度</span>\\n  instance.progress = (insTime / instance.duration) * <span class=\\"hljs-number\\">100</span>;\\n}</code></pre>\\n</code></pre>\\n<p>剩下的就是一些操作函数了：</p>\\n<ul>\\n<li><p>instance.seek </p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 直接跳到参数time的时间所在的位置</span>\\ninstance.seek = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">time</span>) </span>{\\nsetInstanceProgress(adjustTime(time));\\n}</code></pre>\\n</code></pre>\\n</li>\\n<li><p>instance.pause</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API 暂停</span>\\ninstance.pause = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n<span class=\\"hljs-keyword\\">const</span> i = activeInstances.indexOf(instance);\\n<span class=\\"hljs-comment\\">// 删除activeInstances 后续engine中找不到便不会执行</span>\\n<span class=\\"hljs-keyword\\">if</span> (i &gt; <span class=\\"hljs-number\\">-1</span>) activeInstances.splice(i, <span class=\\"hljs-number\\">1</span>);\\ninstance.paused = <span class=\\"hljs-literal\\">true</span>;\\n}</code></pre>\\n</code></pre>\\n</li>\\n<li><p>instance.reverse</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API 反转</span>\\ninstance.reverse = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  toggleInstanceDirection();\\n  startTime = <span class=\\"hljs-number\\">0</span>;\\n  lastTime = adjustTime(instance.currentTime);\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li>instance.restart</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API 重新执行</span>\\ninstance.restart = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  instance.pause();\\n  instance.reset();\\n  instance.play();\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li>instance.reset<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API reset</span>\\ninstance.reset = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n<span class=\\"hljs-keyword\\">const</span> direction = instance.direction;\\n<span class=\\"hljs-keyword\\">const</span> loops = instance.loop;\\n<span class=\\"hljs-comment\\">// 当前位置,进度 归零</span>\\ninstance.currentTime = <span class=\\"hljs-number\\">0</span>;\\ninstance.progress = <span class=\\"hljs-number\\">0</span>;\\ninstance.paused = <span class=\\"hljs-literal\\">true</span>;\\ninstance.began = <span class=\\"hljs-literal\\">false</span>;\\ninstance.completed = <span class=\\"hljs-literal\\">false</span>;\\ninstance.reversed = direction === <span class=\\"hljs-string\\">\'reverse\'</span>;\\ninstance.remaining = direction === <span class=\\"hljs-string\\">\'alternate\'</span> &amp;&amp; loops === <span class=\\"hljs-number\\">1</span> ? <span class=\\"hljs-number\\">2</span> : loops;\\nsetAnimationsProgress(<span class=\\"hljs-number\\">0</span>);\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = instance.children.length; i--; ){\\n  instance.children[i].reset();\\n}\\n}</code></pre>\\n</code></pre>\\n</li>\\n</ul>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<ol>\\n<li>使用了<code>requestAnimateFrame</code>和<code>CSS</code>动画提高流畅度。</li>\\n<li>使用了缓动函数，只需要通过<code>当前动画消耗的时间</code>，搭配其他定义的配置项，就可以计算出当前动画具体位置。</li>\\n</ol>\\n","toc":[{"anchor":"jie-shao","level":2,"text":"介绍"},{"anchor":"shen-ru-li-jie","level":2,"text":"深入理解"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":["源码","css","算法","promise"],"created_at":"2018-07-20","timeArr":[2018,6,20,17,13,2,0],"title":"源码阅读-anime","uuid":"4eefd89367cd780830f848b989d9ff1f2ad1c9e9","summary":"<p>为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\\n地址在<a href=\\"https://github.com/stonehank/simplify-anime\\">这里</a></p>","slug":"source-code-anime","sha":"f2de765b0c50caf3a3f5e97ffda9d8b60e27ac0c"}')},687:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"antd-comments\\">antd-comments</h1>\\n<p>阅读ant-design源码（部分）</p>\\n<h3 id=\\"shen-me-shi-zheng-ti-？\\">什么是整体？</h3>\\n<p>&emsp;在我们阅读项目源码之前，如果你对它的功能一无所知，那简直是最可怕的事情...\\n经常不知不觉就深入其中的逻辑，就像进入一团团迷雾，甚至会觉得有很多重复没必要的东西，完全不知道它们的区别。</p>\\n<p>&emsp;当然，值的我们阅读的源码，绝大部分每个功能都是有意义的，而极少重复。</p>\\n<p>&emsp;因此，不能一开始就深入其中，而往往先需要知道功能，会用功能，再去阅读源码。</p>\\n<p>&emsp;ant-design是一个华丽的项目，将最常用组件及其逻辑搭配大量css进行组装，\\n我们只需外部调用API，即可轻松搭建美观的界面，同时，ant-design也是可扩展的，底层是react-component，\\n更为复杂，功能也更加强大。</p>\\n<p>&emsp;此项目的理想目的就是希望能从整体入手，除了源码细节注释外，在每一个页面的开头会有一段注释，对当前页面的整体功能做了个介绍，\\n如果需要自行配置，只看介绍就可以知道要去哪里细看进行配置；如果需要深入源码，看完整体介绍，再去细看源码，\\n能提升阅读效率。</p>\\n","toc":[{"anchor":"antd-comments","level":1,"text":"antd-comments"},{"anchor":"shen-me-shi-zheng-ti-？","level":3,"text":"什么是整体？"}],"relatedTags":["源码","react","css"],"created_at":"2018-08-07","timeArr":[2018,7,7,22,27,0,0],"title":"源码阅读-ant-design","uuid":"bd2212eb183cedc05eb9b873778391f62063fada","summary":"<h4>antd-comments</h4>\\n<p>阅读ant-design源码（部分）</p>\\n<h4>什么是整体？</h4>\\n<p> 在我们阅读项目源码之前，如果你对它的功能一无所知，那简直是最可怕的事情...\\n经常不知不觉就深入其中的逻辑，就像进入一团团迷雾，甚至会觉得有很多重复没必要的东西，完全不知道它们的区别。</p>\\n<p> 当然，值的...</p>","slug":"source-code-ant-design","sha":"34b8759cdf2a2234851effc42681c04302784030"}')},688:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li><p>7-29：更新至webpack-config-dev.js</p>\\n</li>\\n<li><p>9-25：更新webpackDevServer.config.js</p>\\n</li>\\n<li><p>10-16：更新webpack.config.prod.js</p>\\n</li>\\n</ul>\\n<p>粗读了一遍<code>create-react-app.js</code>，主要是用node对检测和创建上的操作，还有安装依赖，\\n下次会将它粗略分析下，并且将导图画出</p>\\n<p><code>webpack-config-dev.js</code>是开发模式下的配置，基本上每一行都有注释，解释了代码的功能和相关插件的作用\\n(等待后续更新)</p>\\n<hr>\\n<p>看完config.prod和config.dev，觉得<code>CRA</code>的webpack配置真的是解决了大量的issue才能达到今天的优化地步，基本每一次选用插件或者\\n修改配置options都有独特的issue。</p>\\n<p>要真正做到理解<code>CRA</code>，还需要去理解这些问题的产生，去看一看他们的讨论，要不然以后遇到同样的问题，还要重新去寻求解决办法。</p>\\n","toc":[],"relatedTags":["webpack","react","源码"],"created_at":"2018-11-19","timeArr":[2018,10,19,15,45,55,0],"title":"源码阅读-create-react-app(webpack配置)","uuid":"2bbdd2a09d1bce1b097fe092c4929ed1a7673f6d","summary":"<ul>\\n<li>\\n<p>7-29：更新至webpack-config-dev.js</p>\\n</li>\\n<li>\\n<p>9-25：更新webpackDevServer.config.js</p>\\n</li>\\n<li>\\n<p>10-16：更新webpack.config.prod.js</p>\\n</li>\\n</ul>\\n<p>粗读了一遍<code>create-react-app.js</code>，主要是用node对检测和创建上的操作，还有安装依赖，\\n下次...</p>","slug":"source-code-create-react-app-webpack-pei-zhi","sha":"6e444f7cb5dd23463be4f5eb867ac6e67ebc2bce"}')},689:function(n){n.exports=JSON.parse('{"content":"<p>至今天(2018年9月7日)，这2个工具的实现源码思想是极其相似的，基本上，只要阅读了其中一个源码，也就了解了另外一个的实现。</p>\\n<p>fast-memoize导图:</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.fast-memoizeVSnano-memoize/fast-memoize.png\\" alt=\\"\\"></p>\\n<h2 id=\\"chu-shi\\">初识</h2>\\n<p>大概说说它们的实现思路：</p>\\n<ol>\\n<li>定义缓存结构，其中<code>fast</code>使用了<code>无prototype的对象</code>，<code>nano</code>使用了<code>普通对象</code>。</li>\\n<li>定义序列化方法：当检测到是单参数时，都是选择JSON.stringify，而多个参数，两者有不同（后面再说）。</li>\\n<li>定义策略：也就是缓存的具体方法，其实很简单，就是对当前缓存结构查找，找到就返回，找不到就重新运行，\\n 两者都使用了<code>bind</code>方法注入参数，可以省去运行时再去查找参数。</li>\\n</ol>\\n<p>接着分析两者的异同：</p>\\n<p>相同处：</p>\\n<ul>\\n<li>都使用了<code>JSON.stringify</code>作为序列化方法，因为它是原生的。</li>\\n<li>都对返回的缓存函数进行了参数注入（这是一个极大提升性能的方法）。</li>\\n<li>对单参数还是多参数的判断都是使用<code>func.length</code>(形参的数量判断)，因为<code>func.length</code>比<code>arguments.length</code>这种动态判断性能会好很多。</li>\\n</ul>\\n<p>不同点：</p>\\n<ul>\\n<li><code>fast</code>使用了<code>无prototype的对象</code>，<code>nano</code>使用了<code>普通对象</code>(这一点性能上相差不多)。</li>\\n<li>当遇到多个参数时，<code>fast</code>还是继续对<code>arguments</code>进行序列化，而<code>nano</code>则复杂一点，它通过用数组将每一次多个参数保存起来，\\n后续通过遍历每个参数进行全等对比<code>===</code>，判断是否从缓存调取结果。</li>\\n<li>同样是多个参数，<code>nano</code>增加了一个参数<code>max</code>，可以让用户自定义需要进行对比参数的长度。</li>\\n</ul>\\n<h2 id=\\"shen-ru\\">深入</h2>\\n<p>接着看下第二点不同点的源码：\\n主要看<code>nano-memoize</code>：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">multiple</span>(<span class=\\"hljs-params\\">f,k,v,eq,change,max=<span class=\\"hljs-number\\">0</span>,...args</span>) </span>{\\n      <span class=\\"hljs-comment\\">// 用来储存i(当前对比的参数索引)和缓存值</span>\\n      <span class=\\"hljs-keyword\\">const</span> rslt = {};\\n      <span class=\\"hljs-comment\\">// k是一个专门存放多个参数的数组 格式类似</span>\\n      <span class=\\"hljs-comment\\">// [[...args],[...args],[...args]...]</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;k.length;i++) { <span class=\\"hljs-comment\\">// an array of arrays of args</span>\\n        <span class=\\"hljs-keyword\\">let</span> key = k[i];\\n        <span class=\\"hljs-comment\\">// 判断是否需要使用max</span>\\n        <span class=\\"hljs-keyword\\">if</span>(max) { key = key.slice(<span class=\\"hljs-number\\">0</span>,max); }\\n        <span class=\\"hljs-comment\\">// 当前长度相等或者有max值，开始进行对比</span>\\n        <span class=\\"hljs-keyword\\">if</span>(key.length===args.length || (max &amp;&amp; key.length&lt;args.length)) {\\n          <span class=\\"hljs-comment\\">// 获取长度</span>\\n          <span class=\\"hljs-keyword\\">const</span> max = key.length - <span class=\\"hljs-number\\">1</span>;\\n          <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;=max;j++) {\\n            <span class=\\"hljs-comment\\">// 如果发现不等，直接跳出</span>\\n            <span class=\\"hljs-keyword\\">if</span>(!eq(key[j],args[j])) { <span class=\\"hljs-keyword\\">break</span>; } <span class=\\"hljs-comment\\">// go to next key if args don\'t match</span>\\n            <span class=\\"hljs-comment\\">// 当到了最后一项都没跳出 说明参数相同</span>\\n            <span class=\\"hljs-keyword\\">if</span>(j===max) { <span class=\\"hljs-comment\\">// the args matched</span>\\n              <span class=\\"hljs-comment\\">// 记录当前索引</span>\\n              rslt.i = i;\\n              <span class=\\"hljs-comment\\">// 调用当前参数的缓存</span>\\n              rslt.v = v[i]; <span class=\\"hljs-comment\\">// get the cached value</span>\\n            }\\n          }\\n        }\\n      }\\n      <span class=\\"hljs-comment\\">// 如果有i 说明是调用缓存，如果没有i，则添加缓存</span>\\n      <span class=\\"hljs-keyword\\">const</span> i = rslt.i&gt;=<span class=\\"hljs-number\\">0</span> ? rslt.i : v.length;\\n      <span class=\\"hljs-keyword\\">if</span>(change) { change(i); }\\n      <span class=\\"hljs-comment\\">// 如果缓存不存在就执行func，存在直接返回缓存</span>\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">typeof</span> rslt.v === <span class=\\"hljs-string\\">\\"undefined\\"</span> ? v[i] = f.call(<span class=\\"hljs-keyword\\">this</span>,...(k[i] = args)) : rslt.v;\\n    }</code></pre>\\n</code></pre>\\n<p>可以看出，这是通过2次遍历，对<code> [[...args],[...args],[...args]...]</code>这样一种结构比较，外层遍历判断length，\\nlength相等才会进入内层遍历，内层遍历就是逐个判断了。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 注入参数，提升性能</span>\\nf = multiple.bind(\\n        <span class=\\"hljs-keyword\\">this</span>,\\n        fn,\\n        k,\\n        v,\\n        <span class=\\"hljs-comment\\">// 逐个判断方式默认为 ===</span>\\n        equals || <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(a,b</span>) =&gt;</span> a===b), <span class=\\"hljs-comment\\">// default to just a regular strict comparison</span>\\n        (maxAge ? change.bind(<span class=\\"hljs-keyword\\">this</span>,v): <span class=\\"hljs-literal\\">null</span>), <span class=\\"hljs-comment\\">// turn change logging on and bind to arg cache v</span>\\n        maxArgs\\n      );</code></pre>\\n</code></pre>\\n<p>上面一段则是参数注入方式和默认的对比方式。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p>一个表格总结两者最大不同，假设：</p>\\n<ul>\\n<li>忽略===的执行时间</li>\\n<li>使用的参数分为 引用相同 和 引用不同(但是深比较都为true)\\n  例如：<code>{x:1}</code>和<code>{x:1}</code></li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th><em>耗时操作</em></th>\\n<th><em>多个参数(引用相同)</em></th>\\n<th></th>\\n<th><em>多个参数(引用不同)</em></th>\\n<th></th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>状态</td>\\n<td>首次运行</td>\\n<td>后续运行</td>\\n<td>首次运行</td>\\n<td>后续运行</td>\\n</tr>\\n<tr>\\n<td>fast</td>\\n<td>序列化+运行函数</td>\\n<td>序列化比较</td>\\n<td>序列化+运行函数</td>\\n<td>序列化比较</td>\\n</tr>\\n<tr>\\n<td>nano</td>\\n<td>运行函数</td>\\n<td>0(===比较)</td>\\n<td>运行函数</td>\\n<td>运行函数(===比较失败)</td>\\n</tr>\\n</tbody></table>\\n","toc":[{"anchor":"chu-shi","level":2,"text":"初识"},{"anchor":"shen-ru","level":2,"text":"深入"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":["源码","缓存","性能"],"created_at":"2018-09-09","timeArr":[2018,8,9,23,10,16,0],"title":"源码阅读-fast-memoizeVSnano-memoize","uuid":"192cb2d796eb6fa7798923cf1e642b9be3a00af6","summary":"<p>至今天(2018年9月7日)，这2个工具的实现源码思想是极其相似的，基本上，只要阅读了其中一个源码，也就了解了另外一个的实现。</p>\\n<p>fast-memoize导图:</p>\\n<p>![](https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/sou...</p>","slug":"source-code-fast-memoizeVSnano-memoize","sha":"7253519654d49748be385ec948aa3d448a6d4a7c"}')},690:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"source-codefullpage\\">source-code.fullpage</h1>\\n<p>fullPage 2.5.4</p>\\n<p>阅读<a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.fullpage/src/jquery.fullPage.js\\">fullpage源码(依赖jquery)</a></p>\\n","toc":[{"anchor":"source-codefullpage","level":1,"text":"source-code.fullpage"}],"relatedTags":["源码"],"created_at":"2018-07-15","timeArr":[2018,6,15,16,20,8,0],"title":"源码阅读-fullpage","uuid":"f68337e3bce79a95ca9f0a7524fba1c2773f2223","summary":"<h4>source-code.fullpage</h4>\\n<p>fullPage 2.5.4</p>\\n<p>阅读[fullpage源码(依赖jquery)](https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.fullpage/src/jquery.fu...</p>","slug":"source-code-fullpage","sha":"9863e94895d22e63146b5b0f24f28bed4b5682f4"}')},691:function(n){n.exports=JSON.parse('{"content":"<p><code>graphql-request</code>一个极小的<code>graphql</code>请求方法</p>\\n<p>如果不太了解<code>graphql</code>，看一下这个库，或许能知道它的请求就可以这么简单...</p>\\n<p>就是熟悉的<code>fetch</code>，这里使用了<code>cross-fetch</code>(兼容的fetch)</p>\\n<ol>\\n<li><code>Content-Type</code>设置为<code>application/json</code></li>\\n<li><code>method</code>设置为<code>POST</code></li>\\n<li>合并自定义<code>headers</code></li>\\n<li>传入<code>query</code>(<code>graphql</code>的查询模板)，<code>variables</code>(查询模板中的变量，可选)</li>\\n</ol>\\n<p>剩下的只需要等待数据返回。</p>\\n","toc":[],"relatedTags":["graphql","源码"],"created_at":"2018-12-21","timeArr":[2018,11,21,23,12,52,0],"title":"源码阅读-graphql-request","uuid":"003e6a0839f7a3aa25452aa0631217c7d52b51b0","summary":"<p><code>graphql-request</code>一个极小的<code>graphql</code>请求方法</p>\\n<p>如果不太了解<code>graphql</code>，看一下这个库，或许能知道它的请求就可以这么简单...</p>\\n<p>就是熟悉的<code>fetch</code>，这里使用了<code>cross-fetch</code>(兼容的fetch)</p>\\n<ol>\\n<li><code>Content-Type</code>设置为`application/js...</li>\\n</ol>","slug":"source-code-graphql-request","sha":"2153a5389109334a02980708ba72e829b64515a2"}')},692:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"source-codehyperapp\\">source-code.hyperapp</h1>\\n<p>v1.2.6</p>\\n<p>一个极小的(1kb)类react框架，实现了virtual-dom，diff比较(需要key)，数据绑定到actions上，通过actions改变数据，会自动更新页面</p>\\n<p>主要步骤：</p>\\n<ul>\\n<li>通过app()对其参数进行处理</li>\\n<li>克隆state（不在原state上修改）</li>\\n<li>增强actions，当调用时会自动检查结果result和原state是否有变化，有变化进行render</li>\\n<li>将state和增强actions绑定到view上</li>\\n<li>初始化render，执行patch</li>\\n</ul>\\n<p>patch是hyperapp进行节点更新的核心，主要步骤：</p>\\n<ul>\\n<li>先判断node节点</li>\\n<li>当节点相同---&gt;进行key判断---&gt;递归patch，直到指针到尾部</li>\\n<li>最后判断是否需要删除节点</li>\\n<li>返回更新的element</li>\\n</ul>\\n<p>思维导图(整体)：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.hyperapp/hyperapp%E5%AF%BC%E5%9B%BE.jpg\\" alt=\\"\\"></p>\\n<p>思维导图(patch)：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.hyperapp/hyperapp-patch%E5%AF%BC%E5%9B%BE.png\\" alt=\\"\\"></p>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.hyperapp/src/hyperapp.js\\">具体源码</a></p>\\n","toc":[{"anchor":"source-codehyperapp","level":1,"text":"source-code.hyperapp"}],"relatedTags":["源码","diff","react"],"created_at":"2018-07-15","timeArr":[2018,6,15,16,20,8,0],"title":"源码阅读-hyperapp","uuid":"b9a6aca4245dad7a679816c10e50173b0357ef2e","summary":"<h4>source-code.hyperapp</h4>\\n<p>v1.2.6</p>\\n<p>一个极小的(1kb)类react框架，实现了virtual-dom，diff比较(需要key)，数据绑定到actions上，通过actions改变数据，会自动更新页面</p>\\n<p>主要步骤：</p>\\n<ul>\\n<li>通过app()对其参数进行处理</li>\\n<li>克隆state（不在原state上...</li>\\n</ul>","slug":"source-code-hyperapp","sha":"c3e25401738f99932f31b1c1cb759018ab90d901"}')},693:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"source-codejquery-mousewheel\\">source-code.jquery-mousewheel</h1>\\n<p>v3.1.13</p>\\n<p>阅读<a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.jquery-mousewheel/src/JQmousewheel.js\\">jquery-mousewheel源码</a></p>\\n","toc":[{"anchor":"source-codejquery-mousewheel","level":1,"text":"source-code.jquery-mousewheel"}],"relatedTags":["源码"],"created_at":"2018-07-15","timeArr":[2018,6,15,16,20,8,0],"title":"源码阅读-jquery-mousewheel","uuid":"3e19d01000962a53236a4d75fa6088929fb906b0","summary":"<h4>source-code.jquery-mousewheel</h4>\\n<p>v3.1.13</p>\\n<p>阅读[jquery-mousewheel源码](https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.jquery-mousewheel/src/...</p>","slug":"source-code-jquery-mousewheel","sha":"e2e6ecfafb5dc2261961975823daf66d3005fa91"}')},694:function(n){n.exports=JSON.parse('{"content":"<p>一个简单的图片延迟加载</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.lazyestload/lazyestload.png\\" alt=\\"\\"></p>\\n","toc":[],"relatedTags":["源码"],"created_at":"2018-09-02","timeArr":[2018,8,2,16,59,32,0],"title":"源码阅读-lazyestload","uuid":"994f8990aab0296dacd6b9d0e6a892f4c81d24b0","summary":"<p>一个简单的图片延迟加载</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.lazyestload/lazyestload.png\\" alt=\\"\\">...</p>","slug":"source-code-lazyestload","sha":"95431918e3ec508fbccff663e21e575930976d60"}')},695:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"lodash--yuan-ma-zhu-shi\\">Lodash 源码注释</h2>\\n","toc":[{"anchor":"lodash--yuan-ma-zhu-shi","level":2,"text":"Lodash 源码注释"}],"relatedTags":["源码"],"created_at":"2018-08-14","timeArr":[2018,7,14,23,14,50,0],"title":"源码阅读-lodash","uuid":"4902ccf3b4127bfc210513e3529617f88f760b4d","summary":"<h4>Lodash 源码注释...</h4>","slug":"source-code-lodash","sha":"dd07adcdb7946319494cf5b107890fa70800d860"}')},696:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p>pubsub-js: 一个用 JavaScript 编写的<code>基于主题</code>的发布/订阅库</p>\\n</blockquote>\\n<hr>\\n<p><code>pubsub-js</code>代码量不大，代码逻辑也较简单，也确实完成了一个发布订阅库，基于<code>javascript</code>的<code>key:value</code>普通对象。</p>\\n<p>代码结构</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>messages={\\n   <span class=\\"hljs-attr\\">topic1</span>:{\\n        <span class=\\"hljs-attr\\">token1_1</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n        <span class=\\"hljs-attr\\">token1_2</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n    }, \\n   <span class=\\"hljs-attr\\">topic2</span>:{\\n        <span class=\\"hljs-attr\\">token2_1</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n        <span class=\\"hljs-attr\\">token2_2</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n        ...\\n    }, \\n    ...\\n}</code></pre>\\n</code></pre>\\n<p>这个<code>基于主题</code>结构，允许对同一个主题进行多次不同的订阅，因此每次订阅会返回一个<code>token</code>可以通过<code>unsubscribe</code>对\\n<code>token</code>取消订阅，</p>\\n<p><code>unsubscribe</code>也接收<code>topic</code>(主题的名称)，对当前主题下所有<code>token</code>取消订阅，也接收<code>function</code>，删除所有与参数一致的订阅函数。</p>\\n<p>同时<code>pubsub-js</code>也提供了层级订阅，通过<code>.</code>进行分级，例如当订阅了<code>a</code>和<code>a.b</code>时，发布<code>a.b</code>同时也会触发<code>a</code>的订阅，而通配符<code>*</code>则表示任何发布都将触发它的订阅。</p>\\n<blockquote>\\n<p><strong>注意：<code>pubsub-js</code>是一个简单的发布订阅库，并不能解决真正的异步问题。</strong></p>\\n</blockquote>\\n<hr>\\n<p>思维导图：\\n<img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.pubsub-js/PubSub.png\\" alt=\\"\\"></p>\\n","toc":[],"relatedTags":["源码"],"created_at":"2021-07-04","timeArr":[2021,6,4,12,35,31,0],"title":"源码阅读-pubsub-js","uuid":"24fa8b0bfed56ded378d93d387506bfc37b3b319","summary":"<p>pubsub-js: 一个用 JavaScript 编写的<code>基于主题</code>的发布/订阅库</p>","slug":"source-code-pubsub-js","sha":"b27fe9696b30d036d66f5bba75e75dde8bc13449"}')},697:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"source-codereach-router\\">source-code.reach-router</h1>\\n<p>v1.1.1</p>\\n<h2 id=\\"chu-shi\\">初识</h2>\\n<p>一张导图：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.reach-router/reachRouter.png\\" alt=\\"\\"></p>\\n<p>对几个亮点进行说明：</p>\\n<ul>\\n<li>匹配顺序</li>\\n</ul>\\n<p>源码中是使用了一个评分的方法：</p>\\n<ol>\\n<li>先对路径去除头尾的<code>/</code> ，并且按<code>/</code>分割成路径片段数组</li>\\n<li>对数组使用reduce方法计算分值，如下：<pre><code><pre class=\\"hljs\\"><code>let SEGMENT_POINTS = 4;     // 基本分值，每一个路径片段都有\\nlet STATIC_POINTS = 3;      // 静态路径，如：/abc\\nlet DYNAMIC_POINTS = 2;     // 动态路径，如：/:section\\nlet SPLAT_PENALTY = 1;      // 通配符（减分），如：/*，此处遇到通配符会先减去基本分值，再减1分（优先权很低）\\nlet ROOT_POINTS = 1;        // 根路径</code></pre>\\n</code></pre>\\n可知优先权排序为：</li>\\n</ol>\\n<p>静态路径 &gt; 动态路径 &gt; 根路径 &gt; 通配符</p>\\n<ul>\\n<li>相对路径</li>\\n</ul>\\n<p>涉及到3个方法：</p>\\n<p><code>./index.js--&gt;createRoute</code></p>\\n<p><code>./lib/utils.js--&gt;resolve</code></p>\\n<p><code>./lib/util.js--&gt;pick</code></p>\\n<p>首先是通过<code>basepath</code>(一个Router自定义属性，用作路径的公共前缀)结合每一个children(即Route Component)的path通过<code>createRoute</code>方法计算出一个绝对路径</p>\\n<p>再通过<code>pick</code>方法与当前<code>pathname</code>(即window.location.pathname)进行匹配，计算得出一个非通配(*)路径匹配值(baseuri)，<code>例如：&#39;a/*&#39; --&gt;匹配出 basuri:&#39;/a&#39;</code></p>\\n<p>这个baseuri会作为<code>BaseContext</code>(React.createContext)的context传递给内部组件，最后使用<code>resolve</code>方法对Link上的to的路径(可能是绝对路径，也可能是相对路径)搭配<code>baseuri</code>进行解析(转换成绝对路径)，并且跳转</p>\\n<ul>\\n<li>自动focus</li>\\n</ul>\\n<p>对屏幕阅读器特别友好，每次通过Link跳转后，会自动focus到当前跳转对应的Component，也就是不需要再通过大量的tab按钮去寻找内容页面</p>\\n<h2 id=\\"shen-ru\\">深入</h2>\\n<p>首先看源码最后，输出了什么：</p>\\n<pre><code><pre class=\\"hljs\\"><code>export {\\n  Link,\\n  Location,\\n  LocationProvider,\\n  Match,\\n  Redirect,\\n  Router,\\n  ServerLocation,\\n  createHistory,\\n  createMemorySource,\\n  isRedirect,\\n  navigate,\\n  redirectTo\\n};</code></pre>\\n</code></pre>\\n<p>而这些输出的组件有些是方法，有些是组件，它们的构造基本围绕着3个context，就是导图中的蓝，绿，红</p>\\n<p>关于React中Provider和Consumer的2个特性：</p>\\n<ol>\\n<li>Consumer会获取离它最近的父元素Provider的context</li>\\n<li>每当Provider内部value改变，其内部的Consumer都会被重新渲染</li>\\n</ol>\\n<p>源码中对context结构的书写，都是Consumer包裹Provider，这就能形成：\\n<code>最外层无context(无defaultValue的情况)，而嵌套层能获取上一层的Provider</code></p>\\n<p>因此对这3个context分析：</p>\\n<ul>\\n<li>BaseContext</li>\\n</ul>\\n<p>context有默认值 &quot;/&quot;：</p>\\n<p><code>basepath       //公共前缀路径，自定义</code></p>\\n<p><code>baseuri        //非通配匹配路径，自动对路径匹配计算得出</code></p>\\n<p>只有Router包含BaseContext.Provider(在<code>RouterImpl</code>中渲染)</p>\\n<p><code>RouterImpl</code>对每一个children(Route Component)进行当前<code>location</code>路径匹配，匹配成功的路径作为<code>BaseContext</code>的context，\\n如果children内部还有children，会使用一个新的<code>Router --&gt;primary=true</code>包裹内部的children</p>\\n<p>因此只有被Router包裹的内部的标签才能获取到context值（当前的动态的basepath和baseuri）</p>\\n<p>而Router外部的标签或者Router本身则为默认值&quot;/&quot;</p>\\n<ul>\\n<li>LocationContext</li>\\n</ul>\\n<p>context无默认值</p>\\n<p><code>location       //pushState的&quot;state&quot;，&quot;key&quot;(时间戳)，window.location的&quot;pathname&quot;和&quot;search&quot;</code></p>\\n<p><code>navigate        //一个跳转方法，默认使用pushState，每次跳转都会自动更新location</code></p>\\n<p>首次渲染会加载<code>LocationProvider</code>，后续加载会直接调用<code>children(contnext)</code>，</p>\\n<p>而<code>LocationProvider</code>通过history的listen方法绑定了每次调用navigate都会更新location，返回值是<code>Provider</code>，传递了location和navigate给context</p>\\n<p>由于首次渲染是Router组件，Router中context为undefined，但它加载<code>LocationProvider</code>计算出context，\\n后续渲染的组件则能获取到<code>Provider</code>的context</p>\\n<ul>\\n<li>FocusContext</li>\\n</ul>\\n<p>context无默认值</p>\\n<p><code>requestFocus       // 是否需要自动获取焦点</code></p>\\n<p>在<code>BaseContext.Provider</code>内部渲染，而且要检查Router组件的<code>primary</code>属性是否为true，<code>primary</code>为true会渲染<code>FocusHandler</code>，否则默认渲染div</p>\\n<p><code>FocusHandler</code>内部就是Consumer包裹<code>FocusHandlerImpl</code>，通过pathname和uri进行判定，满足2个条件确定当前组件的<code>shouldFocus</code>属性为true：</p>\\n<ol>\\n<li>url路径有变动</li>\\n<li>不为通配符(*)匹配路径，可以是动态匹配(:section)</li>\\n</ol>\\n<p>当<code>shouldFocus</code>为true，便可通过context(即requestFocus)进行获取焦点，这里this.node就是这个<code>FocusHandlerImpl</code>返回值(div)的ref</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">if</span> (requestFocus) {\\n      requestFocus(<span class=\\"hljs-keyword\\">this</span>.node);\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n    }</code></pre>\\n</code></pre>\\n<p>再看<code>requestFocus</code>内部：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>requestFocus = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">node</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 内部判断shouldFocus要为false</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>.state.shouldFocus) {\\n      node.focus();\\n    }\\n  };</code></pre>\\n</code></pre>\\n<p>内部判断<code>shouldFocus</code>要为false又是怎么回事呢？</p>\\n<p>注意，此处的this是箭头函数静态绑定，也就是通过context传过来时的this，也就是父级FocusHandlerImpl的this</p>\\n<p>而当子级的uri变化时，父级的uri是不变的（如果在同一个父级下），因此父级的<code>shouldFocus</code>是false，触发子级dom的focus</p>\\n<p>如果不在同一个父级下，例如从父级a的子级a1, 直接跳转到父级b的子级b1，那么父级uri不同，父级的<code>shouldFocus</code>为true，不触发子级dom的focus</p>\\n<p>而再去判断父级的父级的uri是否相等，当判断相同，父级的父级的<code>shouldFocus</code>为false，因此会触发父级(b)dom的focus</p>\\n<p>见动图：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.reach-router/reachRouter-Focus.gif\\" alt=\\"\\"></p>\\n<p><a href=\\"https://codesandbox.io/s/lpv0165m1q\\">例子源码</a></p>\\n<hr>\\n<ul>\\n<li>history</li>\\n</ul>\\n<p>其实大部分方法和组件都贯穿于上面3个context中，另还有一个history.js主要做了以下事情：</p>\\n<ol>\\n<li>判断当前平台，如果非浏览器，则模拟一个history对象，</li>\\n<li>新建一个location方法，里面有pathname，search，state(pushState的参数1),key(跳转的时间戳)</li>\\n<li>创建一个navigate方法，用于跳转，内部默认使用pushState和replaceState，会自动更新上面location对象</li>\\n<li>export</li>\\n</ol>\\n<h2 id=\\"liu-cheng\\">流程</h2>\\n<p>当点击Link---&gt;调用navigate---&gt;内部调用pushState---&gt;更新当前location---&gt;Router会更新context为最新的location\\n---&gt;Router中将children的路径与当前pathname匹配---&gt;匹配成功的进行配置props和渲染</p>\\n","toc":[{"anchor":"source-codereach-router","level":1,"text":"source-code.reach-router"},{"anchor":"chu-shi","level":2,"text":"初识"},{"anchor":"shen-ru","level":2,"text":"深入"},{"anchor":"liu-cheng","level":2,"text":"流程"}],"relatedTags":["源码","router","react"],"created_at":"2018-07-15","timeArr":[2018,6,15,16,20,8,0],"title":"源码阅读-reach-router","uuid":"d4c20e9d6e2481885bd702b49e92a75e20ff8bef","summary":"<h4>source-code.reach-router</h4>\\n<p>v1.1.1</p>\\n<h4>初识</h4>\\n<p>一张导图：</p>\\n<p>![](https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.reach-router/reachRouter...</p>","slug":"source-code-reach-router","sha":"60c69717e8096ec7bcc17c42915f3fb679f32077"}')},698:function(n){n.exports=JSON.parse('{"content":"<p><code>react-infinite-scroller</code>就是一个组件，主要逻辑就是<code>addEventListener</code>绑定<code>scroll</code>事件。</p>\\n<p>看它的源码主要意义不在知道如何使用它，而是知道以后处理<code>滚动加载</code>要注意的东西。</p>\\n<blockquote>\\n<p>此处跳到<a href=\\"#zong-jie\\">总结</a>。</p>\\n</blockquote>\\n<h2 id=\\"chu-shi\\">初识</h2>\\n<p>参数：</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 渲染出来的DOM元素name\\nelement: \'div\',\\n// 是否能继续滚动渲染\\nhasMore: false,\\n// 是否在订阅事件的时候执行事件\\ninitialLoad: true,\\n// 表示当前翻页的值(每渲染一次递增)\\npageStart: 0,\\n// 传递ref，返回此组件渲染的 DOM\\nref: null,\\n// 触发渲染的距离\\nthreshold: 250,\\n// 是否在window上绑定和处理距离\\nuseWindow: true,\\n// 是否反向滚动，即到顶端后渲染\\nisReverse: false,\\n// 是否使用捕获模式\\nuseCapture: false,\\n// 渲染前的loading组件\\nloader: null,\\n// 自定义滚动组件的父元素\\ngetScrollParent: null,</code></pre>\\n</code></pre>\\n<hr>\\n<h2 id=\\"shen-ru\\">深入</h2>\\n<h3 id=\\"componentdidmount\\">componentDidMount</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>componentDidMount() {\\n  <span class=\\"hljs-keyword\\">this</span>.pageLoaded = <span class=\\"hljs-keyword\\">this</span>.props.pageStart;\\n  <span class=\\"hljs-keyword\\">this</span>.attachScrollListener();\\n}</code></pre>\\n</code></pre>\\n<p>执行<code>attachScrollListener</code></p>\\n<hr>\\n<h3 id=\\"attachscrolllistener\\">attachScrollListener</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>attachScrollListener() {\\n  <span class=\\"hljs-keyword\\">const</span> parentElement = <span class=\\"hljs-keyword\\">this</span>.getParentElement(<span class=\\"hljs-keyword\\">this</span>.scrollComponent);\\n  \\n  <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>.props.hasMore || !parentElement) {\\n    <span class=\\"hljs-keyword\\">return</span>;\\n  }\\n\\n  <span class=\\"hljs-keyword\\">let</span> scrollEl = <span class=\\"hljs-built_in\\">window</span>;\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.props.useWindow === <span class=\\"hljs-literal\\">false</span>) {\\n    scrollEl = parentElement;\\n  }\\n  scrollEl.addEventListener(\\n    <span class=\\"hljs-string\\">\'mousewheel\'</span>,\\n    <span class=\\"hljs-keyword\\">this</span>.mousewheelListener,\\n    <span class=\\"hljs-keyword\\">this</span>.props.useCapture,\\n  );\\n  scrollEl.addEventListener(\\n    <span class=\\"hljs-string\\">\'scroll\'</span>,\\n    <span class=\\"hljs-keyword\\">this</span>.scrollListener,\\n    <span class=\\"hljs-keyword\\">this</span>.props.useCapture,\\n  );\\n  scrollEl.addEventListener(\\n    <span class=\\"hljs-string\\">\'resize\'</span>,\\n    <span class=\\"hljs-keyword\\">this</span>.scrollListener,\\n    <span class=\\"hljs-keyword\\">this</span>.props.useCapture,\\n  );\\n  \\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.props.initialLoad) {\\n    <span class=\\"hljs-keyword\\">this</span>.scrollListener();\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>此处通过<code>getParentElement</code>获取父组件(用户自定义父组件或者当前dom的parentNode)</p>\\n<p>然后绑定了3个事件，分别是<code>scroll</code>,<code>resize</code>,<code>mousewheel</code></p>\\n<p>前2种都绑定<code>scrollListener</code>，<code>mousewheel</code>是一个非标准事件，是不建议在生产模式中使用的。</p>\\n<p>那么这里为什么要使用呢？</p>\\n<hr>\\n<h3 id=\\"mousewheel-jie-jue-chrome-de-deng-dai-bug\\">mousewheel解决chrome的等待bug</h3>\\n<p>此处的<code>mousewheel</code>事件是为了处理<code>chrome</code>浏览器的一个特性(不知道是否是一种bug)。</p>\\n<p><a href=\\"https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\\">stackoverflow:Chrome的滚动等待问题</a></p>\\n<p>上面这个问题主要描述，当在使用滚轮加载时，而且加载会触发<code>ajax请求</code>，当滚轮到达底部，会出现一个漫长而且无任何动作的等待(长达2-3s)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-built_in\\">window</span>.addEventListener(<span class=\\"hljs-string\\">\\"mousewheel\\"</span>, (e) =&gt; {\\n    <span class=\\"hljs-keyword\\">if</span> (e.deltaY === <span class=\\"hljs-number\\">1</span>) {\\n        e.preventDefault()\\n    }\\n})</code></pre>\\n</code></pre>\\n<p>以上绑定可以消除这个&quot;bug&quot;。</p>\\n<blockquote>\\n<p>个人并没有遇到过这种情况，不知道是否有遇到过可以说说解决方案。</p>\\n</blockquote>\\n<hr>\\n<h3 id=\\"getparentelement\\">getParentElement</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>getParentElement(el) {\\n  <span class=\\"hljs-keyword\\">const</span> scrollParent =\\n    <span class=\\"hljs-keyword\\">this</span>.props.getScrollParent &amp;&amp; <span class=\\"hljs-keyword\\">this</span>.props.getScrollParent();\\n  <span class=\\"hljs-keyword\\">if</span> (scrollParent != <span class=\\"hljs-literal\\">null</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> scrollParent;\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> el &amp;&amp; el.parentNode;\\n}</code></pre>\\n</code></pre>\\n<p>上面用到了<code>getParentElement</code>，很好理解，使用用户自定义的父组件，或者当前组件<code>DOM.parentNode</code>。</p>\\n<hr>\\n<h3 id=\\"scrolllistener\\">scrollListener</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>scrollListener() {\\n  <span class=\\"hljs-keyword\\">const</span> el = <span class=\\"hljs-keyword\\">this</span>.scrollComponent;\\n  <span class=\\"hljs-keyword\\">const</span> scrollEl = <span class=\\"hljs-built_in\\">window</span>;\\n  <span class=\\"hljs-keyword\\">const</span> parentNode = <span class=\\"hljs-keyword\\">this</span>.getParentElement(el);\\n\\n  <span class=\\"hljs-keyword\\">let</span> offset;\\n  <span class=\\"hljs-comment\\">// 使用window的情况</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.props.useWindow) {\\n    <span class=\\"hljs-keyword\\">const</span> doc = <span class=\\"hljs-built_in\\">document</span>.documentElement || <span class=\\"hljs-built_in\\">document</span>.body.parentNode || <span class=\\"hljs-built_in\\">document</span>.body;\\n    <span class=\\"hljs-keyword\\">const</span> scrollTop = scrollEl.pageYOffset !== <span class=\\"hljs-literal\\">undefined</span>\\n        ? scrollEl.pageYOffset\\n        : doc.scrollTop;\\n    <span class=\\"hljs-comment\\">// isReverse指 滚动到顶端，load新组件</span>\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.props.isReverse) {\\n      <span class=\\"hljs-comment\\">// 相反模式获取到顶端距离</span>\\n      offset = scrollTop;\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 正常模式则获取到底端距离</span>\\n      offset = <span class=\\"hljs-keyword\\">this</span>.calculateOffset(el, scrollTop);\\n    }\\n    <span class=\\"hljs-comment\\">// 不使用window的情况</span>\\n  } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.props.isReverse) {\\n    <span class=\\"hljs-comment\\">// 相反模式组件到顶端的距离</span>\\n    offset = parentNode.scrollTop;\\n  } <span class=\\"hljs-keyword\\">else</span> {\\n    <span class=\\"hljs-comment\\">// 正常模式组件到底端的距离</span>\\n    offset = el.scrollHeight - parentNode.scrollTop - parentNode.clientHeight;\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 此处应该要判断确保滚动组件正常显示</span>\\n  <span class=\\"hljs-keyword\\">if</span> (\\n    offset &lt; <span class=\\"hljs-built_in\\">Number</span>(<span class=\\"hljs-keyword\\">this</span>.props.threshold) &amp;&amp;\\n    (el &amp;&amp; el.offsetParent !== <span class=\\"hljs-literal\\">null</span>)\\n  ) {\\n    <span class=\\"hljs-comment\\">// 卸载事件</span>\\n    <span class=\\"hljs-keyword\\">this</span>.detachScrollListener();\\n    <span class=\\"hljs-comment\\">// 卸载事件后再执行 loadMore</span>\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> <span class=\\"hljs-keyword\\">this</span>.props.loadMore === <span class=\\"hljs-string\\">\'function\'</span>) {\\n      <span class=\\"hljs-keyword\\">this</span>.props.loadMore((<span class=\\"hljs-keyword\\">this</span>.pageLoaded += <span class=\\"hljs-number\\">1</span>));\\n    }\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>组件核心。</p>\\n<h3 id=\\"ji-ge-xue-xi-fu-xi-dian\\">几个学习/复习点</h3>\\n<ol>\\n<li><p><code>offsetParent</code></p>\\n<p> <code>offsetParent</code>返回一个指向最近的包含该元素的定位元素.</p>\\n<p> <code>offsetParent</code>很有用，因为计算<code>offsetTop</code>和<code>offsetLeft</code>都是相对于<code>offsetParent</code>边界的。</p>\\n<p> <code>offsetParent</code>为 null 的几种情况:</p>\\n<ul>\\n<li>ele 为 body</li>\\n<li>ele 的 position 为 fixed</li>\\n<li>ele 的 display 为 none</li>\\n</ul>\\n<p> 此组件中<code>offsetParent</code>处理了2种情况</p>\\n<ol>\\n<li>在<code>useWindow</code>的情况下(即事件绑定在window，滚动作用在body) 通过递归获取<code>offsetParent</code>到达顶端的高度(<code>offsetTop</code>)。<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>calculateTopPosition(el) {\\n <span class=\\"hljs-keyword\\">if</span> (!el) {\\n   <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;   \\n }\\n <span class=\\"hljs-keyword\\">return</span> el.offsetTop + <span class=\\"hljs-keyword\\">this</span>.calculateTopPosition(el.offsetParent);   \\n}</code></pre>\\n</code></pre>\\n</li>\\n<li>通过判断<code>offsetParent</code>不为null的情况，确保滚动组件正常显示</li>\\n</ol>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">if</span> (\\n    offset &lt; <span class=\\"hljs-built_in\\">Number</span>(<span class=\\"hljs-keyword\\">this</span>.props.threshold) &amp;&amp;\\n    (el &amp;&amp; el.offsetParent !== <span class=\\"hljs-literal\\">null</span>)\\n  ) {<span class=\\"hljs-comment\\">/* ... */</span> }</code></pre>\\n</code></pre>\\n</li>\\n<li><p><code>scrollHeight</code>和<code>clientHeight</code></p>\\n<p> 在无滚动的情况下，<code>scrollHeight</code>和<code>clientHeight</code>相等，都为<code>height</code>+<code>padding</code>*2</p>\\n<p> 在有滚动的情况下，<code>scrollHeight</code>表示实际内容高度，<code>clientHeight</code>表示视口高度。</p>\\n</li>\\n<li><p>每次执行<code>loadMore</code>前卸载事件。</p>\\n<p> 确保不会重复(过多)执行<code>loadMore</code>，因为先卸载事件再执行<code>loadMore</code>，可以确保在执行过程中，<code>scroll</code>事件是无效的，然后再每次<code>componentDidUpdate</code>的时候重新绑定事件。</p>\\n</li>\\n</ol>\\n<h3 id=\\"render\\">render</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>render() {\\n  <span class=\\"hljs-comment\\">// 获取porps</span>\\n  <span class=\\"hljs-keyword\\">const</span> renderProps = <span class=\\"hljs-keyword\\">this</span>.filterProps(<span class=\\"hljs-keyword\\">this</span>.props);\\n  <span class=\\"hljs-keyword\\">const</span> {\\n    children,\\n    element,\\n    hasMore,\\n    initialLoad,\\n    isReverse,\\n    loader,\\n    loadMore,\\n    pageStart,\\n    ref,\\n    threshold,\\n    useCapture,\\n    useWindow,\\n    getScrollParent,\\n    ...props\\n  } = renderProps;\\n\\n  <span class=\\"hljs-comment\\">// 定义一个ref</span>\\n  <span class=\\"hljs-comment\\">// 能将当前组件的DOM传出去</span>\\n  props.ref = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">node</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">this</span>.scrollComponent = node;\\n    <span class=\\"hljs-comment\\">// 执行父组件传来的ref(如果有)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (ref) {\\n      ref(node);\\n    }\\n  };\\n\\n  <span class=\\"hljs-keyword\\">const</span> childrenArray = [children];\\n  <span class=\\"hljs-comment\\">// 执行loader</span>\\n  <span class=\\"hljs-keyword\\">if</span> (hasMore) {\\n    <span class=\\"hljs-keyword\\">if</span> (loader) {\\n      isReverse ? childrenArray.unshift(loader) : childrenArray.push(loader);\\n    } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.defaultLoader) {\\n      isReverse\\n        ? childrenArray.unshift(<span class=\\"hljs-keyword\\">this</span>.defaultLoader)\\n        : childrenArray.push(<span class=\\"hljs-keyword\\">this</span>.defaultLoader);\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// ref 传递给 \'div\'元素</span>\\n  <span class=\\"hljs-keyword\\">return</span> React.createElement(element, props, childrenArray);\\n}</code></pre>\\n</code></pre>\\n<p>这里一个小亮点就是，在<code>react</code>中，<code>this.props</code>是不允许修改的。</p>\\n<p>这里使用了解构</p>\\n<pre><code><pre class=\\"hljs\\"><code>getScrollParent,\\n...props\\n} = renderProps;</code></pre>\\n</code></pre>\\n<p>这里解构相当于<code>Object.assign</code>，定义了一个新的<code>object</code>，便可以添加属性了，并且<code>this.props</code>不会受到影响。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p><code>react-infinite-scroller</code>逻辑比较简单。</p>\\n<p>一些注意/学习/复习点：</p>\\n<ul>\\n<li><p><code>Chrome</code>的一个滚动加载请求的bug。<a href=\\"#mousewheel-jie-jue-chrome-de-deng-dai-bug\\">本文位置</a></p>\\n</li>\\n<li><p><code>offsetParent</code>的一些实际用法。<a href=\\"#ji-ge-xue-xi-fu-xi-dian\\">本文位置</a></p>\\n</li>\\n<li><p>通过不断订阅和取消事件绑定让滚动执行函数不会频繁触发。<a href=\\"#ji-ge-xue-xi-fu-xi-dian\\">本文位置</a></p>\\n</li>\\n<li><p><code>scrollHeight</code>和<code>clientHeight</code>区别。<a href=\\"#ji-ge-xue-xi-fu-xi-dian\\">本文位置</a></p>\\n</li>\\n</ul>\\n<p>此库建议使用在自定义的一些组件上并且不那么复杂的逻辑上。</p>\\n<p>用在第三方库可以会无法获取正确的父组件，而通过<code>document.getElementBy..</code>传入。</p>\\n<p>面对稍微复杂的逻辑，</p>\\n<p>例如，一个搜索组件，订阅<code>onChange</code>事件显示内容，搜索&quot;a&quot;，呈现内容，滚动加载了3次，再添加搜索词&quot;b&quot;，这时候&quot;ab&quot;的内容呈现是在3次之后。</p>\\n","toc":[{"anchor":"chu-shi","level":2,"text":"初识"},{"anchor":"shen-ru","level":2,"text":"深入"},{"anchor":"componentdidmount","level":3,"text":"componentDidMount"},{"anchor":"attachscrolllistener","level":3,"text":"attachScrollListener"},{"anchor":"mousewheel-jie-jue-chrome-de-deng-dai-bug","level":3,"text":"mousewheel解决chrome的等待bug"},{"anchor":"getparentelement","level":3,"text":"getParentElement"},{"anchor":"scrolllistener","level":3,"text":"scrollListener"},{"anchor":"ji-ge-xue-xi-fu-xi-dian","level":3,"text":"几个学习/复习点"},{"anchor":"render","level":3,"text":"render"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":["源码","react"],"created_at":"2018-11-25","timeArr":[2018,10,25,23,37,53,0],"title":"源码阅读-react-infinite-scroller","uuid":"7cbb6144b6cfb573e0e828cb0d5cbe5e805fe1d9","summary":"<p><code>react-infinite-scroller</code>就是一个组件，主要逻辑就是<code>addEventListener</code>绑定<code>scroll</code>事件。</p>\\n<p>看它的源码主要意义不在知道如何使用它，而是知道以后处理<code>滚动加载</code>要注意的东西。</p>\\n<blockquote>\\n<p>此处跳到<a href=\\"#zong-jie\\">总结</a>。</p>\\n</blockquote>\\n<h4>初识</h4>\\n<p>参数：</p>\\n<pre class=\\"hljs\\"><code>// 渲染出来的...</code></pre>","slug":"source-code-react-infinite-scroller","sha":"5aba2eaf43528ba166b972e6b13b0b43de1c816c"}')},699:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"jie-shao\\">介绍</h3>\\n<p><a href=\\"https://github.com/jamiebuilds/react-loadable\\">react-loadable</a>是一个组件延迟加载的工具，\\n它本身也是一个组件，通过<code>HOC</code>的方式对参数组件进行处理，\\n具体的延迟加载方式是使用<code>import().then()</code>方法，那么为什么要用这个组件呢？</p>\\n<h3 id=\\"chu-shi\\">初识</h3>\\n<p><code>react-loadable</code>针对多种情况进行抽象处理，例如延迟加载失败，多个延迟加载的逻辑和服务端渲染使用延迟加载...</p>\\n<p>当这些情况整合起来后，我们只需要简单的API即可处理每个情况对应的组件。</p>\\n<p>它对外暴露的API有</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 基本的延迟加载处理\\nLoadable\\n// 多个延迟加载处理\\nLoadable.Map\\n// Loadable或Loadable.Map的返回值\\nLoadableComponent\\n// 预加载\\nLoadableComponent.preLoad\\n// 全部预加载\\nLoadable.preloadAll\\n// 对已经加载完毕的组件处理\\nLoadable.preloadReady\\n// 服务端渲染使用\\nLoadable.Capture</code></pre>\\n</code></pre>\\n<p>Loadable和Loadable.Map还可加入一些options参数，作用如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 延迟加载组件\\nloader: null,\\n// loading组件\\nloading: null,\\n// 加载组件时等待多少时间才开始渲染Loading\\ndelay: 200,\\n// 超时时间\\ntimeout: null,\\n// 对已加载的组件渲染方法\\nrender: render,\\n\\n/* 以下2个是服务端渲染使用 */\\n\\n// 函数，执行后会获取当前延迟加载模块\\n// 这里用途是判断模块是否已经可用，作用于 preLoadReady 上\\nwebpack: null,\\n// 函数，执行后会获取当前import的路径，作为moduleId\\n// 这里用途是通过getBundles将moduleId转换成bundles\\nmodules: null</code></pre>\\n</code></pre>\\n<h3 id=\\"shen-ru\\">深入</h3>\\n<h4 id=\\"loadable\\">Loadable</h4>\\n<p>客户端的单个延迟加载组件</p>\\n<p>当开始载入<code>Loadable</code>组件，会返回<code>LoadableComponent</code>组件，这个组件在生命周期中的<code>constructor</code>下会执行<code>init</code>方法。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">LoadableComponent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n    <span class=\\"hljs-keyword\\">constructor</span>(props) {\\n      <span class=\\"hljs-keyword\\">super</span>(props);\\n      init();\\n\\n  <span class=\\"hljs-comment\\">/* ... */</span></code></pre>\\n</code></pre>\\n<p>这个<code>init</code>方法会执行<code>loadFn(opts.loader)</code>，而这个<code>loadFn</code>会首先会执行<code>参数loader(也就是import(...))</code>，并且将根据<code>执行结果(then或者catch)</code>对3个状态<code>loading</code>,<code>loaded</code>,<code>error</code>进行更新，\\n返回一个包含所有状态和import执行结果的对象；</p>\\n<p>init：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">init</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (!res) {\\n    <span class=\\"hljs-comment\\">// loadFn就是load</span>\\n    <span class=\\"hljs-comment\\">// 这里opts.loader就是组件的延迟加载函数，例如：()=&gt;import(./xxx)</span>\\n    res = loadFn(opts.loader);\\n  }\\n  <span class=\\"hljs-comment\\">// 返回延迟加载的component</span>\\n  <span class=\\"hljs-keyword\\">return</span> res.promise;\\n}</code></pre>\\n</code></pre>\\n<p>loadFn：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">load</span>(<span class=\\"hljs-params\\">loader</span>) </span>{\\n  <span class=\\"hljs-comment\\">// promise保存了延迟加载组件执行的返回值(thenable)</span>\\n  <span class=\\"hljs-keyword\\">let</span> promise = loader();\\n  <span class=\\"hljs-comment\\">// 状态数据</span>\\n  <span class=\\"hljs-keyword\\">let</span> state = {\\n    <span class=\\"hljs-attr\\">loading</span>: <span class=\\"hljs-literal\\">true</span>,\\n    <span class=\\"hljs-attr\\">loaded</span>: <span class=\\"hljs-literal\\">null</span>,\\n    <span class=\\"hljs-attr\\">error</span>: <span class=\\"hljs-literal\\">null</span>\\n  };\\n  <span class=\\"hljs-comment\\">// state.promise是一个Promise的处理返回值</span>\\n  <span class=\\"hljs-comment\\">// 此处根据promise的返回值，更新状态数据</span>\\n  state.promise = promise\\n    .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">loaded</span> =&gt;</span> {\\n      state.loading = <span class=\\"hljs-literal\\">false</span>;\\n      state.loaded = loaded;\\n      <span class=\\"hljs-keyword\\">return</span> loaded;\\n    })\\n    .catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n      state.loading = <span class=\\"hljs-literal\\">false</span>;\\n      state.error = err;\\n      <span class=\\"hljs-keyword\\">throw</span> err;\\n    });\\n\\n  <span class=\\"hljs-comment\\">// state是一个obj，保存了状态和延迟加载组件执行的返回值</span>\\n  <span class=\\"hljs-keyword\\">return</span> state;\\n}</code></pre>\\n</code></pre>\\n<p>接着在<code>componentWillMount</code>下调用了<code>this._loadModule</code>，它会根据<code>options</code>里的参数(例如delay，timeout)对当前状态进行更新，并且继续监听<code>init</code>返回的对象，一旦处理完毕，更新状态。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 载入组件时，根据options加载和更新</span>\\ncomponentWillMount() {\\n  <span class=\\"hljs-keyword\\">this</span>._mounted = <span class=\\"hljs-literal\\">true</span>;\\n  <span class=\\"hljs-keyword\\">this</span>._loadModule();\\n}\\n\\n_loadModule(){\\n  <span class=\\"hljs-comment\\">/* 省略了服务端渲染的处理 */</span> \\n  \\n  <span class=\\"hljs-comment\\">// 延迟加载结束</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!res.loading) {\\n    <span class=\\"hljs-keyword\\">return</span>;\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 默认200ms后更新pastDelay</span>\\n  <span class=\\"hljs-comment\\">// 有时组件加载非常快(&lt;200ms)，这时加载中的样式就会一闪而过</span>\\n  <span class=\\"hljs-comment\\">// 因此可以选择默认隔200ms后才开始渲染loading(避免样式闪动)，这样做是因为能让用户感觉更快</span>\\n  <span class=\\"hljs-comment\\">// https://github.com/jamiebuilds/react-loadable#avoiding-flash-of-loading-component</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> opts.delay === <span class=\\"hljs-string\\">\\"number\\"</span>) {\\n    <span class=\\"hljs-keyword\\">if</span> (opts.delay === <span class=\\"hljs-number\\">0</span>) {\\n      <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">pastDelay</span>: <span class=\\"hljs-literal\\">true</span> });\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-keyword\\">this</span>._delay = setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n        <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">pastDelay</span>: <span class=\\"hljs-literal\\">true</span> });\\n      }, opts.delay);\\n    }\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 判断是否需要更新timeout(用于超时处理)</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> opts.timeout === <span class=\\"hljs-string\\">\\"number\\"</span>) {\\n    <span class=\\"hljs-keyword\\">this</span>._timeout = setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">timedOut</span>: <span class=\\"hljs-literal\\">true</span> });\\n    }, opts.timeout);\\n  }\\n\\n  <span class=\\"hljs-keyword\\">let</span> update = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 当组件未载入或者已经卸载，则返回</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>._mounted) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">this</span>.setState({\\n      <span class=\\"hljs-attr\\">error</span>: res.error,\\n      <span class=\\"hljs-attr\\">loaded</span>: res.loaded,\\n      <span class=\\"hljs-attr\\">loading</span>: res.loading\\n    });\\n\\n    <span class=\\"hljs-keyword\\">this</span>._clearTimeouts();\\n  };\\n\\n  <span class=\\"hljs-comment\\">// res是init()处理后的返回值</span>\\n  <span class=\\"hljs-comment\\">// promise属性对应的是组件延迟加载的返回值</span>\\n  res.promise\\n    .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 加载完毕后，执行update，更新相关状态数据</span>\\n      update();\\n    })\\n    .catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n      update();\\n    });\\n}</code></pre>\\n</code></pre>\\n<p>在<code>render</code>里面则根据当前状态，渲染对应的组件(例如<code>loading</code>或<code>error</code>状态为<code>true</code>，都会调用<code>Loading</code>组件，并且传递props)。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>render() {\\n  <span class=\\"hljs-comment\\">// loading或者error状态为true</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.state.loading || <span class=\\"hljs-keyword\\">this</span>.state.error) {\\n    <span class=\\"hljs-comment\\">// 创建loading组件，第二个参数为props，用于loading渲染的条件</span>\\n    <span class=\\"hljs-comment\\">// loading组件内部根据props定义渲染的内容</span>\\n    <span class=\\"hljs-keyword\\">return</span> React.createElement(opts.loading, {\\n      <span class=\\"hljs-attr\\">isLoading</span>: <span class=\\"hljs-keyword\\">this</span>.state.loading,\\n      <span class=\\"hljs-attr\\">pastDelay</span>: <span class=\\"hljs-keyword\\">this</span>.state.pastDelay,\\n      <span class=\\"hljs-attr\\">timedOut</span>: <span class=\\"hljs-keyword\\">this</span>.state.timedOut,\\n      <span class=\\"hljs-attr\\">error</span>: <span class=\\"hljs-keyword\\">this</span>.state.error,\\n      <span class=\\"hljs-attr\\">retry</span>: <span class=\\"hljs-keyword\\">this</span>.retry\\n    });\\n  } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.state.loaded) {\\n    <span class=\\"hljs-comment\\">// 组件已经加载完毕，渲染延迟加载的组件，render是渲染方法，默认为createElement进行渲染组件</span>\\n    <span class=\\"hljs-keyword\\">return</span> opts.render(<span class=\\"hljs-keyword\\">this</span>.state.loaded, <span class=\\"hljs-keyword\\">this</span>.props);\\n  } <span class=\\"hljs-keyword\\">else</span> {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n  }\\n}\\n\\n <span class=\\"hljs-comment\\">/* 默认的render方法 */</span>\\n\\n<span class=\\"hljs-comment\\">// 兼容babel编译后的组件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">resolve</span>(<span class=\\"hljs-params\\">obj</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> obj &amp;&amp; obj.__esModule ? obj.default : obj;\\n}\\n\\n<span class=\\"hljs-comment\\">// 默认的render函数——创建组件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">render</span>(<span class=\\"hljs-params\\">loaded, props</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> React.createElement(resolve(loaded), props);\\n}</code></pre>\\n</code></pre>\\n<h4 id=\\"loadablemap\\">Loadable.Map</h4>\\n<p>多个延迟加载组件的处理</p>\\n<p>它也是基于单个组件处理的，它的工作逻辑：</p>\\n<p>只要任何一个组件还在加载，整体的<code>loading</code>状态就是<code>true</code>，任意一个组件延迟加载出错，整体的<code>error</code>状态就是<code>true</code>。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 因为遍历并且执行load执行(单个执行)，遇到错误会抛出，因此要try...catch</span>\\n<span class=\\"hljs-keyword\\">try</span> {\\n  <span class=\\"hljs-built_in\\">Object</span>.keys(obj).forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">key</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">let</span> result = load(obj[key]);\\n    <span class=\\"hljs-comment\\">// 第一次判断，目的是改变loading状态</span>\\n    <span class=\\"hljs-comment\\">// 如果某延迟组件加载完毕</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!result.loading) {\\n      <span class=\\"hljs-comment\\">// 对应的loaded为true</span>\\n      <span class=\\"hljs-comment\\">// 整体的loading不变</span>\\n      state.loaded[key] = result.loaded;\\n      <span class=\\"hljs-comment\\">// 任意一个延迟组件有err，整体为err</span>\\n      state.error = result.error;\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 有任意一个延迟组件还在加载，则整体的loading为true</span>\\n      state.loading = <span class=\\"hljs-literal\\">true</span>;\\n    }\\n\\n    <span class=\\"hljs-comment\\">// 处理结果(Promise对象)放进数组</span>\\n    promises.push(result.promise);\\n  \\n    <span class=\\"hljs-comment\\">// 后续then，目的是处理已经加载完毕的组件</span>\\n    result.promise\\n    . then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">res</span> =&gt;</span> {\\n        state.loaded[key] = res;\\n      })\\n    . catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n        state.error = err;\\n      });\\n  });\\n  <span class=\\"hljs-comment\\">// 捕捉load的错误</span>\\n  } <span class=\\"hljs-keyword\\">catch</span> (err) {\\n  state.error = err;\\n}</code></pre>\\n</code></pre>\\n<p>使用了<code>Promise.all()</code>，等待全部完成后，改变<code>整体的loading</code>状态</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 当所有组件加载完毕(每个组件可能成功，也可能失败)</span>\\n<span class=\\"hljs-comment\\">// 整体的loading为false</span>\\n<span class=\\"hljs-comment\\">// 有错误则抛出，否则返回state</span>\\nstate.promise = <span class=\\"hljs-built_in\\">Promise</span>.all(promises)\\n.then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">res</span> =&gt;</span> {\\n  state.loading = <span class=\\"hljs-literal\\">false</span>;\\n  <span class=\\"hljs-keyword\\">return</span> res;\\n})\\n.catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n  state.loading = <span class=\\"hljs-literal\\">false</span>;\\n  <span class=\\"hljs-keyword\\">throw</span> err;\\n});</code></pre>\\n</code></pre>\\n<p>接下来也是<code>render</code>的处理了，跟前面没什么不同。</p>\\n<h4 id=\\"loadablecapture\\">Loadable.Capture</h4>\\n<p>服务端渲染的处理</p>\\n<p>这里要提源码中的<code>webpack.js</code>和<code>babel.js</code>，这里没有具体分析，只是说明它们的用途。</p>\\n<p>一个是webpack插件，作用是创建一个json键值对数据<code>react-loadable.json</code>，包含了每一个modules对应的bundles，\\n并且提供了一个将modulesID转换成bundles的方法<code>getBundles</code>，简单说就是<code>将key转换成value</code></p>\\n<p>另一个是babel插件，作用是自动提供2个参数<code>opts.webpack</code>和<code>opts.modules</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>// 函数，执行后会获取当前延迟加载模块\\n// 这里用途是判断模块是否已经可用，作用于preLoadReady上\\nopts.webpack\\n\\n// 函数，执行后会获取当前import的路径，作为moduleId\\n// 这里用途是通过getBundles将moduleId转换成bundles\\nopts.modules</code></pre>\\n</code></pre>\\n<p>有了上面2个概念，<code>Loadable.Capture</code>做的事情很简单，</p>\\n<p>定义了一个<code>context</code>属性，并且渲染它的唯一子元素</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Capture</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">static</span> propTypes = {\\n    <span class=\\"hljs-attr\\">report</span>: PropTypes.func.isRequired\\n  };\\n  <span class=\\"hljs-comment\\">// 定义传递给子组件的上下文</span>\\n  <span class=\\"hljs-keyword\\">static</span> childContextTypes = {\\n    <span class=\\"hljs-attr\\">loadable</span>: PropTypes.shape({\\n      <span class=\\"hljs-attr\\">report</span>: PropTypes.func.isRequired\\n    }).isRequired\\n  };\\n  <span class=\\"hljs-comment\\">// 传递的上下文内容</span>\\n  getChildContext() {\\n    <span class=\\"hljs-keyword\\">return</span> {\\n      <span class=\\"hljs-attr\\">loadable</span>: {\\n        <span class=\\"hljs-attr\\">report</span>: <span class=\\"hljs-keyword\\">this</span>.props.report\\n      }\\n    };\\n  }\\n  <span class=\\"hljs-comment\\">// 渲染唯一的子元素</span>\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> React.Children.only(<span class=\\"hljs-keyword\\">this</span>.props.children);\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这个context属性一般这么写，这里<code>modules</code>是一个空数组</p>\\n<p><code>report={moduleName =&gt; modules.push(moduleName)}</code></p>\\n<p>然后在<code>LoadableComponent</code>组件内部，如果存在<code>context属性</code>并且存在<code>opts.modules</code>(说明使用了babel插件)，\\n则调用<code>report</code>。</p>\\n<p>这里<code>moduleName</code>就是<code>opts.modules</code>里面每一个<code>moduleId</code>，通过<code>report</code>方法添加到<code>modules(空数组)</code>内部.</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.context.loadable &amp;&amp; <span class=\\"hljs-built_in\\">Array</span>.isArray(opts.modules)) {\\n  <span class=\\"hljs-comment\\">// 遍历并且对每一个执行report</span>\\n  opts.modules.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">moduleName</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">this</span>.context.loadable.report(moduleName);\\n  });\\n}</code></pre>\\n</code></pre>\\n<p>到现在，<code>modules</code>就是一个保存了当前进行延迟加载组件的<code>moduleId</code>的数组，再通过<code>getBundles</code>(webpack插件提供)方法，\\n将<code>moduleId(key)</code>通过查询<code>react-loadable.json(包含moduleId对应的bundles)</code>，转换成<code>bundles(value)</code>。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getBundles</span>(<span class=\\"hljs-params\\">manifest, moduleIds</span>) </span>{\\n  <span class=\\"hljs-comment\\">// moduleIds中每一个作为key，找到manifest[moduleId]合并到bundles(一个数组)中</span>\\n  <span class=\\"hljs-keyword\\">return</span> moduleIds.reduce(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">bundles, moduleId</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> bundles.concat(manifest[moduleId]);\\n  }, []);\\n}</code></pre>\\n</code></pre>\\n<p>现在我们得到了一个<code>bundles</code>数组，里面储存了我们延迟加载组件对应的<code>bundle</code>，我们要做的只是根据<code>bundle</code>类型\\n添加对应的<code>script标签</code>或者<code>link标签</code>。</p>\\n<h4 id=\\"preloadready\\">preLoadReady</h4>\\n<p>因为以上内容都是在服务端上的，客户端必须要等到组件可用了才可以开始渲染，</p>\\n<p>先提一个变量：<code>READY_INITIALIZERS</code>。</p>\\n<p>它储存了通过检查<code>opts.webpack</code>里面每一个<code>moduleId</code>对应的组件是可用的，这个组件的<code>init</code>方法。</p>\\n<p>这里<code>getModuleIds</code>就是<code>opts.webpack</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// __webpack_modules__是一个存储了所有模块的对象</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> __webpack_modules__ !== <span class=\\"hljs-string\\">\\"object\\"</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 检查是否每一个模块存在</span>\\n  <span class=\\"hljs-keyword\\">return</span> getModuleIds().every(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">moduleId</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      <span class=\\"hljs-keyword\\">typeof</span> moduleId !== <span class=\\"hljs-string\\">\\"undefined\\"</span> &amp;&amp;\\n      <span class=\\"hljs-keyword\\">typeof</span> __webpack_modules__[moduleId] !== <span class=\\"hljs-string\\">\\"undefined\\"</span>\\n    );\\n  });</code></pre>\\n</code></pre>\\n<p><code>preLoadReady</code>就是通过遍历<code>READY_INITIALIZERS</code>数组，并且执行每一个组件的<code>init</code>方法，\\n最终当<code>Promise.all</code>全部完成后，就可以开始渲染客户端了。</p>\\n<h3 id=\\"dao-tu-zong-jie\\">导图总结</h3>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-loadable/react-loadabel.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"jie-shao","level":3,"text":"介绍"},{"anchor":"chu-shi","level":3,"text":"初识"},{"anchor":"shen-ru","level":3,"text":"深入"},{"anchor":"loadable","level":4,"text":"Loadable"},{"anchor":"loadablemap","level":4,"text":"Loadable.Map"},{"anchor":"loadablecapture","level":4,"text":"Loadable.Capture"},{"anchor":"preloadready","level":4,"text":"preLoadReady"},{"anchor":"dao-tu-zong-jie","level":3,"text":"导图总结"}],"relatedTags":["源码","react","promise","webpack","babel","github"],"created_at":"2018-09-10","timeArr":[2018,8,10,15,44,34,0],"title":"源码阅读-react-loadable","uuid":"5134ffe9303c7c82cc06321c03aa6dc4abdc9753","summary":"<h4>介绍</h4>\\n<p><a href=\\"https://github.com/jamiebuilds/react-loadable\\">react-loadable</a>是一个组件延迟加载的工具，\\n它本身也是一个组件，通过<code>HOC</code>的方式对参数组件进行处理，\\n具体的延迟加载方式是使用<code>import().then()</code>方法，那么为什么要用这个组件呢？...</p>","slug":"source-code-react-loadable","sha":"7d1a1d670bb1ec624fdef1c489f683ce954302c1"}')},700:function(n){n.exports=JSON.parse('{"content":"<p><code>react-snapshot</code>一个服务端渲染组件，由于内部依赖库和相关<code>API</code>较老，而且有1年没更新了，\\n就不去太详细解释，有兴趣可以自行看源码内容<code>src目录</code>(带详细注释)。</p>\\n<p>读了这个库，要了解<code>服务端渲染</code>是什么流程，因此这里主要讲<code>执行流程</code>。</p>\\n<h3 id=\\"pei-zhi\\">配置</h3>\\n<p>这个库需要更改<code>package.json</code>的<code>build</code>，更改如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>- &quot;build&quot;: &quot;react-scripts build&quot;\\n+ &quot;build&quot;: &quot;react-scripts build &amp;&amp; react-snapshot&quot;</code></pre>\\n</code></pre>\\n<p>然后改变<code>render</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>- import ReactDOM from \'react-dom\';\\n+ import { render } from \'react-snapshot\';\\n\\n- ReactDOM.render(\\n+ render(\\n    &lt;App/&gt;,\\n    document.getElementById(\'root\')\\n  );</code></pre>\\n</code></pre>\\n<h3 id=\\"zhi-xing-liu-cheng\\">执行流程</h3>\\n<ol>\\n<li><p>输入<code>npm run build</code>，先执行<code>react-scripts build</code>，再执行<code>react-snapshot</code></p>\\n</li>\\n<li><p>通过<code>bin</code>内部文件执行<code>cli</code> </p>\\n</li>\\n<li><p>执行<code>cli</code>，处理相关配置(目的是转换路径，确认需要快照的页面路径)</p>\\n<ol>\\n<li>获取<code>package.json</code>内部的<code>homepage</code>，确保以<code>/</code>结尾，如果不存在则用<code>/</code>表示。</li>\\n<li>将路径转换为绝对路径。</li>\\n<li>将<code>homepage</code>加入<code>include</code>，后面将会不断<code>.shift()</code>处理内部的路径。</li>\\n</ol>\\n</li>\\n<li><p>重命名之前的<code>index.html</code>为<code>200.html</code></p>\\n</li>\\n<li><p>定义服务器<code>Server</code></p>\\n<ol>\\n<li>在<code>build</code>内部使用了<code>historyApiFallback</code>(防止SPA应用404)。</li>\\n<li>托管静态<code>build</code>内资源到用户定义的<code>outputFile</code>中，默认也是<code>build</code>。</li>\\n<li>处理了存在<code>proxy</code>(<code>package.json</code>内部的<code>proxy</code>)的情况。</li>\\n</ol>\\n</li>\\n<li><p>开启服务器（使用任意未占用端口）</p>\\n</li>\\n<li><p>在上面端口中开启爬虫<code>Crawler</code></p>\\n<ol>\\n<li>对参数<code>include</code>(数组)执行<code>.shift()</code>，开始爬行<code>snapshot</code><ol>\\n<li>使用<code>jsdom</code>，创建虚拟dom。</li>\\n<li>监听<code>window</code>创建，定义<code>window.reactSnapshotRender</code>，它的作用是改变一个<code>flag</code>。 这个<code>flag</code>的改变说明了当前<code>path</code>已经成功获取到<code>js</code>文件，并且执行了定义在客户端的<code>render</code>，已经将<code>React</code>\\n 首页的<code>document</code>结构放到了虚拟<code>document</code>内部。</li>\\n<li>拦截当前<code>path</code>上的外部资源请求，查看是否相同的<code>host</code>，并且符合<code>jsdom.feature</code>的配置。 当资源符合要求，便会请求并且执行(也就是<code>build</code>中<code>xxx.main.js</code>的代码)，执行它便会触发<code>render</code>，\\n 结果就回到第1步中说的改变<code>flag</code></li>\\n</ol>\\n</li>\\n<li>此时虚拟<code>document</code>结构已经生成，经过<code>scriptJS</code>检查(匹配则删除)和<code>window.react_snapshot_state</code>，\\n它的作用是定义一个数据，客户端运行时，能从<code>window.react_snapshot_state</code>获取到这个数据。</li>\\n<li>序列化这个<code>document</code>，检查<code>document</code>内部的<code>&lt;a&gt;</code>和<code>&lt;iframe</code>是否有链接到其他页面或者目录，如果有，添加到<code>include</code>中，\\n后续执行快照。</li>\\n</ol>\\n</li>\\n<li><p>给<code>path</code>添加<code>.html</code>后缀或者(如果是目录添加)<code>index.html</code>，创建并且写入文件。</p>\\n</li>\\n<li><p>递归到<code>第7步</code>继续执行其他路径的快照。</p>\\n</li>\\n</ol>\\n<h4 id=\\"dao-tu\\">导图</h4>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-snapshot/react-snapshot.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"pei-zhi","level":3,"text":"配置"},{"anchor":"zhi-xing-liu-cheng","level":3,"text":"执行流程"},{"anchor":"dao-tu","level":4,"text":"导图"}],"relatedTags":["react","源码","npm"],"created_at":"2018-12-04","timeArr":[2018,11,4,8,28,32,0],"title":"源码阅读-react-snapshot","uuid":"a1837b08e3c7d440f06a453b4a0a19e1078abcfa","summary":"<p><code>react-snapshot</code>一个服务端渲染组件，由于内部依赖库和相关<code>API</code>较老，而且有1年没更新了，\\n就不去太详细解释，有兴趣可以自行看源码内容<code>src目录</code>(带详细注释)。</p>\\n<p>读了这个库，要了解<code>服务端渲染</code>是什么流程，因此这里主要讲<code>执行流程</code>。</p>\\n<h4>配置</h4>\\n<p>这个库需要更改<code>package.json</code>...</p>","slug":"source-code-react-snapshot","sha":"eee62b3fcb60e43c2db14c27b02e523dc16d5be4"}')},701:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p><code>react-waypoint</code>用于监控元素是否出现在用户定义的视口范围内。</p>\\n</blockquote>\\n<h3 id=\\"chu-shi\\">初识</h3>\\n<p>源码逻辑写的并不复杂，这里基本就不放源码，主要概述一下源码做了些什么事情。</p>\\n<p>此源码内部相关知识</p>\\n<ul>\\n<li><code>onNextTick</code>作用和如何定义</li>\\n<li><code>getBoundingClientRect</code>的使用</li>\\n<li><code>getComputedStyle</code>的作用</li>\\n<li><code>addEventListener</code>中<code>{passive:true}</code>的作用</li>\\n<li><code>React.cloneElement</code>的使用</li>\\n<li>如果用户传递的是<code>React组件</code>不是<code>DOM</code>，需要编写<code>ForwardRef</code>或者<code>InnerRef</code></li>\\n</ul>\\n<h3 id=\\"zheng-ti-liu-cheng\\">整体流程</h3>\\n<hr>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>componentWillMount() {\\n  ensureChildrenIsValid(<span class=\\"hljs-keyword\\">this</span>.props.children);\\n}\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">ensureChildrenIsValid</span>(<span class=\\"hljs-params\\">children</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (children) {\\n    <span class=\\"hljs-keyword\\">try</span> {\\n      React.Children.only(children);\\n    } <span class=\\"hljs-keyword\\">catch</span> (e) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(errorMessage);\\n    }\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这里组件加载前就通过<code>React.Children.only</code>检查用户传入的<code>children</code>，保证必须唯一的子元素，并且不能是<code>TEXT</code></p>\\n<hr>\\n<p>在<code>componentDidMount</code>内部，</p>\\n<ul>\\n<li><p>使用了<code>onNextTick</code>， 一个将任务加入队列执行的方案，通过<code>setTimeout(()=&gt;{},0)</code>的使用：</p>\\n<ol>\\n<li>可以在任务开始前停止。</li>\\n<li>确保<code>ref</code>能完全获取。</li>\\n<li>任务之间不会冲突。</li>\\n</ol>\\n</li>\\n</ul>\\n<p><code>onNextTick</code>源码不复杂，却很实用。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> timeout;\\n<span class=\\"hljs-keyword\\">const</span> timeoutQueue = [];\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">onNextTick</span>(<span class=\\"hljs-params\\">cb</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 放入队列</span>\\n  timeoutQueue.push(cb);\\n  <span class=\\"hljs-keyword\\">if</span> (!timeout) {\\n    timeout = setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      timeout = <span class=\\"hljs-literal\\">null</span>;\\n      <span class=\\"hljs-keyword\\">let</span> item;\\n      <span class=\\"hljs-comment\\">// eslint-disable-next-line no-cond-assign</span>\\n      <span class=\\"hljs-keyword\\">while</span> (item = timeoutQueue.shift()) {\\n        item();\\n      }\\n    }, <span class=\\"hljs-number\\">0</span>);\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> isSubscribed = <span class=\\"hljs-literal\\">true</span>;\\n  <span class=\\"hljs-comment\\">// 返回一个取消函数</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">unsubscribe</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (!isSubscribed) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n    isSubscribed = <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-keyword\\">const</span> index = timeoutQueue.indexOf(cb);\\n    <span class=\\"hljs-comment\\">// 需要取消的任务已经执行完毕，发挥</span>\\n    <span class=\\"hljs-keyword\\">if</span> (index === <span class=\\"hljs-number\\">-1</span>) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n    timeoutQueue.splice(index, <span class=\\"hljs-number\\">1</span>);\\n    <span class=\\"hljs-comment\\">// 如果任务队列无任务 并且 计时器还存在，清除计时器</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!timeoutQueue.length &amp;&amp; timeout) {\\n      clearTimeout(timeout);\\n      timeout = <span class=\\"hljs-literal\\">null</span>;\\n    }\\n  };\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li><p>确认ref能有效获取到children</p>\\n<p>  通过<code>ref</code>获取子元素的<code>DOM</code></p>\\n<ul>\\n<li>子元素是<code>DOM</code>（最容易获取）</li>\\n<li>子元素是组件，尝试通过<code>ForwardRef</code>获取，如果子组件不是<code>ForwardRef</code>，通过<code>innerRef</code>获取</li>\\n</ul>\\n</li>\\n<li><p>父元素获取</p>\\n<p>  通过子元素的<code>parentNode</code>向上遍历，直到找到<code>overflow</code>为<code>auto</code>或者<code>scroll</code>，否则设置为<code>window</code></p>\\n<p>  通过<code>getComputedStyle</code>去获取<code>overflow</code>的值。（此处并不完美，依赖用户自觉）</p>\\n</li>\\n<li><p>绑定<code>scroll</code>和<code>resize</code></p>\\n<p>  选项<code>{passive:true}</code>，这能让浏览器在处理事件时不去检测是否存在<code>preventDefault</code>，事件处理更加流畅。</p>\\n</li>\\n</ul>\\n<hr>\\n<p>接着是<code>_handleScroll</code>，即事件绑定的方法</p>\\n<ol>\\n<li><p>内部存在<code>_getBounds</code>和<code>getCurrentPosition</code>，作用是判断子元素是否出现在规定范围内</p>\\n<ol>\\n<li>用户定义2个属性：<code>topOffset</code>和<code>bottomOffset</code>，可以理解为<code>上边线</code>和<code>下边线</code></li>\\n<li>通过<code>getBoundingClientRect</code>，计算出<code>子元素</code>顶端和底端到<code>视口</code>顶端的距离</li>\\n<li>通过<code>上/下边线</code>和<code>父元素</code>的高度和<code>父元素</code>顶端到视口顶端的距离，计算出<code>上/下边线</code>分别距离视口顶端的距离</li>\\n<li>对比以上2个数据，分别赋予当前<code>子元素</code>的4种位置状态：<code>invisible</code>，<code>inside</code>，<code>below</code>，<code>above</code></li>\\n</ol>\\n</li>\\n<li><p>通过保存当前位置，每次事件后对比与上一次的位置关系，执行对应的<code>enter</code>和<code>leave</code>钩子函数。</p>\\n<p> 一个亮点：<code>fireOnRapidScroll</code>，用于判断是否急速滑动。</p>\\n<p> 如果<code>scroll</code>执行过快，有可能子元素上一次事件还在<code>below</code>，这一次已经是<code>above</code>，当出现这样的情况，\\n 会强制执行<code>enter</code>和<code>leave</code>事件。</p>\\n</li>\\n</ol>\\n<hr>\\n<p>最后是<code>render</code></p>\\n<p>当组件接收到<code>this.props.children</code>，并且<code>children</code>本身是一个组件时，无法直接在上面添加属性的，\\n因为不能这么写<code>&lt;this.props.children prop={xxx} /&gt;</code>。</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>&lt;App&gt;\\n  &lt;Child /&gt;\\n&lt;<span class=\\"hljs-regexp\\">/App&gt;</span></code></pre>\\n</code></pre>\\n<p>在不改变输入格式的情况，使用<code>React.cloneElement</code>可以修改它的属性，当然原理是复制，意思是内存中存在2个<code>children</code>了。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">return</span> (\\n  React.cloneElement(<span class=\\"hljs-keyword\\">this</span>.props.children,{<span class=\\"hljs-attr\\">extraProp</span>:<span class=\\"hljs-number\\">1</span>})\\n)</code></pre>\\n</code></pre>\\n<hr>\\n<p>可能存在的缺陷：</p>\\n<p>当存在一个很长的<code>ul</code>列表，而给<code>ul</code>添加了<code>overflow:auto</code>，但并未设置<code>height</code>，这时<code>ul</code>并不是一个滚动组件，\\n真正的滚动还是触发在<code>window</code>，但<code>waypoint</code>会因为存在属性<code>overflow:auto</code>，而将<code>ul</code>认为是滚动组件父元素。</p>\\n<p><a href=\\"https://codesandbox.io/s/ly9y4v9m5m\\">例子</a></p>\\n<hr>\\n<p>一张导图作为结尾：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-waypoint/react-waypoint.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"chu-shi","level":3,"text":"初识"},{"anchor":"zheng-ti-liu-cheng","level":3,"text":"整体流程"}],"relatedTags":["源码","react"],"created_at":"2018-12-28","timeArr":[2018,11,28,19,30,43,0],"title":"源码阅读-react-waypoint","uuid":"ba215dff0ae6956dac40be3d218cd6ab5cd3c533","summary":"<p><code>react-waypoint</code>用于监控元素是否出现在用户定义的视口范围内。</p>","slug":"source-code-react-waypoint","sha":"f2384a371e4ab1abe1998ae1eb32ea5bed8a7ca9"}')},702:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"source-coderedux\\">source-code.redux</h1>\\n<p>v4.0.0 </p>\\n<p>redux源码设计真的很精妙</p>\\n<p>改变状态是从store一层一层往下找，找到对应的type修改状态，再一层一层返回</p>\\n<p>middleware是链式调用，每一环的返回值作为下一环的dispatch，就像滚雪球一样，最终能得到一个强大的dispatch</p>\\n<p>那么读完了是否能将这种设计思想变为自己的？</p>\\n<p>不能...刚读完去回想整个流程，缺漏的很多，真的是环环相扣</p>\\n<p>但多读几遍，或许哪天写代码的时候灵光一现，用上了某种设计，或许就真的变成你自己的东西了</p>\\n<p>详细解释在源码注释中，思维导图：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.redux/Redux.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"source-coderedux","level":1,"text":"source-code.redux"}],"relatedTags":["源码","redux"],"created_at":"2018-08-02","timeArr":[2018,7,2,18,41,14,0],"title":"源码阅读-redux","uuid":"adc2f51181e5738a7702a3a284bff293b822edca","summary":"<h4>source-code.redux</h4>\\n<p>v4.0.0</p>\\n<p>redux源码设计真的很精妙</p>\\n<p>改变状态是从store一层一层往下找，找到对应的type修改状态，再一层一层返回</p>\\n<p>middleware是链式调用，每一环的返回值作为下一环的dispatch，就像滚雪球一样，最终能得到一个强大的dispatch</p>\\n<p>那么读完了是...</p>","slug":"source-code-redux","sha":"5dc0af13b16222c98bb23e8923957ec20cd52eab"}')},703:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"reselect-yuan-ma-jie-shao\\">reselect源码介绍</h2>\\n<p>v3.0.1</p>\\n<p>导图：\\n<img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.reselect/reselect.png\\" alt=\\"\\"></p>\\n<h3 id=\\"defaultmemoize\\">defaultMemoize</h3>\\n<p>一个缓存函数，其内部：</p>\\n<ol>\\n<li>通过闭包保存参数和结果</li>\\n<li>每次调用对参数进行浅比较</li>\\n<li>参数比较结果相同，返回缓存的结果</li>\\n</ol>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">defaultMemoize</span>(<span class=\\"hljs-params\\">func, equalityCheck = defaultEqualityCheck</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> lastArgs = <span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">let</span> lastResult = <span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-comment\\">// 判断当前参数和上一次的参数是否相同，默认为 ===(全等)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, <span class=\\"hljs-built_in\\">arguments</span>)) {\\n      <span class=\\"hljs-comment\\">// apply arguments instead of spreading for performance.</span>\\n      <span class=\\"hljs-comment\\">// 不同则调用func</span>\\n      lastResult = func.apply(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-built_in\\">arguments</span>)\\n    }\\n    <span class=\\"hljs-comment\\">// 保存当前参数</span>\\n    lastArgs = <span class=\\"hljs-built_in\\">arguments</span>\\n    <span class=\\"hljs-comment\\">// 返回result</span>\\n    <span class=\\"hljs-keyword\\">return</span> lastResult\\n  }\\n}</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"createselectorcreator-createselector\\">createSelectorCreator, createSelector</h3>\\n<p>reselect最主要函数</p>\\n<ol>\\n<li><p><code>createSelectorCreator</code>接收一个参数，缓存函数，返回一个函数，称为<code>createSelector</code></p>\\n<p> <code>const createSelector = createSelectorCreator(defaultMemoize)</code></p>\\n</li>\\n<li><p><code>createSelector</code>接受2类参数</p>\\n<p> <code>依赖数据函数</code>(可以有多个)：</p>\\n<p> 它的结果会传递给<code>数据处理函数</code>作为它的参数</p>\\n<p> <code>数据处理函数</code>(必须放在参数的最后)：</p>\\n<p> 它接受的参数就是<code>依赖数据函数</code>的返回值</p>\\n</li>\\n<li><p><code>createSelector</code>的内部操作</p>\\n<ol>\\n<li>对<code>依赖数据函数</code>和<code>数据处理函数</code>执行缓存函数</li>\\n<li>每次执行<code>createSelector</code>的时候，会先执行<code>依赖数据函数</code>的缓存函数，检查参数是否相等，相等则返回旧的结果；\\n如果不相等，才会再执行<code>数据处理函数</code>的缓存函数，进行比较。这样处理就可以知道要想返回缓存的结果，必须要达到以下条件任一：<ol>\\n<li><code>依赖数据函数</code>的参数(一般为<code>store</code>)全等比较为true</li>\\n<li><code>依赖数据函数</code>的参数(一般为<code>store</code>)全等比较为false, <code>数据处理函数</code>的参数全等比较为true</li>\\n</ol>\\n</li>\\n</ol>\\n</li>\\n<li><p>返回<code>依赖数据函数</code></p>\\n<p> <a href=\\"https://codesandbox.io/s/jlpozpjprw\\">reselect使用例子</a></p>\\n</li>\\n</ol>\\n<hr>\\n<h3 id=\\"createstructuredselector\\">createStructuredSelector</h3>\\n<p>一个便利的函数，可以用于变更数据的key值，通过嵌套可以变更数据的结构</p>\\n<p>它的内部正是调用了<code>createSelector</code></p>\\n<ol>\\n<li><p>接受2个函数，分别为一个(参数1)对象，一个(参数2)<code>selectorCreator</code>(默认就是createSelector)</p>\\n</li>\\n<li><p>调用<code>createSelector</code>，将参数1(对象)的value值作为<code>依赖数据函数</code>，\\n其<code>数据处理函数</code>就是一个将参数1(对象)的key值和<code>依赖数据函数</code>的返回值组成一个新的对象的过程。</p>\\n<p> <a href=\\"https://codesandbox.io/s/53kvl30564\\">createStructuredSelector使用例子</a></p>\\n</li>\\n</ol>\\n<hr>\\n<p>注意点：</p>\\n<ol>\\n<li><p>缓存函数只能保存上一次缓存的值(单个)。</p>\\n</li>\\n<li><p>缓存函数是通过对比参数而进行判断的，因此必须保证所提供的<code>依赖数据函数</code>和<code>数据处理函数</code>都是纯函数，而且它只保存上一次函数。</p>\\n<p> <a href=\\"https://codesandbox.io/s/n6y126v2p\\">非纯函数例子</a></p>\\n</li>\\n<li><p>要想取消缓存，必须取消引用，包括<code>依赖数据函数</code>参数(store)的引用和内部<code>数据处理函数</code>的参数引用</p>\\n<p> <a href=\\"https://codesandbox.io/s/lx1kq3lj39\\">取消缓存例子</a></p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"reselect-yuan-ma-jie-shao","level":2,"text":"reselect源码介绍"},{"anchor":"defaultmemoize","level":3,"text":"defaultMemoize"},{"anchor":"createselectorcreator-createselector","level":3,"text":"createSelectorCreator, createSelector"},{"anchor":"createstructuredselector","level":3,"text":"createStructuredSelector"}],"relatedTags":["源码","缓存"],"created_at":"2018-07-15","timeArr":[2018,6,15,16,20,8,0],"title":"源码阅读-reselect","uuid":"a73ced0b51daf6b55d0965e613d5ed55304f6638","summary":"<h4>reselect源码介绍</h4>\\n<p>v3.0.1</p>\\n<p>导图：\\n<img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.reselect/reselect.png\\" alt=\\"\\"></p>\\n<h4>defaultMemoize</h4>\\n<p>...</p>","slug":"source-code-reselect","sha":"1337a25798f1710973ee215c3e6322aec34e79c8"}')},704:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p><a href=\\"https://github.com/szimek/signature_pad\\">signature_pad</a>一个基于Canvas的平滑手写画板工具</p>\\n</blockquote>\\n<hr>\\n<h4 id=\\"yi-xie-jie-shao\\">一些介绍</h4>\\n<p>实现手写有多种方式。</p>\\n<p>一种比较容易做出的是对鼠标移动轨迹画点，再将两点之间以<code>直线</code>相连，最后再进行平滑处理，这种方案不需要什么算法支持，但同样，它面对一个性能和美观的抉择，打的点多，密集，性能相对较低，但更加美观，视觉上更平滑；</p>\\n<p>此处用的另一种方案，画贝塞尔曲线。</p>\\n<p>由于<code>canvas</code>没有默认的画出贝塞尔曲线方法，因此曲线是通过不断画出<code>一个个点</code>形成的，那么问题来了，这些点谁来定？</p>\\n<p>这里使用了贝塞尔曲线的一系列算法，包括<code>求控制点</code>，<code>求长度</code>，<code>计算当前点的大小</code>，最后用<code>canvas</code>画出每一个确定位置的点。</p>\\n<h4 id=\\"can-shu-ji-pei-zhi-jie-shao\\">参数及配置介绍</h4>\\n<p>提供的可配置参数如下</p>\\n<pre><code><pre class=\\"hljs\\"><code>export interface IOptions {\\n  // 点的大小(不是线条)\\n  dotSize?: number | (() =&gt; number);\\n  // 最粗的线条宽度\\n  minWidth?: number;\\n  // 最细的线条宽度\\n  maxWidth?: number;\\n  // 最小间隔距离(这个距离用贝塞尔曲线填充)\\n  minDistance?: number;\\n  // 背景色\\n  backgroundColor?: string;\\n  // 笔颜色\\n  penColor?: string;\\n  // 节流的间隔\\n  throttle?: number;\\n  // 当前画笔速度的计算率，默认0.7，意思就是 当前速度=当前实际速度*0.7+上一次速度*0.3\\n  velocityFilterWeight?: number;\\n  // 初始回调\\n  onBegin?: (event: MouseEvent | Touch) =&gt; void;\\n  // 结束回调\\n  onEnd?: (event: MouseEvent | Touch) =&gt; void;\\n}</code></pre>\\n</code></pre>\\n<p>这里要注意的是并没有<code>线条粗细</code>这个选项，因为这里面的粗细不等线条都是通过一个个大小不同的点构造而成；</p>\\n<p><code>throttle</code>这个配置可以参考<code>loadsh</code>或者<code>underscore</code>的<code>_.throttle</code>，功能一致，就是为了提高性能。</p>\\n<h4 id=\\"zhu-ce-shi-jian\\">注册事件</h4>\\n<p>在<code>constructor</code>内部，除了配置传入的参数外，就是注册事件。</p>\\n<p>这里优先使用了<a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent\\">PointerEvent</a>触点事件，<code>PointerEvent</code>可以说是触摸以及点击事件的一个统一，如果设备支持，不需要再分别为<code>mouse</code>和<code>touch</code>写两套事件了。</p>\\n<h4 id=\\"zhuang-tai-shu-ju-chu-cun\\">状态数据储存</h4>\\n<p>状态开关：</p>\\n<ul>\\n<li><p><code>this._mouseButtonDown</code></p>\\n<p>  当执行<code>move</code>事件时，会检查此状态，只有在<code>true</code>的情况下才会执行。</p>\\n</li>\\n</ul>\\n<p>数据储存分为2种格式：</p>\\n<ol>\\n<li><p><code>pointGroup</code></p>\\n<p> 这是当前笔画的点的一个集合，内部储存了当前笔画的颜色<code>color</code>和所有的点<code>points&lt;Array&gt;</code>。</p>\\n</li>\\n<li><p><code>this._data</code></p>\\n<p> 这是一个储存所有笔画的栈，格式为<code>[pointGroup, pointGroup, ..., pointGroup]</code>，当需要执行<code>undo</code>的时候，只需要删除<code>this._data</code>中的最后一条数据。</p>\\n</li>\\n</ol>\\n<h4 id=\\"shi-jian-liu-cheng-ji-fang-fa\\">事件流程及方法</h4>\\n<h5 id=\\"mousedown-shi-jian\\"><code>mouseDown</code>事件</h5>\\n<p>当鼠标(触点)按下时，改变状态<code>this._mouseButtonDown = true</code>，调用<code>onBegin</code>回调，创建当前笔画的一个新的集合，然后对<strong>当前点执行更新</strong>。</p>\\n<h5 id=\\"mousemove-shi-jian\\"><code>mouseMove</code>事件</h5>\\n<p>首先检查<code>this._mouseButtonDown</code>状态，对<strong>当前点执行更新</strong>。</p>\\n<h5 id=\\"mouseup-shi-jian\\"><code>mouseUp</code>事件</h5>\\n<p>改变状态<code>this._mouseButtonDown = false;</code>，调用<code>onEnd</code>回调，对<strong>当前点执行更新</strong>。</p>\\n<p>可以看到，上面的每一个事件内部都调用对当前点执行更新的方法。</p>\\n<h5 id=\\"dian-de-geng-xin-fang-fa-_strokeupdate\\">点的更新方法<code>_strokeUpdate</code></h5>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>private _strokeUpdate(event: MouseEvent | Touch): <span class=\\"hljs-keyword\\">void</span> {\\n    <span class=\\"hljs-comment\\">// 获取当前触点的位置</span>\\n    <span class=\\"hljs-keyword\\">const</span> x = event.clientX;\\n    <span class=\\"hljs-keyword\\">const</span> y = event.clientY;\\n\\n    <span class=\\"hljs-comment\\">// 创建点</span>\\n    <span class=\\"hljs-keyword\\">const</span> point = <span class=\\"hljs-keyword\\">this</span>._createPoint(x, y);\\n    <span class=\\"hljs-comment\\">// 调出最后一个点集</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPointGroup = <span class=\\"hljs-keyword\\">this</span>._data[<span class=\\"hljs-keyword\\">this</span>._data.length - <span class=\\"hljs-number\\">1</span>];\\n    <span class=\\"hljs-comment\\">// 获取最后一个点集的点的数组</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPoints = lastPointGroup.points;\\n    <span class=\\"hljs-comment\\">// 如果存在上一个点，获取上一个点</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPoint =\\n      lastPoints.length &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; lastPoints[lastPoints.length - <span class=\\"hljs-number\\">1</span>];\\n    <span class=\\"hljs-comment\\">// 判断上一个点到当前点是否太近(也就是小于配置的最小间隔距离)</span>\\n    <span class=\\"hljs-keyword\\">const</span> isLastPointTooClose = lastPoint\\n      ? point.distanceTo(lastPoint) &lt;= <span class=\\"hljs-keyword\\">this</span>.minDistance\\n      : <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-comment\\">// 调出点集的颜色</span>\\n    <span class=\\"hljs-keyword\\">const</span> color = lastPointGroup.color;\\n\\n    <span class=\\"hljs-comment\\">// Skip this point if it\'s too close to the previous one</span>\\n    <span class=\\"hljs-comment\\">// 存在上一个点但是太近，跳过，其余的执行</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!lastPoint || !(lastPoint &amp;&amp; isLastPointTooClose)) {\\n      <span class=\\"hljs-comment\\">// 向上一次的点数组中添加当前点，并且生成一个新的贝塞尔曲线实例</span>\\n      <span class=\\"hljs-comment\\">// 包括4个点 （初始点，2个控制点，结束点）</span>\\n      <span class=\\"hljs-comment\\">// 初始宽度，最终宽度</span>\\n      <span class=\\"hljs-keyword\\">const</span> curve = <span class=\\"hljs-keyword\\">this</span>._addPoint(point);\\n\\n      <span class=\\"hljs-comment\\">// 如果不存在lastPoint，即当前点是第一个点</span>\\n      <span class=\\"hljs-keyword\\">if</span> (!lastPoint) {\\n        <span class=\\"hljs-comment\\">// 画一个点</span>\\n        <span class=\\"hljs-keyword\\">this</span>._drawDot({ color, point });\\n      <span class=\\"hljs-comment\\">// 如果存在lastPoint 并且能形成一个贝塞尔曲线实例(3个点以上)</span>\\n      } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (curve) {\\n        <span class=\\"hljs-comment\\">// 画出参数中curve实例中两点之间的曲线</span>\\n        <span class=\\"hljs-keyword\\">this</span>._drawCurve({ color, curve });\\n      }\\n      <span class=\\"hljs-comment\\">// 添加到当前笔画的点数组</span>\\n      lastPoints.push({\\n        <span class=\\"hljs-attr\\">time</span>: point.time,\\n        <span class=\\"hljs-attr\\">x</span>: point.x,\\n        <span class=\\"hljs-attr\\">y</span>: point.y,\\n      });\\n    }\\n  }</code></pre>\\n</code></pre>\\n<p>这个方法前面就是一系列判断</p>\\n<ul>\\n<li>判断是否是第一个点</li>\\n<li>判断是否能加入点的集合(满足点的最小间隔)</li>\\n<li>判断是否能画出贝塞尔曲线(满足至少3个点)  对于能画出贝塞尔曲线的点，执行算法，求出<code>Besier</code>实例，包括4个点<code>初始点</code>，<code>结束点</code>，<code>控制点1</code>，<code>控制点2</code>以及当前曲线中线条的的<code>初始宽度</code>和<code>结束宽度</code>。  具体如何算的，请参考源码<code>src/bezier.ts</code>和<a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">这篇文章</a>。</li>\\n</ul>\\n<p>对于能画出贝塞尔曲线的，对已经求出的<code>Bezier</code>实例，执行<code>this._drawCurve</code>，否则执行<code>this._drawDot</code></p>\\n<h5 id=\\"hua-dian-de-fang-fa-this_drawdot\\">画点的方法<code>this._drawDot</code></h5>\\n<p>获取配置中的<code>dotSize</code>，执行<code>canvas</code>画点。</p>\\n<h5 id=\\"hua-xian-de-fang-fa-this__drawcurve\\">画线的方法<code>this.__drawCurve</code></h5>\\n<ol>\\n<li><p>求出当前<code>Bezier</code>实例<code>初始点</code>和<code>结束点</code>之间的距离，这个距离不是直线距离，而是贝塞尔曲线距离。</p>\\n</li>\\n<li><p>对这个距离进行扩展，例如，计算得到距离为<code>50</code>，那就扩展为<code>100</code>个点，即我需要在<code>50</code>这个距离内画出<code>100</code>个点；</p>\\n<p> 这么做可以保证在正常或者稍微快速的书写中，不出现断层。</p>\\n</li>\\n<li><p>接着又是<a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">算法</a>，目的是求出这个距离内的每一个点的大小，这是一个变化值，是的粗细变化更加平滑。</p>\\n</li>\\n<li><p>最后同样是<code>canvas</code>画点。</p>\\n</li>\\n</ol>\\n<p>以上就是整个基本流程。</p>\\n<h4 id=\\"zong-jie\\">总结</h4>\\n<p>阅读一遍后，这个库说白就是基础的事件操作+贝塞尔曲线算法，但是，它内部的代码格式非常清晰，<code>细粒度+代码复用</code>使得维护起来非常方便。</p>\\n<p>同时可以对贝塞尔曲线有一个更深层的了解(算法还是没法手撕囧)，但起码有一个比较完整的思路；</p>\\n<p>一些可以借鉴的东西：</p>\\n<ul>\\n<li><a href=\\"#zhu-ce-shi-jian\\">PointerEvent的优势</a></li>\\n<li>canvas+贝塞尔曲线</li>\\n<li>节流<code>throttle</code>的写法(参考源码src/throttle.ts)</li>\\n<li><a href=\\"#zhuang-tai-shu-ju-chu-cun\\">数据结构及实现<code>undo</code>的方案</a></li>\\n</ul>\\n<h4 id=\\"si-wei-dao-tu\\">思维导图</h4>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.signature_pad/signature_pad.png\\" alt=\\"signature_pad导图\\"></p>\\n<blockquote>\\n<p>贝塞尔曲线算法资料：</p>\\n<ul>\\n<li><a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">https://medium.com/square-corner-blog/smoother-signatures-be64515adb33</a></li>\\n<li><a href=\\"https://www.lemoda.net/maths/bezier-length/index.html\\">https://www.lemoda.net/maths/bezier-length/index.html</a></li>\\n</ul>\\n</blockquote>\\n","toc":[{"anchor":"yi-xie-jie-shao","level":4,"text":"一些介绍"},{"anchor":"can-shu-ji-pei-zhi-jie-shao","level":4,"text":"参数及配置介绍"},{"anchor":"zhu-ce-shi-jian","level":4,"text":"注册事件"},{"anchor":"zhuang-tai-shu-ju-chu-cun","level":4,"text":"状态数据储存"},{"anchor":"shi-jian-liu-cheng-ji-fang-fa","level":4,"text":"事件流程及方法"},{"anchor":"mousedown-shi-jian","level":5,"text":"<code>mouseDown</code>事件"},{"anchor":"mousemove-shi-jian","level":5,"text":"<code>mouseMove</code>事件"},{"anchor":"mouseup-shi-jian","level":5,"text":"<code>mouseUp</code>事件"},{"anchor":"dian-de-geng-xin-fang-fa-_strokeupdate","level":5,"text":"点的更新方法<code>_strokeUpdate</code>"},{"anchor":"hua-dian-de-fang-fa-this_drawdot","level":5,"text":"画点的方法<code>this._drawDot</code>"},{"anchor":"hua-xian-de-fang-fa-this__drawcurve","level":5,"text":"画线的方法<code>this.__drawCurve</code>"},{"anchor":"zong-jie","level":4,"text":"总结"},{"anchor":"si-wei-dao-tu","level":4,"text":"思维导图"}],"relatedTags":["源码","算法","canvas","性能","github"],"created_at":"2019-06-18","timeArr":[2019,5,18,17,28,15,0],"title":"源码阅读-signature_pad","uuid":"020a984c51cbbd2495a0d29f23c81b45f6751f6d","summary":"<p><a href=\\"https://github.com/szimek/signature_pad\\">signature_pad</a>一个基于Canvas的平滑手写画板工具</p>","slug":"source-code-signature_pad","sha":"b8278693dc6d16379d12a1d0c6876b60ec86f4e7"}')},705:function(n){n.exports=JSON.parse('{"content":"<p>一个js性能监控器，使用canvas绘制，简洁美观，思想也不复杂</p>\\n<ol>\\n<li><p>通过<code>performance.now</code>获取当前开始时间，每次调用时，计算时间差，每隔1秒计算每一帧平均消耗的毫秒数，从而计算1000毫秒的帧数。</p>\\n</li>\\n<li><p>根据传入的当前fps和给定的最高fps绘制canvas，分为整体层，字体层，柱状条层。</p>\\n</li>\\n<li><p>因为不使用clearRect清除画布，每次新创建的柱状条不会被清除，从而展示出监测器的效果。</p>\\n</li>\\n</ol>\\n<p>stat：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.stat/Stat.png\\" alt=\\"\\"></p>\\n","toc":[],"relatedTags":["源码","canvas","性能"],"created_at":"2018-08-28","timeArr":[2018,7,28,14,34,42,0],"title":"源码阅读-stat","uuid":"52494eaeba83ec352ddf9911253c8da79c8e67fd","summary":"<p>一个js性能监控器，使用canvas绘制，简洁美观，思想也不复杂</p>\\n<ol>\\n<li>\\n<p>通过<code>performance.now</code>获取当前开始时间，每次调用时，计算时间差，每隔1秒计算每一帧平均消耗的毫秒数，从而计算1000毫秒的帧数。</p>\\n</li>\\n<li>\\n<p>根据传入的当前fps和给定的最高fps绘制canvas，分为整体层，字体层，柱状条层。</p>\\n</li>\\n</ol>\\n<p>3...</p>","slug":"source-code-stat","sha":"63fbb1b85f485cc67805eb912f3d38c366d33e41"}')},706:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"jian-jie\\">简介</h2>\\n<p><code>unstated</code>是一个极简的状态管理组件</p>\\n<blockquote>\\n<p>看它的简介：State so simple, it goes without saying</p>\\n</blockquote>\\n<h2 id=\\"dui-bi\\">对比</h2>\\n<h3 id=\\"dui-bi-redux\\">对比redux</h3>\\n<ul>\\n<li><p>更加灵活(相对的缺点是缺少规则，需要使用者的自觉)</p>\\n<p>  <code>redux</code>的状态是存放在一棵树内，采用严格的单向流</p>\\n<p>  <code>unstated</code>的状态是用户自己定义，说白了就是<code>object</code>，可以放在一个组件的内，也可以放在多个组件内</p>\\n</li>\\n<li><p>针对<code>React</code>，一致的<code>API</code></p>\\n<p>  <code>redux</code>必须编写<code>reducer</code>和<code>action</code>，通过<code>dispatch(action)</code>改变状态，它不限框架</p>\\n<p>  <code>unstated</code><strong>改变状态的<code>API</code>完全与<code>React</code>一致</strong>，使用<code>this.setState</code>，当然和<code>React</code>的<code>setState</code>不同，\\n  但是它的底层也是用到了<code>setState</code>去更新视图</p>\\n</li>\\n<li><p>功能相对简单</p>\\n<p>  <code>unstated</code>没有中间件功能，每次状态改变(不管是否相等)，都会重新渲染(<code>V2.1.1</code>)</p>\\n<p>  可以自定义<code>listener</code>，每次更新状态时都会执行。</p>\\n</li>\\n</ul>\\n<h3 id=\\"dui-bi-react-de-zi-dai-state\\">对比React的自带state</h3>\\n<ul>\\n<li>天生将组件分割为<code>Container(状态管理)</code>和<code>Component(视图管理)</code></li>\\n<li>灵活配置共享状态或者私有状态</li>\\n<li>支持<code>promise</code></li>\\n</ul>\\n<h2 id=\\"chu-shi\\">初识</h2>\\n<p>3大板块和几个关键变量</p>\\n<pre><code><pre class=\\"hljs\\"><code>Provider: 注入状态实例，传递map，本质是Context.Provider，可嵌套达成链式传递\\nContainer: 状态管理类，遵循React的API，发布订阅模式，通过new生成状态管理实例\\nSubscribe: 订阅状态组件，本质是Context.Consumer，接收Provider提供的map，视图渲染组件\\nmap: new Map()，通过类查找当前类创建的状态管理实例</code></pre>\\n</code></pre>\\n<h2 id=\\"shen-ru\\">深入</h2>\\n<p>这里引入官方例子</p>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// @flow</span>\\n<span class=\\"hljs-keyword\\">import</span> React <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react\'</span>;\\n<span class=\\"hljs-keyword\\">import</span> { render } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react-dom\'</span>;\\n<span class=\\"hljs-keyword\\">import</span> { Provider, Subscribe, Container } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'unstated\'</span>;\\n\\n<span class=\\"hljs-keyword\\">type</span> CounterState = {\\n  count: <span class=\\"hljs-built_in\\">number</span>\\n};\\n<span class=\\"hljs-comment\\">// 定义一个状态管理类</span>\\n<span class=\\"hljs-keyword\\">class</span> CounterContainer <span class=\\"hljs-keyword\\">extends</span> Container&lt;CounterState&gt; {\\n  state = {\\n    count: <span class=\\"hljs-number\\">0</span>\\n  };\\n\\n  increment() {\\n    <span class=\\"hljs-keyword\\">this</span>.setState({ count: <span class=\\"hljs-keyword\\">this</span>.state.count + <span class=\\"hljs-number\\">1</span> });\\n  }\\n\\n  decrement() {\\n    <span class=\\"hljs-keyword\\">this</span>.setState({ count: <span class=\\"hljs-keyword\\">this</span>.state.count - <span class=\\"hljs-number\\">1</span> });\\n  }\\n}\\n<span class=\\"hljs-comment\\">// 渲染视图组件(Context.Consumer的模式)</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">Counter</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;Subscribe to={[CounterContainer]}&gt;\\n      {<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">counter</span> =&gt;</span> (\\n        &lt;div&gt;\\n          &lt;button onClick={<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> counter.decrement()}&gt;-&lt;<span class=\\"hljs-regexp\\">/button&gt;\\n          &lt;span&gt;{counter.state.count}&lt;/</span>span&gt;\\n          &lt;button onClick={<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> counter.increment()}&gt;+&lt;<span class=\\"hljs-regexp\\">/button&gt;\\n        &lt;/</span>div&gt;\\n      )}\\n    &lt;<span class=\\"hljs-regexp\\">/Subscribe&gt;\\n  );\\n}\\n\\nrender(\\n  &lt;Provider&gt;\\n    &lt;Counter /</span>&gt;\\n  &lt;<span class=\\"hljs-regexp\\">/Provider&gt;,\\n  document.getElementById(\'root\')\\n);</span></code></pre>\\n</code></pre>\\n<p>这里<code>Counter</code>是我们自定义的视图组件，首先使用<code>&lt;Provider&gt;</code>包裹，接着在<code>Counter</code>内部，调用<code>&lt;Subscribe&gt;</code>组件，\\n传递一个数组给<code>props.to</code>，这个数组内存放了<code>Counter</code>组件需要使用的<code>状态管理类</code>(此处也可传递<code>状态管理实例</code>)。</p>\\n<h3 id=\\"provider\\">Provider</h3>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">Provider</span>(<span class=\\"hljs-params\\">props: ProviderProps</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;StateContext.Consumer&gt;\\n      {<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">parentMap</span> =&gt;</span> {\\n        <span class=\\"hljs-keyword\\">let</span> childMap = <span class=\\"hljs-keyword\\">new</span> Map(parentMap);\\n        <span class=\\"hljs-comment\\">// 外部注入的状态管理实例</span>\\n        <span class=\\"hljs-keyword\\">if</span> (props.inject) {\\n          props.inject.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">instance</span> =&gt;</span> {\\n            childMap.set(instance.<span class=\\"hljs-keyword\\">constructor</span>, instance);\\n          });\\n        }\\n\\n        <span class=\\"hljs-comment\\">// 负责将childMap传递，初始为null</span>\\n        <span class=\\"hljs-keyword\\">return</span> (\\n          &lt;StateContext.Provider value={childMap}&gt;\\n            {props.children}\\n          &lt;<span class=\\"hljs-regexp\\">/StateContext.Provider&gt;\\n        );\\n      }}\\n    &lt;/</span>StateContext.Consumer&gt;\\n  );\\n}</code></pre>\\n</code></pre>\\n<p>这里的模式是</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Consumer&gt;\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-keyword\\">return</span> &lt;Provider&gt;{props.children}&lt;Provider /&gt;\\n  }\\n&lt;/Consumer&gt;  </code></pre>\\n</code></pre>\\n<p>有3个注意点：</p>\\n<ol>\\n<li><p>外层嵌套<code>&lt;Consumer&gt;</code>可以嵌套调用。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Provider value={...}&gt;\\n <span class=\\"hljs-comment\\">/* ... */</span>\\n &lt;Provider value={此处继承了上面的value}&gt;\\n /* ... */ \\n&lt;/Provider&gt;</code></pre>\\n</code></pre>\\n</li>\\n<li><p><code>props.inject</code>可以注入现成的<code>状态管理实例</code>，添加到<code>map</code>之中。</p>\\n</li>\\n<li><p>返回值写成<code>props.children</code>。</p>\\n</li>\\n</ol>\\n<h3 id=\\"fan-hui-zhi-xie-cheng-propschildren-de-yi-yi\\">返回值写成props.children的意义</h3>\\n<p>简单一句话概括，这么写可以避免<code>React.Context</code>改变导致子组件的重复渲染。</p>\\n<p>具体看这里：<a href=\\"https://zhuanlan.zhihu.com/p/50336226\\">避免React Context导致的重复渲染</a></p>\\n<h3 id=\\"container\\">Container</h3>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Container&lt;State: {}&gt; {\\n  <span class=\\"hljs-comment\\">// 保存状态 默认为{}</span>\\n  state: State;\\n  <span class=\\"hljs-comment\\">// 保存监听函数，默认为[]</span>\\n  _listeners: <span class=\\"hljs-built_in\\">Array</span>&lt;Listener&gt; = [];\\n\\n  setState(\\n    updater: $Shape&lt;State&gt; | <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(<span class=\\"hljs-params\\">prevState: $Shape&lt;State&gt;</span>) =&gt; $Shape&lt;State&gt;</span>),\\n    <span class=\\"hljs-params\\">callback</span>?: <span class=\\"hljs-params\\">()</span> =&gt;</span> <span class=\\"hljs-built_in\\">void</span>\\n  ): <span class=\\"hljs-built_in\\">Promise</span>&lt;<span class=\\"hljs-built_in\\">void</span>&gt; {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">let</span> nextState;\\n\\n      <span class=\\"hljs-comment\\">/* 利用Object.assign改变state */</span>\\n\\n      <span class=\\"hljs-comment\\">// 执行listener(promise)</span>\\n      <span class=\\"hljs-keyword\\">let</span> promises = <span class=\\"hljs-keyword\\">this</span>._listeners.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">listener</span> =&gt;</span> listener());\\n\\n      <span class=\\"hljs-comment\\">// 所有Promise执行完毕</span>\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Promise</span>.all(promises).then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n        <span class=\\"hljs-comment\\">// 全部listener执行完毕，执行回调</span>\\n        <span class=\\"hljs-keyword\\">if</span> (callback) {\\n          <span class=\\"hljs-keyword\\">return</span> callback();\\n        }\\n      });\\n    });\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 增加订阅(这里默认的订阅就是React的setState空值(为了重新渲染)，也可以添加自定义监听函数)</span>\\n  subscribe(fn: Listener) {\\n    <span class=\\"hljs-keyword\\">this</span>._listeners.push(fn);\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 取消订阅</span>\\n  unsubscribe(fn: Listener) {\\n    <span class=\\"hljs-keyword\\">this</span>._listeners = <span class=\\"hljs-keyword\\">this</span>._listeners.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">f</span> =&gt;</span> f !== fn);\\n  }\\n}</code></pre>\\n</code></pre>\\n<p><code>Container</code>内部逻辑很简单，改变<code>state</code>，执行监听函数。</p>\\n<p>其中有一个<code>_listeners</code>，是用于存放监听函数的。</p>\\n<p>每个<code>状态管理实例</code>存在一个默认监听函数<code>onUpdate</code>，\\n这个默认的监听函数的作用就是<code>调用React的setState强制视图重新渲染</code>。</p>\\n<p>这里的监听函数内部返回<code>Promise</code>，最后通过<code>Promise.all</code>确保执行完毕，然后执行<code>回调参数</code>。</p>\\n<p>因此<code>setState</code>在外面使用也可以使用<code>then</code>。</p>\\n<p>例如，在官方例子中：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>increment() {\\n    <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">count</span>: <span class=\\"hljs-keyword\\">this</span>.state.count + <span class=\\"hljs-number\\">1</span> },()=&gt;<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'2\'</span>))\\n    .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'3\'</span>) )\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'1\'</span>) \\n  }\\n  <span class=\\"hljs-comment\\">// 执行顺序是 1 -&gt; 2 -&gt;3</span></code></pre>\\n</code></pre>\\n<p>2个注意点：</p>\\n<ol>\\n<li><p><code>setState</code>和<code>React API</code>一致，第一个参数传入object或者function，第二个传入回调</p>\\n</li>\\n<li><p>这里通过<code>Promise.resolve().then</code>模拟<code>this.setState</code>的异步执行</p>\\n</li>\\n</ol>\\n<h3 id=\\"guan-yu-promiseresolve-he-settimeout-de-qu-bie\\">关于Promise.resolve和setTimeout的区别</h3>\\n<p>简单的说两者都是异步调用，<code>Promise</code>更快执行。</p>\\n<ul>\\n<li><p><code>setTimeout(()=&gt;{},0)</code>会放入下一个新的<code>任务队列</code></p>\\n</li>\\n<li><p><code>Promise.resolve().then({})</code>会放入<code>微任务</code>，在调用栈为空时立刻补充调用栈并执行(简单理解为当前<code>任务队列</code>尾部)</p>\\n</li>\\n</ul>\\n<p>更多详细可以看这里提供的2个视频：<code>https://stackoverflow.com/a/38752743</code></p>\\n<h3 id=\\"subscribe\\">Subscribe</h3>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Subscribe&lt;Containers: ContainersType&gt; <span class=\\"hljs-keyword\\">extends</span> React.Component&lt;\\n  SubscribeProps&lt;Containers&gt;,\\n  SubscribeState\\n&gt; {\\n  state = {};\\n  <span class=\\"hljs-comment\\">// 存放传入的状态组件</span>\\n  instances: <span class=\\"hljs-built_in\\">Array</span>&lt;ContainerType&gt; = [];\\n  unmounted = <span class=\\"hljs-literal\\">false</span>;\\n\\n  componentWillUnmount() {\\n    <span class=\\"hljs-keyword\\">this</span>.unmounted = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">this</span>._unsubscribe();\\n  }\\n\\n  _unsubscribe() {\\n    <span class=\\"hljs-keyword\\">this</span>.instances.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">container</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// container为当前组件的每一个状态管理实例</span>\\n      <span class=\\"hljs-comment\\">// 删除listeners中的this.onUpdate</span>\\n      container.unsubscribe(<span class=\\"hljs-keyword\\">this</span>.onUpdate);\\n    });\\n  }\\n\\n  onUpdate: Listener = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Promise</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">resolve</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 组件未被卸载</span>\\n      <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>.unmounted) {\\n        <span class=\\"hljs-comment\\">// 纯粹是为了让React更新组件</span>\\n        <span class=\\"hljs-keyword\\">this</span>.setState(DUMMY_STATE, resolve);\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 已经被卸载则直接返回</span>\\n        resolve();\\n      }\\n    });\\n  };\\n  \\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>这里的关键就是<code>instances</code>，用于存放当前组件的<code>状态管理实例</code>。</p>\\n<p>当组件<code>unmount</code>的时候，会<code>unsubscribe</code>当前<code>状态管理实例</code>的默认监听函数，那么如果当前的<code>状态管理实例</code>是共享的，会不会有影响呢？</p>\\n<p>不会的。往后看可以知道，当<code>state</code>每次更新，都会重新创建新的<code>状态管理实例</code>(因为<code>props.to</code>的值可能会发生变化，例如取消某一个<code>状态管理实例</code>)，\\n而每次创建时，都会先<code>unsubscribe</code>再<code>subscribe</code>，确保不会重复添加监听函数。</p>\\n<p><code>onUpdate</code>就是创建<code>状态管理组件</code>时默认传递的监听函数，用的是<code>React</code>的<code>setState</code>更新一个<code>DUMMY_STATE</code>(空对象<code>{}</code>)。</p>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Subscribe&lt;Containers: ContainersType&gt; <span class=\\"hljs-keyword\\">extends</span> React.Component&lt;\\n  SubscribeProps&lt;Containers&gt;,\\n  SubscribeState\\n&gt; {\\n  <span class=\\"hljs-comment\\">/* 上面已讲 */</span>\\n\\n  _createInstances(\\n    map: ContainerMapType | <span class=\\"hljs-literal\\">null</span>,\\n    containers: ContainersType\\n  ): <span class=\\"hljs-built_in\\">Array</span>&lt;ContainerType&gt; {\\n    <span class=\\"hljs-comment\\">// 首先全部instances解除订阅</span>\\n    <span class=\\"hljs-keyword\\">this</span>._unsubscribe();\\n\\n    <span class=\\"hljs-comment\\">// 必须存在map 必须被Provider包裹才会有map</span>\\n    <span class=\\"hljs-keyword\\">if</span> (map === <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(\\n        <span class=\\"hljs-string\\">\'You must wrap your &lt;Subscribe&gt; components with a &lt;Provider&gt;\'</span>\\n      );\\n    }\\n\\n    <span class=\\"hljs-keyword\\">let</span> safeMap = map;\\n    <span class=\\"hljs-comment\\">// 重新定义当前组件的状态管理组件(根据to传入的数组)</span>\\n    <span class=\\"hljs-keyword\\">let</span> instances = containers.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">ContainerItem</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">let</span> instance;\\n\\n      <span class=\\"hljs-comment\\">// 传入的是Container组件，则使用</span>\\n      <span class=\\"hljs-keyword\\">if</span> (\\n        <span class=\\"hljs-keyword\\">typeof</span> ContainerItem === <span class=\\"hljs-string\\">\'object\'</span> &amp;&amp;\\n        ContainerItem <span class=\\"hljs-keyword\\">instanceof</span> Container\\n      ) {\\n        instance = ContainerItem;\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 传入的不是Container，可能是其他自定义组件等等(需要用new执行)，尝试获取</span>\\n        instance = safeMap.get(ContainerItem);\\n\\n        <span class=\\"hljs-comment\\">// 不存在则以它为key，value是新的Container组件</span>\\n        <span class=\\"hljs-keyword\\">if</span> (!instance) {\\n          instance = <span class=\\"hljs-keyword\\">new</span> ContainerItem();\\n          safeMap.set(ContainerItem, instance);\\n        }\\n      }\\n\\n      <span class=\\"hljs-comment\\">// 先解绑再绑定，避免重复订阅</span>\\n      instance.unsubscribe(<span class=\\"hljs-keyword\\">this</span>.onUpdate);\\n      instance.subscribe(<span class=\\"hljs-keyword\\">this</span>.onUpdate);\\n\\n      <span class=\\"hljs-keyword\\">return</span> instance;\\n    });\\n\\n    <span class=\\"hljs-keyword\\">this</span>.instances = instances;\\n    <span class=\\"hljs-keyword\\">return</span> instances;\\n  }\\n  \\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>在<code>_createInstances</code>内部，如果检查到传入的<code>props.to</code>的值已经是<code>状态管理实例</code>(私有状态组件)，那么直接使用即可，\\n如果传入的是<code>类class</code>(共享状态组件)，会尝试通过查询<code>map</code>，不存在的则通过<code>new</code>创建。</p>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Subscribe&lt;Containers: ContainersType&gt; <span class=\\"hljs-keyword\\">extends</span> React.Component&lt;\\n  SubscribeProps&lt;Containers&gt;,\\n  SubscribeState\\n&gt; {\\n  \\n  <span class=\\"hljs-comment\\">/* 上面已讲 */</span>\\n  \\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;StateContext.Consumer&gt;\\n      <span class=\\"hljs-comment\\">/* Provider传递的map */</span>\\n      {<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">map</span> =&gt;</span>\\n          <span class=\\"hljs-comment\\">// children是函数</span>\\n          <span class=\\"hljs-keyword\\">this</span>.props.children.apply(\\n            <span class=\\"hljs-literal\\">null</span>,\\n            <span class=\\"hljs-comment\\">// 传给子函数的参数(传进当前组件的状态管理实例)</span>\\n            <span class=\\"hljs-keyword\\">this</span>._createInstances(map, <span class=\\"hljs-keyword\\">this</span>.props.to)\\n          )\\n        }\\n      &lt;<span class=\\"hljs-regexp\\">/StateContext.Consumer&gt;\\n    );\\n  }\\n}</span></code></pre>\\n</code></pre>\\n<p>每一次<code>render</code>都会创建新的<code>状态管理实例</code>。</p>\\n<p>到此，3大板块已经阅读完毕。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<ol>\\n<li><p>简单易用，与<code>React</code>一致的<code>API</code>，一致的书写模式，让使用者很快上手。</p>\\n</li>\\n<li><p>并没有规定如何管理这些<code>状态管理类</code>，非常灵活。</p>\\n<p> 我们可以学<code>redux</code>将所有状态放到一个<code>共享状态管理实例</code>内部，\\n 例如通过<code>Provider</code>的<code>inject</code>属性注入，</p>\\n<p> 或者针对每一个组件创建单独的<code>状态管理实例</code>(可共享可独立)(<code>unstated</code>作者推荐)，</p>\\n<p> 一切可以按照自己的想法，但同时也要求使用者自己定义一些规则去约束写法。</p>\\n</li>\\n<li><p>仅仅是管理了状态，每次更新都是一个全新的<code>instance</code>集合，并没有做任何对比，需要我们在视图层自己实现。</p>\\n</li>\\n<li><p>返回值写成<code>props.children</code>的<a href=\\"#fan-hui-zhi-xie-cheng-propschildren-de-yi-yi\\">意义</a>。</p>\\n</li>\\n<li><p>关于<code>Promise.resolve().then({})</code>和<code>setTimeout(()=&gt;{},0)</code>的<a href=\\"#guan-yu-Promiseresolve-he-setTimeout-de-qu-bie\\">区别</a>。</p>\\n</li>\\n</ol>\\n<h2 id=\\"dao-tu\\">导图</h2>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.unstated/unstated.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"jian-jie","level":2,"text":"简介"},{"anchor":"dui-bi","level":2,"text":"对比"},{"anchor":"dui-bi-redux","level":3,"text":"对比redux"},{"anchor":"dui-bi-react-de-zi-dai-state","level":3,"text":"对比React的自带state"},{"anchor":"chu-shi","level":2,"text":"初识"},{"anchor":"shen-ru","level":2,"text":"深入"},{"anchor":"provider","level":3,"text":"Provider"},{"anchor":"fan-hui-zhi-xie-cheng-propschildren-de-yi-yi","level":3,"text":"返回值写成props.children的意义"},{"anchor":"container","level":3,"text":"Container"},{"anchor":"guan-yu-promiseresolve-he-settimeout-de-qu-bie","level":3,"text":"关于Promise.resolve和setTimeout的区别"},{"anchor":"subscribe","level":3,"text":"Subscribe"},{"anchor":"zong-jie","level":2,"text":"总结"},{"anchor":"dao-tu","level":2,"text":"导图"}],"relatedTags":["源码","react","promise","redux"],"created_at":"2018-12-08","timeArr":[2018,11,8,10,29,27,0],"title":"源码阅读-unstated","uuid":"1ec6d586c759db1ce817117277e391c08a8d1c01","summary":"<p>看它的简介：State so simple, it goes without saying</p>","slug":"source-code-unstated","sha":"471fa80d4139f88a0f770af34e991a0b73babacc"}')},707:function(n){n.exports=JSON.parse('{"content":"<h1 id=\\"source-codezepto\\">source-code.zepto</h1>\\n<p>Zepto v1.2.0 </p>\\n<p>阅读<a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.zepto/src/zepto.js\\">zepto源码</a></p>\\n","toc":[{"anchor":"source-codezepto","level":1,"text":"source-code.zepto"}],"relatedTags":["源码"],"created_at":"2018-07-15","timeArr":[2018,6,15,16,20,8,0],"title":"源码阅读-zepto","uuid":"dbc119259f2d6bc6fb636050446ffdf3cd320af1","summary":"<h4>source-code.zepto</h4>\\n<p>Zepto v1.2.0</p>\\n<p>阅读<a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.zepto/src/zepto.js\\">zepto源码</a>\\n...</p>","slug":"source-code-zepto","sha":"5f736c0f3e3709c79088cd4f60899e05280f35ce"}')}}]);