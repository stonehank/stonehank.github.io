(window.webpackJsonp=window.webpackJsonp||[]).push([[1225],{2023:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">grid</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> shortestPathAllKeys = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">grid</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> r=grid.length,c=grid[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">let</span> moves=[[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">-1</span>]]\\n  <span class=\\"hljs-keyword\\">let</span> finalState=<span class=\\"hljs-number\\">0</span>, startPoint=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;r;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;c;j++){\\n      <span class=\\"hljs-keyword\\">let</span> code=grid[i].charCodeAt(j)<span class=\\"hljs-number\\">-97</span>\\n      <span class=\\"hljs-keyword\\">if</span>(code&gt;=<span class=\\"hljs-number\\">0</span> &amp;&amp; code&lt;=<span class=\\"hljs-number\\">5</span>){\\n        <span class=\\"hljs-comment\\">// 求出当前拿齐所有钥匙的最终状态</span>\\n        finalState=finalState | (<span class=\\"hljs-number\\">1</span>&lt;&lt;code)\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(grid[i][j]===<span class=\\"hljs-string\\">\\"@\\"</span>){\\n        <span class=\\"hljs-comment\\">// 找出开始点</span>\\n        startPoint=[i,j]\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> visited=<span class=\\"hljs-built_in\\">Array</span>(finalState+<span class=\\"hljs-number\\">1</span>).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(r).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(c).fill(<span class=\\"hljs-literal\\">false</span>)))\\n  <span class=\\"hljs-keyword\\">let</span> step=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> arr=[[startPoint[<span class=\\"hljs-number\\">0</span>],startPoint[<span class=\\"hljs-number\\">1</span>],<span class=\\"hljs-number\\">0</span>]]\\n  <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> [x,y,keysState]=arr.shift()\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [dx,dy] <span class=\\"hljs-keyword\\">of</span> moves){\\n        <span class=\\"hljs-keyword\\">let</span> newx=x+dx,newy=y+dy   \\n        <span class=\\"hljs-keyword\\">if</span>(newx&lt;<span class=\\"hljs-number\\">0</span> || newy&lt;<span class=\\"hljs-number\\">0</span> || newx&gt;=r || newy&gt;=c)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> curstr=grid[newx][newy]\\n        <span class=\\"hljs-keyword\\">if</span>(curstr===<span class=\\"hljs-string\\">\\"#\\"</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> code=grid[newx].charCodeAt(newy)\\n        <span class=\\"hljs-keyword\\">if</span>(visited[keysState][newx][newy])<span class=\\"hljs-keyword\\">continue</span>\\n        visited[keysState][newx][newy]=<span class=\\"hljs-literal\\">true</span>\\n        <span class=\\"hljs-keyword\\">if</span>(code&gt;=<span class=\\"hljs-number\\">65</span> &amp;&amp; code&lt;=<span class=\\"hljs-number\\">72</span> &amp;&amp; ((<span class=\\"hljs-number\\">1</span>&lt;&lt;(code<span class=\\"hljs-number\\">-65</span>))&amp;keysState)===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> newState=keysState\\n        <span class=\\"hljs-keyword\\">if</span>(code&gt;=<span class=\\"hljs-number\\">97</span> &amp;&amp; code&lt;=<span class=\\"hljs-number\\">102</span> &amp;&amp; ((<span class=\\"hljs-number\\">1</span>&lt;&lt;(code<span class=\\"hljs-number\\">-97</span>))&amp;keysState)===<span class=\\"hljs-number\\">0</span>){\\n          newState=newState | (<span class=\\"hljs-number\\">1</span>&lt;&lt;(code<span class=\\"hljs-number\\">-97</span>))\\n          <span class=\\"hljs-keyword\\">if</span>(newState===finalState)<span class=\\"hljs-keyword\\">return</span> step+<span class=\\"hljs-number\\">1</span>\\n        }\\n        arr.push([newx,newy,newState])\\n      }\\n    }\\n    step++\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n};\\n</code></pre>\\n"],"querySlug":"shortest-path-to-get-all-keys","created_at":"2019-04-16","timeArr":[2019,3,16,18,27,25,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这题比起一般的最短路径，多了一个找钥匙的过程，这个钥匙的状态是不能共享的。</p>\\n<p>例如：在<code>bfs</code>的过程中，其中一条路径<code>arr[i]</code>找到了<code>a</code>钥匙，另一条路径<code>arr[j]</code>找到了<code>b</code>钥匙，那么路径<code>arr[i]</code>还需要去找<code>b</code>钥匙，\\n而路径<code>arr[j]</code>也还需要找<code>a</code>钥匙。</p>\\n<p>我们可以使用一个数组来保存找到的钥匙，注意的是，每次找到新的钥匙后，不能直接更改钥匙状态数组，需要复制一个新的数组，再去更改，\\n否则会存在引用共享，同时设立<code>hash</code>来保存当前的状态<code>x,y,keysArr</code>。</p>\\n<p>虽然这么做能<code>accept</code>，但还可以继续优化，办法就是使用位操作符。</p>\\n<p>例如：</p>\\n<p>存在钥匙<code>abcdef</code>，钥匙的最终状态就是二进制的<code>111111</code>；</p>\\n<p>存在钥匙<code>aef</code>，钥匙的最终状态是<code>110001</code>。</p>\\n<p>具体操作方法是，</p>\\n<p>通过<code>(1&lt;&lt;当前钥匙的code) &amp; keysState === 0</code>判断是否存在当前<code>code</code>的钥匙。</p>\\n<p>通过<code>(1&lt;&lt;当前钥匙的code) | keysState</code>来更新当前钥匙的状态。</p>\\n","content":"<p>给定一个二维网格&nbsp;<code>grid</code>。&nbsp;<code>&quot;.&quot;</code>&nbsp;代表一个空房间，&nbsp;<code>&quot;#&quot;</code>&nbsp;代表一堵墙，&nbsp;<code>&quot;@&quot;</code>&nbsp;是起点，（<code>&quot;a&quot;</code>,&nbsp;<code>&quot;b&quot;</code>, ...）代表钥匙，（<code>&quot;A&quot;</code>,&nbsp;<code>&quot;B&quot;</code>, ...）代表锁。</p>\\n\\n<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>\\n\\n<p>假设 K 为钥匙/锁的个数，且满足&nbsp;<code>1 &lt;= K &lt;= 6</code>，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>\\n\\n<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>[&quot;@.a.#&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]\\n<strong>输出：</strong>8\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>[&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]\\n<strong>输出：</strong>6\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= grid.length&nbsp;&lt;= 30</code></li>\\n\\t<li><code>1 &lt;= grid[0].length&nbsp;&lt;= 30</code></li>\\n\\t<li><code>grid[i][j]</code>&nbsp;只含有&nbsp;<code>&#39;.&#39;</code>,&nbsp;<code>&#39;#&#39;</code>,&nbsp;<code>&#39;@&#39;</code>,&nbsp;<code>&#39;a&#39;-</code><code>&#39;f</code><code>&#39;</code>&nbsp;以及&nbsp;<code>&#39;A&#39;-&#39;F&#39;</code></li>\\n\\t<li>钥匙的数目范围是&nbsp;<code>[1, 6]</code>，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。</li>\\n</ol>\\n","title":"864. 获取所有钥匙的最短路径","relatedTags":["位运算","广度优先搜索"],"difficult":"Hard","lang":["javascript"],"uniqueID":"864","slug":"864-Shortest-Path-to-Get-All-Keys"}')}}]);