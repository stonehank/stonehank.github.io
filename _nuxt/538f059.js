(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{1003:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">isMatch</span><span class=\\"hljs-params\\">(self, s, p)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \\"\\"\\"</span>\\n        m=len(p)\\n        n=len(s)\\n        dp=[[<span class=\\"hljs-literal\\">False</span>]*(n+<span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(m+<span class=\\"hljs-number\\">1</span>)]\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(m+<span class=\\"hljs-number\\">1</span>):\\n          <span class=\\"hljs-keyword\\">for</span> j <span class=\\"hljs-keyword\\">in</span> range(n+<span class=\\"hljs-number\\">1</span>):\\n            <span class=\\"hljs-keyword\\">if</span> i==<span class=\\"hljs-number\\">0</span> <span class=\\"hljs-keyword\\">and</span> j==<span class=\\"hljs-number\\">0</span>:\\n              dp[i][j]=<span class=\\"hljs-literal\\">True</span>\\n            <span class=\\"hljs-comment\\"># elif j==0 and p[i-1]==\'.\':</span>\\n              <span class=\\"hljs-comment\\"># dp[i][j]=dp[i-1][j]</span>\\n            <span class=\\"hljs-keyword\\">elif</span> j==<span class=\\"hljs-number\\">0</span> <span class=\\"hljs-keyword\\">and</span> p[i<span class=\\"hljs-number\\">-1</span>]==<span class=\\"hljs-string\\">\\"*\\"</span>:\\n              dp[i][j]=dp[i<span class=\\"hljs-number\\">-2</span>][j]\\n            <span class=\\"hljs-keyword\\">elif</span> i==<span class=\\"hljs-number\\">0</span> <span class=\\"hljs-keyword\\">and</span> j!=<span class=\\"hljs-number\\">0</span>:\\n              dp[i][j]=<span class=\\"hljs-literal\\">False</span>\\n        <span class=\\"hljs-comment\\"># print dp</span>\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(<span class=\\"hljs-number\\">1</span>,m+<span class=\\"hljs-number\\">1</span>):\\n          <span class=\\"hljs-keyword\\">for</span> j <span class=\\"hljs-keyword\\">in</span> range(<span class=\\"hljs-number\\">1</span>,n+<span class=\\"hljs-number\\">1</span>):\\n            <span class=\\"hljs-keyword\\">if</span> p[i<span class=\\"hljs-number\\">-1</span>]==s[j<span class=\\"hljs-number\\">-1</span>] <span class=\\"hljs-keyword\\">or</span> p[i<span class=\\"hljs-number\\">-1</span>]==<span class=\\"hljs-string\\">\'.\'</span>:\\n              dp[i][j]=dp[i<span class=\\"hljs-number\\">-1</span>][j<span class=\\"hljs-number\\">-1</span>]\\n            <span class=\\"hljs-comment\\"># elif p[i-1]==\'.\':</span>\\n            <span class=\\"hljs-comment\\">#   dp[i][j]=dp[i-1][j-1]</span>\\n            <span class=\\"hljs-keyword\\">elif</span> p[i<span class=\\"hljs-number\\">-1</span>]==<span class=\\"hljs-string\\">\\"*\\"</span>:\\n              <span class=\\"hljs-keyword\\">if</span> p[i<span class=\\"hljs-number\\">-2</span>]==s[j<span class=\\"hljs-number\\">-1</span>] <span class=\\"hljs-keyword\\">or</span> p[i<span class=\\"hljs-number\\">-2</span>]==<span class=\\"hljs-string\\">\'.\'</span>:\\n                dp[i][j]=dp[i<span class=\\"hljs-number\\">-2</span>][j] <span class=\\"hljs-keyword\\">or</span> dp[i][j<span class=\\"hljs-number\\">-1</span>]\\n              <span class=\\"hljs-keyword\\">else</span>:\\n                dp[i][j]=dp[i<span class=\\"hljs-number\\">-2</span>][j]\\n        <span class=\\"hljs-comment\\"># print dp</span>\\n        <span class=\\"hljs-keyword\\">return</span> dp[m][n]\\n</code></pre>\\n"],"querySlug":"regular-expression-matching","created_at":"2019-02-27","timeArr":[2019,1,27,17,17,24,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p><code>动态规划</code>,<code>dp[i][j]</code>代表到索引<code>[0,i]</code>的<code>p</code>是否能被索引<code>[0,j]</code>的<code>s</code>匹配。</p>\\n<p>如果<code>p[i]===s[j] || p[i]===\'.\'</code>，说明它们匹配，<code>dp[i][j]=dp[i-1][j-1]</code>。</p>\\n<p>如果不匹配，但是<code>p[i]===\'*\'</code>，</p>\\n<ol>\\n<li>如果<code>p</code>的前一个能和当前<code>s</code>匹配并且<code>dp[i][j-1]===true</code>，说明<code>*</code>可以延长上一个的<code>p</code>来匹配当前的<code>s</code>；</li>\\n<li>如果上面条件不符合，但是<code>dp[i-2][j]===true</code>，也就是说前2个的<code>p</code>能和当前<code>s</code>匹配，那么<code>*</code>可以作为数量<code>0</code>,相当与忽略前一个<code>p</code>。</li>\\n</ol>\\n","content":"<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>\'.\'</code> 和 <code>\'*\'</code> 的正则表达式匹配。</p>\\n\\n<ul>\\n\\t<li><code>\'.\'</code> 匹配任意单个字符</li>\\n\\t<li><code>\'*\'</code> 匹配零个或多个前面的那一个元素</li>\\n</ul>\\n\\n<p>所谓匹配，是要涵盖 <strong>整个 </strong>字符串 <code>s</code>的，而不是部分字符串。</p>\\n \\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"aa\\" p = \\"a\\"\\n<strong>输出：</strong>false\\n<strong>解释：</strong>\\"a\\" 无法匹配 \\"aa\\" 整个字符串。\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"aa\\" p = \\"a*\\"\\n<strong>输出：</strong>true\\n<strong>解释：</strong>因为 \'*\' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \'a\'。因此，字符串 \\"aa\\" 可被视为 \'a\' 重复了一次。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"ab\\" p = \\".*\\"\\n<strong>输出：</strong>true\\n<strong>解释：</strong>\\".*\\" 表示可匹配零个或多个（\'*\'）任意字符（\'.\'）。\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"aab\\" p = \\"c*a*b\\"\\n<strong>输出：</strong>true\\n<strong>解释：</strong>因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 \\"aab\\"。\\n</pre>\\n\\n<p><strong>示例 5：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"mississippi\\" p = \\"mis*is*p*.\\"\\n<strong>输出：</strong>false</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>0 <= s.length <= 20</code></li>\\n\\t<li><code>0 <= p.length <= 30</code></li>\\n\\t<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>\\n\\t<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>\\n\\t<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>\\n</ul>\\n","title":"10. 正则表达式匹配","relatedTags":["递归","字符串","动态规划"],"difficult":"Hard","lang":["python"],"uniqueID":"10","slug":"10-Regular-Expression-Matching"}')}}]);