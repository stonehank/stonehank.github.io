(window.webpackJsonp=window.webpackJsonp||[]).push([[1344],{2142:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">voyage</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> flipMatchVoyage = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root, voyage</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> res=[],idx=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-comment\\">// console.log(idx,root.val)</span>\\n    <span class=\\"hljs-keyword\\">if</span>(root.val !== voyage[idx++])<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n    <span class=\\"hljs-keyword\\">let</span> n=idx\\n    <span class=\\"hljs-keyword\\">if</span>(!dfs(root.left) || !dfs(root.right)){\\n      idx=n\\n      res.push(root.val)\\n      <span class=\\"hljs-comment\\">// console.log(res,root.val)</span>\\n      <span class=\\"hljs-keyword\\">return</span> dfs(root.right) &amp;&amp; dfs(root.left)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> r=dfs(root)\\n  <span class=\\"hljs-comment\\">// console.log(idx)</span>\\n  <span class=\\"hljs-keyword\\">if</span>(!r || idx!==voyage.length)<span class=\\"hljs-keyword\\">return</span> [<span class=\\"hljs-number\\">-1</span>]\\n  <span class=\\"hljs-keyword\\">return</span> res\\n  \\n};\\n</code></pre>\\n"],"querySlug":"flip-binary-tree-to-match-preorder-traversal","created_at":"2019-03-21","timeArr":[2019,2,21,10,55,0,0],"hasThinking":false,"content":"<p>给你一棵二叉树的根节点 <code>root</code> ，树中有 <code>n</code> 个节点，每个节点都有一个不同于其他节点且处于 <code>1</code> 到 <code>n</code> 之间的值。</p>\\n\\n<p>另给你一个由 <code>n</code> 个值组成的行程序列 <code>voyage</code> ，表示 <strong>预期</strong> 的二叉树 <a href=\\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\\" target=\\"_blank\\"><strong>先序遍历</strong></a> 结果。</p>\\n\\n<p>通过交换节点的左右子树，可以 <strong>翻转</strong> 该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg\\" style=\\"width: 400px; height: 187px;\\" />\\n<p>请翻转 <strong>最少 </strong>的树中节点，使二叉树的 <strong>先序遍历</strong> 与预期的遍历行程 <code>voyage</code> <strong>相匹配</strong> 。 </p>\\n\\n<p>如果可以，则返回 <strong>翻转的</strong> 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 <code>[-1]</code>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/01/02/1219-01.png\\" style=\\"width: 150px; height: 205px;\\" />\\n<pre>\\n<strong>输入：</strong>root = [1,2], voyage = [2,1]\\n<strong>输出：</strong>[-1]\\n<strong>解释：</strong>翻转节点无法令先序遍历匹配预期行程。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\\" style=\\"width: 150px; height: 142px;\\" />\\n<pre>\\n<strong>输入：</strong>root = [1,2,3], voyage = [1,3,2]\\n<strong>输出：</strong>[1]\\n<strong>解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\\" style=\\"width: 150px; height: 142px;\\" />\\n<pre>\\n<strong>输入：</strong>root = [1,2,3], voyage = [1,2,3]\\n<strong>输出：</strong>[]\\n<strong>解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>树中的节点数目为 <code>n</code></li>\\n\\t<li><code>n == voyage.length</code></li>\\n\\t<li><code>1 <= n <= 100</code></li>\\n\\t<li><code>1 <= Node.val, voyage[i] <= n</code></li>\\n\\t<li>树中的所有值 <strong>互不相同</strong></li>\\n\\t<li><code>voyage</code> 中的所有值 <strong>互不相同</strong></li>\\n</ul>\\n","title":"971. 翻转二叉树以匹配先序遍历","relatedTags":["树","深度优先搜索","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"971","slug":"971-Flip-Binary-Tree-To-Match-Preorder-Traversal"}')}}]);