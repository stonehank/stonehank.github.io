(window.webpackJsonp=window.webpackJsonp||[]).push([[803],{1601:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">rectangles</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> isRectangleCover = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">rectangles</span>) </span>{\\n  <span class=\\"hljs-comment\\">// area相等</span>\\n  <span class=\\"hljs-comment\\">// 每个点次数双数</span>\\n  <span class=\\"hljs-comment\\">// 无相交？</span>\\n  <span class=\\"hljs-keyword\\">let</span> pointHash={}\\n  <span class=\\"hljs-keyword\\">let</span> area=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> leftDown=[<span class=\\"hljs-literal\\">Infinity</span>,<span class=\\"hljs-literal\\">Infinity</span>],\\n      topRight=[-<span class=\\"hljs-literal\\">Infinity</span>,-<span class=\\"hljs-literal\\">Infinity</span>]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [a,b,c,d] <span class=\\"hljs-keyword\\">of</span> rectangles){\\n    area+=(c-a)*(d-b)\\n    leftDown[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-built_in\\">Math</span>.min(leftDown[<span class=\\"hljs-number\\">0</span>],a)\\n    leftDown[<span class=\\"hljs-number\\">1</span>]=<span class=\\"hljs-built_in\\">Math</span>.min(leftDown[<span class=\\"hljs-number\\">1</span>],b)\\n    topRight[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-built_in\\">Math</span>.max(topRight[<span class=\\"hljs-number\\">0</span>],c)\\n    topRight[<span class=\\"hljs-number\\">1</span>]=<span class=\\"hljs-built_in\\">Math</span>.max(topRight[<span class=\\"hljs-number\\">1</span>],d)\\n    addDefault(a+<span class=\\"hljs-string\\">\' \'</span>+b)\\n    addDefault(a+<span class=\\"hljs-string\\">\' \'</span>+d)\\n    addDefault(c+<span class=\\"hljs-string\\">\' \'</span>+b)\\n    addDefault(c+<span class=\\"hljs-string\\">\' \'</span>+d)\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">addDefault</span>(<span class=\\"hljs-params\\">key</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(pointHash[key]==<span class=\\"hljs-literal\\">null</span>)pointHash[key]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> pointHash[key]++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> _area=(topRight[<span class=\\"hljs-number\\">0</span>]-leftDown[<span class=\\"hljs-number\\">0</span>]) * (topRight[<span class=\\"hljs-number\\">1</span>]-leftDown[<span class=\\"hljs-number\\">1</span>])\\n  <span class=\\"hljs-keyword\\">if</span>(area!==_area)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-comment\\">// let count=0</span>\\n  <span class=\\"hljs-comment\\">// let leftDown=[Infinity,Infinity],</span>\\n  <span class=\\"hljs-comment\\">//     topRight=[-Infinity,-Infinity]</span>\\n  \\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k <span class=\\"hljs-keyword\\">in</span> pointHash){\\n    <span class=\\"hljs-keyword\\">if</span>(k===leftDown[<span class=\\"hljs-number\\">0</span>]+<span class=\\"hljs-string\\">\' \'</span>+leftDown[<span class=\\"hljs-number\\">1</span>] ||\\n       k===leftDown[<span class=\\"hljs-number\\">0</span>]+<span class=\\"hljs-string\\">\' \'</span>+topRight[<span class=\\"hljs-number\\">1</span>] ||\\n       k===topRight[<span class=\\"hljs-number\\">0</span>]+<span class=\\"hljs-string\\">\' \'</span>+leftDown[<span class=\\"hljs-number\\">1</span>] ||\\n       k===topRight[<span class=\\"hljs-number\\">0</span>]+<span class=\\"hljs-string\\">\' \'</span>+topRight[<span class=\\"hljs-number\\">1</span>]){\\n      <span class=\\"hljs-keyword\\">if</span>(pointHash[k]!==<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(pointHash[k]%<span class=\\"hljs-number\\">2</span>!==<span class=\\"hljs-number\\">0</span>){\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// console.log(pointHash)</span>\\n  <span class=\\"hljs-comment\\">// if(count!==4)return false</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n};\\n</code></pre>\\n"],"querySlug":"perfect-rectangle","created_at":"2019-04-27","timeArr":[2019,3,27,12,59,52,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>题目定义的完美矩形，包括2个方面：</p>\\n<ol>\\n<li>每一个矩形的面积和与整个矩形的面积相等。</li>\\n<li>任意两个矩形都是不相交的。</li>\\n</ol>\\n<p>如果按照上面做，对每一个矩形都要与另外所有的矩形检查是否相交，因此时间复杂度是<code>O(N^2)</code>，整体算法速度较慢。</p>\\n<p>因此对于第<code>2</code>点，需要优化；如果2个矩形不相交，那么除了他们合并的大矩形的四个边角出现的次数只有<code>1</code>次，其余所有点出现的次数都是偶数次。</p>\\n<p>因此可以定义一个<code>hash</code>，<code>hash</code>保存每一个点出现的次数，如果当前点是边角点，那么只能出现1次；\\n其他情况只能出现偶数次；</p>\\n<p>再次优化，可以考虑在每个点出现<code>2</code>次的时候，删除这个点，因此最后<code>hash</code>内的值只有<code>4</code>个边角点，可以降低空间使用。</p>\\n","content":"<p>我们有 N 个与坐标轴对齐的矩形, 其中 N &gt; 0, 判断它们是否能精确地覆盖一个矩形区域。</p>\\n\\n<p>每个矩形用左下角的点和右上角的点的坐标来表示。例如，&nbsp;一个单位正方形可以表示为 [1,1,2,2]。&nbsp;( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。</p>\\n\\n<p><img src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_perfect.gif\\"></p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>rectangles = [\\n  [1,1,3,3],\\n  [3,1,4,2],\\n  [3,2,4,4],\\n  [1,3,2,4],\\n  [2,3,3,4]\\n]\\n\\n返回 true。5个矩形一起可以精确地覆盖一个矩形区域。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><img src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_separated.gif\\"></p>\\n\\n<p><strong>示例&nbsp;2:</strong></p>\\n\\n<pre>rectangles = [\\n  [1,1,2,3],\\n  [1,3,2,4],\\n  [3,1,4,2],\\n  [3,2,4,4]\\n]\\n\\n返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><img src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_hole.gif\\"></p>\\n\\n<p><strong>示例 3:</strong></p>\\n\\n<pre>rectangles = [\\n  [1,1,3,3],\\n  [3,1,4,2],\\n  [1,3,2,4],\\n  [3,2,4,4]\\n]\\n\\n返回 false。图形顶端留有间隔，无法覆盖成一个矩形。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><img src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_intersect.gif\\"></p>\\n\\n<p><strong>示例 4:</strong></p>\\n\\n<pre>rectangles = [\\n  [1,1,3,3],\\n  [3,1,4,2],\\n  [1,3,2,4],\\n  [2,2,4,4]\\n]\\n\\n返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。\\n</pre>\\n","title":"391. 完美矩形","relatedTags":["数组","扫描线"],"difficult":"Hard","lang":["javascript"],"uniqueID":"391","slug":"391-Perfect-Rectangle"}')}}]);