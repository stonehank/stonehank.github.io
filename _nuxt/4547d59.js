(window.webpackJsonp=window.webpackJsonp||[]).push([[866],{1664:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> circularArrayLoop = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> n = nums.length;\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; n; i++) {\\n    <span class=\\"hljs-keyword\\">if</span> (nums[i] == <span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>;\\n    <span class=\\"hljs-keyword\\">let</span> j = i, k = getIndex(i);\\n    <span class=\\"hljs-keyword\\">while</span> (nums[k] * nums[i] &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; nums[getIndex(k)] * nums[i] &gt; <span class=\\"hljs-number\\">0</span>) {\\n      <span class=\\"hljs-keyword\\">if</span> (j == k) {\\n        <span class=\\"hljs-keyword\\">if</span> (j == getIndex(j))<span class=\\"hljs-keyword\\">break</span>;\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n      }\\n      j = getIndex(j);\\n      k = getIndex(getIndex(k));\\n    }\\n    j = i;\\n    <span class=\\"hljs-keyword\\">let</span> val = nums[i];\\n    <span class=\\"hljs-keyword\\">while</span> (nums[j] * val &gt; <span class=\\"hljs-number\\">0</span>) {\\n        <span class=\\"hljs-keyword\\">let</span> next = getIndex(j);\\n        nums[j] = <span class=\\"hljs-number\\">0</span>;\\n        j = next;\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;    \\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getIndex</span>(<span class=\\"hljs-params\\">i</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> ((i+nums[i]) % n + n) % n\\n    <span class=\\"hljs-comment\\">// let nxtI=i+nums[i]</span>\\n    <span class=\\"hljs-comment\\">// while(nxtI&lt;0)nxtI+=n</span>\\n    <span class=\\"hljs-comment\\">// return nxtI % n</span>\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"circular-array-loop","created_at":"2019-06-01","timeArr":[2019,5,1,17,1,7,0],"hasThinking":false,"content":"<p>存在一个不含 <code>0</code> 的<strong> 环形 </strong>数组&nbsp;<code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 <code>i</code> 的角色应该向前或向后移动的下标个数：</p>\\n\\n<ul>\\n\\t<li>如果 <code>nums[i]</code> 是正数，<strong>向前</strong>（下标递增方向）移动 <code>|nums[i]|</code> 步</li>\\n\\t<li>如果&nbsp;<code>nums[i]</code> 是负数，<strong>向后</strong>（下标递减方向）移动 <code>|nums[i]|</code> 步</li>\\n</ul>\\n\\n<p>因为数组是 <strong>环形</strong> 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>\\n\\n<p>数组中的 <strong>循环</strong> 由长度为 <code>k</code> 的下标序列 <code>seq</code> 标识：</p>\\n\\n<ul>\\n\\t<li>遵循上述移动规则将导致一组重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>\\n\\t<li>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong></li>\\n\\t<li><code>k &gt; 1</code></li>\\n</ul>\\n\\n<p>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [2,-1,1,2,2]\\n<strong>输出：</strong>true\\n<strong>解释：</strong>存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [-1,2]\\n<strong>输出：</strong>false\\n<strong>解释：</strong>按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\\n</pre>\\n\\n<p><strong>示例 3:</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [-2,1,-1,-2,-2]\\n<strong>输出：</strong>false\\n<strong>解释：</strong>按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\\n所有 nums[seq[j]] 应当不是全正就是全负。</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\\n\\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\\n\\t<li><code>nums[i] != 0</code></li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(n)</code> 且额外空间复杂度为 <code>O(1)</code> 的算法吗？</p>\\n","title":"457. 环形数组是否存在循环","relatedTags":["数组","哈希表","双指针"],"difficult":"Middle","lang":["javascript"],"uniqueID":"457","slug":"457-Circular-Array-Loop"}')}}]);