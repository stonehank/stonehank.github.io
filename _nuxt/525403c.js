(window.webpackJsonp=window.webpackJsonp||[]).push([[422],{1220:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * // Definition for a Node.\\n * function Node(val,neighbors) {\\n *    this.val = val;\\n *    this.neighbors = neighbors;\\n * };\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{Node}</span> <span class=\\"hljs-variable\\">node</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{Node}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> cloneGraph = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">node</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">clone</span>(<span class=\\"hljs-params\\">node</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> val=node.val,\\n        adj=node.neighbors\\n    <span class=\\"hljs-keyword\\">if</span>(hash[val])<span class=\\"hljs-keyword\\">return</span> hash[val]\\n    <span class=\\"hljs-keyword\\">let</span> copy=<span class=\\"hljs-keyword\\">new</span> Node(val,[])\\n    hash[val]=copy\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;adj.length;i++){\\n      copy.neighbors[i]=clone(adj[i])\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> copy\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> clone(node)\\n\\n};\\n</code></pre>\\n"],"querySlug":"clone-graph","created_at":"2019-04-08","timeArr":[2019,3,8,15,23,24,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这是一个带有环的图，因此<code>hash</code>必须在执行遍历<code>neighbors</code>之前保存当前的<code>copy Node</code>，这样后面如果遇到循环引用，也能引用到<code>hash</code>里的<code>copy Node</code>。</p>\\n<p>遍历<code>neighbors</code>并且填充<code>copy Node.neighbors</code>。</p>\\n","content":"<p>给你无向&nbsp;<strong><a href=\\"https://baike.baidu.com/item/连通图/6460995?fr=aladdin\\" target=\\"_blank\\">连通</a>&nbsp;</strong>图中一个节点的引用，请你返回该图的&nbsp;<a href=\\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\\" target=\\"_blank\\"><strong>深拷贝</strong></a>（克隆）。</p>\\n\\n<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>\\n\\n<pre>class Node {\\n    public int val;\\n    public List&lt;Node&gt; neighbors;\\n}</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>测试用例格式：</strong></p>\\n\\n<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>\\n\\n<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>\\n\\n<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将&nbsp;<strong>给定节点的拷贝&nbsp;</strong>作为对克隆图的引用返回。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png\\" style=\\"height: 500px; width: 500px;\\"></p>\\n\\n<pre><strong>输入：</strong>adjList = [[2,4],[1,3],[2,4],[1,3]]\\n<strong>输出：</strong>[[2,4],[1,3],[2,4],[1,3]]\\n<strong>解释：\\n</strong>图中有 4 个节点。\\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png\\" style=\\"height: 148px; width: 163px;\\"></p>\\n\\n<pre><strong>输入：</strong>adjList = [[]]\\n<strong>输出：</strong>[[]]\\n<strong>解释：</strong>输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>adjList = []\\n<strong>输出：</strong>[]\\n<strong>解释：</strong>这个图是空的，它不含任何节点。\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png\\" style=\\"height: 133px; width: 272px;\\"></p>\\n\\n<pre><strong>输入：</strong>adjList = [[2],[1]]\\n<strong>输出：</strong>[[2],[1]]</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li>节点数不超过 100 。</li>\\n\\t<li>每个节点值&nbsp;<code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li>\\n\\t<li>无向图是一个<a href=\\"https://baike.baidu.com/item/简单图/1680528?fr=aladdin\\" target=\\"_blank\\">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>\\n\\t<li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em>&nbsp;的邻居。</li>\\n\\t<li>图是连通图，你可以从给定节点访问到所有节点。</li>\\n</ol>\\n","title":"133. 克隆图","relatedTags":["深度优先搜索","广度优先搜索","图","哈希表"],"difficult":"Middle","lang":["javascript"],"uniqueID":"133","slug":"133-Clone-Graph"}')}}]);