(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{663:function(n){n.exports=JSON.parse('{"content":"<ul>\\n<li>如果向 Promise.resolve(..) 传递一个真正的 Promise，就只会返回同一个 promise<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> p1 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( <span class=\\"hljs-number\\">42</span> );\\n<span class=\\"hljs-keyword\\">var</span> p2 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( p1 );\\np1===p2\\n<span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n</li>\\n</ul>\\n<hr>\\n<ul>\\n<li>Promise.resolve(..) 可以接受任何 thenable，将其解封为它的非 thenable 值。<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> c={\\n<span class=\\"hljs-attr\\">then</span>:<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>{\\n  a(<span class=\\"hljs-number\\">5</span>);b(<span class=\\"hljs-string\\">\\"err\\"</span>)}\\n}\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>Promise.resolve( c )\\n.then(\\n  function fulfilled(val){\\n    console.log( &#39;success&#39;,val );\\n  },\\n  function rejected(err){\\n    console.log(&#39;error&#39;,err)\\n  }\\n);\\n// success 5</p>\\n<pre><code><pre class=\\"hljs\\"><code>---------\\n* Deferred模式\\n\\n```js\\nfunction Deferred() {\\n    this.promise = new Promise((resolve, reject)=&gt;{\\n        this._resolve = resolve;\\n        this._reject = reject;\\n    });\\n}\\nDeferred.prototype.resolve = function (value) {\\n    this._resolve(value);\\n};\\nDeferred.prototype.reject = function (reason) {\\n    this._reject(reason);\\n};\\nvar d=new Deferred()\\nvar obj={}\\nobj.res=d.resolve.bind(d)\\nobj.rej=d.reject.bind(d)\\nobj.rej(124)\\nd.promise.then(v=&gt;console.log(v),err=&gt;console.warn(err)).catch(err=&gt;console.error(err))</code></pre></code></pre><hr>\\n<ul>\\n<li>继承prototype<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">A</span>(<span class=\\"hljs-params\\"></span>) </span>{}\\nA.prototype.a = <span class=\\"hljs-number\\">5</span>\\nA.prototype.show = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-number\\">11</span>)\\n}\\nA.prototype.arr = [<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span>]\\n</code></pre></code></pre>\\n</li>\\n</ul>\\n<p>function B() {}\\nfor (let k in A.prototype) {\\n  B.prototype[k] = A.prototype[k]\\n}</p>\\n<p>function C() {}\\nC.prototype = Object.create(A.prototype)</p>\\n<p>// B和C的区别</p>\\n<p>var b = new B()\\nvar c = new C()</p>\\n<p>b instanceof A // false\\nc instanceof A // true\\n```</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-02","timeArr":[2018,7,2,0,0,0,0],"title":"一些promise和其他补缺","uuid":"e1662cfda83fcae8dc160c993bb54ff04956653c","summary":"<ul>\\n<li>如果向 Promise.resolve(..) 传递一个真正的 Promise，就只会返回同一个 promise</li>\\n</ul>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> p1 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( <span class=\\"hljs-number\\">42</span> );\\n<span class=\\"hljs-keyword\\">var</span> p2 = <span class=\\"hljs-built_in\\">Promise</span>.resolve( p1 );\\np1===p2\\n<span class=\\"hljs-comment\\">// true</span>\\n</code></pre>","slug":"yi-xie-promise-he-qi-ta-bu-que","sha":"3bfb5149de44ae6b02ce78a91414ebbd9303a277"}')}}]);