(window.webpackJsonp=window.webpackJsonp||[]).push([[1130],{1928:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">swimInWater</span><span class=\\"hljs-params\\">(self, grid)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\"\\"\\"</span>\\n        N, pq, seen, res = len(grid), [(grid[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">0</span>], <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>)], set([(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>)]), <span class=\\"hljs-number\\">0</span>\\n        <span class=\\"hljs-keyword\\">while</span> <span class=\\"hljs-literal\\">True</span>:\\n            T, x, y = heapq.heappop(pq)\\n            res = max(res, T)\\n            <span class=\\"hljs-keyword\\">if</span> x == y == N - <span class=\\"hljs-number\\">1</span>:\\n                <span class=\\"hljs-keyword\\">return</span> res\\n            <span class=\\"hljs-keyword\\">for</span> i, j <span class=\\"hljs-keyword\\">in</span> [(x + <span class=\\"hljs-number\\">1</span>, y), (x, y + <span class=\\"hljs-number\\">1</span>), (x - <span class=\\"hljs-number\\">1</span>, y), (x, y - <span class=\\"hljs-number\\">1</span>)]:\\n                <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-number\\">0</span> &lt;= i &lt; N <span class=\\"hljs-keyword\\">and</span> <span class=\\"hljs-number\\">0</span> &lt;= j &lt; N <span class=\\"hljs-keyword\\">and</span> (i, j) <span class=\\"hljs-keyword\\">not</span> <span class=\\"hljs-keyword\\">in</span> seen:\\n                    seen.add((i, j))\\n                    heapq.heappush(pq, (grid[i][j], i, j))\\n          \\n</code></pre>\\n"],"querySlug":"swim-in-rising-water","created_at":"2019-02-26","timeArr":[2019,1,26,17,20,7,0],"hasThinking":false,"content":"<p>在一个 N x N 的坐标方格 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示在位置 <code>(i,j)</code> 的平台高度。</p>\\n\\n<p>现在开始下雨了。当时间为 <code>t</code> 时，此时雨水导致水池中任意位置的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>\\n\\n<p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 <code>(N-1, N-1)</code>？</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [[0,2],[1,3]]\\n<strong>输出:</strong> 3\\n<strong>解释:</strong>\\n时间为0时，你位于坐标方格的位置为 <code>(0, 0)。</code>\\n此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。\\n\\n等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置\\n</pre>\\n\\n<p><strong>示例2:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\\n<strong>输出:</strong> 16\\n<strong>解释:</strong>\\n<strong> 0  1  2  3  4</strong>\\n24 23 22 21  <strong>5</strong>\\n<strong>12 13 14 15 16</strong>\\n<strong>11</strong> 17 18 19 20\\n<strong>10  9  8  7  6</strong>\\n\\n最终的路线用加粗进行了标记。\\n我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示:</strong></p>\\n\\n<ol>\\n\\t<li><code>2 <= N <= 50</code>.</li>\\n\\t<li><code>grid[i][j]</code> 是 <code>[0, ..., N*N - 1]</code> 的排列。</li>\\n</ol>\\n","title":"778. 水位上升的泳池中游泳","relatedTags":["深度优先搜索","广度优先搜索","并查集","数组","二分查找","矩阵","堆（优先队列）"],"difficult":"Hard","lang":["python"],"uniqueID":"778","slug":"778-Swim-in-Rising-Water"}')}}]);