(window.webpackJsonp=window.webpackJsonp||[]).push([[251],{1049:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">stones</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> numMovesStonesII = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">stones</span>) </span>{\\n  stones.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a-b)\\n  <span class=\\"hljs-keyword\\">let</span> n=stones.length\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-built_in\\">Math</span>.max(stones[n<span class=\\"hljs-number\\">-1</span>]-stones[<span class=\\"hljs-number\\">1</span>]-(n<span class=\\"hljs-number\\">-2</span>),stones[n<span class=\\"hljs-number\\">-2</span>]-stones[<span class=\\"hljs-number\\">0</span>]-(n<span class=\\"hljs-number\\">-2</span>))\\n  <span class=\\"hljs-keyword\\">let</span> min=<span class=\\"hljs-literal\\">Infinity</span>\\n\\n  <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;n;j++){\\n    <span class=\\"hljs-comment\\">// 确保当前[i,j]区间内的间隔不大于所有的数字</span>\\n    <span class=\\"hljs-keyword\\">while</span>(stones[j]-stones[i]&gt;n<span class=\\"hljs-number\\">-1</span>)i++\\n    <span class=\\"hljs-comment\\">// 如果当前连续的值有n-1个</span>\\n    <span class=\\"hljs-keyword\\">if</span> (j-i+<span class=\\"hljs-number\\">1</span>===n<span class=\\"hljs-number\\">-1</span> &amp;&amp; stones[j]-stones[i]===n<span class=\\"hljs-number\\">-2</span>){\\n      min=<span class=\\"hljs-built_in\\">Math</span>.min(min,<span class=\\"hljs-number\\">2</span>)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-comment\\">// 将除了[i,j]区间以外的数字放入[i,j]区间或者让它们连续，只需要n-(j-i+1)步</span>\\n      <span class=\\"hljs-comment\\">// 例如：</span>\\n      <span class=\\"hljs-comment\\">// [1,4,7,9,20,30]，当前i为0，j为1，那么将[7,9,20,30]与[1,4]连续只需要4步</span>\\n      <span class=\\"hljs-comment\\">// 将7和9放入2,3的位置，将30放入6的位置，将20放入5的位置</span>\\n      <span class=\\"hljs-comment\\">// [1,2,3,56,89]，i为0，j为2，只需要2步</span>\\n      <span class=\\"hljs-comment\\">// 将89放入5的位置，56放入4的位置</span>\\n      min=<span class=\\"hljs-built_in\\">Math</span>.min(min,n-(j-i+<span class=\\"hljs-number\\">1</span>))\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> [min,max]\\n};\\n</code></pre>\\n"],"querySlug":"moving-stones-until-consecutive-ii","created_at":"2019-05-05","timeArr":[2019,4,5,15,2,21,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>首先对<code>stones</code>升序排序。</p>\\n<p><strong>求最大值</strong>：</p>\\n<p>每次可以移动最左端或者最右端，因此最大值一定是要么第一次移动的是最左端，要么第一次移动的是最右端；</p>\\n<p>如果第一次移动最右端，那么第一步一定是移到最右边开始第二个的前面，即<code>stones[n-2]</code>，<code>n</code>为<code>stones</code>的长度，并且最左的位置是<code>stones[0]</code>，\\n因此移动距离就是<code>stones[n-2]-stones[0]-1-(n-3)</code>，也就是当前区间内部的位置，减去内部已经有石头的数量(有<code>3</code>个不在区间内部，分别是区间左右端2个和最后1个<code>stones[n-1]</code>)，剩下的空位置就是能移动石头的位置。</p>\\n<p>例如：<code>[1,3,5,7,12,65]</code>，<code>1</code>到<code>12</code>之间还剩下7个空位置，也就是先移动右端，能最多移动7次。</p>\\n<p>同样的，如果第一次移动最左端，那么第一步一定是移动到最左边开始第二个的后面，即<code>stones[1]</code>，它的最右端即是<code>stones[n-1]</code>，\\n因此移动距离就是<code>stones[n-1]-stones[1]-1-(n-3)</code>；</p>\\n<p>例如：<code>[1,3,5,7,12,65]</code>，<code>3</code>到<code>65</code>之间还剩下58个空位置，也就是先移动左端，能最多移动58次。</p>\\n<p>上面两个值取最大值就是当前能移动的最大步数。</p>\\n<p><strong>求最小值</strong>：</p>\\n<p><code>window slide</code>，不断构造一个区间，这个区间<code>[i,j]</code>满足，区间的长度不会大于石头的数量，即这个区间是可以被区间外部的石头塞满的(可以塞不下，但不能有空隙)。</p>\\n<p>接着检查如果这个区间是<strong>连续</strong>的并且外部非连续的只有<strong>1</strong>个，那么这是一种特殊情况，返回<code>2</code>。</p>\\n<p>例如<code>[1,2,3,4,10]</code>，区间<code>[1,2,3,4]</code>是连续的，但外部非连续的只有1个，需要将<code>1</code>放到<code>6</code>的位置，再将<code>10</code>放到<code>5</code>的位置。</p>\\n<p>如果不是以上的特殊情况，那么不需要检查区间内部是否连续了，也就是将除了<code>[i,j]</code>区间以外的数字放入<code>[i,j]</code>区间，放不下的要让它们连续，只需要<code>n-(j-i+1)</code>步。</p>\\n<p>例如：</p>\\n<p>区间内部不连续：</p>\\n<p><code>[1,4,7,9,20,30]</code>，当前<code>i</code>为0，<code>j</code>为1，那么将<code>[7,9,20,30]</code>与<code>[1,4]</code>连续只需要4步</p>\\n<ol>\\n<li>将<code>30</code>放入<code>6</code>的位置，<code>[1,4,6,7,9,20]</code>；</li>\\n<li>将<code>20</code>放入<code>5</code>的位置，<code>[1,4,5,6,7,9]</code>；</li>\\n<li>将<code>9</code>放入<code>3</code>的位置，<code>[1,3,4,5,6,7]</code>；</li>\\n<li>将<code>7</code>放入<code>2</code>的位置，<code>[1,2,3,4,5,6]</code>，结束。</li>\\n</ol>\\n<p>区间内部连续：</p>\\n<p><code>[1,2,3,56,89]</code>，<code>i</code>为0，<code>j</code>为2，只需要2步</p>\\n<ol>\\n<li>将<code>89</code>放入<code>5</code>的位置，<code>[1,2,3,5,56]</code>；</li>\\n<li>将<code>56</code>放入<code>4</code>的位置，<code>[1,2,3,4,5]</code>，结束。</li>\\n</ol>\\n","content":"<p>在一个长度 <strong>无限 </strong>的数轴上，第 <code>i</code> 颗石子的位置为 <code>stones[i]</code>。如果一颗石子的位置最小/最大，那么该石子被称作 <strong>端点石子 </strong>。</p>\\n\\n<p>每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。</p>\\n\\n<p>值得注意的是，如果石子像 <code>stones = [1,2,5]</code> 这样，你将 <strong>无法 </strong>移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。</p>\\n\\n<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>\\n\\n<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[7,4,9]\\n<strong>输出：</strong>[1,2]\\n<strong>解释：</strong>\\n我们可以移动一次，4 -> 8，游戏结束。\\n或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[6,5,4,3,10]\\n<strong>输出：</strong>[2,3]\\n<strong>解释：</strong>\\n我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。\\n或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。\\n注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[100,101,104,102,103]\\n<strong>输出：</strong>[0,0]</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>3 <= stones.length <= 10^4</code></li>\\n\\t<li><code>1 <= stones[i] <= 10^9</code></li>\\n\\t<li><code>stones[i]</code> 的值各不相同。</li>\\n</ul>\\n\\n<p> </p>\\n","title":"1040. 移动石子直到连续 II","relatedTags":["数组","数学","双指针","排序"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1040","slug":"1040-Moving-Stones-Until-Consecutive-II"}')}}]);