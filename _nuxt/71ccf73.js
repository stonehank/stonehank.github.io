(window.webpackJsonp=window.webpackJsonp||[]).push([[1323],{2121:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">A</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> largestComponentSize = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">A</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-built_in\\">Math</span>.max.apply(<span class=\\"hljs-built_in\\">Math</span>,A)\\n  <span class=\\"hljs-keyword\\">let</span> primes=<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Set</span>()\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">2</span>;i&lt;=max;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(isPrime(i))primes.add(i)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> uf=<span class=\\"hljs-built_in\\">Array</span>(A.length).fill().map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">n,i</span>)=&gt;</span>i)\\n  <span class=\\"hljs-keyword\\">let</span> weight=<span class=\\"hljs-built_in\\">Array</span>(A.length).fill(<span class=\\"hljs-number\\">1</span>)\\n  <span class=\\"hljs-keyword\\">let</span> primeHash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;A.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> cur=A[i]\\n    <span class=\\"hljs-keyword\\">if</span>(primes.has(cur)){\\n      <span class=\\"hljs-keyword\\">if</span>(primeHash[cur]==<span class=\\"hljs-literal\\">null</span>)primeHash[cur]=[i]\\n      <span class=\\"hljs-keyword\\">else</span> primeHash[cur].push(i)\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> limit=<span class=\\"hljs-built_in\\">Math</span>.sqrt(cur)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">2</span>;k&lt;=limit;k++){\\n      <span class=\\"hljs-keyword\\">if</span>(cur % k===<span class=\\"hljs-number\\">0</span>){\\n        <span class=\\"hljs-keyword\\">let</span> p1=k,p2=cur/p1\\n        <span class=\\"hljs-keyword\\">if</span>(primes.has(p1)){\\n          <span class=\\"hljs-keyword\\">if</span>(primeHash[p1]==<span class=\\"hljs-literal\\">null</span>)primeHash[p1]=[i]\\n          <span class=\\"hljs-keyword\\">else</span> primeHash[p1].push(i)          \\n        }\\n        <span class=\\"hljs-keyword\\">if</span>(primes.has(p2)){\\n          <span class=\\"hljs-keyword\\">if</span>(primeHash[p2]==<span class=\\"hljs-literal\\">null</span>)primeHash[p2]=[i]\\n          <span class=\\"hljs-keyword\\">else</span> primeHash[p2].push(i)\\n        }\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k <span class=\\"hljs-keyword\\">in</span> primeHash){\\n    <span class=\\"hljs-keyword\\">let</span> arr=primeHash[k]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;arr.length<span class=\\"hljs-number\\">-1</span>;i++){\\n      connect(arr[i],arr[i+<span class=\\"hljs-number\\">1</span>])\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max.apply(<span class=\\"hljs-built_in\\">Math</span>,weight)\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">isPrime</span>(<span class=\\"hljs-params\\">num</span>)</span>{\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> p <span class=\\"hljs-keyword\\">of</span> primes){\\n      <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-built_in\\">Math</span>.pow(p,<span class=\\"hljs-number\\">2</span>)&gt;num)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-keyword\\">if</span>(num % p===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n    }    \\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n  }\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">find</span>(<span class=\\"hljs-params\\">i</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(i!==uf[i]){\\n      uf[i]=find(uf[i])\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> uf[i]\\n  }\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">connect</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> i=find(a),\\n        j=find(b)\\n    <span class=\\"hljs-keyword\\">if</span>(i===j)<span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">if</span>(weight[i]&lt;weight[j]){\\n      weight[j]+=weight[i]\\n      uf[i]=j\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      weight[i]+=weight[j]\\n      uf[j]=i\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"largest-component-size-by-common-factor","created_at":"2019-04-04","timeArr":[2019,3,4,0,40,47,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这道题求最大连通量，因此可以考虑使用<code>加权连通算法</code>，但如果对于每一个数，都去计算互相的<code>公因数</code>，肯定会超时。</p>\\n<p>因此，怎么去连通它们成为问题的关键。</p>\\n<p>如果每次计算公因数，最后算出来的公因数一定是质数的倍数，因此，干脆对每一个<code>A[i]</code>计算它包含了哪些质数。</p>\\n<p>计算<code>A[i]</code>的包含的质数的复杂度是<code>O(logA[i])</code>，当计算完毕后，可以得到一个这样的数据结构：</p>\\n<pre class=\\"hljs\\"><code>// 以质数为key，value为数组，数组内为索引\\n{\\n  2:[0,1,5,7,8],\\n  3:[1,5,7],\\n  5:[4,6],\\n  13:[2,3],\\n  ...\\n}\\n</code></pre>\\n<p>最后，我们对这个数据结构进行连通。</p>\\n","content":"<p>给定一个由不同正整数的组成的非空数组 <code>A</code>，考虑下面的图：</p>\\n\\n<ul>\\n\\t<li>有 <code>A.length</code> 个节点，按从 <code>A[0]</code> 到 <code>A[A.length - 1]</code> 标记；</li>\\n\\t<li>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j]</code> 之间才有一条边。</li>\\n</ul>\\n\\n<p>返回图中最大连通组件的大小。</p>\\n\\n<p> </p>\\n\\n<ol>\\n</ol>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[4,6,15,35]\\n<strong>输出：</strong>4\\n<img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex1.png\\" style=\\"height: 50px; width: 257px;\\" />\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[20,50,9,63]\\n<strong>输出：</strong>2\\n<img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex2.png\\" style=\\"height: 50px; width: 293px;\\" />\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[2,3,6,7,4,12,21,39]\\n<strong>输出：</strong>8\\n<img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex3.png\\" style=\\"height: 180px; width: 346px;\\" />\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li><code>1 <= A.length <= 20000</code></li>\\n\\t<li><code>1 <= A[i] <= 100000</code></li>\\n</ol>\\n","title":"952. 按公因数计算最大组件大小","relatedTags":["并查集","数组","数学"],"difficult":"Hard","lang":["javascript"],"uniqueID":"952","slug":"952-Largest-Component-Size-by-Common-Factor"}')}}]);