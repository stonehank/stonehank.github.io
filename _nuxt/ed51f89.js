(window.webpackJsonp=window.webpackJsonp||[]).push([[927],{1725:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">strs</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findLUSlength = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">strs</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> str <span class=\\"hljs-keyword\\">of</span> strs){\\n    <span class=\\"hljs-keyword\\">if</span>(hash[str]==<span class=\\"hljs-literal\\">null</span>)hash[str]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> hash[str]++\\n  }\\n  strs.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>b.length-a.length)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> s <span class=\\"hljs-keyword\\">of</span> strs){\\n    <span class=\\"hljs-keyword\\">if</span>(hash[s]&gt;<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">if</span>(!checkIsSubSeq(s))<span class=\\"hljs-keyword\\">return</span> s.length\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">checkIsSubSeq</span>(<span class=\\"hljs-params\\">sub</span>)</span>{\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;strs.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(strs[i]===sub)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">let</span> isSub=<span class=\\"hljs-literal\\">false</span>,k=<span class=\\"hljs-number\\">0</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;strs[i].length;j++){\\n        <span class=\\"hljs-keyword\\">if</span>(strs[i][j]===sub[k])k++\\n        <span class=\\"hljs-keyword\\">if</span>(k===sub.length)isSub=<span class=\\"hljs-literal\\">true</span>\\n      }\\n      <span class=\\"hljs-keyword\\">if</span>(isSub)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"longest-uncommon-subsequence-ii","created_at":"2019-03-25","timeArr":[2019,2,25,13,48,40,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<ol>\\n<li>使用<code>hash</code>保存每个字符串出现的次数。</li>\\n<li>排序，从最长的字符串开始检查，如果发现出现2次以上的字符串，直接<code>continue</code></li>\\n<li>检查当前字符串是否是其他字符串的子序列：\\n<ul>\\n<li>如果不是其他任何字符串的子序列，直接返回答案</li>\\n<li>否则继续检查</li>\\n</ul>\\n</li>\\n<li>最终没有结果，返回<code>-1</code></li>\\n</ol>\\n","content":"<p>给定字符串列表，你需要从它们中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>\\n\\n<p><strong>子序列</strong>可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>\\n\\n<p>输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre><strong>输入:</strong> &quot;aba&quot;, &quot;cdc&quot;, &quot;eae&quot;\\n<strong>输出:</strong> 3\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li>所有给定的字符串长度不会超过 10 。</li>\\n\\t<li>给定字符串列表的长度将在 [2, 50 ] 之间。</li>\\n</ol>\\n\\n<p>&nbsp;</p>\\n","title":"522. 最长特殊序列 II","relatedTags":["数组","哈希表","双指针","字符串","排序"],"difficult":"Middle","lang":["javascript"],"uniqueID":"522","slug":"522-Longest-Uncommon-Subsequence-II"}')}}]);