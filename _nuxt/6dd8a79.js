(window.webpackJsonp=window.webpackJsonp||[]).push([[579],{1377:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">a</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">b</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> checkPalindromeFormation = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">a, b</span>) </span>{\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">isP</span>(<span class=\\"hljs-params\\">str</span>)</span>{\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;str.length/<span class=\\"hljs-number\\">2</span>;i++){\\n            <span class=\\"hljs-keyword\\">if</span>(str[i]!==str[str.length-i<span class=\\"hljs-number\\">-1</span>])<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n        }\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(isP(a) || isP(b))<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">let</span> len=a.length\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n        <span class=\\"hljs-keyword\\">if</span>(a[i]!==b[len-i<span class=\\"hljs-number\\">-1</span>]){\\n            <span class=\\"hljs-keyword\\">let</span> rest1=b.slice(i,len-i)\\n            <span class=\\"hljs-keyword\\">let</span> rest2=a.slice(i,len-i)\\n            res=isP(rest1) || isP(rest2)\\n            <span class=\\"hljs-keyword\\">break</span>\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(res)<span class=\\"hljs-keyword\\">return</span> res\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n        <span class=\\"hljs-keyword\\">if</span>(b[i]!==a[len-i<span class=\\"hljs-number\\">-1</span>]){\\n            <span class=\\"hljs-keyword\\">let</span> rest1=b.slice(i,len-i)\\n            <span class=\\"hljs-keyword\\">let</span> rest2=a.slice(i,len-i)\\n            res=isP(rest1) || isP(rest2)\\n            <span class=\\"hljs-keyword\\">break</span>\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"split-two-strings-to-make-palindrome","created_at":"2020-10-17","timeArr":[2020,9,17,16,19,30,0],"hasThinking":false,"content":"<p>给你两个字符串 <code>a</code> 和 <code>b</code> ，它们长度相同。请你选择一个下标，将两个字符串都在 <strong>相同的下标 </strong>分割开。由 <code>a</code> 可以得到两个字符串： <code>a<sub>prefix</sub></code> 和 <code>a<sub>suffix</sub></code> ，满足 <code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub> </sub>，同理，由 <code>b</code> 可以得到两个字符串 <code>b<sub>prefix</sub></code> 和 <code>b<sub>suffix</sub></code> ，满足 <code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code> 。请你判断 <code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者 <code>b<sub>prefix</sub> + a<sub>suffix</sub></code> 能否构成回文串。</p>\\n\\n<p>当你将一个字符串 <code>s</code> 分割成 <code>s<sub>prefix</sub></code> 和 <code>s<sub>suffix</sub></code> 时， <code>s<sub>suffix</sub></code> 或者 <code>s<sub>prefix</sub></code> 可以为空。比方说， <code>s = \\"abc\\"</code> 那么 <code>\\"\\" + \\"abc\\"</code> ， <code>\\"a\\" + \\"bc\\" </code>， <code>\\"ab\\" + \\"c\\"</code> 和 <code>\\"abc\\" + \\"\\"</code> 都是合法分割。</p>\\n\\n<p>如果 <strong>能构成回文字符串</strong> ，那么请返回 <code>true</code>，否则返回<em> </em><code>false</code> 。</p>\\n\\n<p><strong>注意</strong>， <code>x + y</code> 表示连接字符串 <code>x</code> 和 <code>y</code> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<b>输入：</b>a = \\"x\\", b = \\"y\\"\\n<b>输出：</b>true\\n<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\\na<sub>prefix</sub> = \\"\\", a<sub>suffix</sub> = \\"x\\"\\nb<sub>prefix</sub> = \\"\\", b<sub>suffix</sub> = \\"y\\"\\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \\"\\" + \\"y\\" = \\"y\\" 是回文串。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>a = \\"abdef\\", b = \\"fecab\\"\\n<strong>输出：</strong>true\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<b>输入：</b>a = \\"ulacfd\\", b = \\"jizalu\\"\\n<b>输出：</b>true\\n<b>解释：</b>在下标为 3 处分割：\\na<sub>prefix</sub> = \\"ula\\", a<sub>suffix</sub> = \\"cfd\\"\\nb<sub>prefix</sub> = \\"jiz\\", b<sub>suffix</sub> = \\"alu\\"\\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \\"ula\\" + \\"alu\\" = \\"ulaalu\\" 是回文串。</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>a = \\"xbdef\\", b = \\"xecab\\"\\n<strong>输出：</strong>false\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= a.length, b.length <= 10<sup>5</sup></code></li>\\n\\t<li><code>a.length == b.length</code></li>\\n\\t<li><code>a</code> 和 <code>b</code> 都只包含小写英文字母</li>\\n</ul>\\n","title":"1616. 分割两个字符串得到回文串","relatedTags":["贪心","双指针","字符串"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1616","slug":"1616-Split-Two-Strings-to-Make-Palindrome"}')}}]);