(window.webpackJsonp=window.webpackJsonp||[]).push([[730],{1528:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> lengthOfLIS = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">arr</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> longestLens=<span class=\\"hljs-built_in\\">Array</span>(arr.length).fill(<span class=\\"hljs-number\\">1</span>)\\n  <span class=\\"hljs-keyword\\">let</span> preIndex=<span class=\\"hljs-number\\">0</span>,curIndex=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">while</span>(curIndex&lt;arr.length){\\n    <span class=\\"hljs-keyword\\">if</span>(arr[curIndex]&gt;arr[preIndex]){\\n      <span class=\\"hljs-keyword\\">let</span> curLen=longestLens[preIndex]+<span class=\\"hljs-number\\">1</span>\\n      longestLens[curIndex]=<span class=\\"hljs-built_in\\">Math</span>.max(longestLens[curIndex],curLen)\\n    }\\n    preIndex++\\n    <span class=\\"hljs-keyword\\">if</span>(preIndex===curIndex){\\n      preIndex=<span class=\\"hljs-number\\">0</span>\\n      curIndex++\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> maxLen=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;longestLens.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(longestLens[i]&gt;maxLen)maxLen=longestLens[i]\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> maxLen\\n};\\n</code></pre>\\n","<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">lengthOfLIS</span><span class=\\"hljs-params\\">(self, nums)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\"\\"\\"</span>\\n        <span class=\\"hljs-comment\\"># maxLen=0</span>\\n        <span class=\\"hljs-comment\\"># n=len(nums)</span>\\n        <span class=\\"hljs-comment\\"># dp=[1]*n</span>\\n        <span class=\\"hljs-comment\\"># for i in range(n):</span>\\n        <span class=\\"hljs-comment\\">#   cur=nums[i]</span>\\n        <span class=\\"hljs-comment\\">#   for j in range(0,i):</span>\\n        <span class=\\"hljs-comment\\">#     if nums[j]&lt;cur:</span>\\n        <span class=\\"hljs-comment\\">#       dp[i]=max(dp[i],dp[j]+1)</span>\\n        <span class=\\"hljs-comment\\">#   maxLen=max(dp[i],maxLen)</span>\\n        <span class=\\"hljs-comment\\"># return maxLen</span>\\n        \\n        <span class=\\"hljs-comment\\"># O(nlgn)</span>\\n        stack=[]\\n        <span class=\\"hljs-keyword\\">for</span> num <span class=\\"hljs-keyword\\">in</span> nums:\\n          <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">not</span> stack <span class=\\"hljs-keyword\\">or</span> stack[<span class=\\"hljs-number\\">-1</span>]&lt;num:\\n            stack.append(num)\\n          <span class=\\"hljs-keyword\\">elif</span> stack[<span class=\\"hljs-number\\">-1</span>]&gt;num:\\n            lo,hi=<span class=\\"hljs-number\\">0</span>,len(stack)<span class=\\"hljs-number\\">-1</span>\\n            <span class=\\"hljs-keyword\\">while</span> lo&lt;hi:\\n              mid=(lo+hi)//<span class=\\"hljs-number\\">2</span>\\n              <span class=\\"hljs-keyword\\">if</span> stack[mid]&lt;num:\\n                lo=mid+<span class=\\"hljs-number\\">1</span>\\n              <span class=\\"hljs-keyword\\">else</span>:\\n                hi=mid\\n            stack[lo]=num\\n        <span class=\\"hljs-keyword\\">return</span> len(stack)\\n</code></pre>\\n"],"querySlug":"longest-increasing-subsequence","hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这道题用<code>DP</code>解就是<code>O(n^2)</code>时间复杂度。</p>\\n<ul>\\n<li>创建一个<code>dp数组</code>，用来储存每个<code>index</code>及它之前的最长子序列，<code>dp[j]</code>会去检查前面的每一个<code>dp[i]</code>，如果<code>nums[i]&lt;nums[j]</code>，\\n那么<code>dp[j]=Math.max(dp[j],dp[i]+1)</code>。</li>\\n</ul>\\n<p>另外一个<code>O(nlgn)</code>的方法不太容易想到，需要搭建一个<code>单调递增数组</code>。</p>\\n<ul>\\n<li>\\n<p>维护一个数组<code>stack</code>，当<code>stack[-1]</code>比当前<code>nums[i]</code>小的时候，直接<code>append</code>，如果更大，需要二分搜索到<code>nums[i]</code>应该存在的位置，\\n并且替换，最终<code>stack</code>的长度就是最长结果。</p>\\n<p>例如<code>[1,3,6,7,9,4,10,5,6]</code></p>\\n<p>当<code>nums[i]</code>为<code>4</code>时，<code>stack</code>为<code>[1,3,6,7,9]</code>\\n当<code>nums[i]</code>为<code>10</code>时，<code>stack</code>为<code>[1,3,4,7,9]</code></p>\\n</li>\\n</ul>\\n","content":"<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\\n\\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\\n \\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\\n<strong>输出：</strong>4\\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\\n<strong>输出：</strong>4\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= nums.length <= 2500</code></li>\\n\\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><b>进阶：</b></p>\\n\\n<ul>\\n\\t<li>你可以设计时间复杂度为 <code>O(n<sup>2</sup>)</code> 的解决方案吗？</li>\\n\\t<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\\n</ul>\\n","title":"300. 最长递增子序列","relatedTags":["数组","二分查找","动态规划"],"difficult":"Middle","lang":["javascript","python"],"uniqueID":"300","slug":"300-Longest-Increasing-Subsequence"}')}}]);