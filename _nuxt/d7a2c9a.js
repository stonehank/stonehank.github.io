(window.webpackJsonp=window.webpackJsonp||[]).push([[1419],{706:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"jian-jie\\">简介</h2>\\n<p><code>unstated</code>是一个极简的状态管理组件</p>\\n<blockquote>\\n<p>看它的简介：State so simple, it goes without saying</p>\\n</blockquote>\\n<h2 id=\\"dui-bi\\">对比</h2>\\n<h3 id=\\"dui-bi-redux\\">对比redux</h3>\\n<ul>\\n<li><p>更加灵活(相对的缺点是缺少规则，需要使用者的自觉)</p>\\n<p>  <code>redux</code>的状态是存放在一棵树内，采用严格的单向流</p>\\n<p>  <code>unstated</code>的状态是用户自己定义，说白了就是<code>object</code>，可以放在一个组件的内，也可以放在多个组件内</p>\\n</li>\\n<li><p>针对<code>React</code>，一致的<code>API</code></p>\\n<p>  <code>redux</code>必须编写<code>reducer</code>和<code>action</code>，通过<code>dispatch(action)</code>改变状态，它不限框架</p>\\n<p>  <code>unstated</code><strong>改变状态的<code>API</code>完全与<code>React</code>一致</strong>，使用<code>this.setState</code>，当然和<code>React</code>的<code>setState</code>不同，\\n  但是它的底层也是用到了<code>setState</code>去更新视图</p>\\n</li>\\n<li><p>功能相对简单</p>\\n<p>  <code>unstated</code>没有中间件功能，每次状态改变(不管是否相等)，都会重新渲染(<code>V2.1.1</code>)</p>\\n<p>  可以自定义<code>listener</code>，每次更新状态时都会执行。</p>\\n</li>\\n</ul>\\n<h3 id=\\"dui-bi-react-de-zi-dai-state\\">对比React的自带state</h3>\\n<ul>\\n<li>天生将组件分割为<code>Container(状态管理)</code>和<code>Component(视图管理)</code></li>\\n<li>灵活配置共享状态或者私有状态</li>\\n<li>支持<code>promise</code></li>\\n</ul>\\n<h2 id=\\"chu-shi\\">初识</h2>\\n<p>3大板块和几个关键变量</p>\\n<pre><code><pre class=\\"hljs\\"><code>Provider: 注入状态实例，传递map，本质是Context.Provider，可嵌套达成链式传递\\nContainer: 状态管理类，遵循React的API，发布订阅模式，通过new生成状态管理实例\\nSubscribe: 订阅状态组件，本质是Context.Consumer，接收Provider提供的map，视图渲染组件\\nmap: new Map()，通过类查找当前类创建的状态管理实例</code></pre>\\n</code></pre>\\n<h2 id=\\"shen-ru\\">深入</h2>\\n<p>这里引入官方例子</p>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// @flow</span>\\n<span class=\\"hljs-keyword\\">import</span> React <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react\'</span>;\\n<span class=\\"hljs-keyword\\">import</span> { render } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'react-dom\'</span>;\\n<span class=\\"hljs-keyword\\">import</span> { Provider, Subscribe, Container } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'unstated\'</span>;\\n\\n<span class=\\"hljs-keyword\\">type</span> CounterState = {\\n  count: <span class=\\"hljs-built_in\\">number</span>\\n};\\n<span class=\\"hljs-comment\\">// 定义一个状态管理类</span>\\n<span class=\\"hljs-keyword\\">class</span> CounterContainer <span class=\\"hljs-keyword\\">extends</span> Container&lt;CounterState&gt; {\\n  state = {\\n    count: <span class=\\"hljs-number\\">0</span>\\n  };\\n\\n  increment() {\\n    <span class=\\"hljs-keyword\\">this</span>.setState({ count: <span class=\\"hljs-keyword\\">this</span>.state.count + <span class=\\"hljs-number\\">1</span> });\\n  }\\n\\n  decrement() {\\n    <span class=\\"hljs-keyword\\">this</span>.setState({ count: <span class=\\"hljs-keyword\\">this</span>.state.count - <span class=\\"hljs-number\\">1</span> });\\n  }\\n}\\n<span class=\\"hljs-comment\\">// 渲染视图组件(Context.Consumer的模式)</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">Counter</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;Subscribe to={[CounterContainer]}&gt;\\n      {<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">counter</span> =&gt;</span> (\\n        &lt;div&gt;\\n          &lt;button onClick={<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> counter.decrement()}&gt;-&lt;<span class=\\"hljs-regexp\\">/button&gt;\\n          &lt;span&gt;{counter.state.count}&lt;/</span>span&gt;\\n          &lt;button onClick={<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> counter.increment()}&gt;+&lt;<span class=\\"hljs-regexp\\">/button&gt;\\n        &lt;/</span>div&gt;\\n      )}\\n    &lt;<span class=\\"hljs-regexp\\">/Subscribe&gt;\\n  );\\n}\\n\\nrender(\\n  &lt;Provider&gt;\\n    &lt;Counter /</span>&gt;\\n  &lt;<span class=\\"hljs-regexp\\">/Provider&gt;,\\n  document.getElementById(\'root\')\\n);</span></code></pre>\\n</code></pre>\\n<p>这里<code>Counter</code>是我们自定义的视图组件，首先使用<code>&lt;Provider&gt;</code>包裹，接着在<code>Counter</code>内部，调用<code>&lt;Subscribe&gt;</code>组件，\\n传递一个数组给<code>props.to</code>，这个数组内存放了<code>Counter</code>组件需要使用的<code>状态管理类</code>(此处也可传递<code>状态管理实例</code>)。</p>\\n<h3 id=\\"provider\\">Provider</h3>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">Provider</span>(<span class=\\"hljs-params\\">props: ProviderProps</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> (\\n    &lt;StateContext.Consumer&gt;\\n      {<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">parentMap</span> =&gt;</span> {\\n        <span class=\\"hljs-keyword\\">let</span> childMap = <span class=\\"hljs-keyword\\">new</span> Map(parentMap);\\n        <span class=\\"hljs-comment\\">// 外部注入的状态管理实例</span>\\n        <span class=\\"hljs-keyword\\">if</span> (props.inject) {\\n          props.inject.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">instance</span> =&gt;</span> {\\n            childMap.set(instance.<span class=\\"hljs-keyword\\">constructor</span>, instance);\\n          });\\n        }\\n\\n        <span class=\\"hljs-comment\\">// 负责将childMap传递，初始为null</span>\\n        <span class=\\"hljs-keyword\\">return</span> (\\n          &lt;StateContext.Provider value={childMap}&gt;\\n            {props.children}\\n          &lt;<span class=\\"hljs-regexp\\">/StateContext.Provider&gt;\\n        );\\n      }}\\n    &lt;/</span>StateContext.Consumer&gt;\\n  );\\n}</code></pre>\\n</code></pre>\\n<p>这里的模式是</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Consumer&gt;\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>{\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n    <span class=\\"hljs-keyword\\">return</span> &lt;Provider&gt;{props.children}&lt;Provider /&gt;\\n  }\\n&lt;/Consumer&gt;  </code></pre>\\n</code></pre>\\n<p>有3个注意点：</p>\\n<ol>\\n<li><p>外层嵌套<code>&lt;Consumer&gt;</code>可以嵌套调用。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>&lt;Provider value={...}&gt;\\n <span class=\\"hljs-comment\\">/* ... */</span>\\n &lt;Provider value={此处继承了上面的value}&gt;\\n /* ... */ \\n&lt;/Provider&gt;</code></pre>\\n</code></pre>\\n</li>\\n<li><p><code>props.inject</code>可以注入现成的<code>状态管理实例</code>，添加到<code>map</code>之中。</p>\\n</li>\\n<li><p>返回值写成<code>props.children</code>。</p>\\n</li>\\n</ol>\\n<h3 id=\\"fan-hui-zhi-xie-cheng-propschildren-de-yi-yi\\">返回值写成props.children的意义</h3>\\n<p>简单一句话概括，这么写可以避免<code>React.Context</code>改变导致子组件的重复渲染。</p>\\n<p>具体看这里：<a href=\\"https://zhuanlan.zhihu.com/p/50336226\\">避免React Context导致的重复渲染</a></p>\\n<h3 id=\\"container\\">Container</h3>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Container&lt;State: {}&gt; {\\n  <span class=\\"hljs-comment\\">// 保存状态 默认为{}</span>\\n  state: State;\\n  <span class=\\"hljs-comment\\">// 保存监听函数，默认为[]</span>\\n  _listeners: <span class=\\"hljs-built_in\\">Array</span>&lt;Listener&gt; = [];\\n\\n  setState(\\n    updater: $Shape&lt;State&gt; | <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">(<span class=\\"hljs-params\\">prevState: $Shape&lt;State&gt;</span>) =&gt; $Shape&lt;State&gt;</span>),\\n    <span class=\\"hljs-params\\">callback</span>?: <span class=\\"hljs-params\\">()</span> =&gt;</span> <span class=\\"hljs-built_in\\">void</span>\\n  ): <span class=\\"hljs-built_in\\">Promise</span>&lt;<span class=\\"hljs-built_in\\">void</span>&gt; {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">let</span> nextState;\\n\\n      <span class=\\"hljs-comment\\">/* 利用Object.assign改变state */</span>\\n\\n      <span class=\\"hljs-comment\\">// 执行listener(promise)</span>\\n      <span class=\\"hljs-keyword\\">let</span> promises = <span class=\\"hljs-keyword\\">this</span>._listeners.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">listener</span> =&gt;</span> listener());\\n\\n      <span class=\\"hljs-comment\\">// 所有Promise执行完毕</span>\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Promise</span>.all(promises).then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n        <span class=\\"hljs-comment\\">// 全部listener执行完毕，执行回调</span>\\n        <span class=\\"hljs-keyword\\">if</span> (callback) {\\n          <span class=\\"hljs-keyword\\">return</span> callback();\\n        }\\n      });\\n    });\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 增加订阅(这里默认的订阅就是React的setState空值(为了重新渲染)，也可以添加自定义监听函数)</span>\\n  subscribe(fn: Listener) {\\n    <span class=\\"hljs-keyword\\">this</span>._listeners.push(fn);\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 取消订阅</span>\\n  unsubscribe(fn: Listener) {\\n    <span class=\\"hljs-keyword\\">this</span>._listeners = <span class=\\"hljs-keyword\\">this</span>._listeners.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">f</span> =&gt;</span> f !== fn);\\n  }\\n}</code></pre>\\n</code></pre>\\n<p><code>Container</code>内部逻辑很简单，改变<code>state</code>，执行监听函数。</p>\\n<p>其中有一个<code>_listeners</code>，是用于存放监听函数的。</p>\\n<p>每个<code>状态管理实例</code>存在一个默认监听函数<code>onUpdate</code>，\\n这个默认的监听函数的作用就是<code>调用React的setState强制视图重新渲染</code>。</p>\\n<p>这里的监听函数内部返回<code>Promise</code>，最后通过<code>Promise.all</code>确保执行完毕，然后执行<code>回调参数</code>。</p>\\n<p>因此<code>setState</code>在外面使用也可以使用<code>then</code>。</p>\\n<p>例如，在官方例子中：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>increment() {\\n    <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">count</span>: <span class=\\"hljs-keyword\\">this</span>.state.count + <span class=\\"hljs-number\\">1</span> },()=&gt;<span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'2\'</span>))\\n    .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'3\'</span>) )\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'1\'</span>) \\n  }\\n  <span class=\\"hljs-comment\\">// 执行顺序是 1 -&gt; 2 -&gt;3</span></code></pre>\\n</code></pre>\\n<p>2个注意点：</p>\\n<ol>\\n<li><p><code>setState</code>和<code>React API</code>一致，第一个参数传入object或者function，第二个传入回调</p>\\n</li>\\n<li><p>这里通过<code>Promise.resolve().then</code>模拟<code>this.setState</code>的异步执行</p>\\n</li>\\n</ol>\\n<h3 id=\\"guan-yu-promiseresolve-he-settimeout-de-qu-bie\\">关于Promise.resolve和setTimeout的区别</h3>\\n<p>简单的说两者都是异步调用，<code>Promise</code>更快执行。</p>\\n<ul>\\n<li><p><code>setTimeout(()=&gt;{},0)</code>会放入下一个新的<code>任务队列</code></p>\\n</li>\\n<li><p><code>Promise.resolve().then({})</code>会放入<code>微任务</code>，在调用栈为空时立刻补充调用栈并执行(简单理解为当前<code>任务队列</code>尾部)</p>\\n</li>\\n</ul>\\n<p>更多详细可以看这里提供的2个视频：<code>https://stackoverflow.com/a/38752743</code></p>\\n<h3 id=\\"subscribe\\">Subscribe</h3>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Subscribe&lt;Containers: ContainersType&gt; <span class=\\"hljs-keyword\\">extends</span> React.Component&lt;\\n  SubscribeProps&lt;Containers&gt;,\\n  SubscribeState\\n&gt; {\\n  state = {};\\n  <span class=\\"hljs-comment\\">// 存放传入的状态组件</span>\\n  instances: <span class=\\"hljs-built_in\\">Array</span>&lt;ContainerType&gt; = [];\\n  unmounted = <span class=\\"hljs-literal\\">false</span>;\\n\\n  componentWillUnmount() {\\n    <span class=\\"hljs-keyword\\">this</span>.unmounted = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">this</span>._unsubscribe();\\n  }\\n\\n  _unsubscribe() {\\n    <span class=\\"hljs-keyword\\">this</span>.instances.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">container</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// container为当前组件的每一个状态管理实例</span>\\n      <span class=\\"hljs-comment\\">// 删除listeners中的this.onUpdate</span>\\n      container.unsubscribe(<span class=\\"hljs-keyword\\">this</span>.onUpdate);\\n    });\\n  }\\n\\n  onUpdate: Listener = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Promise</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">resolve</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 组件未被卸载</span>\\n      <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>.unmounted) {\\n        <span class=\\"hljs-comment\\">// 纯粹是为了让React更新组件</span>\\n        <span class=\\"hljs-keyword\\">this</span>.setState(DUMMY_STATE, resolve);\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 已经被卸载则直接返回</span>\\n        resolve();\\n      }\\n    });\\n  };\\n  \\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>这里的关键就是<code>instances</code>，用于存放当前组件的<code>状态管理实例</code>。</p>\\n<p>当组件<code>unmount</code>的时候，会<code>unsubscribe</code>当前<code>状态管理实例</code>的默认监听函数，那么如果当前的<code>状态管理实例</code>是共享的，会不会有影响呢？</p>\\n<p>不会的。往后看可以知道，当<code>state</code>每次更新，都会重新创建新的<code>状态管理实例</code>(因为<code>props.to</code>的值可能会发生变化，例如取消某一个<code>状态管理实例</code>)，\\n而每次创建时，都会先<code>unsubscribe</code>再<code>subscribe</code>，确保不会重复添加监听函数。</p>\\n<p><code>onUpdate</code>就是创建<code>状态管理组件</code>时默认传递的监听函数，用的是<code>React</code>的<code>setState</code>更新一个<code>DUMMY_STATE</code>(空对象<code>{}</code>)。</p>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Subscribe&lt;Containers: ContainersType&gt; <span class=\\"hljs-keyword\\">extends</span> React.Component&lt;\\n  SubscribeProps&lt;Containers&gt;,\\n  SubscribeState\\n&gt; {\\n  <span class=\\"hljs-comment\\">/* 上面已讲 */</span>\\n\\n  _createInstances(\\n    map: ContainerMapType | <span class=\\"hljs-literal\\">null</span>,\\n    containers: ContainersType\\n  ): <span class=\\"hljs-built_in\\">Array</span>&lt;ContainerType&gt; {\\n    <span class=\\"hljs-comment\\">// 首先全部instances解除订阅</span>\\n    <span class=\\"hljs-keyword\\">this</span>._unsubscribe();\\n\\n    <span class=\\"hljs-comment\\">// 必须存在map 必须被Provider包裹才会有map</span>\\n    <span class=\\"hljs-keyword\\">if</span> (map === <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(\\n        <span class=\\"hljs-string\\">\'You must wrap your &lt;Subscribe&gt; components with a &lt;Provider&gt;\'</span>\\n      );\\n    }\\n\\n    <span class=\\"hljs-keyword\\">let</span> safeMap = map;\\n    <span class=\\"hljs-comment\\">// 重新定义当前组件的状态管理组件(根据to传入的数组)</span>\\n    <span class=\\"hljs-keyword\\">let</span> instances = containers.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">ContainerItem</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">let</span> instance;\\n\\n      <span class=\\"hljs-comment\\">// 传入的是Container组件，则使用</span>\\n      <span class=\\"hljs-keyword\\">if</span> (\\n        <span class=\\"hljs-keyword\\">typeof</span> ContainerItem === <span class=\\"hljs-string\\">\'object\'</span> &amp;&amp;\\n        ContainerItem <span class=\\"hljs-keyword\\">instanceof</span> Container\\n      ) {\\n        instance = ContainerItem;\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 传入的不是Container，可能是其他自定义组件等等(需要用new执行)，尝试获取</span>\\n        instance = safeMap.get(ContainerItem);\\n\\n        <span class=\\"hljs-comment\\">// 不存在则以它为key，value是新的Container组件</span>\\n        <span class=\\"hljs-keyword\\">if</span> (!instance) {\\n          instance = <span class=\\"hljs-keyword\\">new</span> ContainerItem();\\n          safeMap.set(ContainerItem, instance);\\n        }\\n      }\\n\\n      <span class=\\"hljs-comment\\">// 先解绑再绑定，避免重复订阅</span>\\n      instance.unsubscribe(<span class=\\"hljs-keyword\\">this</span>.onUpdate);\\n      instance.subscribe(<span class=\\"hljs-keyword\\">this</span>.onUpdate);\\n\\n      <span class=\\"hljs-keyword\\">return</span> instance;\\n    });\\n\\n    <span class=\\"hljs-keyword\\">this</span>.instances = instances;\\n    <span class=\\"hljs-keyword\\">return</span> instances;\\n  }\\n  \\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<p>在<code>_createInstances</code>内部，如果检查到传入的<code>props.to</code>的值已经是<code>状态管理实例</code>(私有状态组件)，那么直接使用即可，\\n如果传入的是<code>类class</code>(共享状态组件)，会尝试通过查询<code>map</code>，不存在的则通过<code>new</code>创建。</p>\\n<pre><code class=\\"language-typescript\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">class</span> Subscribe&lt;Containers: ContainersType&gt; <span class=\\"hljs-keyword\\">extends</span> React.Component&lt;\\n  SubscribeProps&lt;Containers&gt;,\\n  SubscribeState\\n&gt; {\\n  \\n  <span class=\\"hljs-comment\\">/* 上面已讲 */</span>\\n  \\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      &lt;StateContext.Consumer&gt;\\n      <span class=\\"hljs-comment\\">/* Provider传递的map */</span>\\n      {<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">map</span> =&gt;</span>\\n          <span class=\\"hljs-comment\\">// children是函数</span>\\n          <span class=\\"hljs-keyword\\">this</span>.props.children.apply(\\n            <span class=\\"hljs-literal\\">null</span>,\\n            <span class=\\"hljs-comment\\">// 传给子函数的参数(传进当前组件的状态管理实例)</span>\\n            <span class=\\"hljs-keyword\\">this</span>._createInstances(map, <span class=\\"hljs-keyword\\">this</span>.props.to)\\n          )\\n        }\\n      &lt;<span class=\\"hljs-regexp\\">/StateContext.Consumer&gt;\\n    );\\n  }\\n}</span></code></pre>\\n</code></pre>\\n<p>每一次<code>render</code>都会创建新的<code>状态管理实例</code>。</p>\\n<p>到此，3大板块已经阅读完毕。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<ol>\\n<li><p>简单易用，与<code>React</code>一致的<code>API</code>，一致的书写模式，让使用者很快上手。</p>\\n</li>\\n<li><p>并没有规定如何管理这些<code>状态管理类</code>，非常灵活。</p>\\n<p> 我们可以学<code>redux</code>将所有状态放到一个<code>共享状态管理实例</code>内部，\\n 例如通过<code>Provider</code>的<code>inject</code>属性注入，</p>\\n<p> 或者针对每一个组件创建单独的<code>状态管理实例</code>(可共享可独立)(<code>unstated</code>作者推荐)，</p>\\n<p> 一切可以按照自己的想法，但同时也要求使用者自己定义一些规则去约束写法。</p>\\n</li>\\n<li><p>仅仅是管理了状态，每次更新都是一个全新的<code>instance</code>集合，并没有做任何对比，需要我们在视图层自己实现。</p>\\n</li>\\n<li><p>返回值写成<code>props.children</code>的<a href=\\"#fan-hui-zhi-xie-cheng-propschildren-de-yi-yi\\">意义</a>。</p>\\n</li>\\n<li><p>关于<code>Promise.resolve().then({})</code>和<code>setTimeout(()=&gt;{},0)</code>的<a href=\\"#guan-yu-Promiseresolve-he-setTimeout-de-qu-bie\\">区别</a>。</p>\\n</li>\\n</ol>\\n<h2 id=\\"dao-tu\\">导图</h2>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.unstated/unstated.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"jian-jie","level":2,"text":"简介"},{"anchor":"dui-bi","level":2,"text":"对比"},{"anchor":"dui-bi-redux","level":3,"text":"对比redux"},{"anchor":"dui-bi-react-de-zi-dai-state","level":3,"text":"对比React的自带state"},{"anchor":"chu-shi","level":2,"text":"初识"},{"anchor":"shen-ru","level":2,"text":"深入"},{"anchor":"provider","level":3,"text":"Provider"},{"anchor":"fan-hui-zhi-xie-cheng-propschildren-de-yi-yi","level":3,"text":"返回值写成props.children的意义"},{"anchor":"container","level":3,"text":"Container"},{"anchor":"guan-yu-promiseresolve-he-settimeout-de-qu-bie","level":3,"text":"关于Promise.resolve和setTimeout的区别"},{"anchor":"subscribe","level":3,"text":"Subscribe"},{"anchor":"zong-jie","level":2,"text":"总结"},{"anchor":"dao-tu","level":2,"text":"导图"}],"relatedTags":["源码","react","promise","redux"],"created_at":"2018-12-08","timeArr":[2018,11,8,10,29,27,0],"title":"源码阅读-unstated","uuid":"1ec6d586c759db1ce817117277e391c08a8d1c01","summary":"<p>看它的简介：State so simple, it goes without saying</p>","slug":"source-code-unstated","sha":"471fa80d4139f88a0f770af34e991a0b73babacc"}')}}]);