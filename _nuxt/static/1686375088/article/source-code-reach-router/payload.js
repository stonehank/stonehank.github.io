__NUXT_JSONP__("/article/source-code-reach-router", (function(a,b){return {data:[{slug:b,articleDetails:{content:"\u003Ch1 id=\"source-codereach-router\"\u003Esource-code.reach-router\u003C\u002Fh1\u003E\n\u003Cp\u003Ev1.1.1\u003C\u002Fp\u003E\n\u003Ch2 id=\"chu-shi\"\u003E初识\u003C\u002Fh2\u003E\n\u003Cp\u003E一张导图：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.reach-router\u002FreachRouter.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E对几个亮点进行说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E匹配顺序\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E源码中是使用了一个评分的方法：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E先对路径去除头尾的\u003Ccode\u003E\u002F\u003C\u002Fcode\u003E ，并且按\u003Ccode\u003E\u002F\u003C\u002Fcode\u003E分割成路径片段数组\u003C\u002Fli\u003E\n\u003Cli\u003E对数组使用reduce方法计算分值，如下：\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Elet SEGMENT_POINTS = 4;     \u002F\u002F 基本分值，每一个路径片段都有\nlet STATIC_POINTS = 3;      \u002F\u002F 静态路径，如：\u002Fabc\nlet DYNAMIC_POINTS = 2;     \u002F\u002F 动态路径，如：\u002F:section\nlet SPLAT_PENALTY = 1;      \u002F\u002F 通配符（减分），如：\u002F*，此处遇到通配符会先减去基本分值，再减1分（优先权很低）\nlet ROOT_POINTS = 1;        \u002F\u002F 根路径\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n可知优先权排序为：\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E静态路径 &gt; 动态路径 &gt; 根路径 &gt; 通配符\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E相对路径\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E涉及到3个方法：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E.\u002Findex.js--&gt;createRoute\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E.\u002Flib\u002Futils.js--&gt;resolve\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E.\u002Flib\u002Futil.js--&gt;pick\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E首先是通过\u003Ccode\u003Ebasepath\u003C\u002Fcode\u003E(一个Router自定义属性，用作路径的公共前缀)结合每一个children(即Route Component)的path通过\u003Ccode\u003EcreateRoute\u003C\u002Fcode\u003E方法计算出一个绝对路径\u003C\u002Fp\u003E\n\u003Cp\u003E再通过\u003Ccode\u003Epick\u003C\u002Fcode\u003E方法与当前\u003Ccode\u003Epathname\u003C\u002Fcode\u003E(即window.location.pathname)进行匹配，计算得出一个非通配(*)路径匹配值(baseuri)，\u003Ccode\u003E例如：&#39;a\u002F*&#39; --&gt;匹配出 basuri:&#39;\u002Fa&#39;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这个baseuri会作为\u003Ccode\u003EBaseContext\u003C\u002Fcode\u003E(React.createContext)的context传递给内部组件，最后使用\u003Ccode\u003Eresolve\u003C\u002Fcode\u003E方法对Link上的to的路径(可能是绝对路径，也可能是相对路径)搭配\u003Ccode\u003Ebaseuri\u003C\u002Fcode\u003E进行解析(转换成绝对路径)，并且跳转\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E自动focus\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E对屏幕阅读器特别友好，每次通过Link跳转后，会自动focus到当前跳转对应的Component，也就是不需要再通过大量的tab按钮去寻找内容页面\u003C\u002Fp\u003E\n\u003Ch2 id=\"shen-ru\"\u003E深入\u003C\u002Fh2\u003E\n\u003Cp\u003E首先看源码最后，输出了什么：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Eexport {\n  Link,\n  Location,\n  LocationProvider,\n  Match,\n  Redirect,\n  Router,\n  ServerLocation,\n  createHistory,\n  createMemorySource,\n  isRedirect,\n  navigate,\n  redirectTo\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E而这些输出的组件有些是方法，有些是组件，它们的构造基本围绕着3个context，就是导图中的蓝，绿，红\u003C\u002Fp\u003E\n\u003Cp\u003E关于React中Provider和Consumer的2个特性：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EConsumer会获取离它最近的父元素Provider的context\u003C\u002Fli\u003E\n\u003Cli\u003E每当Provider内部value改变，其内部的Consumer都会被重新渲染\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E源码中对context结构的书写，都是Consumer包裹Provider，这就能形成：\n\u003Ccode\u003E最外层无context(无defaultValue的情况)，而嵌套层能获取上一层的Provider\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E因此对这3个context分析：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EBaseContext\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Econtext有默认值 &quot;\u002F&quot;：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Ebasepath       \u002F\u002F公共前缀路径，自定义\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Ebaseuri        \u002F\u002F非通配匹配路径，自动对路径匹配计算得出\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E只有Router包含BaseContext.Provider(在\u003Ccode\u003ERouterImpl\u003C\u002Fcode\u003E中渲染)\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003ERouterImpl\u003C\u002Fcode\u003E对每一个children(Route Component)进行当前\u003Ccode\u003Elocation\u003C\u002Fcode\u003E路径匹配，匹配成功的路径作为\u003Ccode\u003EBaseContext\u003C\u002Fcode\u003E的context，\n如果children内部还有children，会使用一个新的\u003Ccode\u003ERouter --&gt;primary=true\u003C\u002Fcode\u003E包裹内部的children\u003C\u002Fp\u003E\n\u003Cp\u003E因此只有被Router包裹的内部的标签才能获取到context值（当前的动态的basepath和baseuri）\u003C\u002Fp\u003E\n\u003Cp\u003E而Router外部的标签或者Router本身则为默认值&quot;\u002F&quot;\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ELocationContext\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Econtext无默认值\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Elocation       \u002F\u002FpushState的&quot;state&quot;，&quot;key&quot;(时间戳)，window.location的&quot;pathname&quot;和&quot;search&quot;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Enavigate        \u002F\u002F一个跳转方法，默认使用pushState，每次跳转都会自动更新location\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E首次渲染会加载\u003Ccode\u003ELocationProvider\u003C\u002Fcode\u003E，后续加载会直接调用\u003Ccode\u003Echildren(contnext)\u003C\u002Fcode\u003E，\u003C\u002Fp\u003E\n\u003Cp\u003E而\u003Ccode\u003ELocationProvider\u003C\u002Fcode\u003E通过history的listen方法绑定了每次调用navigate都会更新location，返回值是\u003Ccode\u003EProvider\u003C\u002Fcode\u003E，传递了location和navigate给context\u003C\u002Fp\u003E\n\u003Cp\u003E由于首次渲染是Router组件，Router中context为undefined，但它加载\u003Ccode\u003ELocationProvider\u003C\u002Fcode\u003E计算出context，\n后续渲染的组件则能获取到\u003Ccode\u003EProvider\u003C\u002Fcode\u003E的context\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EFocusContext\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Econtext无默认值\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003ErequestFocus       \u002F\u002F 是否需要自动获取焦点\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E在\u003Ccode\u003EBaseContext.Provider\u003C\u002Fcode\u003E内部渲染，而且要检查Router组件的\u003Ccode\u003Eprimary\u003C\u002Fcode\u003E属性是否为true，\u003Ccode\u003Eprimary\u003C\u002Fcode\u003E为true会渲染\u003Ccode\u003EFocusHandler\u003C\u002Fcode\u003E，否则默认渲染div\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EFocusHandler\u003C\u002Fcode\u003E内部就是Consumer包裹\u003Ccode\u003EFocusHandlerImpl\u003C\u002Fcode\u003E，通过pathname和uri进行判定，满足2个条件确定当前组件的\u003Ccode\u003EshouldFocus\u003C\u002Fcode\u003E属性为true：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Eurl路径有变动\u003C\u002Fli\u003E\n\u003Cli\u003E不为通配符(*)匹配路径，可以是动态匹配(:section)\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E当\u003Ccode\u003EshouldFocus\u003C\u002Fcode\u003E为true，便可通过context(即requestFocus)进行获取焦点，这里this.node就是这个\u003Ccode\u003EFocusHandlerImpl\u003C\u002Fcode\u003E返回值(div)的ref\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (requestFocus) {\n      requestFocus(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.node);\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E再看\u003Ccode\u003ErequestFocus\u003C\u002Fcode\u003E内部：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003ErequestFocus = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Enode\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 内部判断shouldFocus要为false\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.shouldFocus) {\n      node.focus();\n    }\n  };\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E内部判断\u003Ccode\u003EshouldFocus\u003C\u002Fcode\u003E要为false又是怎么回事呢？\u003C\u002Fp\u003E\n\u003Cp\u003E注意，此处的this是箭头函数静态绑定，也就是通过context传过来时的this，也就是父级FocusHandlerImpl的this\u003C\u002Fp\u003E\n\u003Cp\u003E而当子级的uri变化时，父级的uri是不变的（如果在同一个父级下），因此父级的\u003Ccode\u003EshouldFocus\u003C\u002Fcode\u003E是false，触发子级dom的focus\u003C\u002Fp\u003E\n\u003Cp\u003E如果不在同一个父级下，例如从父级a的子级a1, 直接跳转到父级b的子级b1，那么父级uri不同，父级的\u003Ccode\u003EshouldFocus\u003C\u002Fcode\u003E为true，不触发子级dom的focus\u003C\u002Fp\u003E\n\u003Cp\u003E而再去判断父级的父级的uri是否相等，当判断相同，父级的父级的\u003Ccode\u003EshouldFocus\u003C\u002Fcode\u003E为false，因此会触发父级(b)dom的focus\u003C\u002Fp\u003E\n\u003Cp\u003E见动图：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.reach-router\u002FreachRouter-Focus.gif\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Flpv0165m1q\"\u003E例子源码\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cul\u003E\n\u003Cli\u003Ehistory\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E其实大部分方法和组件都贯穿于上面3个context中，另还有一个history.js主要做了以下事情：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E判断当前平台，如果非浏览器，则模拟一个history对象，\u003C\u002Fli\u003E\n\u003Cli\u003E新建一个location方法，里面有pathname，search，state(pushState的参数1),key(跳转的时间戳)\u003C\u002Fli\u003E\n\u003Cli\u003E创建一个navigate方法，用于跳转，内部默认使用pushState和replaceState，会自动更新上面location对象\u003C\u002Fli\u003E\n\u003Cli\u003Eexport\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"liu-cheng\"\u003E流程\u003C\u002Fh2\u003E\n\u003Cp\u003E当点击Link---&gt;调用navigate---&gt;内部调用pushState---&gt;更新当前location---&gt;Router会更新context为最新的location\n---&gt;Router中将children的路径与当前pathname匹配---&gt;匹配成功的进行配置props和渲染\u003C\u002Fp\u003E\n",toc:[{anchor:"source-codereach-router",level:1,text:"source-code.reach-router"},{anchor:"chu-shi",level:a,text:"初识"},{anchor:"shen-ru",level:a,text:"深入"},{anchor:"liu-cheng",level:a,text:"流程"}],relatedTags:["源码","router","react"],created_at:"2018-07-15",timeArr:[2018,6,15,16,20,8,0],title:"源码阅读-reach-router",uuid:"d4c20e9d6e2481885bd702b49e92a75e20ff8bef",summary:"\u003Ch4\u003Esource-code.reach-router\u003C\u002Fh4\u003E\n\u003Cp\u003Ev1.1.1\u003C\u002Fp\u003E\n\u003Ch4\u003E初识\u003C\u002Fh4\u003E\n\u003Cp\u003E一张导图：\u003C\u002Fp\u003E\n\u003Cp\u003E![](https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.reach-router\u002FreachRouter...\u003C\u002Fp\u003E",slug:b,sha:"60c69717e8096ec7bcc17c42915f3fb679f32077"}}],fetch:{},mutations:void 0}}(2,"source-code-reach-router")));