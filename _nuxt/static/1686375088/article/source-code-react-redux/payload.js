__NUXT_JSONP__("/article/source-code-react-redux", (function(a,b,c,d,e){return {data:[{slug:d,articleDetails:{content:"\u003Cblockquote\u003E\n\u003Cp\u003E注意：文章很长，只想了解逻辑而不深入的，可以直接跳到最后的\u003Ca href=\"#zong-jie\"\u003E总结部分\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"chu-shi\"\u003E初识\u003C\u002Fh2\u003E\n\u003Cp\u003E首先，从它暴露对外的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E开始\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EReactReduxContext\n\u002F*\n提供了 React.createContext(null)\n*\u002F\n\nProvider  \n\u002F*\n一个储存数据的组件，渲染了ContextProvider，内部调用redux中store.subscribe\n订阅数据，每当redux中的数据变动，比较新值与旧值，判断是否重新渲染\n*\u002F \n\nconnect\n\u002F* \n一个高阶组件，第一阶传入对数据处理方法，第二阶传入要渲染的组件\n内部处理了：\n1. 对参数的检查\n2. 对传入的数据处理方法进行处理\n(没传怎么处理，传了提供什么参数，传的类型不同怎么处理，结果如何比较等等)\n3. 静态方法转移\n4. 对渲染组件的传递(传递给connectAdvanced)\n*\u002F\n\nconnectAdvanced\n\u002F*\n保存每一次执行的数据，执行connect定义的方案和逻辑，新旧数据对比(全等对比)，渲染组件\n这里作为公开API，如果我们去使用，那么connect里面的逻辑就需要我们自定义了。\n*\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E现在对它的大概工作范围有了解后，我们可以开始沿着执行顺序分析。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"chou-si\"\u003E抽丝\u003C\u002Fh2\u003E\n\u003Ch3 id=\"provider\"\u003EProvider\u003C\u002Fh3\u003E\n\u003Cp\u003E我们使用时，当写完了redux的\u003Ccode\u003Ereducer\u003C\u002Fcode\u003E, \u003Ccode\u003Eaction\u003C\u002Fcode\u003E, \u003Ccode\u003EbindActionCreators\u003C\u002Fcode\u003E, \u003Ccode\u003EcombineReducers\u003C\u002Fcode\u003E, \u003Ccode\u003EcreateStore\u003C\u002Fcode\u003E这一系列内容后，\n我们得到了一个\u003Ccode\u003Estore\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E会先使用\u003Ccode\u003E&lt;Provider store={store}\u003C\u002Fcode\u003E包裹住根组件。\u003C\u002Fp\u003E\n\u003Cp\u003E这时，\u003Ccode\u003EProvider\u003C\u002Fcode\u003E组件开始工作\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentDidMount() {\n  this._isMounted = true\n  this.subscribe()\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E第一次加载，需要执行\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E是什么呢，就是对\u003Ccode\u003Eredux\u003C\u002Fcode\u003E的\u003Ccode\u003Estore\u003C\u002Fcode\u003E执行\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E一个自定义函数，\n这样，每当数据变动，这个函数便会执行\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Esubscribe() {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { store } = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F redux 的 store 订阅\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 订阅后，每当state改变 则自动执行这个函数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unsubscribe = store.subscribe(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F store.getState() 获取最新的 state\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E newStoreState = store.getState()\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 组件未加载，取消\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._isMounted) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 比较state是否相等，全等的不更新\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EproviderState\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (providerState.storeState === newStoreState) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E\n      }\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E { \u003Cspan class=\"hljs-attr\"\u003EstoreState\u003C\u002Fspan\u003E: newStoreState }\n    })\n  })\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E看到吗，这个自定义函数非常简单，每次收到数据，进行全等比较，不等则更新数据。\u003C\u002Fp\u003E\n\u003Cp\u003E这个组件的另2个生命周期函数：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentWillUnmount() {\n  if (this.unsubscribe) this.unsubscribe()\n  this._isMounted = false\n}\n\ncomponentDidUpdate(prevProps) {\n  \u002F\u002F 比较store是否相等,如果相等则跳过\n  if (this.props.store !== prevProps.store) {\n    \u002F\u002F 取消订阅之前的，再订阅现在的(因为数据(store)不同了)\n    if (this.unsubscribe) this.unsubscribe()\n    this.subscribe()\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这2段的意思就是，每当数据变了，就取消上一次数据的订阅，在订阅本次的数据，\n当要销毁组件，取消订阅。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E一段题外话(可跳过)：\u003C\u002Fp\u003E\n\u003Cp\u003E这个逻辑用\u003Ccode\u003EHooks\u003C\u002Fcode\u003E的\u003Ccode\u003EuseEffect\u003C\u002Fcode\u003E简直完美匹配！\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EuseEffect(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E=&gt;\u003C\u002Fspan\u003E{\n  subscribe()\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E=&gt;\u003C\u002Fspan\u003E{\n    unSubscribe()\n  }\n},props.data)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这段的意思就是，当\u003Ccode\u003Eprops.data\u003C\u002Fcode\u003E发生改变，执行\u003Ccode\u003EunSubscribe()\u003C\u002Fcode\u003E，再执行\u003Ccode\u003Esubscribe()\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E逻辑完全一致有没有！\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E最后的\u003Ccode\u003Erender\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cp\u003E这里\u003Ccode\u003EContext\u003C\u002Fcode\u003E就是\u003Ccode\u003EReact.createContext(null)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E&lt;Context.Provider value={\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state}&gt;\n  {\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children}\n&lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002FContext.Provider&gt;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E到这里我称为\u003Ccode\u003Ereact-redux\u003C\u002Fcode\u003E的第一阶段。\u003C\u002Fp\u003E\n\u003Cp\u003E一个小总结，第一阶段就做了1件事：\u003C\u002Fp\u003E\n\u003Cp\u003E定义了\u003Ccode\u003EProvider\u003C\u002Fcode\u003E组件，内部订阅了\u003Ccode\u003Estore\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"connect\"\u003Econnect\u003C\u002Fh3\u003E\n\u003Cp\u003E到主菜了，先看它的\u003Ccode\u003Eexport\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eexport default createConnect()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E一看，我们应该有个猜测，这货\u003Ccode\u003EcreateConnect\u003C\u002Fcode\u003E是个高阶函数。\u003C\u002Fp\u003E\n\u003Cp\u003E看看它的参数吧。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateConnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E{\n  connectHOC = connectAdvanced,\n  mapStateToPropsFactories = defaultMapStateToPropsFactories,\n  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,\n  mergePropsFactories = defaultMergePropsFactories,\n  selectorFactory = defaultSelectorFactory\n} = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E题外话：一个编写默认对象内部含有默认值的方法\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Efunction a({x=1,y=2}={}){}\n\na()      \u002F\u002F x:1,y:2\na({})    \u002F\u002F x:1,y:2\na({x:2,z:5}) \u002F\u002Fx:2,y:2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这里先说明一下它的参数，后面读起来会很顺。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EconnectHOC: 一个重要组件，用于执行已确定的逻辑，渲染最终组件，后面会详细说。\nmapStateToPropsFactories: 对 mapStateToProps 这个传入的参数的类型选择一个合适的方法。\nmapDispatchToPropsFactories: 对 mapDispatchToProps 这个传入的参数的类型选择一个合适的方法。\nmergePropsFactories: 对 mergeProps 这个传入的参数的类型选择一个合适的方法。 \nselectorFactory: 以上3个只是简单的返回另一个合适的处理方法，它则执行这些处理方法，并且对结果定义了如何比较的逻辑。\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可能有点绕，但\u003Ccode\u003Ereact-redux\u003C\u002Fcode\u003E就是这么一个个高阶函数组成的，\u003Ccode\u003EselectorFactory\u003C\u002Fcode\u003E后面会详细说。\u003C\u002Fp\u003E\n\u003Cp\u003E首先我们再次确定这3个名字很长，实际很简单的函数(源码这里不放了)\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EmapStateToPropsFactories\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003EmapDispatchToPropsFactories\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003EmergePropsFactories\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E它们只是判断了参数是否存在，是什么类型，并且返回一个合适的处理方法，它们并没有任何处理逻辑。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E举个例子：\u003C\u002Fp\u003E\n\u003Cp\u003E  \u003Ccode\u003Econst MyComponent=connect((state)=&gt;state.articles})\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E  这里我只定义了\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E，并且是个\u003Ccode\u003Efunction\u003C\u002Fcode\u003E，那么\u003Ccode\u003EmapStateToPropsFactories\u003C\u002Fcode\u003E就会返回一个\n  处理\u003Ccode\u003Efunction\u003C\u002Fcode\u003E的方法。\u003C\u002Fp\u003E\n\u003Cp\u003E  我没有定义\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E，那么\u003Ccode\u003EmapDispatchToPropsFactories\u003C\u002Fcode\u003E检测不到参数，\n  则会提供一个默认值\u003Ccode\u003Edispatch =&gt; ({ dispatch })\u003C\u002Fcode\u003E，返回一个处理\u003Ccode\u003E非function\u003C\u002Fcode\u003E(object)的方法。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E那么处理逻辑是谁定义呢？\u003C\u002Fp\u003E\n\u003Ch4 id=\"wrapmaptoprops\"\u003EwrapMapToProps\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003EwrapMapToProps.js\u003C\u002Fcode\u003E这个文件内部做了以下事情：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E定义了一个处理\u003Ccode\u003Eobject\u003C\u002Fcode\u003E的方法(简单的返回即可，因为最终目的就是要object)。\u003C\u002Fli\u003E\n\u003Cli\u003E定义了一个处理\u003Ccode\u003E函数\u003C\u002Fcode\u003E和\u003Ccode\u003E高阶函数\u003C\u002Fcode\u003E(执行2次)的方法，这个方法比上面的复杂在于它需要检测参数是否订阅了\u003Ccode\u003EownProps\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E检测方法很简单，就是检查参数的\u003Ccode\u003Elength\u003C\u002Fcode\u003E（这里\u003Ccode\u003EdependsOnOwnProps\u003C\u002Fcode\u003E是上一次检查的结果，如果存在则不需要再次检查）\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EgetDependsOnOwnProps\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EmapToProps\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E mapToProps.dependsOnOwnProps !== \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E &amp;&amp;\n    mapToProps.dependsOnOwnProps !== \u003Cspan class=\"hljs-literal\"\u003Eundefined\u003C\u002Fspan\u003E\n    ? \u003Cspan class=\"hljs-built_in\"\u003EBoolean\u003C\u002Fspan\u003E(mapToProps.dependsOnOwnProps)\n    : mapToProps.length !== \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E回到connect，继续往下看\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateConnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E{\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F* 上面所讲的参数 *\u002F\u003C\u002Fspan\u003E\n} = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Econnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    {\n      pure = true,\n      areStatesEqual = strictEqual,\n      areOwnPropsEqual = shallowEqual,\n      areStatePropsEqual = shallowEqual,\n      areMergedPropsEqual = shallowEqual,\n      ...extraOptions\n    } = {}\n  \u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E已经到了我们传递参数的地方，前3个参数意思就不解释了，最后的参数\u003Ccode\u003Eoptions\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EareStatesEqual = strictEqual,           \u002F\u002F ===比较\nareOwnPropsEqual = shallowEqual,        \u002F\u002F 浅比较\nareStatePropsEqual = shallowEqual,      \u002F\u002F 浅比较\nareMergedPropsEqual = shallowEqual,     \u002F\u002F 浅比较\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E它们用在\u003Ccode\u003EselectorFactory\u003C\u002Fcode\u003E这个比较数据结果的方法内部。\u003C\u002Fp\u003E\n\u003Cp\u003E继续往下看\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateConnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E{\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n} = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Econnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n  \u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E initMapStateToProps = match(\n      mapStateToProps,\n      mapStateToPropsFactories,\n      \u003Cspan class=\"hljs-string\"\u003E'mapStateToProps'\u003C\u002Fspan\u003E\n    )\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E initMapDispatchToProps = match(\n      mapDispatchToProps,\n      mapDispatchToPropsFactories,\n      \u003Cspan class=\"hljs-string\"\u003E'mapDispatchToProps'\u003C\u002Fspan\u003E\n    )\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E initMergeProps = match(mergeProps, mergePropsFactories, \u003Cspan class=\"hljs-string\"\u003E'mergeProps'\u003C\u002Fspan\u003E)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里定义了3个变量(函数)，\u003Ccode\u003Ematch\u003C\u002Fcode\u003E的作用是什么？\u003C\u002Fp\u003E\n\u003Cp\u003E以\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E举例来说，\u003C\u002Fp\u003E\n\u003Cp\u003E因为上面也说了，\u003Ccode\u003EmapStateToPropsFactories\u003C\u002Fcode\u003E里面有多个方法，需要找到一个适合\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E的，\n\u003Ccode\u003Ematch\u003C\u002Fcode\u003E就是干这事了。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Ematch\u003C\u002Fcode\u003E方法内部遍历\u003Ccode\u003EmapStateToPropsFactories\u003C\u002Fcode\u003E所有的处理方法，任何一个方法能够匹配参数\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E，便被\u003Ccode\u003Ematch\u003C\u002Fcode\u003E捕获返回，\n如果一个都找不到则报错提示参数配置错误。\u003C\u002Fp\u003E\n\u003Cp\u003E现在这3个变量定义明确了，都是对应的参数的合适的处理方法。\u003C\u002Fp\u003E\n\u003Cp\u003E至此，我们已经完成了第二阶段，\u003C\u002Fp\u003E\n\u003Cp\u003E做个小总结，第二阶段做了哪些事：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Econnect\u003C\u002Fcode\u003E接收了对参数处理方案(3个\u003Ccode\u003E...Factories\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Econnect\u003C\u002Fcode\u003E接收了参数的结果比较方案(\u003Ccode\u003EselectFactory\u003C\u002Fcode\u003E)\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Econnect\u003C\u002Fcode\u003E接收了参数(\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E,\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E,\u003Ccode\u003EmergeProps\u003C\u002Fcode\u003E,\u003Ccode\u003Eoptions\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003Cli\u003E定义了比较方案(4个\u003Ccode\u003Eare...Equal\u003C\u002Fcode\u003E，其实就是\u003Ccode\u003E全等比较\u003C\u002Fcode\u003E和\u003Ccode\u003E浅比较\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E前2个阶段都是定义阶段，接下来需要我们传入自定义组件，也就是最后一个阶段\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Econnect(...)(Component)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E接着看\u003Ccode\u003Econnect\u003C\u002Fcode\u003E源码\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateConnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E{\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n} = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Econnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n  \u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E connectHOC(selectorFactory, {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 方法名称，用在错误提示信息\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-attr\"\u003EmethodName\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'connect'\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 最终渲染的组件名称\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-attr\"\u003EgetDisplayName\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Ename\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E`Connect(\u003Cspan class=\"hljs-subst\"\u003E${name}\u003C\u002Fspan\u003E)`\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-attr\"\u003EshouldHandleStateChanges\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003EBoolean\u003C\u002Fspan\u003E(mapStateToProps),\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 以下是传递给 selectFactory\u003C\u002Fspan\u003E\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps,\n      pure,\n      areStatesEqual,\n      areOwnPropsEqual,\n      areStatePropsEqual,\n      areMergedPropsEqual,\n\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F any extra options args can override defaults of connect or connectAdvanced\u003C\u002Fspan\u003E\n      ...extraOptions\n    })\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里执行了\u003Ccode\u003EconnectHOC()\u003C\u002Fcode\u003E，传递了上面已经讲过的参数，而\u003Ccode\u003EconnectHOC = connectAdvanced\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E因此我们进入最后一个对外\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，\u003Ccode\u003EconnectAdvanced\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"connectadvanced\"\u003EconnectAdvanced\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003EconnectAdvanced\u003C\u002Fcode\u003E函数，之前也提过，就是一个执行、组件渲染和组件更新的地方。\u003C\u002Fp\u003E\n\u003Cp\u003E它里面没有什么新概念，都是将我们上面讲到的参数进行调用，最后根据结果进行渲染新组件。\u003C\u002Fp\u003E\n\u003Cp\u003E还是从源码开始\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EconnectAdvanced\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  selectorFactory,\n  {\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 执行后作用于connect这个HOC组件名称\n    getDisplayName = name =&gt; \u003Cspan class=\"hljs-string\"\u003E`ConnectAdvanced(\u003Cspan class=\"hljs-subst\"\u003E${name}\u003C\u002Fspan\u003E)`\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 用于错误提示\n    methodName = \u003Cspan class=\"hljs-string\"\u003E'connectAdvanced'\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 有REMOVED标志，这里不关注\n    renderCountProp = undefined,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 确定connect这个HOC是否订阅state变动，好像已经没有用到了\n    shouldHandleStateChanges = true,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 有REMOVED标志，这里不关注\n    storeKey = \u003Cspan class=\"hljs-string\"\u003E'store'\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 有REMOVED标志，这里不关注\n    withRef = false,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 是否通过 forwardRef 暴露出传入的Component的DOM\n    forwardRef = false,\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E React的createContext\n    context = ReactReduxContext,\n\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 其余的(比较方法，参数处理方法等\u003C\u002Fspan\u003E)将会传递给上面的 \u003Cspan class=\"hljs-title\"\u003EselectFactory\u003C\u002Fspan\u003E\n    ...\u003Cspan class=\"hljs-title\"\u003EconnectOptions\u003C\u002Fspan\u003E\n  } = \u003C\u002Fspan\u003E{}\n) {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E参数也没什么特别的，有一个\u003Ccode\u003EforwardRef\u003C\u002Fcode\u003E作用就是能获取到我们传入的\u003Ccode\u003EComponent\u003C\u002Fcode\u003E的DOM。\n这里也不深入。\u003C\u002Fp\u003E\n\u003Cp\u003E接着看\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EconnectAdvanced\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...对参数的一些验证和提示哪些参数已经作废... *\u002F\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义Context\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E Context = context\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EwrapWithConnect\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EWrappedComponent\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...检查 WrappedComponent 是否符合要求... *\u002F\u003C\u002Fspan\u003E\n   \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...获取传入的WrappedComponent的名称... *\u002F\u003C\u002Fspan\u003E\n   \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...通过WrappedComponent的名称计算出当前HOC的名称... *\u002F\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...获取一些上面的参数(没有新的参数,都是之前见过的)... *\u002F\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Component就是React.Component\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E OuterBaseComponent = Component\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E FinalWrappedComponent = WrappedComponent\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 是否纯组件\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (pure) {\n      OuterBaseComponent = PureComponent\n    }\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 定义 makeDerivedPropsSelector 方法，作用后面讲 *\u002F\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 定义 makeChildElementSelector 方法，作用后面讲 *\u002F\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 定义 Connect 组件，作用后面讲 *\u002F\u003C\u002Fspan\u003E\n\n    Connect.WrappedComponent = WrappedComponent\n    Connect.displayName = displayName\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...如果是forWardRef 为true的情况，此处不深入... *\u002F\u003C\u002Fspan\u003E\n    \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 静态方法转换\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hoistStatics(Connect, WrappedComponent)\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这一段特别长，因此我将不太重要的直接用注释说明了它们在做什么，具体代码就不放了(不重要)。\u003C\u002Fp\u003E\n\u003Cp\u003E并且定义了3个新东西，\u003Ccode\u003EmakeDerivedPropsSelector\u003C\u002Fcode\u003E，\u003Ccode\u003EmakeChildElementSelector\u003C\u002Fcode\u003E,\u003Ccode\u003EConnect\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E先看最后一句\u003Ccode\u003EhoistStatics\u003C\u002Fcode\u003E就是\u003Ccode\u003Ehoist-non-react-statics\u003C\u002Fcode\u003E，它的作用是将组件\u003Ccode\u003EWrappedComponent\u003C\u002Fcode\u003E的所有非\u003Ccode\u003EReact\u003C\u002Fcode\u003E\n静态方法传递到\u003Ccode\u003EConnect\u003C\u002Fcode\u003E内部。\u003C\u002Fp\u003E\n\u003Cp\u003E那么最终它还是返回了一个\u003Ccode\u003EConnect\u003C\u002Fcode\u003E组件。\u003C\u002Fp\u003E\n\u003Ch4 id=\"connect-zu-jian\"\u003EConnect组件\u003C\u002Fh4\u003E\n\u003Cp\u003E这个组件已经是我们写了完整\u003Ccode\u003Econnect(...)(Component)\u003C\u002Fcode\u003E的返回值了，所以能确定，只要调用\u003Ccode\u003E&lt;Connect \u002F&gt;\u003C\u002Fcode\u003E，就能渲染出一个新的组件出来。\u003C\u002Fp\u003E\n\u003Cp\u003E因此它的功能就是确定是否重复更新组件和确定到底更新什么？\u003C\u002Fp\u003E\n\u003Cp\u003E看一个组件，从\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E看起\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EConnect\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EOuterBaseComponent\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(props) {\n    \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E(props)\n   \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...提示一些无用的参数...*\u002F\u003C\u002Fspan\u003E\n    \n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.selectDerivedProps = makeDerivedPropsSelector()\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.selectChildElement = makeChildElementSelector()\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.renderWrappedComponent = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.renderWrappedComponent.bind(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E)\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E绑定了一个方法，看名字是render的意思，先不管它。\u003C\u002Fp\u003E\n\u003Cp\u003E执行了2个函数。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EConnect\u003C\u002Fcode\u003E组件还没完，这里先放着，我们先看\u003Ccode\u003EmakeDerivedPropsSelector\u003C\u002Fcode\u003E和\u003Ccode\u003EmakeChildElementSelector\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"makederivedpropsselector\"\u003EmakeDerivedPropsSelector\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EmakeDerivedPropsSelector\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 闭包储存上一次的执行结果\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E lastProps\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E lastState\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E lastDerivedProps\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E lastStore\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E sourceSelector\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EselectDerivedProps\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Estate, props, store\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F props和state都和之前相等 直接返回上一次的结果\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (pure &amp;&amp; lastProps === props &amp;&amp; lastState === state) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E lastDerivedProps\n    }\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前store和lastStore不等，更新lastStore\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (store !== lastStore) {\n      lastStore = store\n      \n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 终于调用 selectorFactory 了\u003C\u002Fspan\u003E\n      sourceSelector = selectorFactory(\n        store.dispatch,\n        selectorFactoryOptions\n      )\n    }\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 更新数据\u003C\u002Fspan\u003E\n    lastProps = props\n    lastState = state\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回的就是最终的包含所有相应的 state 和 props 的结果\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E nextProps = sourceSelector(state, props)\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 最终的比较\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (lastDerivedProps === nextProps) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E lastDerivedProps\n    }\n    lastDerivedProps = nextProps\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E lastDerivedProps\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E大概的说，\u003Ccode\u003EmakeDerivedPropsSelector\u003C\u002Fcode\u003E的执行，先判断了当前传入的\u003Ccode\u003Eprops(组件的props)\u003C\u002Fcode\u003E和\u003Ccode\u003Estate(redux传入的state)\u003C\u002Fcode\u003E\n跟以前的是否全等，如果全等就不需要更新了；\u003C\u002Fp\u003E\n\u003Cp\u003E如果不等，则调用了高阶函数\u003Ccode\u003EselectFactory\u003C\u002Fcode\u003E，并且获得最终数据，最后再判断最终数据和之前的最终数据是否全等。\u003C\u002Fp\u003E\n\u003Cp\u003E为什么第一次判断了，还要判断第二次，而且都是\u003Ccode\u003E===\u003C\u002Fcode\u003E判断？\u003C\u002Fp\u003E\n\u003Cp\u003E因为第一次获取的\u003Ccode\u003Estate\u003C\u002Fcode\u003E是\u003Ccode\u003Eredux\u003C\u002Fcode\u003E传入的，是整个APP的所有数据，它们不等说明有组件更新了，但不确定是否是当前组件；\u003C\u002Fp\u003E\n\u003Cp\u003E第二次比较的是当前组件的最新数据和以前数据对比。\u003C\u002Fp\u003E\n\u003Cp\u003E现在，我们知道\u003Ccode\u003EselectFactory\u003C\u002Fcode\u003E的作用是获取当前组件的的最新数据，深入源码看看。\u003C\u002Fp\u003E\n\u003Ch4 id=\"selectfactory\"\u003EselectFactory\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EfinalPropsSelectorFactory\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E redux store的store.dispatch\n  dispatch,\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E种已经确定了的处理方法\n  { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }\n\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回一个针对用户传入的类型的解析函数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 例如 mapStateToProps 如果是function，那么就返回proxy，proxy可以判断是否需要ownProps，并且对高阶函数的 mapStateToProps 进行2次处理，\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 最终确保返回一个plainObject，否则报错\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E mapStateToProps = initMapStateToProps(dispatch, options)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E mapDispatchToProps = initMapDispatchToProps(dispatch, options)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E mergeProps = initMergeProps(dispatch, options)\n\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (process.env.NODE_ENV !== \u003Cspan class=\"hljs-string\"\u003E'production'\u003C\u002Fspan\u003E) {\n    verifySubselectors(\n      mapStateToProps,\n      mapDispatchToProps,\n      mergeProps,\n      options.displayName\n    )\n  }\n\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E selectorFactory = options.pure\n    ? pureFinalPropsSelectorFactory\n    : impureFinalPropsSelectorFactory\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认pure问题true，因此执行 pureFinalPropsSelectorFactory(...)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E selectorFactory(\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    dispatch,\n    options\n  )\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E参数就不说了，看注释。\u003C\u002Fp\u003E\n\u003Cp\u003E以下3个，到底返回了什么，源码在\u003Ccode\u003EwrapMapToProps.js\u003C\u002Fcode\u003E，\u003Ca href=\"#wrapMapToProps\"\u003E上面\u003C\u002Fa\u003E也说过这个文件内部做了什么事情。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Econst mapStateToProps = initMapStateToProps(dispatch, options)\nconst mapDispatchToProps = initMapDispatchToProps(dispatch, options)\nconst mergeProps = initMergeProps(dispatch, options)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这3个调用返回的一个函数，名字叫\u003Ccode\u003Eproxy\u003C\u002Fcode\u003E，这个\u003Ccode\u003Eproxy\u003C\u002Fcode\u003E一旦调用，\n就能返回经过\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E, \u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E, \u003Ccode\u003EmergeProps\u003C\u002Fcode\u003E这3个参数处理过后的数据(\u003Ccode\u003EplainObject\u003C\u002Fcode\u003E)。\u003C\u002Fp\u003E\n\u003Cp\u003E接下来：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E selectorFactory = options.pure\n    ? pureFinalPropsSelectorFactory\n    : impureFinalPropsSelectorFactory\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认pure问题true，因此执行 pureFinalPropsSelectorFactory(...)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E selectorFactory(\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    dispatch,\n    options\n  )\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E返回了\u003Ccode\u003EselectorFactory\u003C\u002Fcode\u003E的调用值，也就是\u003Ccode\u003EpureFinalPropsSelectorFactory\u003C\u002Fcode\u003E(pure默认为true)。\u003C\u002Fp\u003E\n\u003Cp\u003E看\u003Ccode\u003EpureFinalPropsSelectorFactory\u003C\u002Fcode\u003E，它的代码不少，但逻辑很明了，大方向就是对比数据。\u003C\u002Fp\u003E\n\u003Cp\u003E这里关键的如何比较不列代码，只用注释讲明白它的逻辑。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EpureFinalPropsSelectorFactory\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 接受\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E个proxy方法\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  dispatch,\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 接受\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E个比较方法\n  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }\n\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...定义变量保存之前的数据(闭包)... *\u002F\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EhandleFirstCall\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EfirstState, firstOwnProps\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...定义第一次执行数据比较的方法，也就是简单的赋值给上面定义的闭包变量... *\u002F\u003C\u002Fspan\u003E\n  }\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EhandleNewPropsAndNewState\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 当state和props都有变动时的处理方法 *\u002F\u003C\u002Fspan\u003E\n  }\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EhandleNewProps\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 当state无变动，props有变动时的处理方法 *\u002F\u003C\u002Fspan\u003E\n  }\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EhandleNewState\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 当state有变动，props无变动时的处理方法 *\u002F\u003C\u002Fspan\u003E\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 后续数据比较的方法\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EhandleSubsequentCalls\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EnextState, nextOwnProps\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 浅比较\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 全等比较\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E stateChanged = !areStatesEqual(nextState, state)\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 更新数据\u003C\u002Fspan\u003E\n    state = nextState\n    ownProps = nextOwnProps\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当发生不相等的3种情况(关键)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (propsChanged &amp;&amp; stateChanged) \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E handleNewPropsAndNewState()\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (propsChanged) \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E handleNewProps()\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (stateChanged) \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E handleNewState()\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 比较都相等，直接返回旧值\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E mergedProps\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EpureFinalPropsSelector\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EnextState, nextOwnProps\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E上面的闭包变量储存了上一次的数据，关键点就是当和这一次的数据比较后，如果处理更新。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Ereact-redux\u003C\u002Fcode\u003E将它分为3种情况\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Estate\u003C\u002Fcode\u003E和\u003Ccode\u003Eprops\u003C\u002Fcode\u003E都相等。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estate\u003C\u002Fcode\u003E相等，\u003Ccode\u003Eprops\u003C\u002Fcode\u003E不等。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estate\u003C\u002Fcode\u003E不等，\u003Ccode\u003Eprops\u003C\u002Fcode\u003E相等。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E第一种：\u003Ccode\u003Estate\u003C\u002Fcode\u003E和\u003Ccode\u003Eprops\u003C\u002Fcode\u003E都相等\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EmapStateToProps(proxy)：不管是否订阅\u003Ccode\u003EownProps\u003C\u002Fcode\u003E，执行\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E， 因为\u003Ccode\u003Estate\u003C\u002Fcode\u003E有变动。\u003C\u002Fli\u003E\n\u003Cli\u003EmapDispatchToProps(proxy)：  只有订阅了\u003Ccode\u003EownProps\u003C\u002Fcode\u003E，才会执行\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E，因为\u003Ccode\u003Estate\u003C\u002Fcode\u003E变动与\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E无影响。\u003C\u002Fli\u003E\n\u003Cli\u003EmergedProps(proxy)：  必定执行，将所有结果合并。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E第二种：\u003Ccode\u003Estate\u003C\u002Fcode\u003E相等，\u003Ccode\u003Eprops\u003C\u002Fcode\u003E不等\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EmapStateToProps(proxy)：只有订阅了\u003Ccode\u003EownProps\u003C\u002Fcode\u003E，才会执行\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E， 因为\u003Ccode\u003Estate\u003C\u002Fcode\u003E无变动。\u003C\u002Fli\u003E\n\u003Cli\u003EmapDispatchToProps(proxy)：  只有订阅了\u003Ccode\u003EownProps\u003C\u002Fcode\u003E，才会执行\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E，因为\u003Ccode\u003Estate\u003C\u002Fcode\u003E变动与\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E无影响。\u003C\u002Fli\u003E\n\u003Cli\u003EmergedProps(proxy)：  必定执行，将所有结果合并。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E第三种：\u003Ccode\u003Estate\u003C\u002Fcode\u003E不等，\u003Ccode\u003Eprops\u003C\u002Fcode\u003E相等\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EmapStateToProps(proxy)：  不管是否订阅\u003Ccode\u003EownProps\u003C\u002Fcode\u003E，执行\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E， 因为\u003Ccode\u003Estate\u003C\u002Fcode\u003E有变动。  注意，这里结果需要\u003Ccode\u003E浅比较\u003C\u002Fcode\u003E判断  因为如果没有\u003Ccode\u003E浅比较\u003C\u002Fcode\u003E检查，而两者刚好\u003Ccode\u003E浅比较相等\u003C\u002Fcode\u003E，\n  那么最后也会认为返回一个新的props，也就是相当于重复更新了。  之所以第一个\u003Ccode\u003Estate\u003C\u002Fcode\u003E和\u003Ccode\u003Eprops\u003C\u002Fcode\u003E都有变动的不需要浅比较检查，\n  是因为如果\u003Ccode\u003Eprops\u003C\u002Fcode\u003E变了，则必须要更新组件。\u003C\u002Fli\u003E\n\u003Cli\u003EmapDispatchToProps(proxy)：  不会执行，因为它只关注\u003Ccode\u003Eprops\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003EmergedProps(proxy)：  只有上面浅比较不等，才会执行。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Ccode\u003EmakeDerivedPropsSelector\u003C\u002Fcode\u003E的总结：\u003C\u002Fp\u003E\n\u003Cp\u003E通过闭包管理数据，并且通过浅比较和全等比较判断是否需要更新组件数据。\u003C\u002Fp\u003E\n\u003Ch4 id=\"makechildelementselector\"\u003EmakeChildElementSelector\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003EmakeChildElementSelector\u003C\u002Fcode\u003E也是一个高阶函数，储存了之前的\u003Ccode\u003E数据\u003C\u002Fcode\u003E和\u003Ccode\u003E组件\u003C\u002Fcode\u003E，并且判断与当前的判断。\u003C\u002Fp\u003E\n\u003Cp\u003E这里是最终渲染组件的地方，因为需要判断一下刚才最终给出的数据是否需要去更新组件。\u003C\u002Fp\u003E\n\u003Cp\u003E2个逻辑：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E数据与之前不等(\u003Ccode\u003E===\u003C\u002Fcode\u003E)，更新组件。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EforWardRef\u003C\u002Fcode\u003E属性值与之前不等，更新组件。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E否则，返回旧组件(不更新)。\u003C\u002Fp\u003E\n\u003Cp\u003E继续回到\u003Ccode\u003EConnect\u003C\u002Fcode\u003E组件。\u003C\u002Fp\u003E\n\u003Cp\u003E之后就是\u003Ccode\u003Erender\u003C\u002Fcode\u003E了\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Erender() {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F React的createContext\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ContextToUse = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.context || Context\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n    &lt;ContextToUse.Consumer&gt;\n      {this.renderWrappedComponent}\n    &lt;\u002FContextToUse.Consumer&gt;\n  )\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EContext.Consumer\u003C\u002Fcode\u003E内部必须是一个函数，这个函数的参数就是\u003Ccode\u003EContext.Provider\u003C\u002Fcode\u003E的\u003Ccode\u003Evalue\u003C\u002Fcode\u003E，也就是\u003Ccode\u003Eredux\u003C\u002Fcode\u003E的\u003Ccode\u003Estore\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch4 id=\"renderwrappedcomponent\"\u003ErenderWrappedComponent\u003C\u002Fh4\u003E\n\u003Cp\u003E最后一个函数：\u003Ccode\u003ErenderWrappedComponent\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003ErenderWrappedComponent(value) {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ...验证参数有效性... *\u002F\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里 storeState=store.getState()\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { storeState, store } = value\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 传入自定义组件的props\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E wrapperProps = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props\n  \n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E forwardedRef\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (forwardRef) {\n    wrapperProps = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.wrapperProps\n    forwardedRef = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.forwardedRef\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 上面已经讲了，返回最终数据\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E derivedProps = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.selectDerivedProps(\n    storeState,\n    wrapperProps,\n    store\n  )\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回最终渲染的自定义组件\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.selectChildElement(derivedProps, forwardedRef)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E总算结束了，可能有点混乱，做个总结吧。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"zong-jie\"\u003E总结\u003C\u002Fh2\u003E\n\u003Cp\u003E我把\u003Ccode\u003Ereact-redux\u003C\u002Fcode\u003E的执行流程分为3个阶段，分别对应我们的代码编写(搭配导图阅读)\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E一张导图：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.react-redux\u002FReact-Redux.png\" alt=\"react-redux导图 by stonehank\"\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E第一阶段：\u003C\u002Fp\u003E\n\u003Cp\u003E对应的用户代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E&lt;Provider store={store}&gt;\n  &lt;App \u002F&gt;\n&lt;\u002FProvider&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E执行内容有：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E定义了\u003Ccode\u003EProvider\u003C\u002Fcode\u003E组件，这个组件内部订阅了\u003Ccode\u003Eredux\u003C\u002Fcode\u003E的\u003Ccode\u003Estore\u003C\u002Fcode\u003E，保证当\u003Ccode\u003Estore\u003C\u002Fcode\u003E发生变动，会立刻执行更新。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Chr\u003E\n\u003Cp\u003E第二阶段：\u003C\u002Fp\u003E\n\u003Cp\u003E对应的用户代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Econnect(mapStateToProps,mapDispatchToProps,mergeProps,options)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E执行内容有：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Econnect\u003C\u002Fcode\u003E接收了参数(\u003Ccode\u003EmapStateToProps\u003C\u002Fcode\u003E,\u003Ccode\u003EmapDispatchToProps\u003C\u002Fcode\u003E,\u003Ccode\u003EmergeProps\u003C\u002Fcode\u003E,\u003Ccode\u003Eoptions\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Econnect\u003C\u002Fcode\u003E接收了对参数如何处理方案(3个\u003Ccode\u003E...Factories\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Econnect\u003C\u002Fcode\u003E接收了参数的结果比较方案(\u003Ccode\u003EselectFactory\u003C\u002Fcode\u003E)\u003C\u002Fli\u003E\n\u003Cli\u003E定义了比较方案(4个\u003Ccode\u003Eare...Equal\u003C\u002Fcode\u003E，其实就是\u003Ccode\u003E全等比较\u003C\u002Fcode\u003E和\u003Ccode\u003E浅比较\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Chr\u003E\n\u003Cp\u003E第三阶段：\u003C\u002Fp\u003E\n\u003Cp\u003E对应的用户代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Elet newComponent=connect(...)(Component)\n\n&lt;newComponent \u002F&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E执行内容有：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E接受自定义组件(\u003Ccode\u003EComponent\u003C\u002Fcode\u003E)。\u003C\u002Fli\u003E\n\u003Cli\u003E创建一个\u003Ccode\u003EConnect\u003C\u002Fcode\u003E组件。\u003C\u002Fli\u003E\n\u003Cli\u003E将\u003Ccode\u003EComponent\u003C\u002Fcode\u003E的非\u003Ccode\u003EReact\u003C\u002Fcode\u003E静态方法转移到\u003Ccode\u003EConnect\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E获取\u003Ccode\u003EProvider\u003C\u002Fcode\u003E传入的\u003Ccode\u003E数据\u003C\u002Fcode\u003E(\u003Ccode\u003Eredux\u003C\u002Fcode\u003E的整个数据)，利用闭包保存数据，用于和未来数据做比较。\u003C\u002Fli\u003E\n\u003Cli\u003E当比较(\u003Ccode\u003E===\u003C\u002Fcode\u003E)有变动，执行上一阶段传入的参数，获取当前组件真正的数据。\u003C\u002Fli\u003E\n\u003Cli\u003E利用闭包保存当前组件真正的数据，用于和未来作比较。\u003C\u002Fli\u003E\n\u003Cli\u003E通过全等和浅比较，处理\u003Ccode\u003Estate\u003C\u002Fcode\u003E变动和\u003Ccode\u003Eprops\u003C\u002Fcode\u003E变动的逻辑，判断返回新数据还是旧数据。\u003C\u002Fli\u003E\n\u003Cli\u003E利用闭包保存渲染的组件，通过上面返回的最终数据，判断需要返回新组件还是就组件。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E逻辑理顺了，还是很好理解的。\u003C\u002Fp\u003E\n\u003Cp\u003E其中第三阶段就是对外API\u003Ccode\u003EconnectAdvanced\u003C\u002Fcode\u003E的执行内容。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fstonehank\u002Fsourcecode-analysis\"\u003E此处\u003C\u002Fa\u003E查看更多前端源码阅读内容。\u003C\u002Fp\u003E\n\u003Cp\u003E或许哪一天，我们需要设计一个专用的数据管理系统，那么就利用好\u003Ccode\u003EconnectAdvanced\u003C\u002Fcode\u003E，\n我们要做的就是编写一个自定义\u003Ccode\u003E第二阶段\u003C\u002Fcode\u003E的逻辑体系。\u003C\u002Fp\u003E\n\u003Cp\u003E感谢阅读！\u003C\u002Fp\u003E\n",toc:[{anchor:"chu-shi",level:b,text:"初识"},{anchor:"chou-si",level:b,text:"抽丝"},{anchor:"provider",level:c,text:"Provider"},{anchor:e,level:c,text:e},{anchor:"wrapmaptoprops",level:a,text:"wrapMapToProps"},{anchor:"connectadvanced",level:c,text:"connectAdvanced"},{anchor:"connect-zu-jian",level:a,text:"Connect组件"},{anchor:"makederivedpropsselector",level:a,text:"makeDerivedPropsSelector"},{anchor:"selectfactory",level:a,text:"selectFactory"},{anchor:"makechildelementselector",level:a,text:"makeChildElementSelector"},{anchor:"renderwrappedcomponent",level:a,text:"renderWrappedComponent"},{anchor:"zong-jie",level:b,text:"总结"}],relatedTags:["源码","react","redux"],created_at:"2018-11-19",timeArr:[2018,10,19,15,39,31,0],title:"源码阅读-react-redux",uuid:"61fc5f70332f76ba26036558a7f1f43790ca025b",summary:"\u003Cp\u003E注意：文章很长，只想了解逻辑而不深入的，可以直接跳到最后的\u003Ca href=\"#zong-jie\"\u003E总结部分\u003C\u002Fa\u003E。\u003C\u002Fp\u003E",slug:d,sha:"53f1636d897b807f6392f3fa5cdce56274193679"}}],fetch:{},mutations:void 0}}(4,2,3,"source-code-react-redux","connect")));