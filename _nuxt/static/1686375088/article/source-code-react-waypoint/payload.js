__NUXT_JSONP__("/article/source-code-react-waypoint", (function(a,b){return {data:[{slug:a,articleDetails:{content:"\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ccode\u003Ereact-waypoint\u003C\u002Fcode\u003E用于监控元素是否出现在用户定义的视口范围内。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"chu-shi\"\u003E初识\u003C\u002Fh3\u003E\n\u003Cp\u003E源码逻辑写的并不复杂，这里基本就不放源码，主要概述一下源码做了些什么事情。\u003C\u002Fp\u003E\n\u003Cp\u003E此源码内部相关知识\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EonNextTick\u003C\u002Fcode\u003E作用和如何定义\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EgetBoundingClientRect\u003C\u002Fcode\u003E的使用\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EgetComputedStyle\u003C\u002Fcode\u003E的作用\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EaddEventListener\u003C\u002Fcode\u003E中\u003Ccode\u003E{passive:true}\u003C\u002Fcode\u003E的作用\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EReact.cloneElement\u003C\u002Fcode\u003E的使用\u003C\u002Fli\u003E\n\u003Cli\u003E如果用户传递的是\u003Ccode\u003EReact组件\u003C\u002Fcode\u003E不是\u003Ccode\u003EDOM\u003C\u002Fcode\u003E，需要编写\u003Ccode\u003EForwardRef\u003C\u002Fcode\u003E或者\u003Ccode\u003EInnerRef\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"zheng-ti-liu-cheng\"\u003E整体流程\u003C\u002Fh3\u003E\n\u003Chr\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentWillMount() {\n  ensureChildrenIsValid(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children);\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EensureChildrenIsValid\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Echildren\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (children) {\n    \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n      React.Children.only(children);\n    } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E (e) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EError\u003C\u002Fspan\u003E(errorMessage);\n    }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里组件加载前就通过\u003Ccode\u003EReact.Children.only\u003C\u002Fcode\u003E检查用户传入的\u003Ccode\u003Echildren\u003C\u002Fcode\u003E，保证必须唯一的子元素，并且不能是\u003Ccode\u003ETEXT\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E在\u003Ccode\u003EcomponentDidMount\u003C\u002Fcode\u003E内部，\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E使用了\u003Ccode\u003EonNextTick\u003C\u002Fcode\u003E， 一个将任务加入队列执行的方案，通过\u003Ccode\u003EsetTimeout(()=&gt;{},0)\u003C\u002Fcode\u003E的使用：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E可以在任务开始前停止。\u003C\u002Fli\u003E\n\u003Cli\u003E确保\u003Ccode\u003Eref\u003C\u002Fcode\u003E能完全获取。\u003C\u002Fli\u003E\n\u003Cli\u003E任务之间不会冲突。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Ccode\u003EonNextTick\u003C\u002Fcode\u003E源码不复杂，却很实用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E timeout;\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E timeoutQueue = [];\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EonNextTick\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ecb\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 放入队列\u003C\u002Fspan\u003E\n  timeoutQueue.push(cb);\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!timeout) {\n    timeout = setTimeout(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      timeout = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E item;\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F eslint-disable-next-line no-cond-assign\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E (item = timeoutQueue.shift()) {\n        item();\n      }\n    }, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E);\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E isSubscribed = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回一个取消函数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eunsubscribe\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!isSubscribed) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E;\n    }\n    isSubscribed = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E index = timeoutQueue.indexOf(cb);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 需要取消的任务已经执行完毕，发挥\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (index === \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E;\n    }\n    timeoutQueue.splice(index, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果任务队列无任务 并且 计时器还存在，清除计时器\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!timeoutQueue.length &amp;&amp; timeout) {\n      clearTimeout(timeout);\n      timeout = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n    }\n  };\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E确认ref能有效获取到children\u003C\u002Fp\u003E\n\u003Cp\u003E  通过\u003Ccode\u003Eref\u003C\u002Fcode\u003E获取子元素的\u003Ccode\u003EDOM\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E子元素是\u003Ccode\u003EDOM\u003C\u002Fcode\u003E（最容易获取）\u003C\u002Fli\u003E\n\u003Cli\u003E子元素是组件，尝试通过\u003Ccode\u003EForwardRef\u003C\u002Fcode\u003E获取，如果子组件不是\u003Ccode\u003EForwardRef\u003C\u002Fcode\u003E，通过\u003Ccode\u003EinnerRef\u003C\u002Fcode\u003E获取\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E父元素获取\u003C\u002Fp\u003E\n\u003Cp\u003E  通过子元素的\u003Ccode\u003EparentNode\u003C\u002Fcode\u003E向上遍历，直到找到\u003Ccode\u003Eoverflow\u003C\u002Fcode\u003E为\u003Ccode\u003Eauto\u003C\u002Fcode\u003E或者\u003Ccode\u003Escroll\u003C\u002Fcode\u003E，否则设置为\u003Ccode\u003Ewindow\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E  通过\u003Ccode\u003EgetComputedStyle\u003C\u002Fcode\u003E去获取\u003Ccode\u003Eoverflow\u003C\u002Fcode\u003E的值。（此处并不完美，依赖用户自觉）\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E绑定\u003Ccode\u003Escroll\u003C\u002Fcode\u003E和\u003Ccode\u003Eresize\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E  选项\u003Ccode\u003E{passive:true}\u003C\u002Fcode\u003E，这能让浏览器在处理事件时不去检测是否存在\u003Ccode\u003EpreventDefault\u003C\u002Fcode\u003E，事件处理更加流畅。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cp\u003E接着是\u003Ccode\u003E_handleScroll\u003C\u002Fcode\u003E，即事件绑定的方法\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E内部存在\u003Ccode\u003E_getBounds\u003C\u002Fcode\u003E和\u003Ccode\u003EgetCurrentPosition\u003C\u002Fcode\u003E，作用是判断子元素是否出现在规定范围内\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E用户定义2个属性：\u003Ccode\u003EtopOffset\u003C\u002Fcode\u003E和\u003Ccode\u003EbottomOffset\u003C\u002Fcode\u003E，可以理解为\u003Ccode\u003E上边线\u003C\u002Fcode\u003E和\u003Ccode\u003E下边线\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E通过\u003Ccode\u003EgetBoundingClientRect\u003C\u002Fcode\u003E，计算出\u003Ccode\u003E子元素\u003C\u002Fcode\u003E顶端和底端到\u003Ccode\u003E视口\u003C\u002Fcode\u003E顶端的距离\u003C\u002Fli\u003E\n\u003Cli\u003E通过\u003Ccode\u003E上\u002F下边线\u003C\u002Fcode\u003E和\u003Ccode\u003E父元素\u003C\u002Fcode\u003E的高度和\u003Ccode\u003E父元素\u003C\u002Fcode\u003E顶端到视口顶端的距离，计算出\u003Ccode\u003E上\u002F下边线\u003C\u002Fcode\u003E分别距离视口顶端的距离\u003C\u002Fli\u003E\n\u003Cli\u003E对比以上2个数据，分别赋予当前\u003Ccode\u003E子元素\u003C\u002Fcode\u003E的4种位置状态：\u003Ccode\u003Einvisible\u003C\u002Fcode\u003E，\u003Ccode\u003Einside\u003C\u002Fcode\u003E，\u003Ccode\u003Ebelow\u003C\u002Fcode\u003E，\u003Ccode\u003Eabove\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E通过保存当前位置，每次事件后对比与上一次的位置关系，执行对应的\u003Ccode\u003Eenter\u003C\u002Fcode\u003E和\u003Ccode\u003Eleave\u003C\u002Fcode\u003E钩子函数。\u003C\u002Fp\u003E\n\u003Cp\u003E 一个亮点：\u003Ccode\u003EfireOnRapidScroll\u003C\u002Fcode\u003E，用于判断是否急速滑动。\u003C\u002Fp\u003E\n\u003Cp\u003E 如果\u003Ccode\u003Escroll\u003C\u002Fcode\u003E执行过快，有可能子元素上一次事件还在\u003Ccode\u003Ebelow\u003C\u002Fcode\u003E，这一次已经是\u003Ccode\u003Eabove\u003C\u002Fcode\u003E，当出现这样的情况，\n 会强制执行\u003Ccode\u003Eenter\u003C\u002Fcode\u003E和\u003Ccode\u003Eleave\u003C\u002Fcode\u003E事件。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Chr\u003E\n\u003Cp\u003E最后是\u003Ccode\u003Erender\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E当组件接收到\u003Ccode\u003Ethis.props.children\u003C\u002Fcode\u003E，并且\u003Ccode\u003Echildren\u003C\u002Fcode\u003E本身是一个组件时，无法直接在上面添加属性的，\n因为不能这么写\u003Ccode\u003E&lt;this.props.children prop={xxx} \u002F&gt;\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E例如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E&lt;App&gt;\n  &lt;Child \u002F&gt;\n&lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002FApp&gt;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在不改变输入格式的情况，使用\u003Ccode\u003EReact.cloneElement\u003C\u002Fcode\u003E可以修改它的属性，当然原理是复制，意思是内存中存在2个\u003Ccode\u003Echildren\u003C\u002Fcode\u003E了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n  React.cloneElement(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children,{\u003Cspan class=\"hljs-attr\"\u003EextraProp\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E})\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Cp\u003E可能存在的缺陷：\u003C\u002Fp\u003E\n\u003Cp\u003E当存在一个很长的\u003Ccode\u003Eul\u003C\u002Fcode\u003E列表，而给\u003Ccode\u003Eul\u003C\u002Fcode\u003E添加了\u003Ccode\u003Eoverflow:auto\u003C\u002Fcode\u003E，但并未设置\u003Ccode\u003Eheight\u003C\u002Fcode\u003E，这时\u003Ccode\u003Eul\u003C\u002Fcode\u003E并不是一个滚动组件，\n真正的滚动还是触发在\u003Ccode\u003Ewindow\u003C\u002Fcode\u003E，但\u003Ccode\u003Ewaypoint\u003C\u002Fcode\u003E会因为存在属性\u003Ccode\u003Eoverflow:auto\u003C\u002Fcode\u003E，而将\u003Ccode\u003Eul\u003C\u002Fcode\u003E认为是滚动组件父元素。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Fly9y4v9m5m\"\u003E例子\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E一张导图作为结尾：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.react-waypoint\u002Freact-waypoint.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n",toc:[{anchor:"chu-shi",level:b,text:"初识"},{anchor:"zheng-ti-liu-cheng",level:b,text:"整体流程"}],relatedTags:["源码","react"],created_at:"2018-12-28",timeArr:[2018,11,28,19,30,43,0],title:"源码阅读-react-waypoint",uuid:"ba215dff0ae6956dac40be3d218cd6ab5cd3c533",summary:"\u003Cp\u003E\u003Ccode\u003Ereact-waypoint\u003C\u002Fcode\u003E用于监控元素是否出现在用户定义的视口范围内。\u003C\u002Fp\u003E",slug:a,sha:"f2384a371e4ab1abe1998ae1eb32ea5bed8a7ca9"}}],fetch:{},mutations:void 0}}("source-code-react-waypoint",3)));