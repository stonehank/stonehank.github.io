__NUXT_JSONP__("/article/source-code-react-infinite-scroller", (function(a,b,c,d){return {data:[{slug:c,articleDetails:{content:"\u003Cp\u003E\u003Ccode\u003Ereact-infinite-scroller\u003C\u002Fcode\u003E就是一个组件，主要逻辑就是\u003Ccode\u003EaddEventListener\u003C\u002Fcode\u003E绑定\u003Ccode\u003Escroll\u003C\u002Fcode\u003E事件。\u003C\u002Fp\u003E\n\u003Cp\u003E看它的源码主要意义不在知道如何使用它，而是知道以后处理\u003Ccode\u003E滚动加载\u003C\u002Fcode\u003E要注意的东西。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E此处跳到\u003Ca href=\"#zong-jie\"\u003E总结\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"chu-shi\"\u003E初识\u003C\u002Fh2\u003E\n\u003Cp\u003E参数：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u002F\u002F 渲染出来的DOM元素name\nelement: 'div',\n\u002F\u002F 是否能继续滚动渲染\nhasMore: false,\n\u002F\u002F 是否在订阅事件的时候执行事件\ninitialLoad: true,\n\u002F\u002F 表示当前翻页的值(每渲染一次递增)\npageStart: 0,\n\u002F\u002F 传递ref，返回此组件渲染的 DOM\nref: null,\n\u002F\u002F 触发渲染的距离\nthreshold: 250,\n\u002F\u002F 是否在window上绑定和处理距离\nuseWindow: true,\n\u002F\u002F 是否反向滚动，即到顶端后渲染\nisReverse: false,\n\u002F\u002F 是否使用捕获模式\nuseCapture: false,\n\u002F\u002F 渲染前的loading组件\nloader: null,\n\u002F\u002F 自定义滚动组件的父元素\ngetScrollParent: null,\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"shen-ru\"\u003E深入\u003C\u002Fh2\u003E\n\u003Ch3 id=\"componentdidmount\"\u003EcomponentDidMount\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentDidMount() {\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.pageLoaded = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.pageStart;\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.attachScrollListener();\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E执行\u003Ccode\u003EattachScrollListener\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"attachscrolllistener\"\u003EattachScrollListener\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EattachScrollListener() {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E parentElement = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.getParentElement(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.scrollComponent);\n  \n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.hasMore || !parentElement) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E;\n  }\n\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E scrollEl = \u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.useWindow === \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E) {\n    scrollEl = parentElement;\n  }\n  scrollEl.addEventListener(\n    \u003Cspan class=\"hljs-string\"\u003E'mousewheel'\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.mousewheelListener,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.useCapture,\n  );\n  scrollEl.addEventListener(\n    \u003Cspan class=\"hljs-string\"\u003E'scroll'\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.scrollListener,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.useCapture,\n  );\n  scrollEl.addEventListener(\n    \u003Cspan class=\"hljs-string\"\u003E'resize'\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.scrollListener,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.useCapture,\n  );\n  \n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.initialLoad) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.scrollListener();\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E此处通过\u003Ccode\u003EgetParentElement\u003C\u002Fcode\u003E获取父组件(用户自定义父组件或者当前dom的parentNode)\u003C\u002Fp\u003E\n\u003Cp\u003E然后绑定了3个事件，分别是\u003Ccode\u003Escroll\u003C\u002Fcode\u003E,\u003Ccode\u003Eresize\u003C\u002Fcode\u003E,\u003Ccode\u003Emousewheel\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E前2种都绑定\u003Ccode\u003EscrollListener\u003C\u002Fcode\u003E，\u003Ccode\u003Emousewheel\u003C\u002Fcode\u003E是一个非标准事件，是不建议在生产模式中使用的。\u003C\u002Fp\u003E\n\u003Cp\u003E那么这里为什么要使用呢？\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"mousewheel-jie-jue-chrome-de-deng-dai-bug\"\u003Emousewheel解决chrome的等待bug\u003C\u002Fh3\u003E\n\u003Cp\u003E此处的\u003Ccode\u003Emousewheel\u003C\u002Fcode\u003E事件是为了处理\u003Ccode\u003Echrome\u003C\u002Fcode\u003E浏览器的一个特性(不知道是否是一种bug)。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F47524205\u002Frandom-high-content-download-time-in-chrome\u002F47684257#47684257\"\u003Estackoverflow:Chrome的滚动等待问题\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E上面这个问题主要描述，当在使用滚轮加载时，而且加载会触发\u003Ccode\u003Eajax请求\u003C\u002Fcode\u003E，当滚轮到达底部，会出现一个漫长而且无任何动作的等待(长达2-3s)。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E.addEventListener(\u003Cspan class=\"hljs-string\"\u003E\"mousewheel\"\u003C\u002Fspan\u003E, (e) =&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (e.deltaY === \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n        e.preventDefault()\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上绑定可以消除这个&quot;bug&quot;。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E个人并没有遇到过这种情况，不知道是否有遇到过可以说说解决方案。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"getparentelement\"\u003EgetParentElement\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EgetParentElement(el) {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E scrollParent =\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.getScrollParent &amp;&amp; \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.getScrollParent();\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (scrollParent != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E scrollParent;\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E el &amp;&amp; el.parentNode;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E上面用到了\u003Ccode\u003EgetParentElement\u003C\u002Fcode\u003E，很好理解，使用用户自定义的父组件，或者当前组件\u003Ccode\u003EDOM.parentNode\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"scrolllistener\"\u003EscrollListener\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EscrollListener() {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E el = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.scrollComponent;\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E scrollEl = \u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E parentNode = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.getParentElement(el);\n\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E offset;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 使用window的情况\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.useWindow) {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E doc = \u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.documentElement || \u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.body.parentNode || \u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.body;\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E scrollTop = scrollEl.pageYOffset !== \u003Cspan class=\"hljs-literal\"\u003Eundefined\u003C\u002Fspan\u003E\n        ? scrollEl.pageYOffset\n        : doc.scrollTop;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F isReverse指 滚动到顶端，load新组件\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.isReverse) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 相反模式获取到顶端距离\u003C\u002Fspan\u003E\n      offset = scrollTop;\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 正常模式则获取到底端距离\u003C\u002Fspan\u003E\n      offset = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.calculateOffset(el, scrollTop);\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不使用window的情况\u003C\u002Fspan\u003E\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.isReverse) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 相反模式组件到顶端的距离\u003C\u002Fspan\u003E\n    offset = parentNode.scrollTop;\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 正常模式组件到底端的距离\u003C\u002Fspan\u003E\n    offset = el.scrollHeight - parentNode.scrollTop - parentNode.clientHeight;\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此处应该要判断确保滚动组件正常显示\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\n    offset &lt; \u003Cspan class=\"hljs-built_in\"\u003ENumber\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.threshold) &amp;&amp;\n    (el &amp;&amp; el.offsetParent !== \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E)\n  ) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 卸载事件\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.detachScrollListener();\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 卸载事件后再执行 loadMore\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.loadMore === \u003Cspan class=\"hljs-string\"\u003E'function'\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.loadMore((\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.pageLoaded += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E));\n    }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E组件核心。\u003C\u002Fp\u003E\n\u003Ch3 id=\"ji-ge-xue-xi-fu-xi-dian\"\u003E几个学习\u002F复习点\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E返回一个指向最近的包含该元素的定位元素.\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E很有用，因为计算\u003Ccode\u003EoffsetTop\u003C\u002Fcode\u003E和\u003Ccode\u003EoffsetLeft\u003C\u002Fcode\u003E都是相对于\u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E边界的。\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E为 null 的几种情况:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Eele 为 body\u003C\u002Fli\u003E\n\u003Cli\u003Eele 的 position 为 fixed\u003C\u002Fli\u003E\n\u003Cli\u003Eele 的 display 为 none\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E 此组件中\u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E处理了2种情况\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E在\u003Ccode\u003EuseWindow\u003C\u002Fcode\u003E的情况下(即事件绑定在window，滚动作用在body) 通过递归获取\u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E到达顶端的高度(\u003Ccode\u003EoffsetTop\u003C\u002Fcode\u003E)。\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcalculateTopPosition(el) {\n \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!el) {\n   \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;   \n }\n \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E el.offsetTop + \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.calculateTopPosition(el.offsetParent);   \n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E通过判断\u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E不为null的情况，确保滚动组件正常显示\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\n    offset &lt; \u003Cspan class=\"hljs-built_in\"\u003ENumber\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.threshold) &amp;&amp;\n    (el &amp;&amp; el.offsetParent !== \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E)\n  ) {\u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EscrollHeight\u003C\u002Fcode\u003E和\u003Ccode\u003EclientHeight\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E 在无滚动的情况下，\u003Ccode\u003EscrollHeight\u003C\u002Fcode\u003E和\u003Ccode\u003EclientHeight\u003C\u002Fcode\u003E相等，都为\u003Ccode\u003Eheight\u003C\u002Fcode\u003E+\u003Ccode\u003Epadding\u003C\u002Fcode\u003E*2\u003C\u002Fp\u003E\n\u003Cp\u003E 在有滚动的情况下，\u003Ccode\u003EscrollHeight\u003C\u002Fcode\u003E表示实际内容高度，\u003Ccode\u003EclientHeight\u003C\u002Fcode\u003E表示视口高度。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E每次执行\u003Ccode\u003EloadMore\u003C\u002Fcode\u003E前卸载事件。\u003C\u002Fp\u003E\n\u003Cp\u003E 确保不会重复(过多)执行\u003Ccode\u003EloadMore\u003C\u002Fcode\u003E，因为先卸载事件再执行\u003Ccode\u003EloadMore\u003C\u002Fcode\u003E，可以确保在执行过程中，\u003Ccode\u003Escroll\u003C\u002Fcode\u003E事件是无效的，然后再每次\u003Ccode\u003EcomponentDidUpdate\u003C\u002Fcode\u003E的时候重新绑定事件。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"render\"\u003Erender\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Erender() {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取porps\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E renderProps = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.filterProps(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props);\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {\n    children,\n    element,\n    hasMore,\n    initialLoad,\n    isReverse,\n    loader,\n    loadMore,\n    pageStart,\n    ref,\n    threshold,\n    useCapture,\n    useWindow,\n    getScrollParent,\n    ...props\n  } = renderProps;\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义一个ref\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 能将当前组件的DOM传出去\u003C\u002Fspan\u003E\n  props.ref = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Enode\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.scrollComponent = node;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 执行父组件传来的ref(如果有)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (ref) {\n      ref(node);\n    }\n  };\n\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E childrenArray = [children];\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 执行loader\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hasMore) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (loader) {\n      isReverse ? childrenArray.unshift(loader) : childrenArray.push(loader);\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.defaultLoader) {\n      isReverse\n        ? childrenArray.unshift(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.defaultLoader)\n        : childrenArray.push(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.defaultLoader);\n    }\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ref 传递给 'div'元素\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E React.createElement(element, props, childrenArray);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里一个小亮点就是，在\u003Ccode\u003Ereact\u003C\u002Fcode\u003E中，\u003Ccode\u003Ethis.props\u003C\u002Fcode\u003E是不允许修改的。\u003C\u002Fp\u003E\n\u003Cp\u003E这里使用了解构\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EgetScrollParent,\n...props\n} = renderProps;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里解构相当于\u003Ccode\u003EObject.assign\u003C\u002Fcode\u003E，定义了一个新的\u003Ccode\u003Eobject\u003C\u002Fcode\u003E，便可以添加属性了，并且\u003Ccode\u003Ethis.props\u003C\u002Fcode\u003E不会受到影响。\u003C\u002Fp\u003E\n\u003Ch2 id=\"zong-jie\"\u003E总结\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Ereact-infinite-scroller\u003C\u002Fcode\u003E逻辑比较简单。\u003C\u002Fp\u003E\n\u003Cp\u003E一些注意\u002F学习\u002F复习点：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EChrome\u003C\u002Fcode\u003E的一个滚动加载请求的bug。\u003Ca href=\"#mousewheel-jie-jue-chrome-de-deng-dai-bug\"\u003E本文位置\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EoffsetParent\u003C\u002Fcode\u003E的一些实际用法。\u003Ca href=\"#ji-ge-xue-xi-fu-xi-dian\"\u003E本文位置\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E通过不断订阅和取消事件绑定让滚动执行函数不会频繁触发。\u003Ca href=\"#ji-ge-xue-xi-fu-xi-dian\"\u003E本文位置\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EscrollHeight\u003C\u002Fcode\u003E和\u003Ccode\u003EclientHeight\u003C\u002Fcode\u003E区别。\u003Ca href=\"#ji-ge-xue-xi-fu-xi-dian\"\u003E本文位置\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E此库建议使用在自定义的一些组件上并且不那么复杂的逻辑上。\u003C\u002Fp\u003E\n\u003Cp\u003E用在第三方库可以会无法获取正确的父组件，而通过\u003Ccode\u003Edocument.getElementBy..\u003C\u002Fcode\u003E传入。\u003C\u002Fp\u003E\n\u003Cp\u003E面对稍微复杂的逻辑，\u003C\u002Fp\u003E\n\u003Cp\u003E例如，一个搜索组件，订阅\u003Ccode\u003EonChange\u003C\u002Fcode\u003E事件显示内容，搜索&quot;a&quot;，呈现内容，滚动加载了3次，再添加搜索词&quot;b&quot;，这时候&quot;ab&quot;的内容呈现是在3次之后。\u003C\u002Fp\u003E\n",toc:[{anchor:"chu-shi",level:b,text:"初识"},{anchor:"shen-ru",level:b,text:"深入"},{anchor:"componentdidmount",level:a,text:"componentDidMount"},{anchor:"attachscrolllistener",level:a,text:"attachScrollListener"},{anchor:"mousewheel-jie-jue-chrome-de-deng-dai-bug",level:a,text:"mousewheel解决chrome的等待bug"},{anchor:"getparentelement",level:a,text:"getParentElement"},{anchor:"scrolllistener",level:a,text:"scrollListener"},{anchor:"ji-ge-xue-xi-fu-xi-dian",level:a,text:"几个学习\u002F复习点"},{anchor:d,level:a,text:d},{anchor:"zong-jie",level:b,text:"总结"}],relatedTags:["源码","react"],created_at:"2018-11-25",timeArr:[2018,10,25,23,37,53,0],title:"源码阅读-react-infinite-scroller",uuid:"7cbb6144b6cfb573e0e828cb0d5cbe5e805fe1d9",summary:"\u003Cp\u003E\u003Ccode\u003Ereact-infinite-scroller\u003C\u002Fcode\u003E就是一个组件，主要逻辑就是\u003Ccode\u003EaddEventListener\u003C\u002Fcode\u003E绑定\u003Ccode\u003Escroll\u003C\u002Fcode\u003E事件。\u003C\u002Fp\u003E\n\u003Cp\u003E看它的源码主要意义不在知道如何使用它，而是知道以后处理\u003Ccode\u003E滚动加载\u003C\u002Fcode\u003E要注意的东西。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E此处跳到\u003Ca href=\"#zong-jie\"\u003E总结\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch4\u003E初识\u003C\u002Fh4\u003E\n\u003Cp\u003E参数：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u002F\u002F 渲染出来的...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",slug:c,sha:"5aba2eaf43528ba166b972e6b13b0b43de1c816c"}}],fetch:{},mutations:void 0}}(3,2,"source-code-react-infinite-scroller","render")));