__NUXT_JSONP__("/article/source-code-react-loadable", (function(a,b,c){return {data:[{slug:c,articleDetails:{content:"\u003Ch3 id=\"jie-shao\"\u003E介绍\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fjamiebuilds\u002Freact-loadable\"\u003Ereact-loadable\u003C\u002Fa\u003E是一个组件延迟加载的工具，\n它本身也是一个组件，通过\u003Ccode\u003EHOC\u003C\u002Fcode\u003E的方式对参数组件进行处理，\n具体的延迟加载方式是使用\u003Ccode\u003Eimport().then()\u003C\u002Fcode\u003E方法，那么为什么要用这个组件呢？\u003C\u002Fp\u003E\n\u003Ch3 id=\"chu-shi\"\u003E初识\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003Ereact-loadable\u003C\u002Fcode\u003E针对多种情况进行抽象处理，例如延迟加载失败，多个延迟加载的逻辑和服务端渲染使用延迟加载...\u003C\u002Fp\u003E\n\u003Cp\u003E当这些情况整合起来后，我们只需要简单的API即可处理每个情况对应的组件。\u003C\u002Fp\u003E\n\u003Cp\u003E它对外暴露的API有\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u002F\u002F 基本的延迟加载处理\nLoadable\n\u002F\u002F 多个延迟加载处理\nLoadable.Map\n\u002F\u002F Loadable或Loadable.Map的返回值\nLoadableComponent\n\u002F\u002F 预加载\nLoadableComponent.preLoad\n\u002F\u002F 全部预加载\nLoadable.preloadAll\n\u002F\u002F 对已经加载完毕的组件处理\nLoadable.preloadReady\n\u002F\u002F 服务端渲染使用\nLoadable.Capture\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ELoadable和Loadable.Map还可加入一些options参数，作用如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u002F\u002F 延迟加载组件\nloader: null,\n\u002F\u002F loading组件\nloading: null,\n\u002F\u002F 加载组件时等待多少时间才开始渲染Loading\ndelay: 200,\n\u002F\u002F 超时时间\ntimeout: null,\n\u002F\u002F 对已加载的组件渲染方法\nrender: render,\n\n\u002F* 以下2个是服务端渲染使用 *\u002F\n\n\u002F\u002F 函数，执行后会获取当前延迟加载模块\n\u002F\u002F 这里用途是判断模块是否已经可用，作用于 preLoadReady 上\nwebpack: null,\n\u002F\u002F 函数，执行后会获取当前import的路径，作为moduleId\n\u002F\u002F 这里用途是通过getBundles将moduleId转换成bundles\nmodules: null\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"shen-ru\"\u003E深入\u003C\u002Fh3\u003E\n\u003Ch4 id=\"loadable\"\u003ELoadable\u003C\u002Fh4\u003E\n\u003Cp\u003E客户端的单个延迟加载组件\u003C\u002Fp\u003E\n\u003Cp\u003E当开始载入\u003Ccode\u003ELoadable\u003C\u002Fcode\u003E组件，会返回\u003Ccode\u003ELoadableComponent\u003C\u002Fcode\u003E组件，这个组件在生命周期中的\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E下会执行\u003Ccode\u003Einit\u003C\u002Fcode\u003E方法。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ELoadableComponent\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EReact\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title\"\u003EComponent\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(props) {\n      \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E(props);\n      init();\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这个\u003Ccode\u003Einit\u003C\u002Fcode\u003E方法会执行\u003Ccode\u003EloadFn(opts.loader)\u003C\u002Fcode\u003E，而这个\u003Ccode\u003EloadFn\u003C\u002Fcode\u003E会首先会执行\u003Ccode\u003E参数loader(也就是import(...))\u003C\u002Fcode\u003E，并且将根据\u003Ccode\u003E执行结果(then或者catch)\u003C\u002Fcode\u003E对3个状态\u003Ccode\u003Eloading\u003C\u002Fcode\u003E,\u003Ccode\u003Eloaded\u003C\u002Fcode\u003E,\u003Ccode\u003Eerror\u003C\u002Fcode\u003E进行更新，\n返回一个包含所有状态和import执行结果的对象；\u003C\u002Fp\u003E\n\u003Cp\u003Einit：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Einit\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!res) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F loadFn就是load\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里opts.loader就是组件的延迟加载函数，例如：()=&gt;import(.\u002Fxxx)\u003C\u002Fspan\u003E\n    res = loadFn(opts.loader);\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回延迟加载的component\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E res.promise;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EloadFn：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eload\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eloader\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F promise保存了延迟加载组件执行的返回值(thenable)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E promise = loader();\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 状态数据\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E state = {\n    \u003Cspan class=\"hljs-attr\"\u003Eloading\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003Eloaded\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003Eerror\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E\n  };\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F state.promise是一个Promise的处理返回值\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此处根据promise的返回值，更新状态数据\u003C\u002Fspan\u003E\n  state.promise = promise\n    .then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eloaded\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      state.loading = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n      state.loaded = loaded;\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E loaded;\n    })\n    .catch(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eerr\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      state.loading = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n      state.error = err;\n      \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E err;\n    });\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F state是一个obj，保存了状态和延迟加载组件执行的返回值\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E state;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接着在\u003Ccode\u003EcomponentWillMount\u003C\u002Fcode\u003E下调用了\u003Ccode\u003Ethis._loadModule\u003C\u002Fcode\u003E，它会根据\u003Ccode\u003Eoptions\u003C\u002Fcode\u003E里的参数(例如delay，timeout)对当前状态进行更新，并且继续监听\u003Ccode\u003Einit\u003C\u002Fcode\u003E返回的对象，一旦处理完毕，更新状态。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 载入组件时，根据options加载和更新\u003C\u002Fspan\u003E\ncomponentWillMount() {\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._mounted = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._loadModule();\n}\n\n_loadModule(){\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* 省略了服务端渲染的处理 *\u002F\u003C\u002Fspan\u003E \n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 延迟加载结束\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!res.loading) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E;\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认200ms后更新pastDelay\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 有时组件加载非常快(&lt;200ms)，这时加载中的样式就会一闪而过\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 因此可以选择默认隔200ms后才开始渲染loading(避免样式闪动)，这样做是因为能让用户感觉更快\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F https:\u002F\u002Fgithub.com\u002Fjamiebuilds\u002Freact-loadable#avoiding-flash-of-loading-component\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E opts.delay === \u003Cspan class=\"hljs-string\"\u003E\"number\"\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (opts.delay === \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({ \u003Cspan class=\"hljs-attr\"\u003EpastDelay\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E });\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._delay = setTimeout(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({ \u003Cspan class=\"hljs-attr\"\u003EpastDelay\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E });\n      }, opts.delay);\n    }\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 判断是否需要更新timeout(用于超时处理)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E opts.timeout === \u003Cspan class=\"hljs-string\"\u003E\"number\"\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._timeout = setTimeout(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({ \u003Cspan class=\"hljs-attr\"\u003EtimedOut\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E });\n    }, opts.timeout);\n  }\n\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E update = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当组件未载入或者已经卸载，则返回\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._mounted) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E;\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({\n      \u003Cspan class=\"hljs-attr\"\u003Eerror\u003C\u002Fspan\u003E: res.error,\n      \u003Cspan class=\"hljs-attr\"\u003Eloaded\u003C\u002Fspan\u003E: res.loaded,\n      \u003Cspan class=\"hljs-attr\"\u003Eloading\u003C\u002Fspan\u003E: res.loading\n    });\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._clearTimeouts();\n  };\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F res是init()处理后的返回值\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F promise属性对应的是组件延迟加载的返回值\u003C\u002Fspan\u003E\n  res.promise\n    .then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 加载完毕后，执行update，更新相关状态数据\u003C\u002Fspan\u003E\n      update();\n    })\n    .catch(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eerr\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      update();\n    });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003Erender\u003C\u002Fcode\u003E里面则根据当前状态，渲染对应的组件(例如\u003Ccode\u003Eloading\u003C\u002Fcode\u003E或\u003Ccode\u003Eerror\u003C\u002Fcode\u003E状态为\u003Ccode\u003Etrue\u003C\u002Fcode\u003E，都会调用\u003Ccode\u003ELoading\u003C\u002Fcode\u003E组件，并且传递props)。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Erender() {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F loading或者error状态为true\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.loading || \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.error) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 创建loading组件，第二个参数为props，用于loading渲染的条件\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F loading组件内部根据props定义渲染的内容\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E React.createElement(opts.loading, {\n      \u003Cspan class=\"hljs-attr\"\u003EisLoading\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.loading,\n      \u003Cspan class=\"hljs-attr\"\u003EpastDelay\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.pastDelay,\n      \u003Cspan class=\"hljs-attr\"\u003EtimedOut\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.timedOut,\n      \u003Cspan class=\"hljs-attr\"\u003Eerror\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.error,\n      \u003Cspan class=\"hljs-attr\"\u003Eretry\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.retry\n    });\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.loaded) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 组件已经加载完毕，渲染延迟加载的组件，render是渲染方法，默认为createElement进行渲染组件\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E opts.render(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.loaded, \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props);\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n  }\n}\n\n \u003Cspan class=\"hljs-comment\"\u003E\u002F* 默认的render方法 *\u002F\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 兼容babel编译后的组件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eresolve\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eobj\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E obj &amp;&amp; obj.__esModule ? obj.default : obj;\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认的render函数——创建组件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erender\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eloaded, props\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E React.createElement(resolve(loaded), props);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4 id=\"loadablemap\"\u003ELoadable.Map\u003C\u002Fh4\u003E\n\u003Cp\u003E多个延迟加载组件的处理\u003C\u002Fp\u003E\n\u003Cp\u003E它也是基于单个组件处理的，它的工作逻辑：\u003C\u002Fp\u003E\n\u003Cp\u003E只要任何一个组件还在加载，整体的\u003Ccode\u003Eloading\u003C\u002Fcode\u003E状态就是\u003Ccode\u003Etrue\u003C\u002Fcode\u003E，任意一个组件延迟加载出错，整体的\u003Ccode\u003Eerror\u003C\u002Fcode\u003E状态就是\u003Ccode\u003Etrue\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 因为遍历并且执行load执行(单个执行)，遇到错误会抛出，因此要try...catch\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.keys(obj).forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Ekey\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E result = load(obj[key]);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 第一次判断，目的是改变loading状态\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果某延迟组件加载完毕\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!result.loading) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对应的loaded为true\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 整体的loading不变\u003C\u002Fspan\u003E\n      state.loaded[key] = result.loaded;\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 任意一个延迟组件有err，整体为err\u003C\u002Fspan\u003E\n      state.error = result.error;\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 有任意一个延迟组件还在加载，则整体的loading为true\u003C\u002Fspan\u003E\n      state.loading = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    }\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 处理结果(Promise对象)放进数组\u003C\u002Fspan\u003E\n    promises.push(result.promise);\n  \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 后续then，目的是处理已经加载完毕的组件\u003C\u002Fspan\u003E\n    result.promise\n    . then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eres\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n        state.loaded[key] = res;\n      })\n    . catch(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eerr\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n        state.error = err;\n      });\n  });\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 捕捉load的错误\u003C\u002Fspan\u003E\n  } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E (err) {\n  state.error = err;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E使用了\u003Ccode\u003EPromise.all()\u003C\u002Fcode\u003E，等待全部完成后，改变\u003Ccode\u003E整体的loading\u003C\u002Fcode\u003E状态\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当所有组件加载完毕(每个组件可能成功，也可能失败)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 整体的loading为false\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 有错误则抛出，否则返回state\u003C\u002Fspan\u003E\nstate.promise = \u003Cspan class=\"hljs-built_in\"\u003EPromise\u003C\u002Fspan\u003E.all(promises)\n.then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eres\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n  state.loading = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E res;\n})\n.catch(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eerr\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n  state.loading = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E err;\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来也是\u003Ccode\u003Erender\u003C\u002Fcode\u003E的处理了，跟前面没什么不同。\u003C\u002Fp\u003E\n\u003Ch4 id=\"loadablecapture\"\u003ELoadable.Capture\u003C\u002Fh4\u003E\n\u003Cp\u003E服务端渲染的处理\u003C\u002Fp\u003E\n\u003Cp\u003E这里要提源码中的\u003Ccode\u003Ewebpack.js\u003C\u002Fcode\u003E和\u003Ccode\u003Ebabel.js\u003C\u002Fcode\u003E，这里没有具体分析，只是说明它们的用途。\u003C\u002Fp\u003E\n\u003Cp\u003E一个是webpack插件，作用是创建一个json键值对数据\u003Ccode\u003Ereact-loadable.json\u003C\u002Fcode\u003E，包含了每一个modules对应的bundles，\n并且提供了一个将modulesID转换成bundles的方法\u003Ccode\u003EgetBundles\u003C\u002Fcode\u003E，简单说就是\u003Ccode\u003E将key转换成value\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E另一个是babel插件，作用是自动提供2个参数\u003Ccode\u003Eopts.webpack\u003C\u002Fcode\u003E和\u003Ccode\u003Eopts.modules\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u002F\u002F 函数，执行后会获取当前延迟加载模块\n\u002F\u002F 这里用途是判断模块是否已经可用，作用于preLoadReady上\nopts.webpack\n\n\u002F\u002F 函数，执行后会获取当前import的路径，作为moduleId\n\u002F\u002F 这里用途是通过getBundles将moduleId转换成bundles\nopts.modules\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E有了上面2个概念，\u003Ccode\u003ELoadable.Capture\u003C\u002Fcode\u003E做的事情很简单，\u003C\u002Fp\u003E\n\u003Cp\u003E定义了一个\u003Ccode\u003Econtext\u003C\u002Fcode\u003E属性，并且渲染它的唯一子元素\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ECapture\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EReact\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title\"\u003EComponent\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E propTypes = {\n    \u003Cspan class=\"hljs-attr\"\u003Ereport\u003C\u002Fspan\u003E: PropTypes.func.isRequired\n  };\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义传递给子组件的上下文\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E childContextTypes = {\n    \u003Cspan class=\"hljs-attr\"\u003Eloadable\u003C\u002Fspan\u003E: PropTypes.shape({\n      \u003Cspan class=\"hljs-attr\"\u003Ereport\u003C\u002Fspan\u003E: PropTypes.func.isRequired\n    }).isRequired\n  };\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 传递的上下文内容\u003C\u002Fspan\u003E\n  getChildContext() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-attr\"\u003Eloadable\u003C\u002Fspan\u003E: {\n        \u003Cspan class=\"hljs-attr\"\u003Ereport\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.report\n      }\n    };\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 渲染唯一的子元素\u003C\u002Fspan\u003E\n  render() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E React.Children.only(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children);\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这个context属性一般这么写，这里\u003Ccode\u003Emodules\u003C\u002Fcode\u003E是一个空数组\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Ereport={moduleName =&gt; modules.push(moduleName)}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E然后在\u003Ccode\u003ELoadableComponent\u003C\u002Fcode\u003E组件内部，如果存在\u003Ccode\u003Econtext属性\u003C\u002Fcode\u003E并且存在\u003Ccode\u003Eopts.modules\u003C\u002Fcode\u003E(说明使用了babel插件)，\n则调用\u003Ccode\u003Ereport\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E这里\u003Ccode\u003EmoduleName\u003C\u002Fcode\u003E就是\u003Ccode\u003Eopts.modules\u003C\u002Fcode\u003E里面每一个\u003Ccode\u003EmoduleId\u003C\u002Fcode\u003E，通过\u003Ccode\u003Ereport\u003C\u002Fcode\u003E方法添加到\u003Ccode\u003Emodules(空数组)\u003C\u002Fcode\u003E内部.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.context.loadable &amp;&amp; \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E.isArray(opts.modules)) {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 遍历并且对每一个执行report\u003C\u002Fspan\u003E\n  opts.modules.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EmoduleName\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.context.loadable.report(moduleName);\n  });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E到现在，\u003Ccode\u003Emodules\u003C\u002Fcode\u003E就是一个保存了当前进行延迟加载组件的\u003Ccode\u003EmoduleId\u003C\u002Fcode\u003E的数组，再通过\u003Ccode\u003EgetBundles\u003C\u002Fcode\u003E(webpack插件提供)方法，\n将\u003Ccode\u003EmoduleId(key)\u003C\u002Fcode\u003E通过查询\u003Ccode\u003Ereact-loadable.json(包含moduleId对应的bundles)\u003C\u002Fcode\u003E，转换成\u003Ccode\u003Ebundles(value)\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EgetBundles\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Emanifest, moduleIds\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F moduleIds中每一个作为key，找到manifest[moduleId]合并到bundles(一个数组)中\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E moduleIds.reduce(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Ebundles, moduleId\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E bundles.concat(manifest[moduleId]);\n  }, []);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E现在我们得到了一个\u003Ccode\u003Ebundles\u003C\u002Fcode\u003E数组，里面储存了我们延迟加载组件对应的\u003Ccode\u003Ebundle\u003C\u002Fcode\u003E，我们要做的只是根据\u003Ccode\u003Ebundle\u003C\u002Fcode\u003E类型\n添加对应的\u003Ccode\u003Escript标签\u003C\u002Fcode\u003E或者\u003Ccode\u003Elink标签\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch4 id=\"preloadready\"\u003EpreLoadReady\u003C\u002Fh4\u003E\n\u003Cp\u003E因为以上内容都是在服务端上的，客户端必须要等到组件可用了才可以开始渲染，\u003C\u002Fp\u003E\n\u003Cp\u003E先提一个变量：\u003Ccode\u003EREADY_INITIALIZERS\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E它储存了通过检查\u003Ccode\u003Eopts.webpack\u003C\u002Fcode\u003E里面每一个\u003Ccode\u003EmoduleId\u003C\u002Fcode\u003E对应的组件是可用的，这个组件的\u003Ccode\u003Einit\u003C\u002Fcode\u003E方法。\u003C\u002Fp\u003E\n\u003Cp\u003E这里\u003Ccode\u003EgetModuleIds\u003C\u002Fcode\u003E就是\u003Ccode\u003Eopts.webpack\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F __webpack_modules__是一个存储了所有模块的对象\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E __webpack_modules__ !== \u003Cspan class=\"hljs-string\"\u003E\"object\"\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 检查是否每一个模块存在\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E getModuleIds().every(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EmoduleId\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n      \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E moduleId !== \u003Cspan class=\"hljs-string\"\u003E\"undefined\"\u003C\u002Fspan\u003E &amp;&amp;\n      \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E __webpack_modules__[moduleId] !== \u003Cspan class=\"hljs-string\"\u003E\"undefined\"\u003C\u002Fspan\u003E\n    );\n  });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EpreLoadReady\u003C\u002Fcode\u003E就是通过遍历\u003Ccode\u003EREADY_INITIALIZERS\u003C\u002Fcode\u003E数组，并且执行每一个组件的\u003Ccode\u003Einit\u003C\u002Fcode\u003E方法，\n最终当\u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E全部完成后，就可以开始渲染客户端了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"dao-tu-zong-jie\"\u003E导图总结\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.react-loadable\u002Freact-loadabel.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n",toc:[{anchor:"jie-shao",level:a,text:"介绍"},{anchor:"chu-shi",level:a,text:"初识"},{anchor:"shen-ru",level:a,text:"深入"},{anchor:"loadable",level:b,text:"Loadable"},{anchor:"loadablemap",level:b,text:"Loadable.Map"},{anchor:"loadablecapture",level:b,text:"Loadable.Capture"},{anchor:"preloadready",level:b,text:"preLoadReady"},{anchor:"dao-tu-zong-jie",level:a,text:"导图总结"}],relatedTags:["源码","react","promise","webpack","babel","github"],created_at:"2018-09-10",timeArr:[2018,8,10,15,44,34,0],title:"源码阅读-react-loadable",uuid:"5134ffe9303c7c82cc06321c03aa6dc4abdc9753",summary:"\u003Ch4\u003E介绍\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fjamiebuilds\u002Freact-loadable\"\u003Ereact-loadable\u003C\u002Fa\u003E是一个组件延迟加载的工具，\n它本身也是一个组件，通过\u003Ccode\u003EHOC\u003C\u002Fcode\u003E的方式对参数组件进行处理，\n具体的延迟加载方式是使用\u003Ccode\u003Eimport().then()\u003C\u002Fcode\u003E方法，那么为什么要用这个组件呢？...\u003C\u002Fp\u003E",slug:c,sha:"7d1a1d670bb1ec624fdef1c489f683ce954302c1"}}],fetch:{},mutations:void 0}}(3,4,"source-code-react-loadable")));