__NUXT_JSONP__("/article/source-code-react-motion", (function(a,b,c,d,e,f,g){return {data:[{slug:d,articleDetails:{content:"\u003Ch2 id=\"jie-shao\"\u003E介绍\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Ereact-motion\u003C\u002Fcode\u003E是一个react的动画组件，只需要为UI元素设置一个弹力和阻力和目标位置，便可渲染出符合现实的弹性动画效果\u003C\u002Fp\u003E\n\u003Cp\u003E算法：\u003C\u002Fp\u003E\n\u003Cp\u003E弹性算法，算法本身(\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fblob\u002Fmaster\u002Fsource-code.react-motion\u002Fsrc\u002Fstepper.js\"\u003Estepper.js\u003C\u002Fa\u003E)简单易懂\u003C\u002Fp\u003E\n\u003Ch2 id=\"jie-gou\"\u003E结构\u003C\u002Fh2\u003E\n\u003Cp\u003E对每一个文件作用先大致说明\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E├──src\n    ├──mapToZero.js             \u002F\u002F 初始化目标的速度值为0\n    ├──mergeDiff.js             \u002F\u002F 对TransitionMotion的动画序列进行排序\n    ├──Motion.js                \u002F\u002F 单个目标动画的执行文件\n    ├──presets.js               \u002F\u002F 预定义的动画效果参数\n    ├──react-motion.js          \u002F\u002F 接口\n    ├──reorderKeys.js           \u002F\u002F 已经被移除\n    ├──shouldStopAnimation.js   \u002F\u002F 判断是否需要停止动画\n    ├──spring.js                \u002F\u002F 默认动画参数配置，只需要提供目标位置\n    ├──StaggeredMotion.js       \u002F\u002F 多个目标动画的执行文件\n    ├──stepper.js               \u002F\u002F 弹力动画的算法\n    ├──stripStyle.js            \u002F\u002F 提取传入的参数的位置值\n    ├──TransitionMotion.js      \u002F\u002F 目标进入和取消动画的处理\n    ├──Types.js                 \u002F\u002F 规定了type\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E模块分析跳转\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"#maptozero\"\u003EmapToZero\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#mergediff\"\u003EmergeDiff\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#motion\"\u003EMotion\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#presets\"\u003Epresets\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#shouldstopanimation\"\u003EshouldStopAnimation\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#spring\"\u003Espring\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#staggeredmotion\"\u003EStaggeredMotion\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#stepper\"\u003Estepper\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#stripstyle\"\u003EstripStyle\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca href=\"#transitionmotion\"\u003ETransitionMotion\u003C\u002Fa\u003E              \u003C\u002Fp\u003E\n\u003Ch2 id=\"3-da-mo-kuai-gong-gong-fang-fa\"\u003E3大模块+公共方法\u003C\u002Fh2\u003E\n\u003Cp\u003E提供了3个主要模块，分别是\u003Ccode\u003EMotion\u003C\u002Fcode\u003E, \u003Ccode\u003EStaggeredMotion\u003C\u002Fcode\u003E, \u003Ccode\u003ETransitionMotion\u003C\u002Fcode\u003E，其中还会穿插一些公用方法，\n有几个模块不去分析，因为它们很简单：\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"presets\"\u003Epresets\u003C\u002Fh3\u003E\n\u003Cp\u003E定义了几个常用效果的参数\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"spring\"\u003Espring\u003C\u002Fh3\u003E\n\u003Cp\u003E提供了默认动画参数配置\u003C\u002Fp\u003E\n\u003Cp\u003E调用\u003Ccode\u003Espring(x:100)\u003C\u002Fcode\u003E转换成\u003Ccode\u003E{x: {stiffness: 170, damping: 26, precision:0.01, val:100}}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"maptozero\"\u003EmapToZero\u003C\u002Fh3\u003E\n\u003Cp\u003E设置初始速度为0\u003C\u002Fp\u003E\n\u003Cp\u003E将\u003Ccode\u003E{x: {val: 100, stiffness: 200, damping: 14}, y: 60}\u003C\u002Fcode\u003E转换成\u003Ccode\u003E{x: 0, y: 0}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"stripstyle\"\u003EstripStyle\u003C\u002Fh3\u003E\n\u003Cp\u003E提取传入的参数的位置值\u003C\u002Fp\u003E\n\u003Cp\u003E将\u003Ccode\u003E{x: {val: 100, stiffness: 200, damping: 14}, y: 60}\u003C\u002Fcode\u003E转换成\u003Ccode\u003E{x: 100, y: 60}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E解释几个变量：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Ethis.props.style: 这个并不是css的style，而是对动画的配置\ncurrentStyle: 当前动画属性(例如height，width)状态\ncurrentVelocitie: 当前动画属性速度\nlastIdealStyle: 上一次动画属性状态\nlastIdealVelocitie: 上一次动画属性速度\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"motion\"\u003EMotion\u003C\u002Fh3\u003E\n\u003Cp\u003E我们按它的生命周期函数的顺序分析\u003C\u002Fp\u003E\n\u003Cp\u003E首先调用\u003Ccode\u003EdefaultState\u003C\u002Fcode\u003E，它对传入的参数进行处理，\n通过\u003Ca href=\"#stripstyle\"\u003EscriptStyle\u003C\u002Fa\u003E转换成一个\u003Ccode\u003E位置值\u003C\u002Fcode\u003E和通过\u003Ca href=\"#maptozero\"\u003EmapToZero\u003C\u002Fa\u003E转换成一个\u003Ccode\u003E速度值\u003C\u002Fcode\u003E，\n整套算法就是建立在这两个属性之上\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(props: MotionProps) {\n  \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E(props);\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.defaultState();\n}\n\ndefaultState(): MotionState {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F defaultStyles指定一个初始值，后续计算不处理它或者通过stripStyle处理\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {defaultStyle, style} = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props;\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E currentStyle = defaultStyle || stripStyle(style);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对每一个位置(x,y)，默认速度都为0\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E currentVelocity = mapToZero(currentStyle);\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n      currentStyle,\n      currentVelocity,\n      \u003Cspan class=\"hljs-attr\"\u003ElastIdealStyle\u003C\u002Fspan\u003E: currentStyle,\n      \u003Cspan class=\"hljs-attr\"\u003ElastIdealVelocity\u003C\u002Fspan\u003E: currentVelocity,\n    };\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来，执行\u003Ccode\u003EstartAnimationIfNecessary\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentDidMount() {\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.prevTime = defaultNow();\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.startAnimationIfNecessary();\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EstartAnimationIfNecessary\u003C\u002Fcode\u003E使用了\u003Ccode\u003Eraf\u003C\u002Fcode\u003E库，默认使用requestAnimationFrame，\n它的几个重要点如下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"#shouldstopanimation\"\u003EshouldStopAnimation\u003C\u002Fa\u003E检测是否停止动画\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E定义了几个变量\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E1. currentTime     \u002F\u002F 当前的时间戳\n2. this.prevTime   \u002F\u002F 上一帧的时间戳\n3. timeDelta       \u002F\u002F 当前帧消耗的时间\n4. this.accumulatedTime \n\u002F\u002F 偏差值，例如当前帧消耗20ms，而规定的帧时间是16.7，那么偏差值就是3.3\n\u002F\u002F 这里偏差值后面会计算补充到当前位置，但是下一次计算的开始点不会包括偏差值\n\n一个例子：\n假设规定的每帧时间是16.7，第一帧消耗了20ms，第二帧消耗了16.4ms\n那么第一帧偏差值是3.3ms，行走的距离就是：\n-----------&gt;  +   -&gt;  \n16.7ms的距离   3.3ms距离\n第二帧偏差值是3.3-0.3=3ms，距离是\n            --------&gt;   +   -&gt;\n       从16.7的位置开始    3ms的距离\n       \n5. framesToCatchUp \u002F\u002F 可执行帧数\n\u002F\u002F 如果第一帧消耗15ms ，那么它的可执行帧数就是0，偏差值是15ms\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E通过\u003Ca href=\"#stepper\"\u003Estepper\u003C\u002Fa\u003E具体计算当前\u003Ccode\u003E位置值\u003C\u002Fcode\u003E和\u003Ccode\u003E速度值\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E先看源码的动画计算的思想部分，这里不仅仅有\u003Ccode\u003E上一次的位置和速度\u003C\u002Fcode\u003E，\n\u003Ccode\u003E本次的位置和速度\u003C\u002Fcode\u003E，还计算了\u003Ccode\u003E下一次的位置和速度\u003C\u002Fcode\u003E，之所以这么做是为了补上偏差值带来的误差：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EstartAnimationIfNecessary = (): \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evoid\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F* 定义和判断的部分省略... *\u002F\u003C\u002Fspan\u003E\n  \n     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果传入的style参数是数字，则直接设置，没有动画效果\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E styleValue === \u003Cspan class=\"hljs-string\"\u003E'number'\u003C\u002Fspan\u003E) {\n      newCurrentStyle[key] = styleValue;\n      newCurrentVelocity[key] = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n      newLastIdealStyle[key] = styleValue;\n      newLastIdealVelocity[key] = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 上一次位置\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newLastIdealStyleValue = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealStyle[key];\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 上一次速度\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newLastIdealVelocityValue = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealVelocity[key];\n      \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; framesToCatchUp; i++) {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 通过上一次的位置和速度返回当前新的位置和速度\u003C\u002Fspan\u003E\n        [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n          msPerFrame \u002F \u003Cspan class=\"hljs-number\"\u003E1000\u003C\u002Fspan\u003E,\n          newLastIdealStyleValue,\n          newLastIdealVelocityValue,\n          styleValue.val,\n          styleValue.stiffness,\n          styleValue.damping,\n          styleValue.precision,\n        );\n      }\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 计算next(下一次的位置和速度)是为了计算偏差值所占有的速度和位置\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E [nextIdealX, nextIdealV] = stepper(\n        msPerFrame \u002F \u003Cspan class=\"hljs-number\"\u003E1000\u003C\u002Fspan\u003E,\n        newLastIdealStyleValue,\n        newLastIdealVelocityValue,\n        styleValue.val,\n        styleValue.stiffness,\n        styleValue.damping,\n        styleValue.precision,\n      );\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 通过偏差值计算当前实际位置，就是上面例如画的图\u003C\u002Fspan\u003E\n      \n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此次动画的位置=这一次执行帧数的位置+下一帧动画的位置*偏差值\u003C\u002Fspan\u003E\n      newCurrentStyle[key] =\n        newLastIdealStyleValue +\n        (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此次动画的速度=这一次执行帧数的速度+下一帧动画的速度*偏差值\u003C\u002Fspan\u003E\n      newCurrentVelocity[key] =\n        newLastIdealVelocityValue +\n        (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n      newLastIdealStyle[key] = newLastIdealStyleValue;\n      newLastIdealVelocity[key] = newLastIdealVelocityValue;\n    }\n  }\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({\n    \u003Cspan class=\"hljs-attr\"\u003EcurrentStyle\u003C\u002Fspan\u003E: newCurrentStyle,\n    \u003Cspan class=\"hljs-attr\"\u003EcurrentVelocity\u003C\u002Fspan\u003E: newCurrentVelocity,\n    \u003Cspan class=\"hljs-attr\"\u003ElastIdealStyle\u003C\u002Fspan\u003E: newLastIdealStyle,\n    \u003Cspan class=\"hljs-attr\"\u003ElastIdealVelocity\u003C\u002Fspan\u003E: newLastIdealVelocity,\n  });\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 递归调用，保持动画\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.startAnimationIfNecessary();\n  });\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca href=\"#shouldstopanimation\"\u003EshouldStopAnimation\u003C\u002Fa\u003E和\u003Ca href=\"#stepper\"\u003Estepper\u003C\u002Fa\u003E放到\u003Ccode\u003EMotion\u003C\u002Fcode\u003E后再去分析。\u003C\u002Fp\u003E\n\u003Cp\u003E接着是\u003Ccode\u003EcomponentWillReceiveProps\u003C\u002Fcode\u003E，\n这里有个\u003Ccode\u003EunreadPropStyle\u003C\u002Fcode\u003E和\u003Ccode\u003EclearUnreadPropStyle\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E先做一个大概解释：\n\u003Ccode\u003EunreadPropStyle\u003C\u002Fcode\u003E的意义是当连续调用\u003Ccode\u003E x:0 --&gt;x:400 ---&gt;x:spring(0)\u003C\u002Fcode\u003E这种情况，\n默认会跳过\u003Ccode\u003Ex:400\u003C\u002Fcode\u003E，因为在\u003Ccode\u003Ex:400\u003C\u002Fcode\u003E的raf调用之前，会触发\u003Ccode\u003Ex:spring(0)\u003C\u002Fcode\u003E，但这时已经有\u003Ccode\u003EanimationID(400那个触发的)\u003C\u002Fcode\u003E，\n因此\u003Ccode\u003Ex:spring(0)\u003C\u002Fcode\u003E的raf调用不会执行，但是它改变了当前Motion的style，因此\u003Ccode\u003Ex:400\u003C\u002Fcode\u003E执行raf的时候，对比的是当前位置0，\n和\u003Ccode\u003Ex:spring(0)\u003C\u002Fcode\u003E的目标位置0，对比相等，因此不会触发动画\u003C\u002Fp\u003E\n\u003Cp\u003E这里使用\u003Ccode\u003EunreadPropStyle\u003C\u002Fcode\u003E记录每一次的style值(当前帧的目标值)，在raf调用结束会清除\u003Ccode\u003EunreadPropStyle\u003C\u002Fcode\u003E的值，所以当检测到\u003Ccode\u003EunreadPropStyle\u003C\u002Fcode\u003E有值，\n说明上一次的raf未结束就又触发新的，于是就进入\u003Ccode\u003EclearUnreadPropStyle\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentWillReceiveProps(props: MotionProps) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果unreadPropStyle有值，说明config的值被设置成数字并且被跳过了，需要清除(也就是直接跳转到位置)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyle != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 先检查是否有number的style，如果有就直接跳转到位置\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.clearUnreadPropStyle(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyle);\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyle = props.style;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F this.animationID == null 说明之前没有未结束的raf\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.prevTime = defaultNow();\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.startAnimationIfNecessary();\n    }\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EclearUnreadPropStyle\u003C\u002Fcode\u003E本身非常简单，就是查找style为number的，直接setState手动设定state\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  clearUnreadPropStyle = (destStyle: Style): \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evoid\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dirty = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E {currentStyle, currentVelocity, lastIdealStyle, lastIdealVelocity} = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state;\n\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E key \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E destStyle) {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.prototype.hasOwnProperty.call(destStyle, key)) {\n        \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E;\n      }\n\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E styleValue = destStyle[key];\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 参数是number，直接赋值然后setState跳转\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E styleValue === \u003Cspan class=\"hljs-string\"\u003E'number'\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当有多个属性，一次全部更新，而不是多次(每次更新一个)，防止重复获取\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!dirty) {\n          dirty = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n          currentStyle = {...currentStyle};\n          currentVelocity = {...currentVelocity};\n          lastIdealStyle = {...lastIdealStyle};\n          lastIdealVelocity = {...lastIdealVelocity};\n        }\n        currentStyle[key] = styleValue;\n        currentVelocity[key] = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n        lastIdealStyle[key] = styleValue;\n        lastIdealVelocity[key] = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n      }\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F dirty为true说明存在number的style\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (dirty) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({currentStyle, currentVelocity, lastIdealStyle, lastIdealVelocity});\n    }\n  };\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接着是\u003Ccode\u003EcomponentWillUnmount\u003C\u002Fcode\u003E和\u003Ccode\u003Erender\u003C\u002Fcode\u003E，清除raf的调用，返回唯一的children\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EcomponentWillUnmount() {\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unmounting = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n    defaultRaf.cancel(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID);\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n  }\n}\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F children是函数，有返回值并且是唯一的children\u003C\u002Fspan\u003E\nrender(): ReactElement {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E renderedChildren = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.currentStyle);\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E renderedChildren &amp;&amp; React.Children.only(renderedChildren);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EMotion\u003C\u002Fcode\u003E介绍完毕，接下来是\u003Ccode\u003EshouldStopAnimation\u003C\u002Fcode\u003E和\u003Ccode\u003Estepper\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"shouldstopanimation\"\u003EshouldStopAnimation\u003C\u002Fh3\u003E\n\u003Cp\u003E确定停止动画的条件：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E速度为0\u003C\u002Fli\u003E\n\u003Cli\u003E目标为当前位置\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EshouldStopAnimation\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  currentStyle: PlainStyle,\n  style: Style,\n  currentVelocity: Velocity,\n\u003C\u002Fspan\u003E): \u003Cspan class=\"hljs-title\"\u003Eboolean\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E key \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E style) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 原型链的属性跳过\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.prototype.hasOwnProperty.call(style, key)) {\n      \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E;\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 速度不为0，返回false\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (currentVelocity[key] !== \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E styleValue = \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E style[key] === \u003Cspan class=\"hljs-string\"\u003E'number'\u003C\u002Fspan\u003E\n      ? style[key]\n      : style[key].val;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前位置与目标位置不等，返回false\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 在stepper内部会通过设定的precision属性调整位置，例如精确度为0.1，那么0.9===1\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (currentStyle[key] !== styleValue) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n    }\n  }\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"stepper\"\u003Estepper\u003C\u002Fh3\u003E\n\u003Cp\u003E弹性动画的算法，内容不多，但是整个组件的核心\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Estepper\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 每一帧所用秒数\u003C\u002Fspan\u003E\n  secondPerFrame: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前位置\u003C\u002Fspan\u003E\n  x: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前速度\u003C\u002Fspan\u003E\n  v: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 目标位置\u003C\u002Fspan\u003E\n  destX: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 弹性\u003C\u002Fspan\u003E\n  k: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 阻力\u003C\u002Fspan\u003E\n  b: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 精度(用于停止动画)\u003C\u002Fspan\u003E\n  precision: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E): [\u003Cspan class=\"hljs-title\"\u003Enumber\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-title\"\u003Enumber\u003C\u002Fspan\u003E] \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 计算当前弹性力(离目标越近，弹性越小)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E Fspring = -k * (x - destX);\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 计算当前阻力(速度越快，阻力越大)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E Fdamper = -b * v;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前加速度，忽略质量\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E a = Fspring + Fdamper;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 新的速度\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E newV = v + a * secondPerFrame;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 新的位置\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E newX = x + newV * secondPerFrame;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 停止动画的条件，小于当前精度，则速度为0，位置为目标\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.abs(newV) &lt; precision &amp;&amp; \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.abs(newX - destX) &lt; precision) {\n    reusedTuple[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E] = destX;\n    reusedTuple[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E] = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E reusedTuple;\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"staggeredmotion\"\u003EStaggeredMotion\u003C\u002Fh3\u003E\n\u003Cp\u003E这个一个多目标的动画处理，因此大体上就是遍历需要处理的动画，然后使用类似\u003Ccode\u003EMotion\u003C\u002Fcode\u003E的方法\u003C\u002Fp\u003E\n\u003Cp\u003E还是根据生命周期函数分析\u003C\u002Fp\u003E\n\u003Cp\u003E同样先调用\u003Ccode\u003EdefaultState\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eprops: StaggeredProps\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E(props);\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.defaultState();\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里有一点不同，styles必须是函数\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-ts\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E defaultState(): StaggeredMotionState {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {defaultStyles, styles} = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 与Motion不同之处，styles是个函数，接收上一次的styles，返回值是一个数组，里面包含每一个类似Motion的style个格式\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 例如：stylex=()=&gt;[{x:{stiffness:100,damping:10,val:100},\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F                   {x:spring(50)},\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F                   {x:500}}]\u003C\u002Fspan\u003E\n    \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初始的lastIdealStyles是defaultStyles或者是styles()的返回值\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E currentStyles: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;PlainStyle&gt; = defaultStyles || styles().map(stripStyle);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对应的方向，值为0\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E currentVelocities = currentStyles.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EcurrentStyle\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E mapToZero(currentStyle));\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles: currentStyles,\n      lastIdealVelocities: currentVelocities,\n    };\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来是\u003Ccode\u003EcomponentDidMount\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E componentDidMount() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.prevTime = defaultNow();\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.startAnimationIfNecessary();\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EstartAnimationIfNecessary\u003C\u002Fcode\u003E这里取消了onRest的调用，并且是通过遍历动画序列逐个计算，其他和\u003Ccode\u003EMotion\u003C\u002Fcode\u003E的类似\u003C\u002Fp\u003E\n\u003Cp\u003E至于onRest的取消，引用官网解释：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ENo onRest for StaggeredMotion because we haven&#39;t found a good semantics for it yet. Voice your support in the issues section.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E接着是\u003Ccode\u003EcomponentWillReceiveProps\u003C\u002Fcode\u003E，结构也是一样的\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E componentWillReceiveProps(props: StaggeredProps) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyles != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F previous props haven't had the chance to be set yet; set them here\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.clearUnreadPropStyle(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyles);\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyles = props.styles(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealStyles);\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.prevTime = defaultNow();\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.startAnimationIfNecessary();\n    }\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EclearUnreadPropStyle\u003C\u002Fcode\u003E和\u003Ccode\u003EMotion\u003C\u002Fcode\u003E的意思一样，都是处理上一帧动画未结束就又触发的新的属性值，\n只有一个要注意，当任意目标需要手动更新位置，所有目标都会\u003Ccode\u003EsetState\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E接着\u003Ccode\u003Eunmount\u003C\u002Fcode\u003E和\u003Ccode\u003Erender\u003C\u002Fcode\u003E都和\u003Ccode\u003EMotion\u003C\u002Fcode\u003E无区别，就不多说了。\u003C\u002Fp\u003E\n\u003Cp\u003E可以看出，\u003Ccode\u003EStaggeredMotion\u003C\u002Fcode\u003E和\u003Ccode\u003EMotion\u003C\u002Fcode\u003E其实就是一个模子里出来的，总结下它们的不同点：\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E比较\u003C\u002Fth\u003E\n\u003Cth\u003EStaggeredMotion\u003C\u002Fth\u003E\n\u003Cth\u003EMotion\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003E动画支持目标数\u003C\u002Ftd\u003E\n\u003Ctd\u003E多个\u003C\u002Ftd\u003E\n\u003Ctd\u003E1个\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E传入style\u003C\u002Ftd\u003E\n\u003Ctd\u003E函数\u003C\u002Ftd\u003E\n\u003Ctd\u003EArray\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E动画计算\u003C\u002Ftd\u003E\n\u003Ctd\u003E遍历逐个计算\u003C\u002Ftd\u003E\n\u003Ctd\u003E单个计算\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EUnreadPropStyle\u003C\u002Ftd\u003E\n\u003Ctd\u003E任意更新全更新\u003C\u002Ftd\u003E\n\u003Ctd\u003E单个目标更新\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EonRest\u003C\u002Ftd\u003E\n\u003Ctd\u003E有\u003C\u002Ftd\u003E\n\u003Ctd\u003E无\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"transitionmotion\"\u003ETransitionMotion\u003C\u002Fh3\u003E\n\u003Cp\u003E这是最复杂的一个动画组件，涉及到元素的新增和移除，基本架构和前2者类似，但新增了许多不同的变量名，当然都是有用的，\n但也可能会看的比较乱，所以先排列出一些关键的变量，并说明它们是做什么用的\u003C\u002Fp\u003E\n\u003Ch4 id=\"pai-xu-wen-ti\"\u003E排序问题\u003C\u002Fh4\u003E\n\u003Cp\u003E因为有添加和删除，那怎么判断动画的执行顺序，用到了拓扑排序的思想\u003C\u002Fp\u003E\n\u003Cp\u003E例如：\u003C\u002Fp\u003E\n\u003Cp\u003E旧的序列： \u003Ccode\u003Ea -&gt; b -&gt; x\u003C\u002Fcode\u003E\n新的序列： \u003Ccode\u003Ec -&gt; b -&gt; d\u003C\u002Fcode\u003E\n那么很显然 \u003Ccode\u003Ea\u003C\u002Fcode\u003E和\u003Ccode\u003Ec\u003C\u002Fcode\u003E 在\u003Ccode\u003Eb\u003C\u002Fcode\u003E的前面执行， \u003Ccode\u003Ex\u003C\u002Fcode\u003E和\u003Ccode\u003Ed\u003C\u002Fcode\u003E在\u003Ccode\u003Eb\u003C\u002Fcode\u003E的后面执行\u003C\u002Fp\u003E\n\u003Cp\u003E那么\u003Ccode\u003Ea\u003C\u002Fcode\u003E和\u003Ccode\u003Ec\u003C\u002Fcode\u003E的顺序，\u003Ccode\u003Ex\u003C\u002Fcode\u003E和\u003Ccode\u003Ed\u003C\u002Fcode\u003E的顺序怎么判断\n这里使用的是next默认在后面，即默认 \u003Ccode\u003Ea -&gt; c\u003C\u002Fcode\u003E ，\u003Ccode\u003E x -&gt; d\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"transitionmotion-can-shu\"\u003ETransitionMotion参数\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E* 即将新增元素的动画起点\nwillEnter\n----------------------------\n* 即将移除元素的动画终点\nwillLeave\n----------------------------\n* 已经移除的回调，无返回值\ndidLeave\n----------------------------\n* old代表未排序的动画列表或者数据\n例如：oldMergedPropsStyles就是未排序的mergedPropsStyles\noldMergedPropsStyles\noldCurrentStyles\noldCurrentVelocities\noldLastIdealStyles\noldLastIdealVelocities\n----------------------------\n* new代表已经排序的动画列表或者数据\n例如：newMergedPropsStyles就是已经排好序的mergedPropsStyles\nnewMergedPropsStyles, \nnewCurrentStyles, \nnewCurrentVelocities, \nnewLastIdealStyles, \nnewLastIdealVelocities\n----------------------------\n以上的new和old后面变量名称的具体意思：\n\n* 当前动画属性列表(例如height，width)位置\ncurrentStyles\n----------------------------\n* 当前动画属性列表速度\ncurrentVelocities\n----------------------------\n* 上一次动画属性列表位置\nlastIdealStyles \n----------------------------\n* 上一次动画属性列表速度\nlastIdealVelocities \n----------------------------\n* 储存了key和data数据的当前动画列表\nmergedPropsStyles\n----------------------------\n通过rehydrateStyles组合而成，\n* 储存了key和data数据的目标动画列表\ndestStyles\n----------------------------\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4 id=\"rehydratestyles\"\u003ErehydrateStyles\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003ErehydrateStyles\u003C\u002Fcode\u003E是什么\u003C\u002Fp\u003E\n\u003Cp\u003E当styles是函数的时候，接受一个参数是type为\u003Ccode\u003ETransitionPlainStyle\u003C\u002Fcode\u003E，返回本次的目标值\u003C\u002Fp\u003E\n\u003Cp\u003E类似\u003Ccode\u003E{key: string, data?: any, style: PlainStyle}\u003C\u002Fcode\u003E，而它的内容则是上一次的位置，\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EmergedPropsStyles\u003C\u002Fcode\u003E的结构有key和data，但它的style有可能不是PlainStyle格式的，(有可能是\u003Ccode\u003E{stifiness:xx,damping:xxx...}\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\n\u003Cp\u003E因此要通过\u003Ccode\u003ErehydrateStyles\u003C\u002Fcode\u003E创建这种格式\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ErehydrateStyles\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  mergedPropsStyles: Array&lt;TransitionStyle&gt;,\n  unreadPropStyles: ?Array&lt;TransitionStyle&gt;,\n  plainStyles: Array&lt;PlainStyle&gt;,\n\u003C\u002Fspan\u003E): \u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003ETransitionPlainStyle\u003C\u002Fspan\u003E&gt; \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E cUnreadPropStyles = unreadPropStyles;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果unreadPropStyles不存在，则通过mergedPropsStyles创建\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (cUnreadPropStyles == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E mergedPropsStyles.map(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003EmergedPropsStyle, i\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E ({\n      \u003Cspan class=\"hljs-attr\"\u003Ekey\u003C\u002Fspan\u003E: mergedPropsStyle.key,\n      \u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: mergedPropsStyle.data,\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里style使用的是第三个参数的值，\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里计算动画时用的是lastIdealStyles，\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 而在render的时候用的是currentStyles\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-attr\"\u003Estyle\u003C\u002Fspan\u003E: plainStyles[i],\n    }));\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果unreadPropStyles对应的key存在，则通过unreadPropStyles创建\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E mergedPropsStyles.map(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003EmergedPropsStyle, i\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E j = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; j &lt; cUnreadPropStyles.length; j++) {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (cUnreadPropStyles[j].key === mergedPropsStyle.key) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n          \u003Cspan class=\"hljs-attr\"\u003Ekey\u003C\u002Fspan\u003E: cUnreadPropStyles[j].key,\n          \u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: cUnreadPropStyles[j].data,\n          \u003Cspan class=\"hljs-attr\"\u003Estyle\u003C\u002Fspan\u003E: plainStyles[i],\n        };\n      }\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\u003Cspan class=\"hljs-attr\"\u003Ekey\u003C\u002Fspan\u003E: mergedPropsStyle.key, \u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: mergedPropsStyle.data, \u003Cspan class=\"hljs-attr\"\u003Estyle\u003C\u002Fspan\u003E: plainStyles[i]};\n  });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E还是按照流程走，\u003C\u002Fp\u003E\n\u003Cp\u003E首先是\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  \u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(props: TransitionProps) {\n    \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E(props);\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.defaultState();\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E跳到\u003Ccode\u003EdefaultState\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这里用到了\u003Ca href=\"#stripstyle\"\u003EstripStyle\u003C\u002Fa\u003E，\u003Ca href=\"#mergeandsync\"\u003EmergeAndSync\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  defaultState(): TransitionMotionState {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {defaultStyles, styles, willEnter, willLeave, didLeave} = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F styles可以是对象也可以是函数，将动画目标数据赋值给destStyles\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E destStyles: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;TransitionStyle&gt; = \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E styles === \u003Cspan class=\"hljs-string\"\u003E'function'\u003C\u002Fspan\u003E ? styles(defaultStyles) : styles;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初始化oldMergedPropsStyles为defaultStyles或者destStyles\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E oldMergedPropsStyles: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;TransitionStyle&gt;;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (defaultStyles == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      oldMergedPropsStyles = destStyles;\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      oldMergedPropsStyles = (defaultStyles: any).map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EdefaultStyleCell\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; destStyles.length; i++) {\n          \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (destStyles[i].key === defaultStyleCell.key) {\n            \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E destStyles[i];\n          }\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E defaultStyleCell;\n      });\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 通过stripStyle计算出当前位置和速度\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E oldCurrentStyles = defaultStyles == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E\n      ? destStyles.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Es\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E stripStyle(s.style))\n      : (defaultStyles: any).map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Es\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E stripStyle(s.style));\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E oldCurrentVelocities = defaultStyles == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E\n      ? destStyles.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Es\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E mapToZero(s.style))\n      : defaultStyles.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Es\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E mapToZero(s.style));\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(\n      (willEnter: any),\n      (willLeave: any),\n      (didLeave: any),\n      oldMergedPropsStyles,\n      destStyles,\n      oldCurrentStyles,\n      oldCurrentVelocities,\n      oldCurrentStyles, \n      oldCurrentVelocities, \n    );\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n      mergedPropsStyles,\n    };\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接着是\u003Ccode\u003EcomponentDidMount\u003C\u002Fcode\u003E，内部调用了\u003Ccode\u003EstartAnimationIfNecessary\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这里用到了\u003Ca href=\"#rehydratestyles\"\u003ErehydrateStyles\u003C\u002Fa\u003E和\u003Ca href=\"#mergeandsync\"\u003EmergeAndSync\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EstartAnimationIfNecessary = (): \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evoid\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E propStyles = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.styles;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 通过rehydrateStyles计算destStyles\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果styles是函数，destStyles就是根据上一次的动画数据通过styles函数计算出本次的目标位置\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果styles不是函数，destStyles就是styles，也就是本次动画目标位置\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E destStyles: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;TransitionStyle&gt; = \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E propStyles === \u003Cspan class=\"hljs-string\"\u003E'function'\u003C\u002Fspan\u003E\n    ? propStyles(rehydrateStyles(\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.mergedPropsStyles,\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyles,\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealStyles,\n    ))\n    : propStyles;\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* 省略：判断是否需要停止动画，计算当前动画帧和偏差值... *\u002F\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 将旧的动画数据(未排序)转换成新的动画数据(已排序)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities] = mergeAndSync(\n    (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.willEnter: any),\n    (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.willLeave: any),\n    (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.didLeave: any),\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.mergedPropsStyles,\n    destStyles,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.currentStyles,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.currentVelocities,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealStyles,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealVelocities,\n  );\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对newMergedPropsStyles逐个计算\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; newMergedPropsStyles.length; i++) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* 省略：与StaggeredMotion流程一致... *\u002F\u003C\u002Fspan\u003E\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的\u003Ca href=\"#mergeandsync\"\u003EmergeAndSync\u003C\u002Fa\u003E我们第一次遇到，它是\u003Ccode\u003ETransitionMotion\u003C\u002Fcode\u003E组件的重点，\n对动画序列进行排序和提取当前每一个动画的位置和速度\u003C\u002Fp\u003E\n\u003Ch4 id=\"mergeandsync\"\u003EmergeAndSync\u003C\u002Fh4\u003E\n\u003Cp\u003E代码长，参数也很多，再次回顾下每个参数代表的\u003Ca href=\"#transitionmotion-can-shu\"\u003E意思\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这里调用了\u003Ca href=\"#mergediff\"\u003EmergeDiff\u003C\u002Fa\u003E，它的功能就是对要进行的动画进行先后排序，具体怎么做后面再说，先知道它的功能\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EmergeAndSync\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  willEnter: WillEnter,\n  willLeave: WillLeave,\n  didLeave: DidLeave,\n  oldMergedPropsStyles: Array&lt;TransitionStyle&gt;,\n  destStyles: Array&lt;TransitionStyle&gt;,\n  oldCurrentStyles: Array&lt;PlainStyle&gt;,\n  oldCurrentVelocities: Array&lt;Velocity&gt;,\n  oldLastIdealStyles: Array&lt;PlainStyle&gt;,\n  oldLastIdealVelocities: Array&lt;Velocity&gt;,\n\u003C\u002Fspan\u003E): [\u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003ETransitionStyle\u003C\u002Fspan\u003E&gt;, \u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003EPlainStyle\u003C\u002Fspan\u003E&gt;, \u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003EVelocity\u003C\u002Fspan\u003E&gt;, \u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003EPlainStyle\u003C\u002Fspan\u003E&gt;, \u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003EVelocity\u003C\u002Fspan\u003E&gt;] \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对要进行的动画进行先后排序(拓扑排序思想)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E newMergedPropsStyles = mergeDiff(\n    oldMergedPropsStyles,\n    destStyles,\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 参数3 是执行删除的动作，无删除动画则直接删除，有删除动画的还需要进入到动画排序\u003C\u002Fspan\u003E\n    (oldIndex, oldMergedPropsStyle) =&gt; {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E leavingStyle = willLeave(oldMergedPropsStyle);\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 无willLeave动画，直接调用didLeave\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (leavingStyle == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n        didLeave({ \u003Cspan class=\"hljs-attr\"\u003Ekey\u003C\u002Fspan\u003E: oldMergedPropsStyle.key, \u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: oldMergedPropsStyle.data });\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n      }\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 判断需要停止动画，调用didLeave\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (shouldStopAnimation(\n          oldCurrentStyles[oldIndex],\n          leavingStyle,\n          oldCurrentVelocities[oldIndex])) {\n        didLeave({ \u003Cspan class=\"hljs-attr\"\u003Ekey\u003C\u002Fspan\u003E: oldMergedPropsStyle.key, \u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: oldMergedPropsStyle.data });\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n      }\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 有willLeave并且动画还未停止，返回删除动画\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\u003Cspan class=\"hljs-attr\"\u003Ekey\u003C\u002Fspan\u003E: oldMergedPropsStyle.key, \u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: oldMergedPropsStyle.data, \u003Cspan class=\"hljs-attr\"\u003Estyle\u003C\u002Fspan\u003E: leavingStyle};\n    },\n  );\n\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newCurrentStyles = [];\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newCurrentVelocities = [];\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newLastIdealStyles = [];\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newLastIdealVelocities = [];\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 注意！！此处newMergedPropsStyles已经是排好序的动画序列\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 后面的就是填充上面这个4个变量了(根据排好的顺序)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; newMergedPropsStyles.length; i++) {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E newMergedPropsStyleCell = newMergedPropsStyles[i];\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E foundOldIndex = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E j = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; j &lt; oldMergedPropsStyles.length; j++) {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {\n        foundOldIndex = j;\n        \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E;\n      }\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 无旧的全是新增，创建新的数据\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (foundOldIndex == \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E plainStyle = willEnter(newMergedPropsStyleCell);\n      newCurrentStyles[i] = plainStyle;\n      newLastIdealStyles[i] = plainStyle;\n\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E velocity = mapToZero(newMergedPropsStyleCell.style);\n      newCurrentVelocities[i] = velocity;\n      newLastIdealVelocities[i] = velocity;\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 有旧的target更新或者删除，使用旧的数据作为新排序的数据\u003C\u002Fspan\u003E\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];\n      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];\n      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];\n      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];\n    }\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F*\n  * newMergedPropsStyles：已经排好序的动画序列\n  * newCurrentStyles：已经排好序的目前的位置\n  * newCurrentVelocities：已经排好序的目前的速度\n  * newLastIdealStyles：已经排好序的旧的位置\n  * newLastIdealVelocities：已经排好序的旧的速度\n  * *\u002F\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities];\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接着\u003Ccode\u003EcomponentWillReceiveProps\u003C\u002Fcode\u003E调用了\u003Ccode\u003EclearUnreadPropStyle\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这里用到了\u003Ca href=\"#mergeandsync\"\u003EmergeAndSync\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EclearUnreadPropStyle = (unreadPropStyles: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;TransitionStyle&gt;): \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evoid\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对动画序列进行合并及排序\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(\n    (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.willEnter: any),\n    (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.willLeave: any),\n    (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.didLeave: any),\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.mergedPropsStyles,\n    unreadPropStyles,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.currentStyles,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.currentVelocities,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealStyles,\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.lastIdealVelocities,\n  );\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* 省略：如果是number，直接赋值为目标值... *\u002F\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 没有使用dirty判断\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({\n    currentStyles,\n    currentVelocities,\n    mergedPropsStyles,\n    lastIdealStyles,\n    lastIdealVelocities,\n  });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里没有和之前2个组件一样使用if(dirty)\u003C\u002Fp\u003E\n\u003Cp\u003E因为每一个style的data即便属性值不是number，也有可能存在新的属性\u003C\u002Fp\u003E\n\u003Cp\u003E最后便是\u003Ccode\u003EcomponentUnmount\u003C\u002Fcode\u003E和\u003Ccode\u003Erender\u003C\u002Fcode\u003E了\u003C\u002Fp\u003E\n\u003Cp\u003E1个要注意的地方，同样在render的时候调用了\u003Ccode\u003ErehydrateStyles\u003C\u002Fcode\u003E，\n说明这个组件的\u003Ccode\u003Ethis.props.children\u003C\u002Fcode\u003E接受的参数格式和\u003Ccode\u003Ethis.props.styles\u003C\u002Fcode\u003E接受的参数格式一样\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  componentWillUnmount() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unmounting = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      defaultRaf.cancel(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID);\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.animationID = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E;\n    }\n  }\n\n  render(): ReactElement {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 通过currentStyles转化为children参数需要的格式\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hydratedStyles = rehydrateStyles(\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.mergedPropsStyles,\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unreadPropStyles,\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.currentStyles,\n    );\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E renderedChildren = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children(hydratedStyles);\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E renderedChildren &amp;&amp; React.Children.only(renderedChildren);\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E三大模块都结束了，其中穿插着各种方法也介绍完了，除了\u003Ccode\u003EmergeDiff\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"mergediff\"\u003EmergeDiff\u003C\u002Fh3\u003E\n\u003Cp\u003E对\u003Ca href=\"#pai-xu-wen-ti\"\u003E排序问题\u003C\u002Fa\u003E的具体操作\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EmergeDiff\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\n  prev: Array&lt;TransitionStyle&gt;,\n  next: Array&lt;TransitionStyle&gt;,\n  onRemove: (prevIndex: number, prevStyleCell: TransitionStyle\u003C\u002Fspan\u003E) =&gt; ?\u003Cspan class=\"hljs-title\"\u003ETransitionStyle\u003C\u002Fspan\u003E\n): \u003Cspan class=\"hljs-title\"\u003EArray\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-title\"\u003ETransitionStyle\u003C\u002Fspan\u003E&gt; \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 保存初始index的顺序，后面排序比较时使用\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E prevKeyIndex: {[key: string]: number} = {};\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; prev.length; i++) {\n    prevKeyIndex[prev[i].key] = i;\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E nextKeyIndex: {[key: string]: number} = {};\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; next.length; i++) {\n    nextKeyIndex[next[i].key] = i;\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 先保存所有next中的动画序列，再去处理prev中的 \u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E ret = [];\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; next.length; i++) {\n    ret[i] = next[i];\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; prev.length; i++) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F prev中有key的属性，而next中这个属性名无key，说明是要删除的\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.prototype.hasOwnProperty.call(nextKeyIndex, prev[i].key)) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果已经删除，返回null，如果正在执行删除动画，返回状态\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E fill = onRemove(i, prev[i]);\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (fill != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 添加进ret\u003C\u002Fspan\u003E\n        ret.push(fill);\n      }\n    }\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ret就是所有要进行的动画，现在进行排序(4种情况，其实是3种，3和4相反)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E ret.sort(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Ea, b\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E nextOrderA = nextKeyIndex[a.key];\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E nextOrderB = nextKeyIndex[b.key];\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E prevOrderA = prevKeyIndex[a.key];\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E prevOrderB = prevKeyIndex[b.key];\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 1. a,b都在next，按next的位置排序\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nextOrderA != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E &amp;&amp; nextOrderB != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E nextKeyIndex[a.key] - nextKeyIndex[b.key];\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2. a,b都在prev，按prev的位置排序\u003C\u002Fspan\u003E\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (prevOrderA != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E &amp;&amp; prevOrderB != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E prevKeyIndex[a.key] - prevKeyIndex[b.key];\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3. a在next，b在prev\u003C\u002Fspan\u003E\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nextOrderA != \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 采取找中间值的办法，\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 例如\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 旧的：a, b, x\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 新的：c, b, d\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初始ret顺序为： c-&gt;b-&gt;d-&gt;a-&gt;x\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F a和x都不在新的里面，因此\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果判断 a 和 d 的顺序，找中间值 b， a&lt;b， d&gt;b， 因此 a-&gt;b-&gt;d\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果判断 x 和 d 的顺序，没有中间值，因此按照next放在后面  x-&gt;d\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; next.length; i++) {\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E pivot = next[i].key;\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F prev没有这个中间值，跳过\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {\n          \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E;\n        }\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F next和prev都存在，判断之前的位置关系\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nextOrderA &lt; nextKeyIndex[pivot] &amp;&amp; prevOrderB &gt; prevKeyIndex[pivot]) {\n          \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E;\n        } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nextOrderA &gt; nextKeyIndex[pivot] &amp;&amp; prevOrderB &lt; prevKeyIndex[pivot]) {\n          \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n        }\n      }\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认为next放后面\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 4. b在next, a在prev, 和第3种情况相反\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; next.length; i++) {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E pivot = next[i].key;\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {\n        \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E;\n      }\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nextOrderB &lt; nextKeyIndex[pivot] &amp;&amp; prevOrderA &gt; prevKeyIndex[pivot]) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n      } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nextOrderB &gt; nextKeyIndex[pivot] &amp;&amp; prevOrderA &lt; prevKeyIndex[pivot]) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E;\n      }\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E;\n  });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E所有\u003Ccode\u003Ereact-motion\u003C\u002Fcode\u003E的分析就到此为止！\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003Ereact-motion流程导图\n\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.react-motion\u002Freact-motion.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n",toc:[{anchor:"jie-shao",level:c,text:"介绍"},{anchor:"jie-gou",level:c,text:"结构"},{anchor:"3-da-mo-kuai-gong-gong-fang-fa",level:c,text:"3大模块+公共方法"},{anchor:e,level:a,text:e},{anchor:f,level:a,text:f},{anchor:"maptozero",level:a,text:"mapToZero"},{anchor:"stripstyle",level:a,text:"stripStyle"},{anchor:"motion",level:a,text:"Motion"},{anchor:"shouldstopanimation",level:a,text:"shouldStopAnimation"},{anchor:g,level:a,text:g},{anchor:"staggeredmotion",level:a,text:"StaggeredMotion"},{anchor:"transitionmotion",level:a,text:"TransitionMotion"},{anchor:"pai-xu-wen-ti",level:b,text:"排序问题"},{anchor:"transitionmotion-can-shu",level:b,text:"TransitionMotion参数"},{anchor:"rehydratestyles",level:b,text:"rehydrateStyles"},{anchor:"mergeandsync",level:b,text:"mergeAndSync"},{anchor:"mergediff",level:a,text:"mergeDiff"}],relatedTags:["react","源码","算法"],created_at:"2021-08-08",timeArr:[2021,7,8,11,45,40,0],title:"源码阅读-react-motion",uuid:"f7719af5b1eadd4423c1b00da230569e16d39662",summary:"\u003Ch4\u003E介绍\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003Ereact-motion\u003C\u002Fcode\u003E是一个react的动画组件，只需要为UI元素设置一个弹力和阻力和目标位置，便可渲染出符合现实的弹性动画效果\u003C\u002Fp\u003E\n\u003Cp\u003E算法：\u003C\u002Fp\u003E\n\u003Cp\u003E弹性算法，算法本身([stepper.js](https:\u002F\u002Fgithub.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fblob\u002Fma...\u003C\u002Fp\u003E",slug:d,sha:"b8d21fe030902ab5d37cc67bc1955e0e28545c9c"}}],fetch:{},mutations:void 0}}(3,4,2,"source-code-react-motion","presets","spring","stepper")));