__NUXT_JSONP__("/article/source-code-unstated", (function(a,b,c){return {data:[{slug:c,articleDetails:{content:"\u003Ch2 id=\"jian-jie\"\u003E简介\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Eunstated\u003C\u002Fcode\u003E是一个极简的状态管理组件\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E看它的简介：State so simple, it goes without saying\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"dui-bi\"\u003E对比\u003C\u002Fh2\u003E\n\u003Ch3 id=\"dui-bi-redux\"\u003E对比redux\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E更加灵活(相对的缺点是缺少规则，需要使用者的自觉)\u003C\u002Fp\u003E\n\u003Cp\u003E  \u003Ccode\u003Eredux\u003C\u002Fcode\u003E的状态是存放在一棵树内，采用严格的单向流\u003C\u002Fp\u003E\n\u003Cp\u003E  \u003Ccode\u003Eunstated\u003C\u002Fcode\u003E的状态是用户自己定义，说白了就是\u003Ccode\u003Eobject\u003C\u002Fcode\u003E，可以放在一个组件的内，也可以放在多个组件内\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E针对\u003Ccode\u003EReact\u003C\u002Fcode\u003E，一致的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E  \u003Ccode\u003Eredux\u003C\u002Fcode\u003E必须编写\u003Ccode\u003Ereducer\u003C\u002Fcode\u003E和\u003Ccode\u003Eaction\u003C\u002Fcode\u003E，通过\u003Ccode\u003Edispatch(action)\u003C\u002Fcode\u003E改变状态，它不限框架\u003C\u002Fp\u003E\n\u003Cp\u003E  \u003Ccode\u003Eunstated\u003C\u002Fcode\u003E\u003Cstrong\u003E改变状态的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E完全与\u003Ccode\u003EReact\u003C\u002Fcode\u003E一致\u003C\u002Fstrong\u003E，使用\u003Ccode\u003Ethis.setState\u003C\u002Fcode\u003E，当然和\u003Ccode\u003EReact\u003C\u002Fcode\u003E的\u003Ccode\u003EsetState\u003C\u002Fcode\u003E不同，\n  但是它的底层也是用到了\u003Ccode\u003EsetState\u003C\u002Fcode\u003E去更新视图\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E功能相对简单\u003C\u002Fp\u003E\n\u003Cp\u003E  \u003Ccode\u003Eunstated\u003C\u002Fcode\u003E没有中间件功能，每次状态改变(不管是否相等)，都会重新渲染(\u003Ccode\u003EV2.1.1\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\n\u003Cp\u003E  可以自定义\u003Ccode\u003Elistener\u003C\u002Fcode\u003E，每次更新状态时都会执行。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"dui-bi-react-de-zi-dai-state\"\u003E对比React的自带state\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E天生将组件分割为\u003Ccode\u003EContainer(状态管理)\u003C\u002Fcode\u003E和\u003Ccode\u003EComponent(视图管理)\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E灵活配置共享状态或者私有状态\u003C\u002Fli\u003E\n\u003Cli\u003E支持\u003Ccode\u003Epromise\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"chu-shi\"\u003E初识\u003C\u002Fh2\u003E\n\u003Cp\u003E3大板块和几个关键变量\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EProvider: 注入状态实例，传递map，本质是Context.Provider，可嵌套达成链式传递\nContainer: 状态管理类，遵循React的API，发布订阅模式，通过new生成状态管理实例\nSubscribe: 订阅状态组件，本质是Context.Consumer，接收Provider提供的map，视图渲染组件\nmap: new Map()，通过类查找当前类创建的状态管理实例\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"shen-ru\"\u003E深入\u003C\u002Fh2\u003E\n\u003Cp\u003E这里引入官方例子\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-typescript\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F @flow\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E React \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'react'\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { render } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'react-dom'\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { Provider, Subscribe, Container } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'unstated'\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E CounterState = {\n  count: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E\n};\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义一个状态管理类\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E CounterContainer \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E Container&lt;CounterState&gt; {\n  state = {\n    count: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n  };\n\n  increment() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({ count: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.count + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E });\n  }\n\n  decrement() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({ count: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.count - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E });\n  }\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 渲染视图组件(Context.Consumer的模式)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ECounter\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n    &lt;Subscribe to={[CounterContainer]}&gt;\n      {\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Ecounter\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E (\n        &lt;div&gt;\n          &lt;button onClick={\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E counter.decrement()}&gt;-&lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002Fbutton&gt;\n          &lt;span&gt;{counter.state.count}&lt;\u002F\u003C\u002Fspan\u003Espan&gt;\n          &lt;button onClick={\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E counter.increment()}&gt;+&lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002Fbutton&gt;\n        &lt;\u002F\u003C\u002Fspan\u003Ediv&gt;\n      )}\n    &lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002FSubscribe&gt;\n  );\n}\n\nrender(\n  &lt;Provider&gt;\n    &lt;Counter \u002F\u003C\u002Fspan\u003E&gt;\n  &lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002FProvider&gt;,\n  document.getElementById('root')\n);\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里\u003Ccode\u003ECounter\u003C\u002Fcode\u003E是我们自定义的视图组件，首先使用\u003Ccode\u003E&lt;Provider&gt;\u003C\u002Fcode\u003E包裹，接着在\u003Ccode\u003ECounter\u003C\u002Fcode\u003E内部，调用\u003Ccode\u003E&lt;Subscribe&gt;\u003C\u002Fcode\u003E组件，\n传递一个数组给\u003Ccode\u003Eprops.to\u003C\u002Fcode\u003E，这个数组内存放了\u003Ccode\u003ECounter\u003C\u002Fcode\u003E组件需要使用的\u003Ccode\u003E状态管理类\u003C\u002Fcode\u003E(此处也可传递\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E)。\u003C\u002Fp\u003E\n\u003Ch3 id=\"provider\"\u003EProvider\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-typescript\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EProvider\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eprops: ProviderProps\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n    &lt;StateContext.Consumer&gt;\n      {\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EparentMap\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E childMap = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Map(parentMap);\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 外部注入的状态管理实例\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (props.inject) {\n          props.inject.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Einstance\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n            childMap.set(instance.\u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E, instance);\n          });\n        }\n\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 负责将childMap传递，初始为null\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n          &lt;StateContext.Provider value={childMap}&gt;\n            {props.children}\n          &lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002FStateContext.Provider&gt;\n        );\n      }}\n    &lt;\u002F\u003C\u002Fspan\u003EStateContext.Consumer&gt;\n  );\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的模式是\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E&lt;Consumer&gt;\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E=&gt;\u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E &lt;Provider&gt;{props.children}&lt;Provider \u002F&gt;\n  }\n&lt;\u002FConsumer&gt;  \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E有3个注意点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E外层嵌套\u003Ccode\u003E&lt;Consumer&gt;\u003C\u002Fcode\u003E可以嵌套调用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E&lt;Provider value={...}&gt;\n \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n &lt;Provider value={此处继承了上面的value}&gt;\n \u002F* ... *\u002F \n&lt;\u002FProvider&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eprops.inject\u003C\u002Fcode\u003E可以注入现成的\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E，添加到\u003Ccode\u003Emap\u003C\u002Fcode\u003E之中。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E返回值写成\u003Ccode\u003Eprops.children\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"fan-hui-zhi-xie-cheng-propschildren-de-yi-yi\"\u003E返回值写成props.children的意义\u003C\u002Fh3\u003E\n\u003Cp\u003E简单一句话概括，这么写可以避免\u003Ccode\u003EReact.Context\u003C\u002Fcode\u003E改变导致子组件的重复渲染。\u003C\u002Fp\u003E\n\u003Cp\u003E具体看这里：\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F50336226\"\u003E避免React Context导致的重复渲染\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"container\"\u003EContainer\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-typescript\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E Container&lt;State: {}&gt; {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 保存状态 默认为{}\u003C\u002Fspan\u003E\n  state: State;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 保存监听函数，默认为[]\u003C\u002Fspan\u003E\n  _listeners: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;Listener&gt; = [];\n\n  setState(\n    updater: $Shape&lt;State&gt; | \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E(\u003Cspan class=\"hljs-params\"\u003EprevState: $Shape&lt;State&gt;\u003C\u002Fspan\u003E) =&gt; $Shape&lt;State&gt;\u003C\u002Fspan\u003E),\n    \u003Cspan class=\"hljs-params\"\u003Ecallback\u003C\u002Fspan\u003E?: \u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Evoid\u003C\u002Fspan\u003E\n  ): \u003Cspan class=\"hljs-built_in\"\u003EPromise\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Evoid\u003C\u002Fspan\u003E&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EPromise\u003C\u002Fspan\u003E.resolve().then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E nextState;\n\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F* 利用Object.assign改变state *\u002F\u003C\u002Fspan\u003E\n\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 执行listener(promise)\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E promises = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._listeners.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Elistener\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E listener());\n\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 所有Promise执行完毕\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EPromise\u003C\u002Fspan\u003E.all(promises).then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 全部listener执行完毕，执行回调\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (callback) {\n          \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E callback();\n        }\n      });\n    });\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 增加订阅(这里默认的订阅就是React的setState空值(为了重新渲染)，也可以添加自定义监听函数)\u003C\u002Fspan\u003E\n  subscribe(fn: Listener) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._listeners.push(fn);\n  }\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 取消订阅\u003C\u002Fspan\u003E\n  unsubscribe(fn: Listener) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._listeners = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._listeners.filter(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Ef\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E f !== fn);\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EContainer\u003C\u002Fcode\u003E内部逻辑很简单，改变\u003Ccode\u003Estate\u003C\u002Fcode\u003E，执行监听函数。\u003C\u002Fp\u003E\n\u003Cp\u003E其中有一个\u003Ccode\u003E_listeners\u003C\u002Fcode\u003E，是用于存放监听函数的。\u003C\u002Fp\u003E\n\u003Cp\u003E每个\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E存在一个默认监听函数\u003Ccode\u003EonUpdate\u003C\u002Fcode\u003E，\n这个默认的监听函数的作用就是\u003Ccode\u003E调用React的setState强制视图重新渲染\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E这里的监听函数内部返回\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，最后通过\u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E确保执行完毕，然后执行\u003Ccode\u003E回调参数\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E因此\u003Ccode\u003EsetState\u003C\u002Fcode\u003E在外面使用也可以使用\u003Ccode\u003Ethen\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E例如，在官方例子中：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Eincrement() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState({ \u003Cspan class=\"hljs-attr\"\u003Ecount\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.state.count + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E },()=&gt;\u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E'2'\u003C\u002Fspan\u003E))\n    .then(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E=&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E'3'\u003C\u002Fspan\u003E) )\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E'1'\u003C\u002Fspan\u003E) \n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 执行顺序是 1 -&gt; 2 -&gt;3\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E2个注意点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EsetState\u003C\u002Fcode\u003E和\u003Ccode\u003EReact API\u003C\u002Fcode\u003E一致，第一个参数传入object或者function，第二个传入回调\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E这里通过\u003Ccode\u003EPromise.resolve().then\u003C\u002Fcode\u003E模拟\u003Ccode\u003Ethis.setState\u003C\u002Fcode\u003E的异步执行\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"guan-yu-promiseresolve-he-settimeout-de-qu-bie\"\u003E关于Promise.resolve和setTimeout的区别\u003C\u002Fh3\u003E\n\u003Cp\u003E简单的说两者都是异步调用，\u003Ccode\u003EPromise\u003C\u002Fcode\u003E更快执行。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EsetTimeout(()=&gt;{},0)\u003C\u002Fcode\u003E会放入下一个新的\u003Ccode\u003E任务队列\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EPromise.resolve().then({})\u003C\u002Fcode\u003E会放入\u003Ccode\u003E微任务\u003C\u002Fcode\u003E，在调用栈为空时立刻补充调用栈并执行(简单理解为当前\u003Ccode\u003E任务队列\u003C\u002Fcode\u003E尾部)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E更多详细可以看这里提供的2个视频：\u003Ccode\u003Ehttps:\u002F\u002Fstackoverflow.com\u002Fa\u002F38752743\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"subscribe\"\u003ESubscribe\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-typescript\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E Subscribe&lt;Containers: ContainersType&gt; \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E React.Component&lt;\n  SubscribeProps&lt;Containers&gt;,\n  SubscribeState\n&gt; {\n  state = {};\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 存放传入的状态组件\u003C\u002Fspan\u003E\n  instances: \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;ContainerType&gt; = [];\n  unmounted = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n\n  componentWillUnmount() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unmounted = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._unsubscribe();\n  }\n\n  _unsubscribe() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.instances.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Econtainer\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F container为当前组件的每一个状态管理实例\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 删除listeners中的this.onUpdate\u003C\u002Fspan\u003E\n      container.unsubscribe(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.onUpdate);\n    });\n  }\n\n  onUpdate: Listener = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EPromise\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eresolve\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 组件未被卸载\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.unmounted) {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 纯粹是为了让React更新组件\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.setState(DUMMY_STATE, resolve);\n      } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 已经被卸载则直接返回\u003C\u002Fspan\u003E\n        resolve();\n      }\n    });\n  };\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的关键就是\u003Ccode\u003Einstances\u003C\u002Fcode\u003E，用于存放当前组件的\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E当组件\u003Ccode\u003Eunmount\u003C\u002Fcode\u003E的时候，会\u003Ccode\u003Eunsubscribe\u003C\u002Fcode\u003E当前\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E的默认监听函数，那么如果当前的\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E是共享的，会不会有影响呢？\u003C\u002Fp\u003E\n\u003Cp\u003E不会的。往后看可以知道，当\u003Ccode\u003Estate\u003C\u002Fcode\u003E每次更新，都会重新创建新的\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E(因为\u003Ccode\u003Eprops.to\u003C\u002Fcode\u003E的值可能会发生变化，例如取消某一个\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E)，\n而每次创建时，都会先\u003Ccode\u003Eunsubscribe\u003C\u002Fcode\u003E再\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E，确保不会重复添加监听函数。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EonUpdate\u003C\u002Fcode\u003E就是创建\u003Ccode\u003E状态管理组件\u003C\u002Fcode\u003E时默认传递的监听函数，用的是\u003Ccode\u003EReact\u003C\u002Fcode\u003E的\u003Ccode\u003EsetState\u003C\u002Fcode\u003E更新一个\u003Ccode\u003EDUMMY_STATE\u003C\u002Fcode\u003E(空对象\u003Ccode\u003E{}\u003C\u002Fcode\u003E)。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-typescript\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E Subscribe&lt;Containers: ContainersType&gt; \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E React.Component&lt;\n  SubscribeProps&lt;Containers&gt;,\n  SubscribeState\n&gt; {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n\n  _createInstances(\n    map: ContainerMapType | \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E,\n    containers: ContainersType\n  ): \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E&lt;ContainerType&gt; {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 首先全部instances解除订阅\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._unsubscribe();\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 必须存在map 必须被Provider包裹才会有map\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (map === \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EError\u003C\u002Fspan\u003E(\n        \u003Cspan class=\"hljs-string\"\u003E'You must wrap your &lt;Subscribe&gt; components with a &lt;Provider&gt;'\u003C\u002Fspan\u003E\n      );\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E safeMap = map;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 重新定义当前组件的状态管理组件(根据to传入的数组)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E instances = containers.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EContainerItem\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E instance;\n\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 传入的是Container组件，则使用\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\n        \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E ContainerItem === \u003Cspan class=\"hljs-string\"\u003E'object'\u003C\u002Fspan\u003E &amp;&amp;\n        ContainerItem \u003Cspan class=\"hljs-keyword\"\u003Einstanceof\u003C\u002Fspan\u003E Container\n      ) {\n        instance = ContainerItem;\n      } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 传入的不是Container，可能是其他自定义组件等等(需要用new执行)，尝试获取\u003C\u002Fspan\u003E\n        instance = safeMap.get(ContainerItem);\n\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不存在则以它为key，value是新的Container组件\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!instance) {\n          instance = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E ContainerItem();\n          safeMap.set(ContainerItem, instance);\n        }\n      }\n\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 先解绑再绑定，避免重复订阅\u003C\u002Fspan\u003E\n      instance.unsubscribe(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.onUpdate);\n      instance.subscribe(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.onUpdate);\n\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E instance;\n    });\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.instances = instances;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E instances;\n  }\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* ... *\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E_createInstances\u003C\u002Fcode\u003E内部，如果检查到传入的\u003Ccode\u003Eprops.to\u003C\u002Fcode\u003E的值已经是\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E(私有状态组件)，那么直接使用即可，\n如果传入的是\u003Ccode\u003E类class\u003C\u002Fcode\u003E(共享状态组件)，会尝试通过查询\u003Ccode\u003Emap\u003C\u002Fcode\u003E，不存在的则通过\u003Ccode\u003Enew\u003C\u002Fcode\u003E创建。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-typescript\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E Subscribe&lt;Containers: ContainersType&gt; \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E React.Component&lt;\n  SubscribeProps&lt;Containers&gt;,\n  SubscribeState\n&gt; {\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F* 上面已讲 *\u002F\u003C\u002Fspan\u003E\n  \n  render() {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n      &lt;StateContext.Consumer&gt;\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F* Provider传递的map *\u002F\u003C\u002Fspan\u003E\n      {\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Emap\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E\n          \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F children是函数\u003C\u002Fspan\u003E\n          \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.children.apply(\n            \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E,\n            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 传给子函数的参数(传进当前组件的状态管理实例)\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._createInstances(map, \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.props.to)\n          )\n        }\n      &lt;\u003Cspan class=\"hljs-regexp\"\u003E\u002FStateContext.Consumer&gt;\n    );\n  }\n}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E每一次\u003Ccode\u003Erender\u003C\u002Fcode\u003E都会创建新的\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E到此，3大板块已经阅读完毕。\u003C\u002Fp\u003E\n\u003Ch2 id=\"zong-jie\"\u003E总结\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E简单易用，与\u003Ccode\u003EReact\u003C\u002Fcode\u003E一致的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，一致的书写模式，让使用者很快上手。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E并没有规定如何管理这些\u003Ccode\u003E状态管理类\u003C\u002Fcode\u003E，非常灵活。\u003C\u002Fp\u003E\n\u003Cp\u003E 我们可以学\u003Ccode\u003Eredux\u003C\u002Fcode\u003E将所有状态放到一个\u003Ccode\u003E共享状态管理实例\u003C\u002Fcode\u003E内部，\n 例如通过\u003Ccode\u003EProvider\u003C\u002Fcode\u003E的\u003Ccode\u003Einject\u003C\u002Fcode\u003E属性注入，\u003C\u002Fp\u003E\n\u003Cp\u003E 或者针对每一个组件创建单独的\u003Ccode\u003E状态管理实例\u003C\u002Fcode\u003E(可共享可独立)(\u003Ccode\u003Eunstated\u003C\u002Fcode\u003E作者推荐)，\u003C\u002Fp\u003E\n\u003Cp\u003E 一切可以按照自己的想法，但同时也要求使用者自己定义一些规则去约束写法。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E仅仅是管理了状态，每次更新都是一个全新的\u003Ccode\u003Einstance\u003C\u002Fcode\u003E集合，并没有做任何对比，需要我们在视图层自己实现。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E返回值写成\u003Ccode\u003Eprops.children\u003C\u002Fcode\u003E的\u003Ca href=\"#fan-hui-zhi-xie-cheng-propschildren-de-yi-yi\"\u003E意义\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E关于\u003Ccode\u003EPromise.resolve().then({})\u003C\u002Fcode\u003E和\u003Ccode\u003EsetTimeout(()=&gt;{},0)\u003C\u002Fcode\u003E的\u003Ca href=\"#guan-yu-Promiseresolve-he-setTimeout-de-qu-bie\"\u003E区别\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"dao-tu\"\u003E导图\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.unstated\u002Funstated.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n",toc:[{anchor:"jian-jie",level:b,text:"简介"},{anchor:"dui-bi",level:b,text:"对比"},{anchor:"dui-bi-redux",level:a,text:"对比redux"},{anchor:"dui-bi-react-de-zi-dai-state",level:a,text:"对比React的自带state"},{anchor:"chu-shi",level:b,text:"初识"},{anchor:"shen-ru",level:b,text:"深入"},{anchor:"provider",level:a,text:"Provider"},{anchor:"fan-hui-zhi-xie-cheng-propschildren-de-yi-yi",level:a,text:"返回值写成props.children的意义"},{anchor:"container",level:a,text:"Container"},{anchor:"guan-yu-promiseresolve-he-settimeout-de-qu-bie",level:a,text:"关于Promise.resolve和setTimeout的区别"},{anchor:"subscribe",level:a,text:"Subscribe"},{anchor:"zong-jie",level:b,text:"总结"},{anchor:"dao-tu",level:b,text:"导图"}],relatedTags:["源码","react","promise","redux"],created_at:"2018-12-08",timeArr:[2018,11,8,10,29,27,0],title:"源码阅读-unstated",uuid:"1ec6d586c759db1ce817117277e391c08a8d1c01",summary:"\u003Cp\u003E看它的简介：State so simple, it goes without saying\u003C\u002Fp\u003E",slug:c,sha:"471fa80d4139f88a0f770af34e991a0b73babacc"}}],fetch:{},mutations:void 0}}(3,2,"source-code-unstated")));