__NUXT_JSONP__("/article/source-code-redux-observable", (function(a,b,c,d,e,f){return {data:[{slug:c,articleDetails:{content:"\u003Ch2 id=\"yue-du-qian-ti\"\u003E阅读前提\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E有rxjs基础，对\u003Ccode\u003EObservable\u003C\u002Fcode\u003E, \u003Ccode\u003ESubject\u003C\u002Fcode\u003E,\u003Ccode\u003Epipe\u003C\u002Fcode\u003E和一些操作符(例如\u003Ccode\u003Efilter\u003C\u002Fcode\u003E,\u003Ccode\u003Emap\u003C\u002Fcode\u003E,\u003Ccode\u003Emerge\u003C\u002Fcode\u003E,\u003Ccode\u003EmergeMap\u003C\u002Fcode\u003E)执行流程有基本了解，最起码遇到不清楚有去查阅的动力\u003C\u002Fli\u003E\n\u003Cli\u003E比较熟悉\u003Ccode\u003Eredux\u003C\u002Fcode\u003E中间件的写法，否则像\u003Ccode\u003EcreateEpicMiddleware.js\u003C\u002Fcode\u003E中的这一段会搞不清楚\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Ereturn next =&gt; {\n  return action =&gt; {\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n 关于redux也可以查阅我之前写的\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fstonehank\u002Fsourcecode-analysis\u002Ftree\u002Fmaster\u002Fsource-code.redux\"\u003Eredux源码注释\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"mu-lu-jie-gou\"\u003E目录结构\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Esrc\u002F\n├──utils\u002F\n    ├──console.js\n├── ActionsObservable.js    \u002F\u002F 自定义的类，继承Observable, 绑定了操作符的链式调用\n├── combineEpics.js         \u002F\u002F \n├── createEpicMiddleware.js \u002F\u002F 调用可生成redux的中间件, 通过run绑定需要执行的流\n├── index.js                \u002F\u002F 对外接口\n├── operators.js            \u002F\u002F 自定义的流操作方法, 目前只有ofType\n├── StateObservable.js      \u002F\u002F 自定义的类，继承Observable, 用于保存当前state\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"yuan-ma-fen-xi\"\u003E源码分析\u003C\u002Fh2\u003E\n\u003Cp\u003Eindex.js：公开接口，略\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"actionobservablejs\"\u003EActionObservable.js\u003C\u002Fh3\u003E\n\u003Cp\u003E继承了\u003Ccode\u003EObservable\u003C\u002Fcode\u003E类\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EActionsObservable\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EObservable\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E定义了两个静态函数，用调用的对象包装了原来的\u003Ccode\u003Eof\u003C\u002Fcode\u003E和\u003Ccode\u003Efrom\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  \u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eof\u003C\u002Fspan\u003E(...actions) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Eof\u003C\u002Fspan\u003E(...actions));\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Estatic\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E(actions, scheduler) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E(actions, scheduler));\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E构造函数，定义了\u003Ccode\u003Esource\u003C\u002Fcode\u003E属性为参数，这个属性用来绑定操作符的链式调用\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  \u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(actionsSubject) {\n    \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E();\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.source = actionsSubject;\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里重写了父类(Observable)的\u003Ccode\u003Elift\u003C\u002Fcode\u003E，先看一下父类的\u003Ccode\u003Elift\u003C\u002Fcode\u003E是怎样的\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E observable = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Observable();\nobservable.source = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E;\nobservable.operator = operator;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E observable;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以看到改动就在于原来的用\u003Ccode\u003Enew Observable\u003C\u002Fcode\u003E，这里使用\u003Ccode\u003Enew ActionObservable()\u003C\u002Fcode\u003E，其他都是一模一样，\n封装成\u003Ccode\u003EActionObservable\u003C\u002Fcode\u003E类的意义，统一类型，方便后面的链式绑定\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Elift\u003C\u002Fcode\u003E在\u003Ccode\u003Epipe\u003C\u002Fcode\u003E的时候会用到，其实这都是rxjs源码调用的方式()\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Elift(operator) {\n \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E observable = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E ActionsObservable(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E);\n observable.operator = operator;\n \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E observable;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E定义了一个操作方法\u003Ccode\u003EofType\u003C\u002Fcode\u003E，具体见operators\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  ofType(...keys) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E ofType(...keys)(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E);\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"combineepicsjs\"\u003EcombineEpics.js\u003C\u002Fh3\u003E\n\u003Cp\u003E将多个epic合并成1个epic，就是分别执行每一个epic(绑定用户定义的操作符)，然后将每一个结果的流用merge合并\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 引入merge\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { merge } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'rxjs'\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F**\n  Merges all epics into a single one.\n *\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E combineEpics = \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E...epics\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 通过merge操作符合并多个epic执行后的output$流\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ...epics是多个epic\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E merger = \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E...args\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E merge(\n    ...epics.map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eepic\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 执行每一个epic，确保有返回值，此处执行就是绑定了用户自定义操作符的步骤\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E output$ = epic(...args);\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!output$) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003ETypeError\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E`combineEpics: one of the provided Epics \"\u003Cspan class=\"hljs-subst\"\u003E${epic.name || \u003Cspan class=\"hljs-string\"\u003E'&lt;anonymous&gt;'\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\" does not return a stream. Double check you\\'re not missing a return statement!`\u003C\u002Fspan\u003E);\n      }\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回结果，最后进行merge合并\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E output$;\n    })\n  );\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Technically the `name` property on Function's are supposed to be read-only.\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F While some JS runtimes allow it anyway (so this is useful in debugging)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F some actually throw an exception when you attempt to do so.\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.defineProperty(merger, \u003Cspan class=\"hljs-string\"\u003E'name'\u003C\u002Fspan\u003E, {\n      \u003Cspan class=\"hljs-attr\"\u003Evalue\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E`combineEpics(\u003Cspan class=\"hljs-subst\"\u003E${epics.map(epic =&gt; epic.name || \u003Cspan class=\"hljs-string\"\u003E'&lt;anonymous&gt;'\u003C\u002Fspan\u003E).join(\u003Cspan class=\"hljs-string\"\u003E', '\u003C\u002Fspan\u003E)}\u003C\u002Fspan\u003E)`\u003C\u002Fspan\u003E,\n    });\n  } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E (e) {}\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E merger;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"createepicmiddlewarejs\"\u003EcreateEpicMiddleware.js\u003C\u002Fh3\u003E\n\u003Cp\u003E一、提示目前参数不在接受\u003Ccode\u003ErootEpic\u003C\u002Fcode\u003E，而是使用\u003Ccode\u003EepicMiddleware.run(rootEpic)\u003C\u002Fcode\u003E，这里\u003Ccode\u003EepicMiddleware\u003C\u002Fcode\u003E就是执行\u003Ccode\u003EcreateEpicMiddleware\u003C\u002Fcode\u003E的返回值\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateEpicMiddleware\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eoptions = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (process.env.NODE_ENV !== \u003Cspan class=\"hljs-string\"\u003E'production'\u003C\u002Fspan\u003E &amp;&amp; \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E options === \u003Cspan class=\"hljs-string\"\u003E'function'\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003ETypeError\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E'Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https:\u002F\u002Fredux-observable.js.org\u002FMIGRATION.html#setting-up-the-middleware'\u003C\u002Fspan\u003E);\n  }\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E二、这一定义了几个重要变量(流)，这里一个重要问题\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E1. rxjs内部的source是什么(在ActionObservable内部出现)\n2. rxjs内部的operator是什么(在ActionObservable内部出现)\nA：source定义了操作符执行的流向，operator定义了操作符是什么操作符，这两者结合使用来进行链式绑定\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接着看注释\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateEpicMiddleware\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eoptions = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义一个Subject，绑定内部操作流，通过调用epic$.next()，也就是`epicMiddleware.run`来初始化action$的绑定\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E epic$ = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Subject();\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E store;\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 作为redux的中间件，其中epicMiddleware是返回值作为外部API\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E epicMiddleware = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E_store\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当在开发环境并且多次使用不同的 createEpicMiddleware返回值，会提出警告(避免重复执行多次)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (process.env.NODE_ENV !== \u003Cspan class=\"hljs-string\"\u003E'production'\u003C\u002Fspan\u003E &amp;&amp; store) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F https:\u002F\u002Fgithub.com\u002Fredux-observable\u002Fredux-observable\u002Fissues\u002F389\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E'.\u002Futils\u002Fconsole'\u003C\u002Fspan\u003E).warn(\u003Cspan class=\"hljs-string\"\u003E'this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https:\u002F\u002Fgoo.gl\u002F2GQ7Da'\u003C\u002Fspan\u003E);\n    }\n    store = _store;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义一个Subject，绑定了队列调度器 (后面这个用来绑定所有操作流)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E actionSubject$ = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Subject().pipe(\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F todo 调度器，看了一些资料，还有有点模糊\u003C\u002Fspan\u003E\n      observeOn(queueScheduler)\n    );\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F  定义一个Subject，绑定了队列调度器 (后面这个用来对比当前store，防止重复渲染)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E stateSubject$ = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Subject().pipe(\n      observeOn(queueScheduler)\n    );\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义一个ActionsObservable，用来绑定用户定义的操作流\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E action$ = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E ActionsObservable(actionSubject$);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 定义一个StateObservable，内部改写了Observable的_subscribe方法，并且让stateSubject$绑定了value对比操作，就是简单的引用对比`===`\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E state$ = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E StateObservable(stateSubject$, store.getState());\n    \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E三、这里是核心，所有流和操作符的绑定就是在此内部进行\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateEpicMiddleware\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eoptions = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F pipe操作符\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E result$ = epic$.pipe(\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对发射源逐个处理\u003C\u002Fspan\u003E\n  map(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eepic\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果配置有 dependencies 就放置到第三个参数中\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E output$ = \u003Cspan class=\"hljs-string\"\u003E'dependencies'\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E options\n      ? epic(action$, state$, options.dependencies)\n      : epic(action$, state$);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 无返回值，报错，应该要返回一个不同的流\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!output$) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003ETypeError\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E`Your root Epic \"\u003Cspan class=\"hljs-subst\"\u003E${epic.name || \u003Cspan class=\"hljs-string\"\u003E'&lt;anonymous&gt;'\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\" does not return a stream. Double check you\\'re not missing a return statement!`\u003C\u002Fspan\u003E);\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F output$ 是一个ActionObservable类型的流\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E output$;\n  }),\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对所有外部流，绑定队列调度并且使用mergeMap重新subscribe\u003C\u002Fspan\u003E\n  mergeMap(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eoutput$\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E(output$).pipe(\n      subscribeOn(queueScheduler),\n      observeOn(queueScheduler)\n    )\n  )\n);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E四、epic执行主要流程，\u003Ccode\u003Edispatch(action$)\u003C\u002Fcode\u003E--&gt; \u003Ccode\u003EactionSubject$.next(action)\u003C\u002Fcode\u003E--&gt;经过一系列操作符--&gt;最后到达底层\u003Ccode\u003Edispatch(state)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateEpicMiddleware\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eoptions = {}\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n\u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 订阅 dispatch，此处将dispath作为流执行的最底层\u003C\u002Fspan\u003E\nresult$.subscribe(store.dispatch);\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回的格式是按照redux中间件的格式\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 里面的内容都是运行时redux里dispatch后会执行的流程\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Enext\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eaction\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此处先截取next(action)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E result = next(action);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 先执行 stateSubject$.next 可以保证state的更新\u003C\u002Fspan\u003E\n    stateSubject$.next(store.getState());\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 操作符按步骤执行，此时的actionSubject$已经绑定了所有的操作符\u003C\u002Fspan\u003E\n    actionSubject$.next(action);\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E result;\n  };\n};\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F run方法，通过epic$的next方法初始化action(见第三)，从而绑定用户自定义的操作符\u003C\u002Fspan\u003E\nepicMiddleware.run = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003ErootEpic\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (process.env.NODE_ENV !== \u003Cspan class=\"hljs-string\"\u003E'production'\u003C\u002Fspan\u003E &amp;&amp; !store) {\n    \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E'.\u002Futils\u002Fconsole'\u003C\u002Fspan\u003E).warn(\u003Cspan class=\"hljs-string\"\u003E'epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.'\u003C\u002Fspan\u003E);\n  }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F rootEpic就是用户自定义的操作符\u003C\u002Fspan\u003E\n  epic$.next(rootEpic);\n};\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E epicMiddleware;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"operatorsjs\"\u003Eoperators.js\u003C\u002Fh3\u003E\n\u003Cp\u003E定义了\u003Ccode\u003EofType\u003C\u002Fcode\u003E，其实就是一个filter\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 引入filter\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { filter } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'rxjs\u002Foperators'\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里type就是传给epic的action的type的值，key就是用户自定义需要过滤的值\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E keyHasType = \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Etype, key\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E type === key || \u003Cspan class=\"hljs-keyword\"\u003Etypeof\u003C\u002Fspan\u003E key === \u003Cspan class=\"hljs-string\"\u003E'function'\u003C\u002Fspan\u003E &amp;&amp; type === key.toString();\n};\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F source就是调用ofType的流，也就是createEpicMiddleware里的action$\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 结果只有返回true才会继续链式调用\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ofType = \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E...keys\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Esource\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E source.pipe(\n  filter(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E{ type }\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E len = keys.length;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (len === \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E keyHasType(type, keys[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; len; i++) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (keyHasType(type, keys[i])) {\n          \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        }\n      }\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n  })\n);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"stateobservablejs\"\u003EStateObservable.js\u003C\u002Fh3\u003E\n\u003Cp\u003E继承\u003Ccode\u003EObservable\u003C\u002Fcode\u003E，定义了一个保存状态的类，里面改写了父类(\u003Ccode\u003EObservable\u003C\u002Fcode\u003E)的\u003Ccode\u003E_subscribe\u003C\u002Fcode\u003E(作用不太清楚)，\n并且定义了一个保存当前数据状态的函数，通过stateSubject(也就是createEpicMiddleware里面的\u003Ccode\u003EstateSubject$\u003C\u002Fcode\u003E)的\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E绑定到底层\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { Observable, Subject } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'rxjs'\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EStateObservable\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EObservable\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(stateSubject, initialState) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 调用父类构造函数，改写父类的_subscribe\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F todo 作用？\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Esuper\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Esubscriber\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E subscription = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.__notifier.subscribe(subscriber);\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (subscription &amp;&amp; !subscription.closed) {\n        subscriber.next(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.value);\n      }\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E subscription;\n    });\n    \n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.value = initialState;\n     \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.__notifier = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Subject();\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 绑定一个引用比较的状态函数\u003C\u002Fspan\u003E\n     \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.__subscription = stateSubject.subscribe(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n       \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (value !== \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.value) {\n         \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.value = value;\n         \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.__notifier.next(value);\n       }\n     });\n   }\n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E源码就到此分析完了，看到这里可能还是一头雾水，知道是什么也只是概念上的知道，对整个流程还是没有头绪，\n接着，会对几个关键流程源码分析和画出导图\u003C\u002Fp\u003E\n\u003Cp\u003E这些流程基本都是rxjs源码的东西，为什么要对rxjs源码进行分析，只有这样才能正确掌握\u003Ccode\u003Eredux-observable\u003C\u002Fcode\u003E的整个流程\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EPS：rxjs源码真让人看的头大\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"liu-cheng-fen-xi\"\u003E流程分析\u003C\u002Fh2\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"pipe\"\u003Epipe\u003C\u002Fh3\u003E\n\u003Cp\u003E首先是\u003Ccode\u003Epipe\u003C\u002Fcode\u003E，\u003Ccode\u003Epipe\u003C\u002Fcode\u003E在rxjs源码中到底做了些什么\u003C\u002Fp\u003E\n\u003Cp\u003E这里处理了参数，然后调用\u003Ccode\u003EpipeFromArray\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Epipe\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E fns = [];\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 遍历参数合并为数组的形式\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E _i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; _i &lt; \u003Cspan class=\"hljs-built_in\"\u003Earguments\u003C\u002Fspan\u003E.length; _i++) {\n        fns[_i] = \u003Cspan class=\"hljs-built_in\"\u003Earguments\u003C\u002Fspan\u003E[_i];\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E pipeFromArray(fns);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EpipeFromArray\u003C\u002Fcode\u003E是做什么用呢，看最后一句，当参数大于1个时，会执行\u003Ccode\u003Ereduce\u003C\u002Fcode\u003E方法，这不就是compose\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EpipeFromArray\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Efns\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!fns) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E noop;\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (fns.length === \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fns[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E];\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Epiped\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Einput\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fns.reduce(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eprev, fn\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{ \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fn(prev); }, input);\n    };\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E也就是将\u003Ccode\u003Eaction$.pipe(oper1,oper2,oper3)\u003C\u002Fcode\u003E转换成\n\u003Ccode\u003Eoper3(oper2(oper1(action$)))\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E那么\u003Ccode\u003Eoper1(action$)\u003C\u002Fcode\u003E又是什么\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EfilterOperatorFunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Esource\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E source.lift(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E FilterOperator(predicate, thisArg));\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003Eoper1(action$)\u003C\u002Fcode\u003E也就是\u003Ccode\u003Eaction$.lift(oper1)\u003C\u002Fcode\u003E，这里不去管操作符的构造函数\u003C\u002Fp\u003E\n\u003Cp\u003E而\u003Ccode\u003Esource\u003C\u002Fcode\u003E表示操作符的链式的下一个指向，这里是一个\u003Ccode\u003EActionObservable\u003C\u002Fcode\u003E类，还记得前面吗，\u003Ccode\u003EActionObservable\u003C\u002Fcode\u003E重写了lift方法\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E  lift(operator) {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E observable = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E ActionsObservable(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F operator能表示具体当前操作符\u003C\u002Fspan\u003E\n    observable.operator = operator;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E observable;\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E它也会创建新的\u003Ccode\u003EActionObservable\u003C\u002Fcode\u003E，并且加入\u003Ccode\u003Esource\u003C\u002Fcode\u003E和\u003Ccode\u003Eoperator\u003C\u002Fcode\u003E，这次的\u003Ccode\u003Esource\u003C\u002Fcode\u003E又作为下一次lift的\u003Ccode\u003Esource\u003C\u002Fcode\u003E，这就构成了链式\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Epipe\u003C\u002Fcode\u003E流程图\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.redux-observable\u002Fredux-observable-pipe.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"subscribe\"\u003Esubscribe\u003C\u002Fh3\u003E\n\u003Cp\u003E接着是\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E，它的参数会转换成Subscriber类，作为最底层的执行操作\u003C\u002Fp\u003E\n\u003Cp\u003E这里提出了几个属性，而且分清楚\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E和\u003Ccode\u003ESubscriber\u003C\u002Fcode\u003E，前者是类似订阅，动词；后者是一种结构\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E1. source: 见上面pipe，执行list时添加的一个属性，表示操作符的链式的下一个指向\n\n2. operator: 见上面pipe，执行list的时添加一个属性，表示具体当前操作符\n\n3. destination: 它的作用是链式连接每一个操作符的Subscriber\n例如：a,b,c 3个操作符\naSubscriber.destination=bSubscriber\nbSubscriber.destination=cSubscriber\ncSubscriber.destination=SafeSubscriber(作为最底层)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E源码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EObservable.prototype.subscribe = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003EobserverOrNext, error, complete\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F operator就是通过pipe后的具体当前操作符\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E operator = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.operator;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里是将参数 （next,error,complete）转换成Subscriber的类，它的destination是SafeSubscriber\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E sink = toSubscriber(observerOrNext, error, complete);\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (operator) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果this是一个操作符时 执行operator.call ，这里的call是重写的（后面单独分析）\u003C\u002Fspan\u003E\n        operator.call(sink, \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.source);\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果this不是一个操作符，即链式调用到顶端，这里所做的大概是\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 1. 有source 说明它还有通过pipe绑定的操作符，继续从source.subscribe\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2. 没有source 说明它是最顶层了，给它添加一个属性`observers`，用于绑定链式subscribe的结果\u003C\u002Fspan\u003E\n        sink.add(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.source || (config.useDeprecatedSynchronousErrorHandling &amp;&amp; !sink.syncErrorThrowable) ?\n            \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._subscribe(sink) :\n            \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._trySubscribe(sink));\n    }\n    \n    \u003Cspan class=\"hljs-comment\"\u003E\u002F*...*\u002F\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E sink;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里就是\u003Ccode\u003Eoperator.call(sink, this.source);\u003C\u002Fcode\u003E，找了一个\u003Ccode\u003EmapTo\u003C\u002Fcode\u003E操作符的例子，每一个操作符的call都是不同的\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EMapToOperator.prototype.call = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Esubscriber, source\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E source.subscribe(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E MapToSubscriber(subscriber, \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.value));\n    };\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E其实这里就是用\u003Ccode\u003Esource\u003C\u002Fcode\u003E再次subscribe，参数是一个当前操作符的\u003Ccode\u003ESubscriber\u003C\u002Fcode\u003E，这个\u003Ccode\u003ESubscriber\u003C\u002Fcode\u003E内部保存了当前操作符的具体操作，\n通过再次subscribe，又回到了上面的\u003Ccode\u003EObservable.prototype.subscribe \u003C\u002Fcode\u003E，构成链式subscribe\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E流程图\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.redux-observable\u002Fredux-observable-subscribe.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"next\"\u003Enext\u003C\u002Fh3\u003E\n\u003Cp\u003E最后是\u003Ccode\u003Enext\u003C\u002Fcode\u003E，每一个结构的\u003Ccode\u003Enext\u003C\u002Fcode\u003E都不太同，因此这里就说1个主要的，1个通用的\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESubject.next\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E这里其实很好理解，就是一次调用它的observers上的数据的next，那它的observers存放了什么数据，也就是下一个要说的: Subscriber.next\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003ESubject.prototype.next = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.closed) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ethrow\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E ObjectUnsubscribedError();\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.isStopped) {\n        \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E observers = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.observers;\n        \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E len = observers.length;\n        \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E copy = observers.slice();\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; len; i++) {\n            copy[i].next(value);\n        }\n    }\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003ESubscriber.next\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E这里调用了\u003Ccode\u003Ethis._next\u003C\u002Fcode\u003E，这里的this是动态的，并不一定是\u003Ccode\u003ESubscriber\u003C\u002Fcode\u003E，也有可能是\u003Ccode\u003EFilterSubscriber\u003C\u002Fcode\u003E(这里举FilterSubscriber的例子)\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003ESubscriber.prototype.next = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.isStopped) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E._next(value);\n    }\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果\u003Ccode\u003Ethis\u003C\u002Fcode\u003E是\u003Ccode\u003ESubscriber\u003C\u002Fcode\u003E，调用\u003Ccode\u003Ethis.destination.next\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003ESubscriber.prototype._next = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.destination.next(value);\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果\u003Ccode\u003Ethis\u003C\u002Fcode\u003E是\u003Ccode\u003EFilterSubscriber\u003C\u002Fcode\u003E，首先会执行\u003Ccode\u003Epredicate\u003C\u002Fcode\u003E，这个就是filter操作符的具体执行内容，也就是它的参数，\n当result为true，才会调用\u003Ccode\u003Ethis.destination.next\u003C\u002Fcode\u003E，进行下一个操作符的执行\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EFilterSubscriber.prototype._next = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n        \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E result;\n        \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n            result = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.predicate.call(\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.thisArg, value, \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.count++);\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E (err) {\n            \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.destination.error(err);\n            \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E;\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (result) {\n            \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.destination.next(value);\n        }\n    };\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003Enext\u003C\u002Fcode\u003E就是这么样的流程，通过\u003Ccode\u003Edestination\u003C\u002Fcode\u003E一层一层往下执行，到最后就执行之前\u003Ccode\u003Esubscriber\u003C\u002Fcode\u003E的参数\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E接着是\u003Ccode\u003Esubscribe\u003C\u002Fcode\u003E，它的参数会转换成Subscriber类，作为最底层的执行操作\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Ccode\u003Enext\u003C\u002Fcode\u003E流程图\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.redux-observable\u002Fredux-observable-next.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E理解了这3种方法，这个\u003Ccode\u003Eredux-observable\u003C\u002Fcode\u003E脉络就十分清楚了，当然，这之中还会涉及\u003Ccode\u003Erxjs\u003C\u002Fcode\u003E中还有更多的属性，例如\u003Ccode\u003E_subscriptions\u003C\u002Fcode\u003E,\u003Ccode\u003EisClosed\u003C\u002Fcode\u003E,\u003Ccode\u003Escheduler\u003C\u002Fcode\u003E等，这里也不展开了。\u003C\u002Fp\u003E\n\u003Ch2 id=\"zong-jie\"\u003E总结\u003C\u002Fh2\u003E\n\u003Cp\u003E最后一张完整的\u003Ccode\u003Eredux-observable\u003C\u002Fcode\u003E导图\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.redux-observable\u002Fredux-observable.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n",toc:[{anchor:"yue-du-qian-ti",level:b,text:"阅读前提"},{anchor:"mu-lu-jie-gou",level:b,text:"目录结构"},{anchor:"yuan-ma-fen-xi",level:b,text:"源码分析"},{anchor:"actionobservablejs",level:a,text:"ActionObservable.js"},{anchor:"combineepicsjs",level:a,text:"combineEpics.js"},{anchor:"createepicmiddlewarejs",level:a,text:"createEpicMiddleware.js"},{anchor:"operatorsjs",level:a,text:"operators.js"},{anchor:"stateobservablejs",level:a,text:"StateObservable.js"},{anchor:"liu-cheng-fen-xi",level:b,text:"流程分析"},{anchor:d,level:a,text:d},{anchor:e,level:a,text:e},{anchor:f,level:a,text:f},{anchor:"zong-jie",level:b,text:"总结"}],relatedTags:["源码","redux","github"],created_at:"2018-08-02",timeArr:[2018,7,b,18,41,14,0],title:"源码阅读-redux-observable",uuid:"d7c0278bb7ed377e72b7b8f38c777e8da7e1cbac",summary:"\u003Ch4\u003E阅读前提：\u003C\u002Fh4\u003E\n\u003Col\u003E\n\u003Cli\u003E有rxjs基础，对\u003Ccode\u003EObservable\u003C\u002Fcode\u003E, \u003Ccode\u003ESubject\u003C\u002Fcode\u003E,\u003Ccode\u003Epipe\u003C\u002Fcode\u003E和一些操作符(例如\u003Ccode\u003Efilter\u003C\u002Fcode\u003E,\u003Ccode\u003Emap\u003C\u002Fcode\u003E,\u003Ccode\u003Emerge\u003C\u002Fcode\u003E,\u003Ccode\u003EmergeMap\u003C\u002Fcode\u003E)执行流程有基本了解，最起码遇到不清楚有去查阅的动力\u003C\u002Fli\u003E\n\u003Cli\u003E比较熟悉\u003Ccode\u003Eredux\u003C\u002Fcode\u003E中间件的写法，否则像`createEpicMidd...\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E",slug:c,sha:"93bd88b16c7b9dfc51ce170d182382f0ecefdd78"}}],fetch:{},mutations:void 0}}(3,2,"source-code-redux-observable","pipe","subscribe","next")));