__NUXT_JSONP__("/article/source-code-reselect", (function(a,b){return {data:[{slug:b,articleDetails:{content:"\u003Ch2 id=\"reselect-yuan-ma-jie-shao\"\u003Ereselect源码介绍\u003C\u002Fh2\u003E\n\u003Cp\u003Ev3.0.1\u003C\u002Fp\u003E\n\u003Cp\u003E导图：\n\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.reselect\u002Freselect.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"defaultmemoize\"\u003EdefaultMemoize\u003C\u002Fh3\u003E\n\u003Cp\u003E一个缓存函数，其内部：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E通过闭包保存参数和结果\u003C\u002Fli\u003E\n\u003Cli\u003E每次调用对参数进行浅比较\u003C\u002Fli\u003E\n\u003Cli\u003E参数比较结果相同，返回缓存的结果\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EdefaultMemoize\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Efunc, equalityCheck = defaultEqualityCheck\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E lastArgs = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E lastResult = \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 判断当前参数和上一次的参数是否相同，默认为 ===(全等)\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, \u003Cspan class=\"hljs-built_in\"\u003Earguments\u003C\u002Fspan\u003E)) {\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F apply arguments instead of spreading for performance.\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不同则调用func\u003C\u002Fspan\u003E\n      lastResult = func.apply(\u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-built_in\"\u003Earguments\u003C\u002Fspan\u003E)\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 保存当前参数\u003C\u002Fspan\u003E\n    lastArgs = \u003Cspan class=\"hljs-built_in\"\u003Earguments\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回result\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E lastResult\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"createselectorcreator-createselector\"\u003EcreateSelectorCreator, createSelector\u003C\u002Fh3\u003E\n\u003Cp\u003Ereselect最主要函数\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EcreateSelectorCreator\u003C\u002Fcode\u003E接收一个参数，缓存函数，返回一个函数，称为\u003Ccode\u003EcreateSelector\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003Econst createSelector = createSelectorCreator(defaultMemoize)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EcreateSelector\u003C\u002Fcode\u003E接受2类参数\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E(可以有多个)：\u003C\u002Fp\u003E\n\u003Cp\u003E 它的结果会传递给\u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E作为它的参数\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E(必须放在参数的最后)：\u003C\u002Fp\u003E\n\u003Cp\u003E 它接受的参数就是\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E的返回值\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EcreateSelector\u003C\u002Fcode\u003E的内部操作\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E对\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E和\u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E执行缓存函数\u003C\u002Fli\u003E\n\u003Cli\u003E每次执行\u003Ccode\u003EcreateSelector\u003C\u002Fcode\u003E的时候，会先执行\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E的缓存函数，检查参数是否相等，相等则返回旧的结果；\n如果不相等，才会再执行\u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E的缓存函数，进行比较。这样处理就可以知道要想返回缓存的结果，必须要达到以下条件任一：\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E的参数(一般为\u003Ccode\u003Estore\u003C\u002Fcode\u003E)全等比较为true\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E的参数(一般为\u003Ccode\u003Estore\u003C\u002Fcode\u003E)全等比较为false, \u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E的参数全等比较为true\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E返回\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Fjlpozpjprw\"\u003Ereselect使用例子\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"createstructuredselector\"\u003EcreateStructuredSelector\u003C\u002Fh3\u003E\n\u003Cp\u003E一个便利的函数，可以用于变更数据的key值，通过嵌套可以变更数据的结构\u003C\u002Fp\u003E\n\u003Cp\u003E它的内部正是调用了\u003Ccode\u003EcreateSelector\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E接受2个函数，分别为一个(参数1)对象，一个(参数2)\u003Ccode\u003EselectorCreator\u003C\u002Fcode\u003E(默认就是createSelector)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E调用\u003Ccode\u003EcreateSelector\u003C\u002Fcode\u003E，将参数1(对象)的value值作为\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E，\n其\u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E就是一个将参数1(对象)的key值和\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E的返回值组成一个新的对象的过程。\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002F53kvl30564\"\u003EcreateStructuredSelector使用例子\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Chr\u003E\n\u003Cp\u003E注意点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E缓存函数只能保存上一次缓存的值(单个)。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E缓存函数是通过对比参数而进行判断的，因此必须保证所提供的\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E和\u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E都是纯函数，而且它只保存上一次函数。\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Fn6y126v2p\"\u003E非纯函数例子\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E要想取消缓存，必须取消引用，包括\u003Ccode\u003E依赖数据函数\u003C\u002Fcode\u003E参数(store)的引用和内部\u003Ccode\u003E数据处理函数\u003C\u002Fcode\u003E的参数引用\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Flx1kq3lj39\"\u003E取消缓存例子\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n",toc:[{anchor:"reselect-yuan-ma-jie-shao",level:2,text:"reselect源码介绍"},{anchor:"defaultmemoize",level:a,text:"defaultMemoize"},{anchor:"createselectorcreator-createselector",level:a,text:"createSelectorCreator, createSelector"},{anchor:"createstructuredselector",level:a,text:"createStructuredSelector"}],relatedTags:["源码","缓存"],created_at:"2018-07-15",timeArr:[2018,6,15,16,20,8,0],title:"源码阅读-reselect",uuid:"a73ced0b51daf6b55d0965e613d5ed55304f6638",summary:"\u003Ch4\u003Ereselect源码介绍\u003C\u002Fh4\u003E\n\u003Cp\u003Ev3.0.1\u003C\u002Fp\u003E\n\u003Cp\u003E导图：\n\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fstonehank\u002Fsourcecode-analysis\u002Fmaster\u002Fsource-code.reselect\u002Freselect.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Ch4\u003EdefaultMemoize\u003C\u002Fh4\u003E\n\u003Cp\u003E...\u003C\u002Fp\u003E",slug:b,sha:"1337a25798f1710973ee215c3e6322aec34e79c8"}}],fetch:{},mutations:void 0}}(3,"source-code-reselect")));