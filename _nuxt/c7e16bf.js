(window.webpackJsonp=window.webpackJsonp||[]).push([[633],{1431:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> constructDistancedSequence = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">n</span>) </span>{\\n    <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">2</span>*n<span class=\\"hljs-number\\">-1</span>).fill(<span class=\\"hljs-number\\">0</span>) \\n    <span class=\\"hljs-keyword\\">let</span> counter={}\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;=n;i++){\\n        counter[i]=<span class=\\"hljs-number\\">2</span>\\n    }\\n    counter[<span class=\\"hljs-number\\">1</span>]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">let</span> find=<span class=\\"hljs-literal\\">false</span>\\n    resolve(<span class=\\"hljs-literal\\">Infinity</span>,<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-keyword\\">return</span> res\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">resolve</span>(<span class=\\"hljs-params\\">lastNum,curIdx</span>)</span>{\\n        <span class=\\"hljs-keyword\\">if</span>(curIdx===res.length){\\n            find=<span class=\\"hljs-literal\\">true</span>\\n            <span class=\\"hljs-keyword\\">return</span>\\n        }\\n        <span class=\\"hljs-comment\\">// console.log(res)</span>\\n        <span class=\\"hljs-keyword\\">if</span>(res[curIdx]!==<span class=\\"hljs-number\\">0</span>){\\n            resolve(<span class=\\"hljs-literal\\">Infinity</span>,curIdx+<span class=\\"hljs-number\\">1</span>)\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n            <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=n;i&gt;<span class=\\"hljs-number\\">0</span>;i--){\\n                <span class=\\"hljs-keyword\\">if</span>(counter[i]&lt;=<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>\\n                <span class=\\"hljs-keyword\\">if</span>(i===lastNum<span class=\\"hljs-number\\">-1</span> &amp;&amp; i!==<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">continue</span>\\n                <span class=\\"hljs-keyword\\">if</span>(counter[i]===<span class=\\"hljs-number\\">2</span> &amp;&amp; curIdx+i&gt;=res.length)<span class=\\"hljs-keyword\\">continue</span>\\n                <span class=\\"hljs-keyword\\">if</span>(counter[i]===<span class=\\"hljs-number\\">2</span> &amp;&amp; res[curIdx+i])<span class=\\"hljs-keyword\\">continue</span>\\n                counter[i]--\\n                res[curIdx]=i\\n                <span class=\\"hljs-keyword\\">if</span>(counter[i]&gt;<span class=\\"hljs-number\\">0</span>){\\n                    counter[i]--\\n                    res[curIdx+i]=i\\n                    resolve(i,curIdx+<span class=\\"hljs-number\\">1</span>)\\n                    <span class=\\"hljs-keyword\\">if</span>(find)<span class=\\"hljs-keyword\\">return</span>\\n                    res[curIdx+i]=<span class=\\"hljs-number\\">0</span>\\n                    counter[i]++\\n                }<span class=\\"hljs-keyword\\">else</span>{\\n                    resolve(<span class=\\"hljs-literal\\">Infinity</span>,curIdx+<span class=\\"hljs-number\\">1</span>)\\n                    <span class=\\"hljs-keyword\\">if</span>(find)<span class=\\"hljs-keyword\\">return</span>\\n                }\\n                counter[i]++\\n                res[curIdx]=<span class=\\"hljs-number\\">0</span>\\n            }\\n        }\\n\\n    }\\n};\\n</code></pre>\\n"],"querySlug":"construct-the-lexicographically-largest-valid-sequence","created_at":"2021-01-20","timeArr":[2021,0,20,21,41,21,0],"hasThinking":false,"content":"<p>给你一个整数 <code>n</code> ，请你找到满足下面条件的一个序列：</p>\\n\\n<ul>\\n\\t<li>整数 <code>1</code> 在序列中只出现一次。</li>\\n\\t<li><code>2</code> 到 <code>n</code> 之间每个整数都恰好出现两次。</li>\\n\\t<li>对于每个 <code>2</code> 到 <code>n</code> 之间的整数 <code>i</code> ，两个 <code>i</code> 之间出现的距离恰好为 <code>i</code> 。</li>\\n</ul>\\n\\n<p>序列里面两个数 <code>a[i]</code> 和 <code>a[j]</code> 之间的 <strong>距离</strong> ，我们定义为它们下标绝对值之差 <code>|j - i|</code> 。</p>\\n\\n<p>请你返回满足上述条件中 <strong>字典序最大</strong> 的序列。题目保证在给定限制条件下，一定存在解。</p>\\n\\n<p>一个序列 <code>a</code> 被认为比序列 <code>b</code> （两者长度相同）字典序更大的条件是： <code>a</code> 和 <code>b</code> 中第一个不一样的数字处，<code>a</code> 序列的数字比 <code>b</code> 序列的数字大。比方说，<code>[0,1,9,0]</code> 比 <code>[0,1,5,6]</code> 字典序更大，因为第一个不同的位置是第三个数字，且 <code>9</code> 比 <code>5</code> 大。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><b>输入：</b>n = 3\\n<b>输出：</b>[3,1,2,3,2]\\n<b>解释：</b>[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><b>输入：</b>n = 5\\n<b>输出：</b>[5,3,1,4,3,5,2,4,2]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 20</code></li>\\n</ul>\\n","title":"1718. 构建字典序最大的可行序列","relatedTags":["数组","回溯"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1718","slug":"1718-Construct-the-Lexicographically-Largest-Valid-Sequence"}')}}]);