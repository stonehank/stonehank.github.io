(window.webpackJsonp=window.webpackJsonp||[]).push([[1231],{2029:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s2</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">let</span> memo={}\\n<span class=\\"hljs-keyword\\">var</span> isScramble = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s1, s2</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]!=<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">return</span> memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]\\n    <span class=\\"hljs-keyword\\">if</span>(!haveSameCharacter(s1,s2)){\\n        memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> len=s1.length\\n    <span class=\\"hljs-keyword\\">if</span>(s1===s2){\\n        memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]=<span class=\\"hljs-literal\\">true</span>\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    }\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;len;i++){\\n        <span class=\\"hljs-keyword\\">let</span> l1=s1.slice(<span class=\\"hljs-number\\">0</span>,i)\\n        <span class=\\"hljs-keyword\\">let</span> r1=s1.slice(i)\\n        <span class=\\"hljs-keyword\\">let</span> l2=s2.slice(<span class=\\"hljs-number\\">0</span>,i)\\n        <span class=\\"hljs-keyword\\">let</span> r2=s2.slice(i)\\n        <span class=\\"hljs-keyword\\">let</span> l2R=s2.slice(<span class=\\"hljs-number\\">0</span>,len-i)\\n        <span class=\\"hljs-keyword\\">let</span> r2R=s2.slice(len-i)\\n        <span class=\\"hljs-comment\\">// if(l1+r1===r2+l2)return true</span>\\n        <span class=\\"hljs-keyword\\">if</span>(isScramble(l1,l2) &amp;&amp; isScramble(r1,r2)){\\n            memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]=<span class=\\"hljs-literal\\">true</span>\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n        }  \\n        <span class=\\"hljs-keyword\\">if</span>(isScramble(l1,r2R) &amp;&amp; isScramble(r1,l2R)){\\n            memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]=<span class=\\"hljs-literal\\">true</span>\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n        }  \\n    }\\n    memo[s1+<span class=\\"hljs-string\\">\'-\'</span>+s2]=<span class=\\"hljs-literal\\">false</span>\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n          \\n};\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">haveSameCharacter</span>(<span class=\\"hljs-params\\">s1,s2</span>)</span>{\\n    <span class=\\"hljs-comment\\">// return true</span>\\n    <span class=\\"hljs-keyword\\">let</span> map=<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Map</span>()\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> s <span class=\\"hljs-keyword\\">of</span> s1){\\n        <span class=\\"hljs-keyword\\">if</span>(!map.has(s)){\\n            map.set(s,<span class=\\"hljs-number\\">1</span>)\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n            map.set(s,map.get(s)+<span class=\\"hljs-number\\">1</span>)\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> s <span class=\\"hljs-keyword\\">of</span> s2){\\n        <span class=\\"hljs-keyword\\">if</span>(map.has(s)){\\n            map.set(s,map.get(s)<span class=\\"hljs-number\\">-1</span>)\\n            <span class=\\"hljs-keyword\\">if</span>(map.get(s)===<span class=\\"hljs-number\\">0</span>){\\n                map.delete(s)\\n            }\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> map.size===<span class=\\"hljs-number\\">0</span>\\n}\\n</code></pre>\\n","<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">isScramble</span><span class=\\"hljs-params\\">(self, s1, s2)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \\"\\"\\"</span>\\n        <span class=\\"hljs-keyword\\">if</span> s1==s2:\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">True</span>\\n        <span class=\\"hljs-keyword\\">if</span> sorted(s1)!=sorted(s2):\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">False</span>\\n        res=<span class=\\"hljs-literal\\">True</span>\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(<span class=\\"hljs-number\\">1</span>,len(s1)):\\n          <span class=\\"hljs-keyword\\">if</span> self.isScramble(s1[:i],s2[:i]) <span class=\\"hljs-keyword\\">and</span> self.isScramble(s1[i:],s2[i:]):\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">True</span>\\n          <span class=\\"hljs-keyword\\">if</span> self.isScramble(s1[:i],s2[-i:]) <span class=\\"hljs-keyword\\">and</span> self.isScramble(s1[i:],s2[<span class=\\"hljs-number\\">0</span>:-i]):\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">True</span>\\n          res=<span class=\\"hljs-literal\\">False</span>\\n        <span class=\\"hljs-keyword\\">return</span> res\\n        \\n</code></pre>\\n"],"querySlug":"scramble-string","hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>对<code>s1</code>遍历，将<code>s1</code>和<code>s2</code>分割为<code>[0,i]</code>，<code>[i,length]</code>；</p>\\n<p>如果<code>s1[0,i]</code>与<code>s2[0,i]</code>不是相同字母(相同字母指字母相同但顺序不一定相同)，并且<code>s1[0,i]</code>与<code>s2[length-i,length]</code>也不是相同字母，那么当前分割就是无效的。\\n继续遍历<code>i</code>，直到找出有效分割点。</p>\\n<p>注意，因此对于每一次分割点，只需要检查头和尾；</p>\\n<p>例如<code>great</code>，</p>\\n<p>第一次分割有以下情况：</p>\\n<p><code>g</code>，<code>reat</code>，交换后，<code>reat</code>，<code>g</code></p>\\n<p><code>gr</code>，<code>eat</code>，交换后，<code>eat</code>，<code>gr</code></p>\\n<p><code>gre</code>，<code>at</code>，交换后，<code>at</code>，<code>gre</code></p>\\n<p><code>grea</code>，<code>t</code>，交换后，<code>t</code>，<code>grea</code></p>\\n<p>可以发现，交换前，左侧在左，右侧在右；交换后，左侧在右，右侧在左。</p>\\n","content":"使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：\\n<ol>\\n\\t<li>如果字符串的长度为 1 ，算法停止</li>\\n\\t<li>如果字符串的长度 > 1 ，执行下述步骤：\\n\\t<ul>\\n\\t\\t<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>\\n\\t\\t<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>\\n\\t\\t<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>\\n\\t</ul>\\n\\t</li>\\n</ol>\\n\\n<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code><em> </em>和 <code>s2</code>，判断 <code>s2</code><em> </em>是否是 <code>s1</code><em> </em>的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s1 = \\"great\\", s2 = \\"rgeat\\"\\n<strong>输出：</strong>true\\n<strong>解释：</strong>s1 上可能发生的一种情形是：\\n\\"great\\" --\x3e \\"gr/eat\\" // 在一个随机下标处分割得到两个子字符串\\n\\"gr/eat\\" --\x3e \\"gr/eat\\" // 随机决定：「保持这两个子字符串的顺序不变」\\n\\"gr/eat\\" --\x3e \\"g/r / e/at\\" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割\\n\\"g/r / e/at\\" --\x3e \\"r/g / e/at\\" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」\\n\\"r/g / e/at\\" --\x3e \\"r/g / e/ a/t\\" // 继续递归执行此算法，将 \\"at\\" 分割得到 \\"a/t\\"\\n\\"r/g / e/ a/t\\" --\x3e \\"r/g / e/ a/t\\" // 随机决定：「保持这两个子字符串的顺序不变」\\n算法终止，结果字符串和 s2 相同，都是 \\"rgeat\\"\\n这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s1 = \\"abcde\\", s2 = \\"caebd\\"\\n<strong>输出：</strong>false\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s1 = \\"a\\", s2 = \\"a\\"\\n<strong>输出：</strong>true\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>s1.length == s2.length</code></li>\\n\\t<li><code>1 <= s1.length <= 30</code></li>\\n\\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>\\n</ul>\\n","title":"87. 扰乱字符串","relatedTags":["字符串","动态规划"],"difficult":"Hard","lang":["javascript","python"],"uniqueID":"87","slug":"87-Scramble-String"}')}}]);