(window.webpackJsonp=window.webpackJsonp||[]).push([[429],{1227:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> maxProduct = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> MOD=<span class=\\"hljs-number\\">1e9</span>+<span class=\\"hljs-number\\">7</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n    root.leftSum=dfs(root.left)\\n    root.rightSum=dfs(root.right)\\n    sum+=root.val\\n    <span class=\\"hljs-keyword\\">return</span> root.leftSum+root.rightSum+root.val\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs2</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(root.left){\\n      max=<span class=\\"hljs-built_in\\">Math</span>.max(max,root.leftSum*(sum-root.leftSum))\\n      dfs2(root.left)\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(root.right){\\n      max=<span class=\\"hljs-built_in\\">Math</span>.max(max,root.rightSum*(sum-root.rightSum))\\n      dfs2(root.right)\\n    }\\n  }\\n  dfs(root)\\n  dfs2(root)\\n  <span class=\\"hljs-keyword\\">return</span> max % MOD\\n};\\n</code></pre>\\n"],"querySlug":"maximum-product-of-splitted-binary-tree","created_at":"2020-02-02","timeArr":[2020,1,2,11,2,6,0],"hasThinking":false,"content":"<p>给你一棵二叉树，它的根为&nbsp;<code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>\\n\\n<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png\\" style=\\"height: 200px; width: 495px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\\n<strong>输出：</strong>110\\n<strong>解释：</strong>删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png\\" style=\\"height: 200px; width: 495px;\\"></p>\\n\\n<pre><strong>输入：</strong>root = [1,null,2,3,4,null,null,5,6]\\n<strong>输出：</strong>90\\n<strong>解释：</strong>移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>root = [2,3,9,10,7,8,6,5,4,11,1]\\n<strong>输出：</strong>1025\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre><strong>输入：</strong>root = [1,1]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点，且至少有&nbsp;<code>2</code>&nbsp;个节点。</li>\\n\\t<li>每个节点的值在&nbsp;<code>[1, 10000]</code>&nbsp;之间。</li>\\n</ul>\\n","title":"1339. 分裂二叉树的最大乘积","relatedTags":["树","深度优先搜索","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1339","slug":"1339-Maximum-Product-of-Splitted-Binary-Tree"}')}}]);