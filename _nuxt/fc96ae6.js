(window.webpackJsonp=window.webpackJsonp||[]).push([[1412],{699:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"jie-shao\\">介绍</h3>\\n<p><a href=\\"https://github.com/jamiebuilds/react-loadable\\">react-loadable</a>是一个组件延迟加载的工具，\\n它本身也是一个组件，通过<code>HOC</code>的方式对参数组件进行处理，\\n具体的延迟加载方式是使用<code>import().then()</code>方法，那么为什么要用这个组件呢？</p>\\n<h3 id=\\"chu-shi\\">初识</h3>\\n<p><code>react-loadable</code>针对多种情况进行抽象处理，例如延迟加载失败，多个延迟加载的逻辑和服务端渲染使用延迟加载...</p>\\n<p>当这些情况整合起来后，我们只需要简单的API即可处理每个情况对应的组件。</p>\\n<p>它对外暴露的API有</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 基本的延迟加载处理\\nLoadable\\n// 多个延迟加载处理\\nLoadable.Map\\n// Loadable或Loadable.Map的返回值\\nLoadableComponent\\n// 预加载\\nLoadableComponent.preLoad\\n// 全部预加载\\nLoadable.preloadAll\\n// 对已经加载完毕的组件处理\\nLoadable.preloadReady\\n// 服务端渲染使用\\nLoadable.Capture</code></pre>\\n</code></pre>\\n<p>Loadable和Loadable.Map还可加入一些options参数，作用如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>// 延迟加载组件\\nloader: null,\\n// loading组件\\nloading: null,\\n// 加载组件时等待多少时间才开始渲染Loading\\ndelay: 200,\\n// 超时时间\\ntimeout: null,\\n// 对已加载的组件渲染方法\\nrender: render,\\n\\n/* 以下2个是服务端渲染使用 */\\n\\n// 函数，执行后会获取当前延迟加载模块\\n// 这里用途是判断模块是否已经可用，作用于 preLoadReady 上\\nwebpack: null,\\n// 函数，执行后会获取当前import的路径，作为moduleId\\n// 这里用途是通过getBundles将moduleId转换成bundles\\nmodules: null</code></pre>\\n</code></pre>\\n<h3 id=\\"shen-ru\\">深入</h3>\\n<h4 id=\\"loadable\\">Loadable</h4>\\n<p>客户端的单个延迟加载组件</p>\\n<p>当开始载入<code>Loadable</code>组件，会返回<code>LoadableComponent</code>组件，这个组件在生命周期中的<code>constructor</code>下会执行<code>init</code>方法。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">LoadableComponent</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n    <span class=\\"hljs-keyword\\">constructor</span>(props) {\\n      <span class=\\"hljs-keyword\\">super</span>(props);\\n      init();\\n\\n  <span class=\\"hljs-comment\\">/* ... */</span></code></pre>\\n</code></pre>\\n<p>这个<code>init</code>方法会执行<code>loadFn(opts.loader)</code>，而这个<code>loadFn</code>会首先会执行<code>参数loader(也就是import(...))</code>，并且将根据<code>执行结果(then或者catch)</code>对3个状态<code>loading</code>,<code>loaded</code>,<code>error</code>进行更新，\\n返回一个包含所有状态和import执行结果的对象；</p>\\n<p>init：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">init</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (!res) {\\n    <span class=\\"hljs-comment\\">// loadFn就是load</span>\\n    <span class=\\"hljs-comment\\">// 这里opts.loader就是组件的延迟加载函数，例如：()=&gt;import(./xxx)</span>\\n    res = loadFn(opts.loader);\\n  }\\n  <span class=\\"hljs-comment\\">// 返回延迟加载的component</span>\\n  <span class=\\"hljs-keyword\\">return</span> res.promise;\\n}</code></pre>\\n</code></pre>\\n<p>loadFn：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">load</span>(<span class=\\"hljs-params\\">loader</span>) </span>{\\n  <span class=\\"hljs-comment\\">// promise保存了延迟加载组件执行的返回值(thenable)</span>\\n  <span class=\\"hljs-keyword\\">let</span> promise = loader();\\n  <span class=\\"hljs-comment\\">// 状态数据</span>\\n  <span class=\\"hljs-keyword\\">let</span> state = {\\n    <span class=\\"hljs-attr\\">loading</span>: <span class=\\"hljs-literal\\">true</span>,\\n    <span class=\\"hljs-attr\\">loaded</span>: <span class=\\"hljs-literal\\">null</span>,\\n    <span class=\\"hljs-attr\\">error</span>: <span class=\\"hljs-literal\\">null</span>\\n  };\\n  <span class=\\"hljs-comment\\">// state.promise是一个Promise的处理返回值</span>\\n  <span class=\\"hljs-comment\\">// 此处根据promise的返回值，更新状态数据</span>\\n  state.promise = promise\\n    .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">loaded</span> =&gt;</span> {\\n      state.loading = <span class=\\"hljs-literal\\">false</span>;\\n      state.loaded = loaded;\\n      <span class=\\"hljs-keyword\\">return</span> loaded;\\n    })\\n    .catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n      state.loading = <span class=\\"hljs-literal\\">false</span>;\\n      state.error = err;\\n      <span class=\\"hljs-keyword\\">throw</span> err;\\n    });\\n\\n  <span class=\\"hljs-comment\\">// state是一个obj，保存了状态和延迟加载组件执行的返回值</span>\\n  <span class=\\"hljs-keyword\\">return</span> state;\\n}</code></pre>\\n</code></pre>\\n<p>接着在<code>componentWillMount</code>下调用了<code>this._loadModule</code>，它会根据<code>options</code>里的参数(例如delay，timeout)对当前状态进行更新，并且继续监听<code>init</code>返回的对象，一旦处理完毕，更新状态。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 载入组件时，根据options加载和更新</span>\\ncomponentWillMount() {\\n  <span class=\\"hljs-keyword\\">this</span>._mounted = <span class=\\"hljs-literal\\">true</span>;\\n  <span class=\\"hljs-keyword\\">this</span>._loadModule();\\n}\\n\\n_loadModule(){\\n  <span class=\\"hljs-comment\\">/* 省略了服务端渲染的处理 */</span> \\n  \\n  <span class=\\"hljs-comment\\">// 延迟加载结束</span>\\n  <span class=\\"hljs-keyword\\">if</span> (!res.loading) {\\n    <span class=\\"hljs-keyword\\">return</span>;\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 默认200ms后更新pastDelay</span>\\n  <span class=\\"hljs-comment\\">// 有时组件加载非常快(&lt;200ms)，这时加载中的样式就会一闪而过</span>\\n  <span class=\\"hljs-comment\\">// 因此可以选择默认隔200ms后才开始渲染loading(避免样式闪动)，这样做是因为能让用户感觉更快</span>\\n  <span class=\\"hljs-comment\\">// https://github.com/jamiebuilds/react-loadable#avoiding-flash-of-loading-component</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> opts.delay === <span class=\\"hljs-string\\">\\"number\\"</span>) {\\n    <span class=\\"hljs-keyword\\">if</span> (opts.delay === <span class=\\"hljs-number\\">0</span>) {\\n      <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">pastDelay</span>: <span class=\\"hljs-literal\\">true</span> });\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-keyword\\">this</span>._delay = setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n        <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">pastDelay</span>: <span class=\\"hljs-literal\\">true</span> });\\n      }, opts.delay);\\n    }\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 判断是否需要更新timeout(用于超时处理)</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> opts.timeout === <span class=\\"hljs-string\\">\\"number\\"</span>) {\\n    <span class=\\"hljs-keyword\\">this</span>._timeout = setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">this</span>.setState({ <span class=\\"hljs-attr\\">timedOut</span>: <span class=\\"hljs-literal\\">true</span> });\\n    }, opts.timeout);\\n  }\\n\\n  <span class=\\"hljs-keyword\\">let</span> update = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 当组件未载入或者已经卸载，则返回</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>._mounted) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">this</span>.setState({\\n      <span class=\\"hljs-attr\\">error</span>: res.error,\\n      <span class=\\"hljs-attr\\">loaded</span>: res.loaded,\\n      <span class=\\"hljs-attr\\">loading</span>: res.loading\\n    });\\n\\n    <span class=\\"hljs-keyword\\">this</span>._clearTimeouts();\\n  };\\n\\n  <span class=\\"hljs-comment\\">// res是init()处理后的返回值</span>\\n  <span class=\\"hljs-comment\\">// promise属性对应的是组件延迟加载的返回值</span>\\n  res.promise\\n    .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 加载完毕后，执行update，更新相关状态数据</span>\\n      update();\\n    })\\n    .catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n      update();\\n    });\\n}</code></pre>\\n</code></pre>\\n<p>在<code>render</code>里面则根据当前状态，渲染对应的组件(例如<code>loading</code>或<code>error</code>状态为<code>true</code>，都会调用<code>Loading</code>组件，并且传递props)。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>render() {\\n  <span class=\\"hljs-comment\\">// loading或者error状态为true</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.state.loading || <span class=\\"hljs-keyword\\">this</span>.state.error) {\\n    <span class=\\"hljs-comment\\">// 创建loading组件，第二个参数为props，用于loading渲染的条件</span>\\n    <span class=\\"hljs-comment\\">// loading组件内部根据props定义渲染的内容</span>\\n    <span class=\\"hljs-keyword\\">return</span> React.createElement(opts.loading, {\\n      <span class=\\"hljs-attr\\">isLoading</span>: <span class=\\"hljs-keyword\\">this</span>.state.loading,\\n      <span class=\\"hljs-attr\\">pastDelay</span>: <span class=\\"hljs-keyword\\">this</span>.state.pastDelay,\\n      <span class=\\"hljs-attr\\">timedOut</span>: <span class=\\"hljs-keyword\\">this</span>.state.timedOut,\\n      <span class=\\"hljs-attr\\">error</span>: <span class=\\"hljs-keyword\\">this</span>.state.error,\\n      <span class=\\"hljs-attr\\">retry</span>: <span class=\\"hljs-keyword\\">this</span>.retry\\n    });\\n  } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.state.loaded) {\\n    <span class=\\"hljs-comment\\">// 组件已经加载完毕，渲染延迟加载的组件，render是渲染方法，默认为createElement进行渲染组件</span>\\n    <span class=\\"hljs-keyword\\">return</span> opts.render(<span class=\\"hljs-keyword\\">this</span>.state.loaded, <span class=\\"hljs-keyword\\">this</span>.props);\\n  } <span class=\\"hljs-keyword\\">else</span> {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n  }\\n}\\n\\n <span class=\\"hljs-comment\\">/* 默认的render方法 */</span>\\n\\n<span class=\\"hljs-comment\\">// 兼容babel编译后的组件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">resolve</span>(<span class=\\"hljs-params\\">obj</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> obj &amp;&amp; obj.__esModule ? obj.default : obj;\\n}\\n\\n<span class=\\"hljs-comment\\">// 默认的render函数——创建组件</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">render</span>(<span class=\\"hljs-params\\">loaded, props</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> React.createElement(resolve(loaded), props);\\n}</code></pre>\\n</code></pre>\\n<h4 id=\\"loadablemap\\">Loadable.Map</h4>\\n<p>多个延迟加载组件的处理</p>\\n<p>它也是基于单个组件处理的，它的工作逻辑：</p>\\n<p>只要任何一个组件还在加载，整体的<code>loading</code>状态就是<code>true</code>，任意一个组件延迟加载出错，整体的<code>error</code>状态就是<code>true</code>。</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 因为遍历并且执行load执行(单个执行)，遇到错误会抛出，因此要try...catch</span>\\n<span class=\\"hljs-keyword\\">try</span> {\\n  <span class=\\"hljs-built_in\\">Object</span>.keys(obj).forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">key</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">let</span> result = load(obj[key]);\\n    <span class=\\"hljs-comment\\">// 第一次判断，目的是改变loading状态</span>\\n    <span class=\\"hljs-comment\\">// 如果某延迟组件加载完毕</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!result.loading) {\\n      <span class=\\"hljs-comment\\">// 对应的loaded为true</span>\\n      <span class=\\"hljs-comment\\">// 整体的loading不变</span>\\n      state.loaded[key] = result.loaded;\\n      <span class=\\"hljs-comment\\">// 任意一个延迟组件有err，整体为err</span>\\n      state.error = result.error;\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 有任意一个延迟组件还在加载，则整体的loading为true</span>\\n      state.loading = <span class=\\"hljs-literal\\">true</span>;\\n    }\\n\\n    <span class=\\"hljs-comment\\">// 处理结果(Promise对象)放进数组</span>\\n    promises.push(result.promise);\\n  \\n    <span class=\\"hljs-comment\\">// 后续then，目的是处理已经加载完毕的组件</span>\\n    result.promise\\n    . then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">res</span> =&gt;</span> {\\n        state.loaded[key] = res;\\n      })\\n    . catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n        state.error = err;\\n      });\\n  });\\n  <span class=\\"hljs-comment\\">// 捕捉load的错误</span>\\n  } <span class=\\"hljs-keyword\\">catch</span> (err) {\\n  state.error = err;\\n}</code></pre>\\n</code></pre>\\n<p>使用了<code>Promise.all()</code>，等待全部完成后，改变<code>整体的loading</code>状态</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 当所有组件加载完毕(每个组件可能成功，也可能失败)</span>\\n<span class=\\"hljs-comment\\">// 整体的loading为false</span>\\n<span class=\\"hljs-comment\\">// 有错误则抛出，否则返回state</span>\\nstate.promise = <span class=\\"hljs-built_in\\">Promise</span>.all(promises)\\n.then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">res</span> =&gt;</span> {\\n  state.loading = <span class=\\"hljs-literal\\">false</span>;\\n  <span class=\\"hljs-keyword\\">return</span> res;\\n})\\n.catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> {\\n  state.loading = <span class=\\"hljs-literal\\">false</span>;\\n  <span class=\\"hljs-keyword\\">throw</span> err;\\n});</code></pre>\\n</code></pre>\\n<p>接下来也是<code>render</code>的处理了，跟前面没什么不同。</p>\\n<h4 id=\\"loadablecapture\\">Loadable.Capture</h4>\\n<p>服务端渲染的处理</p>\\n<p>这里要提源码中的<code>webpack.js</code>和<code>babel.js</code>，这里没有具体分析，只是说明它们的用途。</p>\\n<p>一个是webpack插件，作用是创建一个json键值对数据<code>react-loadable.json</code>，包含了每一个modules对应的bundles，\\n并且提供了一个将modulesID转换成bundles的方法<code>getBundles</code>，简单说就是<code>将key转换成value</code></p>\\n<p>另一个是babel插件，作用是自动提供2个参数<code>opts.webpack</code>和<code>opts.modules</code></p>\\n<pre><code><pre class=\\"hljs\\"><code>// 函数，执行后会获取当前延迟加载模块\\n// 这里用途是判断模块是否已经可用，作用于preLoadReady上\\nopts.webpack\\n\\n// 函数，执行后会获取当前import的路径，作为moduleId\\n// 这里用途是通过getBundles将moduleId转换成bundles\\nopts.modules</code></pre>\\n</code></pre>\\n<p>有了上面2个概念，<code>Loadable.Capture</code>做的事情很简单，</p>\\n<p>定义了一个<code>context</code>属性，并且渲染它的唯一子元素</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Capture</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">React</span>.<span class=\\"hljs-title\\">Component</span> </span>{\\n  <span class=\\"hljs-keyword\\">static</span> propTypes = {\\n    <span class=\\"hljs-attr\\">report</span>: PropTypes.func.isRequired\\n  };\\n  <span class=\\"hljs-comment\\">// 定义传递给子组件的上下文</span>\\n  <span class=\\"hljs-keyword\\">static</span> childContextTypes = {\\n    <span class=\\"hljs-attr\\">loadable</span>: PropTypes.shape({\\n      <span class=\\"hljs-attr\\">report</span>: PropTypes.func.isRequired\\n    }).isRequired\\n  };\\n  <span class=\\"hljs-comment\\">// 传递的上下文内容</span>\\n  getChildContext() {\\n    <span class=\\"hljs-keyword\\">return</span> {\\n      <span class=\\"hljs-attr\\">loadable</span>: {\\n        <span class=\\"hljs-attr\\">report</span>: <span class=\\"hljs-keyword\\">this</span>.props.report\\n      }\\n    };\\n  }\\n  <span class=\\"hljs-comment\\">// 渲染唯一的子元素</span>\\n  render() {\\n    <span class=\\"hljs-keyword\\">return</span> React.Children.only(<span class=\\"hljs-keyword\\">this</span>.props.children);\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这个context属性一般这么写，这里<code>modules</code>是一个空数组</p>\\n<p><code>report={moduleName =&gt; modules.push(moduleName)}</code></p>\\n<p>然后在<code>LoadableComponent</code>组件内部，如果存在<code>context属性</code>并且存在<code>opts.modules</code>(说明使用了babel插件)，\\n则调用<code>report</code>。</p>\\n<p>这里<code>moduleName</code>就是<code>opts.modules</code>里面每一个<code>moduleId</code>，通过<code>report</code>方法添加到<code>modules(空数组)</code>内部.</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.context.loadable &amp;&amp; <span class=\\"hljs-built_in\\">Array</span>.isArray(opts.modules)) {\\n  <span class=\\"hljs-comment\\">// 遍历并且对每一个执行report</span>\\n  opts.modules.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">moduleName</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">this</span>.context.loadable.report(moduleName);\\n  });\\n}</code></pre>\\n</code></pre>\\n<p>到现在，<code>modules</code>就是一个保存了当前进行延迟加载组件的<code>moduleId</code>的数组，再通过<code>getBundles</code>(webpack插件提供)方法，\\n将<code>moduleId(key)</code>通过查询<code>react-loadable.json(包含moduleId对应的bundles)</code>，转换成<code>bundles(value)</code>。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getBundles</span>(<span class=\\"hljs-params\\">manifest, moduleIds</span>) </span>{\\n  <span class=\\"hljs-comment\\">// moduleIds中每一个作为key，找到manifest[moduleId]合并到bundles(一个数组)中</span>\\n  <span class=\\"hljs-keyword\\">return</span> moduleIds.reduce(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">bundles, moduleId</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> bundles.concat(manifest[moduleId]);\\n  }, []);\\n}</code></pre>\\n</code></pre>\\n<p>现在我们得到了一个<code>bundles</code>数组，里面储存了我们延迟加载组件对应的<code>bundle</code>，我们要做的只是根据<code>bundle</code>类型\\n添加对应的<code>script标签</code>或者<code>link标签</code>。</p>\\n<h4 id=\\"preloadready\\">preLoadReady</h4>\\n<p>因为以上内容都是在服务端上的，客户端必须要等到组件可用了才可以开始渲染，</p>\\n<p>先提一个变量：<code>READY_INITIALIZERS</code>。</p>\\n<p>它储存了通过检查<code>opts.webpack</code>里面每一个<code>moduleId</code>对应的组件是可用的，这个组件的<code>init</code>方法。</p>\\n<p>这里<code>getModuleIds</code>就是<code>opts.webpack</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// __webpack_modules__是一个存储了所有模块的对象</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> __webpack_modules__ !== <span class=\\"hljs-string\\">\\"object\\"</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 检查是否每一个模块存在</span>\\n  <span class=\\"hljs-keyword\\">return</span> getModuleIds().every(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">moduleId</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> (\\n      <span class=\\"hljs-keyword\\">typeof</span> moduleId !== <span class=\\"hljs-string\\">\\"undefined\\"</span> &amp;&amp;\\n      <span class=\\"hljs-keyword\\">typeof</span> __webpack_modules__[moduleId] !== <span class=\\"hljs-string\\">\\"undefined\\"</span>\\n    );\\n  });</code></pre>\\n</code></pre>\\n<p><code>preLoadReady</code>就是通过遍历<code>READY_INITIALIZERS</code>数组，并且执行每一个组件的<code>init</code>方法，\\n最终当<code>Promise.all</code>全部完成后，就可以开始渲染客户端了。</p>\\n<h3 id=\\"dao-tu-zong-jie\\">导图总结</h3>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-loadable/react-loadabel.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"jie-shao","level":3,"text":"介绍"},{"anchor":"chu-shi","level":3,"text":"初识"},{"anchor":"shen-ru","level":3,"text":"深入"},{"anchor":"loadable","level":4,"text":"Loadable"},{"anchor":"loadablemap","level":4,"text":"Loadable.Map"},{"anchor":"loadablecapture","level":4,"text":"Loadable.Capture"},{"anchor":"preloadready","level":4,"text":"preLoadReady"},{"anchor":"dao-tu-zong-jie","level":3,"text":"导图总结"}],"relatedTags":["源码","react","promise","webpack","babel","github"],"created_at":"2018-09-10","timeArr":[2018,8,10,15,44,34,0],"title":"源码阅读-react-loadable","uuid":"5134ffe9303c7c82cc06321c03aa6dc4abdc9753","summary":"<h4>介绍</h4>\\n<p><a href=\\"https://github.com/jamiebuilds/react-loadable\\">react-loadable</a>是一个组件延迟加载的工具，\\n它本身也是一个组件，通过<code>HOC</code>的方式对参数组件进行处理，\\n具体的延迟加载方式是使用<code>import().then()</code>方法，那么为什么要用这个组件呢？...</p>","slug":"source-code-react-loadable","sha":"7d1a1d670bb1ec624fdef1c489f683ce954302c1"}')}}]);