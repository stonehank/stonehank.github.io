(window.webpackJsonp=window.webpackJsonp||[]).push([[1210],{2008:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">rectangles</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> rectangleArea = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">rectangles</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> aux=[]\\n  <span class=\\"hljs-keyword\\">let</span> mod=<span class=\\"hljs-number\\">1e9</span>+<span class=\\"hljs-number\\">7</span>\\n  <span class=\\"hljs-comment\\">// 分割每一个点为开始点和结束点</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [a,b,c,d] <span class=\\"hljs-keyword\\">of</span> rectangles){\\n    aux.push([b,[a,c],<span class=\\"hljs-string\\">\'s\'</span>],[d,[a,c],<span class=\\"hljs-string\\">\'e\'</span>])\\n  }\\n  <span class=\\"hljs-comment\\">// 按y轴排序，用于线段扫描</span>\\n  aux.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a[<span class=\\"hljs-number\\">0</span>]-b[<span class=\\"hljs-number\\">0</span>])\\n  \\n  <span class=\\"hljs-keyword\\">if</span>(aux.length===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> area=<span class=\\"hljs-number\\">0</span>,stack=[],last=aux[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-comment\\">// 对于每一个点，根据当前是结束还是开始，更新stack</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;aux.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [h,range,state]=aux[i]\\n    <span class=\\"hljs-keyword\\">let</span> curArea=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">if</span>(stack.length!==<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-comment\\">// 返回stack的并集</span>\\n      <span class=\\"hljs-keyword\\">let</span> res=merge(stack)\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [x,y] <span class=\\"hljs-keyword\\">of</span> res){\\n        <span class=\\"hljs-keyword\\">let</span> m1=(y-x) % mod, m2=(h-last) % mod\\n        <span class=\\"hljs-comment\\">// js不支持精确大位数数字，使用自定义方法执行大位数数字乘法</span>\\n        curArea=(curArea+multi(m1,m2)) % mod\\n      } \\n    }\\n    last=h\\n    area=(area+curArea) % mod\\n    <span class=\\"hljs-keyword\\">if</span>(state===<span class=\\"hljs-string\\">\\"s\\"</span>){\\n      stack.push(range)\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(state===<span class=\\"hljs-string\\">\'e\'</span>){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">0</span>;k&lt;stack.length;k++){\\n        <span class=\\"hljs-keyword\\">let</span> [x,y]=stack[k]\\n        <span class=\\"hljs-keyword\\">if</span>(x===range[<span class=\\"hljs-number\\">0</span>] &amp;&amp; y===range[<span class=\\"hljs-number\\">1</span>]){\\n          stack.splice(k,<span class=\\"hljs-number\\">1</span>)\\n          <span class=\\"hljs-keyword\\">break</span>\\n        }\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> area\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">multi</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> t=<span class=\\"hljs-built_in\\">Math</span>.floor(b/<span class=\\"hljs-number\\">1000000</span>),\\n        t2=b % <span class=\\"hljs-number\\">1000000</span>\\n    <span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;t;i++){\\n      sum=(sum+<span class=\\"hljs-number\\">1000000</span>*a) % mod\\n    }\\n    sum=(sum+t2*a)%mod\\n    <span class=\\"hljs-keyword\\">return</span> sum\\n  }\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">merge</span>(<span class=\\"hljs-params\\">intervals</span>) </span>{\\n    intervals.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a[<span class=\\"hljs-number\\">0</span>]===b[<span class=\\"hljs-number\\">0</span>]?a[<span class=\\"hljs-number\\">1</span>]-b[<span class=\\"hljs-number\\">1</span>]:a[<span class=\\"hljs-number\\">0</span>]-b[<span class=\\"hljs-number\\">0</span>])\\n    <span class=\\"hljs-keyword\\">let</span> result=[]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [x,y] <span class=\\"hljs-keyword\\">of</span> intervals){\\n      <span class=\\"hljs-keyword\\">if</span>(result.length===<span class=\\"hljs-number\\">0</span>){\\n        result.push([x,y])\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-keyword\\">let</span> last=result[result.length<span class=\\"hljs-number\\">-1</span>]\\n        <span class=\\"hljs-keyword\\">if</span>(x&gt;last[<span class=\\"hljs-number\\">1</span>]){\\n          result.push([x,y])\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n          last[<span class=\\"hljs-number\\">1</span>]=<span class=\\"hljs-built_in\\">Math</span>.max(last[<span class=\\"hljs-number\\">1</span>],y)\\n        }\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> result\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"rectangle-area-ii","created_at":"2019-04-25","timeArr":[2019,3,25,16,12,50,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>扫描线段，思路跟<code>NO.218</code>很像，对当前<code>rectangles</code>内的所有点，构建一个包含每个点的<code>y</code>轴上的当前矩形的开始的<code>x</code>范围和结束的<code>x</code>范围的数组<code>aux</code>。</p>\\n<p>例如<code>[0,0,2,2]</code>，这个矩形的<code>y</code>轴开始就是在<code>y=0</code>的位置，<code>x</code>的范围是<code>[0,2]</code>，在<code>y</code>轴结束的位置是<code>y=2</code>的位置，<code>x</code>范围也是<code>[0,2]</code>。</p>\\n<p>这个构建的数组<code>aux</code>内部为<code>[y,[x1,x2],state]</code>，其中<code>y</code>就是<code>y</code>轴的位置，<code>[x1,x2]</code>就是<code>x</code>轴跨越的范围，<code>state</code>就是<code>s</code>指开始，<code>e</code>指结束。</p>\\n<p>然后按<code>y</code>排序，定义一个<code>stack</code>，用于保存在当前<code>y</code>的位置有效的矩形<code>x</code>轴范围，从<code>y</code>最小开始，逐步检查，每一次遍历之前，\\n先将<code>stack</code>内所有点求并集(参考<code>NO.56</code>)，并集的范围在与当前<code>y</code>轴和上一次<code>y</code>轴的差距相乘。</p>\\n<p>如果当前<code>aux[i]</code>对应的是<code>s</code>(开始点)，添加到<code>stack</code>；如果是<code>e</code>(结束点)，说明这个矩形到此为止，从<code>stack</code>删除这个矩形的<code>x</code>范围。</p>\\n","content":"<p>我们给出了一个（轴对齐的）矩形列表&nbsp;<code>rectangles</code>&nbsp;。 对于&nbsp;<code>rectangle[i] = [x1, y1, x2, y2]</code>，其中（x1，y1）是矩形&nbsp;<code>i</code>&nbsp;左下角的坐标，（x2，y2）是该矩形右上角的坐标。</p>\\n\\n<p>找出平面中所有矩形叠加覆盖后的总面积。 由于答案可能太大，<strong>请返回它对 10 ^ 9 + 7 取模的结果</strong>。</p>\\n\\n<p><img alt=\\"\\" src=\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\\" style=\\"height: 360px; width: 480px;\\"></p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>[[0,0,2,2],[1,0,2,3],[1,0,3,1]]\\n<strong>输出：</strong>6\\n<strong>解释：</strong>如图所示。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>[[0,0,1000000000,1000000000]]\\n<strong>输出：</strong>49\\n<strong>解释：</strong>答案是 10^18 对 (10^9 + 7) 取模的结果， 即 (10^9)^2 &rarr; (-7)^2 = 49 。\\n</pre>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>\\n\\t<li><code>rectanges[i].length = 4</code></li>\\n\\t<li><code>0 &lt;= rectangles[i][j] &lt;= 10^9</code></li>\\n\\t<li>矩形叠加覆盖后的总面积不会超越&nbsp;<code>2^63 - 1</code>&nbsp;，这意味着可以用一个&nbsp;64 位有符号整数来保存面积结果。</li>\\n</ul>\\n","title":"850. 矩形面积 II","relatedTags":["线段树","数组","有序集合","扫描线"],"difficult":"Hard","lang":["javascript"],"uniqueID":"850","slug":"850-Rectangle-Area-II"}')}}]);