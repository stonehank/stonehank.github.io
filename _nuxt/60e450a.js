(window.webpackJsonp=window.webpackJsonp||[]).push([[1158],{1956:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">grid</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">hits</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> hitBricks = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">grid, hits</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> m=grid.length,n=grid[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">let</span> moves=[[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">-1</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>]]\\n  <span class=\\"hljs-comment\\">// 先将hits对应的是1的设置为-1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [x,y] <span class=\\"hljs-keyword\\">of</span> hits){\\n    <span class=\\"hljs-keyword\\">if</span>(grid[x][y]===<span class=\\"hljs-number\\">1</span>)grid[x][y]=<span class=\\"hljs-number\\">-1</span>\\n  }\\n  <span class=\\"hljs-comment\\">// 将剩下与顶部相连的设置为2</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;n;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(grid[<span class=\\"hljs-number\\">0</span>][i]===<span class=\\"hljs-number\\">1</span>)dfs([<span class=\\"hljs-number\\">0</span>,i])\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=[]\\n\\n  <span class=\\"hljs-comment\\">// 逆序逐个修复砖块，获得每次修复砖块能使其他砖块也能和顶端连通的数量</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=hits.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n    <span class=\\"hljs-keyword\\">let</span> [x,y]=hits[i]\\n    <span class=\\"hljs-keyword\\">if</span>(grid[x][y]===<span class=\\"hljs-number\\">0</span>){\\n      res[i]=<span class=\\"hljs-number\\">0</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      grid[x][y]=<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">if</span>(canReachRoof([x,y])){\\n        res[i]=dfs([x,y])<span class=\\"hljs-number\\">-1</span>\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        res[i]=<span class=\\"hljs-number\\">0</span>\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">canReachRoof</span>(<span class=\\"hljs-params\\">[x,y]</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(x===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [dx,dy] <span class=\\"hljs-keyword\\">of</span> moves){\\n      <span class=\\"hljs-keyword\\">let</span> nx=x+dx,ny=dy+y\\n      <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || ny&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">if</span>(grid[nx][ny]===<span class=\\"hljs-number\\">2</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n    } \\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  }\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">[x,y]</span>)</span>{\\n    grid[x][y]=<span class=\\"hljs-number\\">2</span>\\n    <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [dx,dy] <span class=\\"hljs-keyword\\">of</span> moves){\\n      <span class=\\"hljs-keyword\\">let</span> nx=x+dx,ny=dy+y\\n      <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || ny&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">if</span>(grid[nx][ny]===<span class=\\"hljs-number\\">1</span>){\\n        count+=dfs([nx,ny])\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> count\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"bricks-falling-when-hit","created_at":"2019-04-23","timeArr":[2019,3,23,19,24,52,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>先将所有要击碎的砖块击碎(设置为<code>-1</code>)，接着对当前状态将能与顶部连通的设置为<code>2</code>，这时候的<code>grid</code>就是最终状态。</p>\\n<p>然后逆序遍历<code>hits</code>，</p>\\n<p>如果当前位置是<code>0</code>，说明这个<code>hits[i]</code>击碎的位置没有砖块，返回<code>0</code>；</p>\\n<p>检查当前位置周围，如果周围不存在<code>2</code>，说明即使恢复这个砖块，也不能连通到顶部；返回<code>0</code>；</p>\\n<p>其他情况，逐个修复每一个砖块，并且计算修复当前砖块后，能增加连通到顶部(将<code>1</code>变为<code>2</code>)的砖块的数量。</p>\\n","content":"<p>有一个 <code>m x n</code> 的二元网格，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>\\n\\n<ul>\\n\\t<li>一块砖直接连接到网格的顶部，或者</li>\\n\\t<li>至少有一块相邻（4 个方向之一）砖块<strong> 稳定 </strong>不会掉落时</li>\\n</ul>\\n\\n<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除 <code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。</p>\\n\\n<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>\\n\\n<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\\n<strong>输出：</strong>[2]\\n<strong>解释：</strong>\\n网格开始为：\\n[[1,0,0,0]，\\n [<strong>1</strong>,1,1,0]]\\n消除 (1,0) 处加粗的砖块，得到网格：\\n[[1,0,0,0]\\n [0,<strong>1</strong>,<strong>1</strong>,0]]\\n两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：\\n[[1,0,0,0],\\n [0,0,0,0]]\\n因此，结果为 [2] 。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\\n<strong>输出：</strong>[0,0]\\n<strong>解释：</strong>\\n网格开始为：\\n[[1,0,0,0],\\n [1,<strong>1</strong>,0,0]]\\n消除 (1,1) 处加粗的砖块，得到网格：\\n[[1,0,0,0],\\n [1,0,0,0]]\\n剩下的砖都很稳定，所以不会掉落。网格保持不变：\\n[[1,0,0,0], \\n [<strong>1</strong>,0,0,0]]\\n接下来消除 (1,0) 处加粗的砖块，得到网格：\\n[[1,0,0,0],\\n [0,0,0,0]]\\n剩下的砖块仍然是稳定的，所以不会有砖块掉落。\\n因此，结果为 [0,0] 。</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>m == grid.length</code></li>\\n\\t<li><code>n == grid[i].length</code></li>\\n\\t<li><code>1 <= m, n <= 200</code></li>\\n\\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\\n\\t<li><code>1 <= hits.length <= 4 * 10<sup>4</sup></code></li>\\n\\t<li><code>hits[i].length == 2</code></li>\\n\\t<li><code>0 <= x<sub>i </sub><= m - 1</code></li>\\n\\t<li><code>0 <= y<sub>i</sub> <= n - 1</code></li>\\n\\t<li>所有 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 互不相同</li>\\n</ul>\\n","title":"803. 打砖块","relatedTags":["并查集","数组","矩阵"],"difficult":"Hard","lang":["javascript"],"uniqueID":"803","slug":"803-Bricks-Falling-When-Hit"}')}}]);