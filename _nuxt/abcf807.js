(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{611:function(n){n.exports=JSON.parse('{"content":"<p><a href=\\"https://leetcode.com/problems/single-number-ii/description/\\">原题目：</a>\\n<code>LeetCode</code>的一个题目，要求算出数组中单独出现的数字</p>\\n<pre><code><pre class=\\"hljs\\"><code>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\\n\\nNote:\\n\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nExample 1:\\n\\nInput: [2,2,3,2]\\nOutput: 3\\nExample 2:\\n\\nInput: [0,1,0,1,0,1,99]\\nOutput: 99</code></pre></code></pre><p>题目有一个限制：空间复杂度<code>O(1)</code></p>\\n<p>解决代码(简洁到发指)：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> singleNumber = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n    <span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-number\\">0</span>,b=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> nums){\\n        a=(a^n) &amp; ~b\\n        b=(b^n) &amp; ~a\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> a\\n};</code></pre></code></pre>\\n<hr>\\n<p>思路：</p>\\n<ol>\\n<li>我们要过滤出现3个的，保留出现1个的，那么就需要一个<code>状态机</code>，它达到3时为0，达到1时为它本身</li>\\n<li>为了完成第一条，需要2个辅助变量<code>a</code>,<code>b</code>，达到以下状态</li>\\n</ol>\\n<pre><code><pre class=\\"hljs\\"><code>　　　　　　　　　　  a  b\\n初始值  　　　　 ：   0   0\\n第一次碰见某个数n：   0   n\\n第二次碰见某个数n：   n   0\\n第三次碰见某个数n：   0   0</code></pre></code></pre><p>3.有上面看出，a,b初始值为0，</p>\\n<p>b的1,2步很简单，直接 <code>n ^ b</code>两次，但第三步需要处理一个额外的数，</p>\\n<p>a也可以先异或，再处理一个数，</p>\\n<p>我们先手动添加这个数，为了让它们打到状态值</p>\\n<p>b第一步：<code>(b ^ n) &amp; n    ----&gt; n</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; any(n)  ----&gt; 0</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; 0    ----&gt; 0</code></p>\\n<p>再看a的三步：</p>\\n<p>a第一步：<code>(a ^ n) &amp; 0  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; n  ----&gt; n</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; any(n)  ----&gt; 0</code></p>\\n<p>这里<code>any</code>可以表示任何数，为了方便我们用<code>n</code>去代替(后面的括号)</p>\\n<p>但这样后面那个数没有固定，就不能使用迭代，需要选择一个变量(会自动变化的)</p>\\n<p>4.看看b的输出值，<code>n,0,0</code>，看看a的需要的值<code>0,n,n</code> ，这就可以写一个转换函数</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> cov=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">x,n</span>)=&gt;</span>x===<span class=\\"hljs-number\\">0</span>?n:<span class=\\"hljs-number\\">0</span> </code></pre></code></pre>\\n<p>因此合并起来可以写成：</p>\\n<p>b第一步：<code>(b ^ n) &amp; n    ----&gt; n</code></p>\\n<p>a第一步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; n  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; n</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; 0    ----&gt; 0</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>再看b的需要的值<code>n,n,0</code>，a的初始值和前2步的输出值是<code>0,0,n</code>，很上面一样，</p>\\n<p>b第一步：<code>(b ^ n) &amp; cov(a,n)  ----&gt; n</code></p>\\n<p>a第一步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; cov(a,n)  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; n</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; cov(a,n)  ----&gt; 0</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; cov(b,n)  ----&gt; 0</code></p>\\n<p>5.上面只是实现连续数字，<code>[5,5,5,4]</code>这种</p>\\n<p>但实际上往往是这样的：<code>[5,4,5,5]</code></p>\\n<p>那么<code>cov()</code>是需要写成<code>~</code>，因为<code>n &amp; ~n</code>一定为0，<code>n &amp; ~0</code>一定为n，因此最终为：</p>\\n<p>b第一步：<code>(b ^ n) &amp; ~a  ----&gt; n</code></p>\\n<p>a第一步：<code>(a ^ n) &amp; ~b  ----&gt; 0</code></p>\\n<p>b第二步：<code>(b ^ n) &amp; ~a  ----&gt; 0</code></p>\\n<p>a第二步：<code>(a ^ n) &amp; ~b  ----&gt; n</code></p>\\n<p>b第三步：<code>(b ^ n) &amp; ~a  ----&gt; 0</code></p>\\n<p>a第三步：<code>(a ^ n) &amp; ~b  ----&gt; 0</code></p>\\n<p>都是一样的公式，迭代就行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-number\\">0</span>,b=<span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n <span class=\\"hljs-keyword\\">of</span> arr){\\n  b=(b ^ n) &amp; ~a \\n  a=(a ^ n) &amp; ~b\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-10-05","timeArr":[2018,9,5,0,0,0,0],"title":"记录一道LeetCode 位操作符计算单个数字方法","uuid":"df98df497745a7628226928d1110b2baad0c50cb","summary":"<p><a href=\\"https://leetcode.com/problems/single-number-ii/description/\\">原题目：</a>\\n<code>LeetCode</code>的一个题目，要求算出数组中单独出现的数字</p>\\n<pre class=\\"hljs\\"><code>Given a non-empty array of integers, every element appear...</code></pre>","slug":"ji-lu-yi-dao-LeetCode-wei-cao-zuo-fu-ji-suan-dan-ge-shu-zi-fang-fa","sha":"6a99838485b9fda6b8a6b0e9d892100d68d0a27c"}')}}]);