(window.webpackJsonp=window.webpackJsonp||[]).push([[1322],{2120:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root2</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> flipEquiv = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root1, root2</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!root1 &amp;&amp; !root2)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">if</span>(!root1 || !root2)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-keyword\\">if</span>(root1.val!==root2.val)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-keyword\\">return</span> flipEquiv(root1.left,root2.left) &amp;&amp; flipEquiv(root1.right,root2.right) ||\\n         flipEquiv(root1.right,root2.left) &amp;&amp; flipEquiv(root1.left,root2.right)\\n};\\n</code></pre>\\n"],"querySlug":"flip-equivalent-binary-trees","created_at":"2019-03-21","timeArr":[2019,2,21,9,59,21,0],"hasThinking":false,"content":"<p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>\\n\\n<p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X <em>翻转等价</em>于二叉树 Y。</p>\\n\\n<p>编写一个判断两个二叉树是否是<em>翻转等价</em>的函数。这些树由根节点&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;给出。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre><strong>输入：</strong>root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\\n<strong>输出：</strong>true\\n<strong>解释：</strong>我们翻转值为 1，3 以及 5 的三个节点。\\n<img alt=\\"Flipped Trees Diagram\\" src=\\"https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png\\" style=\\"height: 220px; width: 500px;\\">\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li>每棵树最多有&nbsp;<code>100</code>&nbsp;个节点。</li>\\n\\t<li>每棵树中的每个值都是唯一的、在 <code>[0, 99]</code>&nbsp;范围内的整数。</li>\\n</ol>\\n\\n<p>&nbsp;</p>\\n","title":"951. 翻转等价二叉树","relatedTags":["树","深度优先搜索","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"951","slug":"951-Flip-Equivalent-Binary-Trees"}')}}]);