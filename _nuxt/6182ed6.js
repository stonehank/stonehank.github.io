(window.webpackJsonp=window.webpackJsonp||[]).push([[664],{1462:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> minSubArrayLen = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s, nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> windowSum=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> minLen=<span class=\\"hljs-literal\\">Infinity</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n    windowSum+=nums[i]\\n    <span class=\\"hljs-keyword\\">while</span>(windowSum&gt;=s){\\n      minLen=<span class=\\"hljs-built_in\\">Math</span>.min(minLen,i-j+<span class=\\"hljs-number\\">1</span>)\\n      windowSum-=nums[j++]\\n    }    \\n  }\\n  <span class=\\"hljs-keyword\\">return</span> minLen===<span class=\\"hljs-literal\\">Infinity</span>?<span class=\\"hljs-number\\">0</span>:minLen\\n  \\n  <span class=\\"hljs-comment\\">/*\\n  O(nlgn)解法思路:\\n  1. 先求出每一项的和 sum[]\\n  2. 从最后一项开始，二分查找 `sum[i]-s`，找不到则使用前一个idx\\n  3. 计算最小值 `i-idx`\\n  */</span>\\n};\\n</code></pre>\\n","<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">minSubArrayLen</span><span class=\\"hljs-params\\">(self, s, nums)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type s: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \\"\\"\\"</span>\\n        j=<span class=\\"hljs-number\\">0</span>\\n        windowSum=<span class=\\"hljs-number\\">0</span>\\n        minLen=float(<span class=\\"hljs-string\\">\\"inf\\"</span>)\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(<span class=\\"hljs-number\\">0</span>,len(nums)):\\n          windowSum+=nums[i]\\n          <span class=\\"hljs-keyword\\">while</span> windowSum&gt;=s:\\n            minLen=min(minLen,i-j+<span class=\\"hljs-number\\">1</span>)\\n            windowSum-=nums[j]\\n            j+=<span class=\\"hljs-number\\">1</span>\\n        <span class=\\"hljs-keyword\\">if</span> minLen==float(<span class=\\"hljs-string\\">\\"inf\\"</span>):\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n        <span class=\\"hljs-keyword\\">return</span> minLen\\n</code></pre>\\n"],"querySlug":"minimum-size-subarray-sum","hasThinking":false,"content":"<p>给定一个含有 <code>n</code><strong> </strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>\\n\\n<p>找出该数组中满足其和<strong> </strong><code>≥ target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong> <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]\\n<strong>输出：</strong>2\\n<strong>解释：</strong>子数组 <code>[4,3]</code> 是该条件下的长度最小的子数组。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>target = 4, nums = [1,4,4]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]\\n<strong>输出：</strong>0\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= target <= 10<sup>9</sup></code></li>\\n\\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\\n\\t<li><code>1 <= nums[i] <= 10<sup>5</sup></code></li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶：</strong></p>\\n\\n<ul>\\n\\t<li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>\\n</ul>\\n","title":"209. 长度最小的子数组","relatedTags":["数组","二分查找","前缀和","滑动窗口"],"difficult":"Middle","lang":["javascript","python"],"uniqueID":"209","slug":"209-Minimum-Size-Subarray-Sum"}')}}]);