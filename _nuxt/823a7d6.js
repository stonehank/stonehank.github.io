(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{579:function(e){e.exports=JSON.parse('{"content":"<h2 id=\\"web-worker-vs-idlerequestcallback-vs-settimeout\\">web worker VS idleRequestCallback VS setTimeout</h2>\\n<p><strong><em>测试平台：FireFox</em></strong>(Chrome嵌套worker会有<a href=\\"https://bugs.chromium.org/p/chromium/issues/detail?id=31666\\">bug</a>)</p>\\n<table>\\n<thead>\\n<tr>\\n<th><em>方法</em></th>\\n<th align=\\"center\\">从0自加至100亿（相同环境）</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>web worker(10线程)</td>\\n<td align=\\"center\\">7s</td>\\n</tr>\\n<tr>\\n<td>web worker(单线程)</td>\\n<td align=\\"center\\">29s</td>\\n</tr>\\n<tr>\\n<td>idleRequestCallback</td>\\n<td align=\\"center\\">45s</td>\\n</tr>\\n<tr>\\n<td>setTimeout</td>\\n<td align=\\"center\\">61s</td>\\n</tr>\\n</tbody></table>\\n<p><a href=\\"https://github.com/stonehank/handleHugeTask\\">项目地址</a></p>\\n<p>一些注意点：</p>\\n<ol>\\n<li>web worker执行不受主线程执行影响。</li>\\n<li>idle执行收到主线程影响,主线程繁忙会暂停(因为没有空闲帧),setTimeout也会受影响。</li>\\n<li>worker可以嵌套，充分发挥多核cpu的性能（个人的电脑数据，worker能让浏览器进程迅速到90%，idle和setTimeout在35%徘徊，最多40%)。</li>\\n<li>worker任务结束必须手动关闭，否则线程会一直占用资源。</li>\\n<li>idle和setTimeout应该将任务分割成合适的小任务，否则单个任务过大会影响主线程流畅度。</li>\\n</ol>\\n<hr>\\n<h3 id=\\"web-worker-kai-qi-fang-shi\\">web worker开启方式</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 开启</span>\\n<span class=\\"hljs-keyword\\">let</span> worker=<span class=\\"hljs-keyword\\">new</span> Worker(<span class=\\"hljs-string\\">\\"workers-run.js\\"</span>)\\n<span class=\\"hljs-comment\\">// 传递数据，对象会序列化然后再传过去</span>\\nworker.postMessage({target,<span class=\\"hljs-attr\\">threadNum</span>:threadNum.value})\\n<span class=\\"hljs-comment\\">// 接受数据</span>\\nworker.onmessage=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(e.data===<span class=\\"hljs-string\\">\\"done\\"</span>){\\n        workerRunning=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-comment\\">// 结束线程</span>\\n        worker.terminate()\\n    }\\n}</code></pre></code></pre>\\n<p>内部还可以嵌套：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// workers-run.js</span>\\n\\n <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;n;i++) {\\n    <span class=\\"hljs-keyword\\">let</span> subWorker\\n    <span class=\\"hljs-comment\\">// 线程下再分n个子线程</span>\\n    subWorker = <span class=\\"hljs-keyword\\">new</span> Worker(<span class=\\"hljs-string\\">\'sub-workers-run.js\'</span>)\\n    subWorker.postMessage(target / n)\\n    subWorker.onmessage = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{\\n        <span class=\\"hljs-comment\\">//...</span>\\n    }\\n}</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"idlerequestcallback-kai-qi-fang-shi\\">idleRequestCallback开启方式</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> idleID = requestIdleCallback(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createIdle</span>(<span class=\\"hljs-params\\">deadline</span>) </span>{\\n    <span class=\\"hljs-comment\\">// 当有空闲帧 并且 未完成目标时</span>\\n    <span class=\\"hljs-keyword\\">while</span> (deadline.timeRemaining() &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; taskSum &lt; target) {\\n      <span class=\\"hljs-comment\\">// 调用执行函数</span>\\n      smallTask(target/<span class=\\"hljs-number\\">3000</span>);\\n    }\\n    <span class=\\"hljs-comment\\">// 如果未能调用createIdle，didTimeout为true</span>\\n    <span class=\\"hljs-keyword\\">if</span> (deadline.didTimeout) {\\n      <span class=\\"hljs-comment\\">// 未能调用createIdle</span>\\n    }\\n    <span class=\\"hljs-keyword\\">if</span> (taskSum &lt; target) {\\n      <span class=\\"hljs-comment\\">// 递归请求</span>\\n      requestIdleCallback(createIdle)\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 完成！</span>\\n    }\\n    <span class=\\"hljs-comment\\">// 未能调用createIdle的超时时间</span>\\n}, {<span class=\\"hljs-attr\\">timeout</span>: <span class=\\"hljs-number\\">1000</span>})</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"settimeout-de-yun-xing-fang-shi\\">setTimeout的运行方式</h3>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">if</span> (taskSum&lt;target) {\\n  setTimeout( <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    run( tg-eachTask );\\n  }, <span class=\\"hljs-number\\">0</span> );\\n}</code></pre></code></pre>\\n<p>经常看到使用<code>Promise.resolve().then</code>代替<code>setTimeout(function(){},0)</code>的，那么这里能不能这么写呢：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-built_in\\">Promise</span>.resolve().then(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n  run( tg-eachTask );\\n})</code></pre></code></pre>\\n<p>结果是不行的，使用Promise会造成主线程阻塞，原因是Promise会加入到<code>任务队列</code>，而setTimeout会加入到<code>事件循环队列</code></p>\\n<p>一张图理解：</p>\\n<p><img src=\\"/article/img/eventloop%20and%20callbackqueue.png\\" alt=\\"\\"></p>\\n<p>因此，使用Promise就不会去等下一次队列的渲染，结束后放到任务队列末尾继续调用</p>\\n","toc":[{"anchor":"web-worker-vs-idlerequestcallback-vs-settimeout","level":2,"text":"web worker VS idleRequestCallback VS setTimeout"},{"anchor":"web-worker-kai-qi-fang-shi","level":3,"text":"web worker开启方式"},{"anchor":"idlerequestcallback-kai-qi-fang-shi","level":3,"text":"idleRequestCallback开启方式"},{"anchor":"settimeout-de-yun-xing-fang-shi","level":3,"text":"setTimeout的运行方式"}],"relatedTags":null,"created_at":"2018-07-16","timeArr":[2018,6,16,0,0,0,0],"title":"处理额外复杂任务的3种方式","uuid":"54ce9f8dc0d7064cd42d8c9ee6a7138966a00888","summary":"<h4>web worker VS idleRequestCallback VS setTimeout</h4>\\n<p><em><strong>测试平台：FireFox</strong></em>(Chrome嵌套worker会有<a href=\\"https://bugs.chromium.org/p/chromium/issues/detail?id=31666\\">bug</a>)</p>\\n<p>|*方法...</p>","slug":"chu-li-e-wai-fu-za-ren-wu-de-3-zhong-fang-shi","sha":"f28cf454576cd104bf798125e2ecfc91945fc1cf"}')}}]);