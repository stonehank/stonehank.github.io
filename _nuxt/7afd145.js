(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{677:function(n){n.exports=JSON.parse('{"content":"<p><code>react-snapshot</code>一个用于react服务端渲染的工具，并没有使用<code>react V16+</code>的<code>hydrate</code>，但也能学到一些东西</p>\\n<hr>\\n<h4 id=\\"ku-glob-to-regexp\\">库<code>glob-to-regexp</code></h4>\\n<p>它可以将路径转化为正则，适用于路径匹配</p>\\n<p>例如</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>re = globToRegExp(<span class=\\"hljs-string\\">\\"*/www/*.js\\"</span>);\\nre.test(<span class=\\"hljs-string\\">\\"http://example.com/www/app.js\\"</span>); <span class=\\"hljs-comment\\">// true</span>\\nre.test(<span class=\\"hljs-string\\">\\"http://example.com/www/lib/factory-proxy-model-observer.js\\"</span>); <span class=\\"hljs-comment\\">// true</span></code></pre></code></pre>\\n<hr>\\n<h4 id=\\"pathjoin--yu--pathresolve-yu-urlresolve-de-qu-bie\\"><code>path.join</code> 与 <code>path.resolve</code>与<code>url.resolve</code>的区别</h4>\\n<ol>\\n<li><p>对于以/开始的路径片段，path.join只是简单的将该路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃，就像是在terminal中使用cd命令一样。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> path.join(<span class=\\"hljs-string\\">\'/a\'</span>, <span class=\\"hljs-string\\">\'/b\'</span>) <span class=\\"hljs-comment\\">// \'a/b\'</span>\\n path.resolve(<span class=\\"hljs-string\\">\'/a\'</span>, <span class=\\"hljs-string\\">\'/b\'</span>) <span class=\\"hljs-comment\\">// \'/b\'</span></code></pre></code></pre>\\n</li>\\n<li><p><code>path.resolve</code>总是返回一个以相对于参数1的工作目录（working directory）的绝对路径。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> path.join(<span class=\\"hljs-string\\">\'./a\'</span>, <span class=\\"hljs-string\\">\'./b\'</span>) <span class=\\"hljs-comment\\">// \'a/b\'</span>\\n path.resolve(<span class=\\"hljs-string\\">\'./a\'</span>, <span class=\\"hljs-string\\">\'./b\'</span>) <span class=\\"hljs-comment\\">// \'/Users/username/Projects/webpack-demo/a/b\'</span></code></pre></code></pre>\\n</li>\\n<li><p><code>url.resolve(a,b)</code>返回的是url拼接的结果</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> url.resolve(<span class=\\"hljs-string\\">\'/c/\'</span>,<span class=\\"hljs-string\\">\'./xx.png\'</span>) <span class=\\"hljs-comment\\">// /c/xx.png</span>\\n url.resolve(<span class=\\"hljs-string\\">\'/c/\'</span>,<span class=\\"hljs-string\\">\'/xx.png\'</span>)  <span class=\\"hljs-comment\\">// /xx.png</span></code></pre></code></pre>\\n</li>\\n</ol>\\n<ul>\\n<li>延伸</li>\\n</ul>\\n<ol>\\n<li><p><code>require.resolve()</code>：返回完整路径，不会执行(路径必须存在)</p>\\n</li>\\n<li><p><code>process.argv</code>：当前<code>cli</code>指令参数的数组</p>\\n</li>\\n<li><p><code>process.cwd()</code>和<code>__dirname</code></p>\\n<ul>\\n<li><p><code>process.cwd()</code></p>\\n<p>  是当前执行node命令时候的文件夹地址（被哪个位置的命令执行或者调用） </p>\\n<p>  工作目录，保证了文件在不同的目录下执行时，路径始终不变</p>\\n</li>\\n<li><p><code>__dirname</code> </p>\\n<p>  是被执行的js 文件的地址 ——文件所在目录</p>\\n</li>\\n</ul>\\n</li>\\n</ol>\\n<hr>\\n<h4 id=\\"expressstatic\\">express.static</h4>\\n<p><code>express.static(root,[options])</code></p>\\n<p>托管静态资源，当请求资源时，会去查找<code>root</code>目录下的静态资源，多个<code>express.static</code>按定义顺序查找</p>\\n<p>搭配<code>app.use</code>可以设定一个虚拟目录</p>\\n<p>例如</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>app.use(<span class=\\"hljs-string\\">\'/static\'</span>,express.static(__dirname +<span class=\\"hljs-string\\">\'/public\'</span>))</code></pre></code></pre>\\n<p>当请求<code>xxx.com/static/image.png</code>就会自动查找<code>xx.com/public/image.png</code></p>\\n<hr>\\n<h4 id=\\"jsdom\\">jsdom</h4>\\n<p>一个在<code>nodeJs</code>上执行虚拟dom环境</p>\\n<p><code>react-snapshot</code>使用的<code>jsdom</code>比较旧了，版本是<code>9.4.5</code>，而当前最新<code>13.0.0</code>，而且旧版的<code>api</code>目前好像没有使用了。</p>\\n<p>因此也是找到旧版的<code>README</code>文档看的，不管是否过期，先记录吧。</p>\\n<ul>\\n<li><p><code>jsdom.env(string, [scripts], [config], callback);</code></p>\\n<p>  <code>string</code>绑定了一个url，当访问这个url的时候，让它创建一个虚拟DOM。</p>\\n<p>  <code>scripts</code>将要以<code>&lt;script&gt;</code>标签插入的js</p>\\n<p>  <code>config</code>配置</p>\\n<p>  <code>callbakc</code>两个参数，<code>err</code>和<code>window</code>这个window是虚拟DOM的<code>window</code></p>\\n</li>\\n<li><p><code>jsdom</code>的<code>window</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-built_in\\">window</span>.document.documentElement.outerHTML);\\n  <span class=\\"hljs-comment\\">// output: \\"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;\\"</span>\\n\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-built_in\\">window</span>.innerWidth);\\n  <span class=\\"hljs-comment\\">// output: 1024</span>\\n\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-keyword\\">typeof</span> <span class=\\"hljs-built_in\\">window</span>.document.getElementsByClassName);\\n  <span class=\\"hljs-comment\\">// outputs: function</span></code></pre></code></pre>\\n</li>\\n<li><p>这里的使用</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  jsdom.env({\\n    <span class=\\"hljs-comment\\">// 当访问这个url时,这里的url代替了 参数html</span>\\n    url,\\n    <span class=\\"hljs-comment\\">// 响应头设置</span>\\n    <span class=\\"hljs-attr\\">headers</span>: { <span class=\\"hljs-attr\\">Accept</span>: <span class=\\"hljs-string\\">\\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\"</span> },\\n    <span class=\\"hljs-comment\\">// 当前urlPath有外部资源请求时，拦截请求并且进行配置</span>\\n    resourceLoader(resource, callback) {\\n      <span class=\\"hljs-comment\\">// host相同</span>\\n      <span class=\\"hljs-keyword\\">if</span> (resource.url.host === host) {\\n        <span class=\\"hljs-comment\\">// 继续获取资源</span>\\n        <span class=\\"hljs-comment\\">// 相当于</span>\\n        <span class=\\"hljs-comment\\">/*\\n        resource.defaultFetch(function(err,body){\\n          if(err) return callback(err);\\n          callback(null,body)\\n        });\\n        */</span>\\n        resource.defaultFetch(callback);\\n      } <span class=\\"hljs-keyword\\">else</span> {\\n        <span class=\\"hljs-comment\\">// 不获取资源(未传参数)</span>\\n        callback()\\n      }\\n    },\\n    <span class=\\"hljs-attr\\">features</span>: {\\n      <span class=\\"hljs-comment\\">// 允许jsdom 获取哪种类型的外部资源</span>\\n      <span class=\\"hljs-attr\\">FetchExternalResources</span>: [<span class=\\"hljs-string\\">\\"script\\"</span>],\\n      <span class=\\"hljs-comment\\">// 是否允许js的运行  [\\"script\\"] or `false`</span>\\n      <span class=\\"hljs-attr\\">ProcessExternalResources</span>: [<span class=\\"hljs-string\\">\\"script\\"</span>],\\n      <span class=\\"hljs-comment\\">// 需要过滤的特定资源</span>\\n      <span class=\\"hljs-attr\\">SkipExternalResources</span>: <span class=\\"hljs-literal\\">false</span>\\n    },\\n    <span class=\\"hljs-comment\\">// 将window.console 转到node的输出</span>\\n    <span class=\\"hljs-attr\\">virtualConsole</span>: jsdom.createVirtualConsole().sendTo(<span class=\\"hljs-built_in\\">console</span>),\\n    <span class=\\"hljs-comment\\">// 当window属性被创建的时候</span>\\n    <span class=\\"hljs-attr\\">created</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, <span class=\\"hljs-built_in\\">window</span></span>) =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 这里传出了window供外部使用</span>\\n   },\\n    <span class=\\"hljs-comment\\">// 当window创建和document读取完毕</span>\\n    <span class=\\"hljs-attr\\">done</span>: <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, <span class=\\"hljs-built_in\\">window</span></span>) =&gt;</span> {}\\n  })</code></pre></code></pre>\\n</li>\\n</ul>\\n<hr>\\n<h4 id=\\"kuo-zhan-reactdomhydrate\\">扩展：ReactDOM.hydrate</h4>\\n<p>在<code>React V15</code>中，客户端根据<code>data-react-checksum</code>标记判断是否复用；根据<code>data-reactid</code>标记，追踪事件处理，绑定事件。</p>\\n<p>在<code>React V16</code>中，<code>hydrate</code>用于服务端渲染，客户端会保留(尽量复用)服务端的渲染，并只对事件进行获取。</p>\\n<p>这就有以下几个注意点：</p>\\n<ul>\\n<li><p>客户端，服务端渲染内容最好一致</p>\\n</li>\\n<li><p>如果不一致，需要自行处理，不能保证<code>React</code>能完美处理，可以添加<code>suppressHydrationWarning={true}</code>来忽略当前元素的警告。</p>\\n</li>\\n<li><p>如果要求不一致，可以将不一致的内容放到生命周期函数内进行更新(服务端渲染无生命周期函数)</p>\\n<p>  例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">this</span>.state={\\n    <span class=\\"hljs-attr\\">isClient</span>:<span class=\\"hljs-literal\\">false</span>\\n  }\\n\\n  componentDidMount(){\\n    <span class=\\"hljs-keyword\\">this</span>.setState({\\n      <span class=\\"hljs-attr\\">isClient</span>:<span class=\\"hljs-literal\\">true</span>\\n    })\\n  }</code></pre></code></pre>\\n</li>\\n</ul>\\n","toc":[{"anchor":"ku-glob-to-regexp","level":4,"text":"库<code>glob-to-regexp</code>"},{"anchor":"pathjoin--yu--pathresolve-yu-urlresolve-de-qu-bie","level":4,"text":"<code>path.join</code> 与 <code>path.resolve</code>与<code>url.resolve</code>的区别"},{"anchor":"expressstatic","level":4,"text":"express.static"},{"anchor":"jsdom","level":4,"text":"jsdom"},{"anchor":"kuo-zhan-reactdomhydrate","level":4,"text":"扩展：ReactDOM.hydrate"}],"relatedTags":null,"created_at":"2018-12-03","timeArr":[2018,11,3,0,0,0,0],"title":"源码阅读-react-snapshot","uuid":"1c4e38c3c8cdea68cde83fbec5fb641f85a0c066","summary":"<p><code>react-snapshot</code>一个用于react服务端渲染的工具，并没有使用<code>react V16+</code>的<code>hydrate</code>，但也能学到一些东西</p>","slug":"yuan-ma-yue-du-react-snapshot","sha":"d568476c4e1852e8b6439b1bc26f6ea8435bf4bc"}')}}]);