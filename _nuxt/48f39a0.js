(window.webpackJsonp=window.webpackJsonp||[]).push([[844],{1642:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for an interval.\\n * function Interval(start, end) {\\n *     this.start = start;\\n *     this.end = end;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{Interval[]}</span> <span class=\\"hljs-variable\\">intervals</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> eraseOverlapIntervals = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">intervals</span>) </span>{\\n  intervals.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a.start===b.start?b.end-a.end:a.start-b.start)\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;intervals.length<span class=\\"hljs-number\\">-1</span>;i++){\\n    <span class=\\"hljs-keyword\\">let</span> x1=intervals[i].start,y1=intervals[i].end,\\n        x2=intervals[i+<span class=\\"hljs-number\\">1</span>].start,y2=intervals[i+<span class=\\"hljs-number\\">1</span>].end\\n    <span class=\\"hljs-keyword\\">if</span>(x2&lt;y1){\\n      res++\\n      <span class=\\"hljs-keyword\\">if</span>(x1&lt;=x2 &amp;&amp; y1&gt;=y2)intervals.splice(i,<span class=\\"hljs-number\\">1</span>)\\n      <span class=\\"hljs-keyword\\">else</span> intervals.splice(i+<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">1</span>)\\n      i--\\n      <span class=\\"hljs-keyword\\">continue</span>\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"non-overlapping-intervals","created_at":"2019-04-13","timeArr":[2019,3,13,15,36,43,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>首先对<code>end</code>升序排序。</p>\\n<p>之所以只对<code>end</code>排序，因为<code>start</code>一定小于<code>end</code>，因此一个<code>intervals[i].end</code>决定了它前面所有区间的最右端。</p>\\n<p>遍历<code>intervals</code>，如果发现当前和之前一个重叠了(即当前的<code>start</code>小于之前区间的<code>end</code>)，那么直接跳过当前区间即可，也就是删除当前区间，因为2个区间留一个，肯定留<code>end</code>更小的区间。</p>\\n","content":"<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>\\n\\n<p><strong>注意:</strong></p>\\n\\n<ol>\\n\\t<li>可以认为区间的终点总是大于它的起点。</li>\\n\\t<li>区间 [1,2] 和 [2,3] 的边界相互&ldquo;接触&rdquo;，但没有相互重叠。</li>\\n</ol>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [ [1,2], [2,3], [3,4], [1,3] ]\\n\\n<strong>输出:</strong> 1\\n\\n<strong>解释:</strong> 移除 [1,3] 后，剩下的区间没有重叠。\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [ [1,2], [1,2], [1,2] ]\\n\\n<strong>输出:</strong> 2\\n\\n<strong>解释:</strong> 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\\n</pre>\\n\\n<p><strong>示例 3:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> [ [1,2], [2,3] ]\\n\\n<strong>输出:</strong> 0\\n\\n<strong>解释:</strong> 你不需要移除任何区间，因为它们已经是无重叠的了。\\n</pre>\\n","title":"435. 无重叠区间","relatedTags":["贪心","数组","动态规划","排序"],"difficult":"Middle","lang":["javascript"],"uniqueID":"435","slug":"435-Non-overlapping-Intervals"}')}}]);