(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{652:function(n){n.exports=JSON.parse('{"content":"<p>原文：<a href=\\"https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553\\">https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553</a></p>\\n<hr>\\n<h4 id=\\"xian-xiang\\">现象</h4>\\n<p>文章首先就抛出了两段代码，它们的不同之处仅仅在于后者的数据结构多了一个属性而已</p>\\n<p>例一：</p>\\n<pre><code><pre class=\\"hljs\\"><code>(() =&gt; { \\n  const han = {firstname: &quot;Han&quot;, lastname: &quot;Solo&quot;};\\n  const luke = {firstname: &quot;Luke&quot;, lastname: &quot;Skywalker&quot;};\\n  const leia = {firstname: &quot;Leia&quot;, lastname: &quot;Organa&quot;};\\n  const obi = {firstname: &quot;Obi&quot;, lastname: &quot;Wan&quot;};\\n  const yoda = {firstname: &quot;&quot;, lastname: &quot;Yoda&quot;};\\n  const people = [\\n    han, luke, leia, obi, \\n    yoda, luke, leia, obi \\n  ];\\n  const getName = (person) =&gt; person.lastname;\\n  console.time(&quot;engine&quot;);\\n  for(var i = 0; i &lt; 1000 * 1000 * 1000; i++) { \\n    getName(people[i &amp; 7]); \\n  }\\n  console.timeEnd(&quot;engine&quot;); \\n})();</code></pre></code></pre><p>例二：</p>\\n<pre><code><pre class=\\"hljs\\"><code>(() =&gt; {\\n  const han = {firstname: &quot;Han&quot;, lastname: &quot;Solo&quot;, spacecraft: &quot;Falcon&quot;};\\n  const luke = {firstname: &quot;Luke&quot;, lastname: &quot;Skywalker&quot;, job: &quot;Jedi&quot;};\\n  const leia = {firstname: &quot;Leia&quot;, lastname: &quot;Organa&quot;, gender: &quot;female&quot;};\\n  const obi = {firstname: &quot;Obi&quot;, lastname: &quot;Wan&quot;, retired: true};\\n  const yoda = {lastname: &quot;Yoda&quot;};\\n  const people = [\\n    han, luke, leia, obi, \\n    yoda, luke, leia, obi\\n  ];\\n  const getName = (person) =&gt; person.lastname;\\n  console.time(&quot;engine&quot;);\\n  for(var i = 0; i &lt; 1000 * 1000 * 1000; i++) {\\n    getName(people[i &amp; 7]);\\n  }\\n  console.timeEnd(&quot;engine&quot;);\\n})();</code></pre></code></pre><p>结果执行后，第一个耗时约1.2s,第二个耗时约8.5s</p>\\n<p>仅仅加了一个属性，为什么会有这么大的差距？</p>\\n<hr>\\n<h4 id=\\"yuan-yin\\">原因</h4>\\n<p>这就要提到JS的<code>Interpreter</code>(解释器)和<code>Compiler</code>编译器。</p>\\n<p>当创建一个对象后，解释器会对这个对象进行检索，这个检索操作是消耗很大的。</p>\\n<p>因此，又要提出一个概念<code>Inline Caching</code>内联缓存，它会在运行时，将对象按照属性的key名称和顺序完全一致的分类，例如<code>{firstname: &quot;Han&quot;, lastname: &quot;Solo&quot;}</code>和<code>{lastname: &quot;Solo&quot;, firstname: &quot;Han&quot;}</code>会被分为2类。</p>\\n<p>如果对象都属于同一类，也就是它们的<code>shape</code>形状一致，那么内联缓存就会让编译器执行相同的处理，从而提升性能。</p>\\n<p>在第一个例子中，由于所有数据结构的&quot;形状&quot;都是一样的，因此称为<code>单态内联缓存</code>；</p>\\n<p>当&quot;形状&quot;超过1个，第二个例子，即缓存了多个数据结构的&quot;形状&quot;，那么编译器每次都会在几个&quot;形状之间&quot;进行判断；</p>\\n<p>当缓存的&quot;形状&quot;继续增加，超过一个上限值后，就不存在局部缓存，而是全局缓存，那么每次检索都会在全局缓存上查找，这会导致性能下降到极点。</p>\\n<hr>\\n<h4 id=\\"jie-jue\\">解决</h4>\\n<p>知道原因后，问题就很好解决了，定义一个&quot;形状&quot;一样的数据结构就好了</p>\\n<pre><code><pre class=\\"hljs\\"><code>(() =&gt; {\\n  class Person {\\n    constructor({\\n      firstname = \'\',\\n      lastname = \'\',\\n      spaceship = \'\',\\n      job = \'\',\\n      gender = \'\',\\n      retired = false\\n    } = {}) {\\n      Object.assign(this, {\\n        firstname,\\n        lastname,\\n        spaceship,\\n        job,\\n        gender,\\n        retired\\n      });\\n    }\\n  }\\n  const han = new Person({\\n    firstname: \'Han\',\\n    lastname: \'Solo\',\\n    spaceship: \'Falcon\'\\n  });\\n  const luke = new Person({\\n    firstname: \'Luke\',\\n    lastname: \'Skywalker\',\\n    job: \'Jedi\'\\n  });\\n  const leia = new Person({\\n    firstname: \'Leia\',\\n    lastname: \'Organa\',\\n    gender: \'female\'\\n  });\\n  const obi = new Person({\\n    firstname: \'Obi\',\\n    lastname: \'Wan\',\\n    retired: true\\n  });\\n  const yoda = new Person({ lastname: \'Yoda\' });\\n  const people = [\\n    han,\\n    luke,\\n    leia,\\n    obi,\\n    yoda,\\n    luke,\\n    leia,\\n    obi\\n  ];\\n  const getName = person =&gt; person.lastname;\\n  console.time(\'engine\');\\n  for (var i = 0; i &lt; 1000 * 1000 * 1000; i++) {\\n    getName(people[i &amp; 7]);\\n  }\\n  console.timeEnd(\'engine\');\\n})();</code></pre></code></pre><p>运行，消耗时间1.2s，任务完成！</p>\\n","toc":[{"anchor":"xian-xiang","level":4,"text":"现象"},{"anchor":"yuan-yin","level":4,"text":"原因"},{"anchor":"jie-jue","level":4,"text":"解决"}],"relatedTags":null,"created_at":"2018-09-08","timeArr":[2018,8,8,0,0,0,0],"title":"文章记录—为什么要知道js的引擎如何工作","uuid":"1ce699882ae4c19377061e00fa95e2bc41b3f185","summary":"<p>原文：[https://medium.freecodecamp.org/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553](https://medium.freecodecamp.org/javascript-ess...</p>","slug":"wen-zhang-ji-lu-wei-shen-mo-yao-zhi-dao-js-de-yin-qing-ru-he-gong-zuo","sha":"f6d88502864f6fa2ddb9fd4f3a6d78cbd5bc29c5"}')}}]);