(window.webpackJsonp=window.webpackJsonp||[]).push([[1245],{2043:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">edges</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">M</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">N</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> reachableNodes = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">edges, M, N</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> graph=<span class=\\"hljs-built_in\\">Array</span>(N).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>[])\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [v,w,dis] <span class=\\"hljs-keyword\\">of</span> edges){\\n    graph[v].push([w,dis+<span class=\\"hljs-number\\">1</span>])\\n    graph[w].push([v,dis+<span class=\\"hljs-number\\">1</span>])\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> minDist=<span class=\\"hljs-built_in\\">Array</span>(N).fill(<span class=\\"hljs-literal\\">Infinity</span>)\\n  minDist[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> arr=[<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> v=arr.shift()\\n      <span class=\\"hljs-keyword\\">let</span> adj=graph[v]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [w,dis] <span class=\\"hljs-keyword\\">of</span> adj){\\n        <span class=\\"hljs-keyword\\">if</span>(minDist[w]&gt;minDist[v]+dis){\\n          minDist[w]=minDist[v]+dis\\n          arr.push(w)\\n        }\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> result=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [v,w,dis] <span class=\\"hljs-keyword\\">of</span> edges){\\n    <span class=\\"hljs-keyword\\">let</span> left=<span class=\\"hljs-built_in\\">Math</span>.min(<span class=\\"hljs-built_in\\">Math</span>.max(M-minDist[v],<span class=\\"hljs-number\\">0</span>),dis),\\n        right=<span class=\\"hljs-built_in\\">Math</span>.min(<span class=\\"hljs-built_in\\">Math</span>.max(M-minDist[w],<span class=\\"hljs-number\\">0</span>),dis)\\n    result+=<span class=\\"hljs-built_in\\">Math</span>.min(left+right,dis)\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> dis <span class=\\"hljs-keyword\\">of</span> minDist){\\n    <span class=\\"hljs-keyword\\">if</span>(M&gt;=dis)result++\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> result \\n};\\n</code></pre>\\n"],"querySlug":"reachable-nodes-in-subdivided-graph","created_at":"2019-04-23","timeArr":[2019,3,23,1,20,16,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>首先构建<code>graph</code>，然后构建<code>minDis</code>，指的是从<code>0</code>到其他所有点的<strong>最短</strong>距离，计算<code>minDis</code>可以使用<code>Dijkstra</code>算法。</p>\\n<p>当算出所有最短距离后，要计算某一条边上的点哪些能通过，而一条边有两个顶点<code>v</code>和<code>w</code>；</p>\\n<p>因此可以计算出这条边被走过的距离就是<code>到v的最短距离后还剩下的步数 + 到w最短距离后还剩下的步数</code>，当然这个数不能超过这条边的长度。</p>\\n<p>最后，在计算哪些顶点是可以通过的，只要<code>到当前顶点的最短距离&lt;=M</code>，就是可以通过。</p>\\n","content":"<p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边细分为一条节点链，每条边之间的新节点数各不相同。</p>\\n\\n<p>图用由边组成的二维数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边细分后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p>\\n\\n<p>要细分边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和 <code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>+1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p>\\n\\n<p class=\\"MachineTrans-lang-zh-CN\\">现在得到一个新的 <strong>细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？节点 <strong>是否可以到达的判断条件</strong> 为：如果节点间距离是 <code>maxMoves</code> 或更少，则视为可以到达；否则，不可到达。</p>\\n\\n<p class=\\"MachineTrans-lang-zh-CN\\">给你原始图和 <code>maxMoves</code> ，返回新的细分图中从节点 <code>0</code> 出发<strong> 可到达的节点数 </strong>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\\" style=\\"width: 600px; height: 247px;\\" />\\n<pre>\\n<strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\\n<strong>输出：</strong>13\\n<strong>解释：</strong>边的细分情况如上图所示。\\n可以到达的节点已经用黄色标注出来。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\\n<strong>输出：</strong>23\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\\n<strong>输出：</strong>1\\n<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>0 <= edges.length <= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>\\n\\t<li><code>edges[i].length == 3</code></li>\\n\\t<li><code>0 <= u<sub>i</sub> < v<sub>i</sub> < n</code></li>\\n\\t<li>图中 <strong>不存在平行边</strong></li>\\n\\t<li><code>0 <= cnt<sub>i</sub> <= 10<sup>4</sup></code></li>\\n\\t<li><code>0 <= maxMoves <= 10<sup>9</sup></code></li>\\n\\t<li><code>1 <= n <= 3000</code></li>\\n</ul>\\n","title":"882. 细分图中的可到达结点","relatedTags":["图","最短路","堆（优先队列）"],"difficult":"Hard","lang":["javascript"],"uniqueID":"882","slug":"882-Reachable-Nodes-In-Subdivided-Graph"}')}}]);