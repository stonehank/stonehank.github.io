(window.webpackJsonp=window.webpackJsonp||[]).push([[450],{1248:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">grid</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> minCost = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">grid</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> m=grid.length\\n  <span class=\\"hljs-keyword\\">let</span> n=grid[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">if</span>(n===<span class=\\"hljs-number\\">1</span> &amp;&amp; m===<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> arr=[]\\n  <span class=\\"hljs-keyword\\">let</span> moves=[[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">-1</span>],[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>]]\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  arr.push([<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,grid[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">0</span>],<span class=\\"hljs-number\\">0</span>])\\n  <span class=\\"hljs-keyword\\">let</span> step=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> minStep=<span class=\\"hljs-literal\\">Infinity</span>\\n  <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-comment\\">// console.log(arr,noModifyDone,modifyDone)</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> [x,y,idx,step]=arr.shift()\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;moves.length;j++){\\n        <span class=\\"hljs-keyword\\">if</span>(j===idx<span class=\\"hljs-number\\">-1</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> [dx,dy]=moves[j]\\n        <span class=\\"hljs-keyword\\">let</span> nx=dx+x\\n        <span class=\\"hljs-keyword\\">let</span> ny=dy+y\\n        <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&lt;<span class=\\"hljs-number\\">0</span> || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">if</span>(hash[nx+<span class=\\"hljs-string\\">\' \'</span>+ny]!=<span class=\\"hljs-literal\\">null</span> &amp;&amp; hash[nx+<span class=\\"hljs-string\\">\' \'</span>+ny]&lt;=step+<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">if</span>(nx===m<span class=\\"hljs-number\\">-1</span> &amp;&amp; ny===n<span class=\\"hljs-number\\">-1</span>){\\n          minStep=<span class=\\"hljs-built_in\\">Math</span>.min(minStep,step+<span class=\\"hljs-number\\">1</span>)\\n        }\\n        hash[nx+<span class=\\"hljs-string\\">\' \'</span>+ny]=step+<span class=\\"hljs-number\\">1</span>\\n        <span class=\\"hljs-keyword\\">if</span>(step+<span class=\\"hljs-number\\">1</span>&lt;minStep)arr.push([nx,ny,grid[nx][ny],step+<span class=\\"hljs-number\\">1</span>])\\n      }        \\n      <span class=\\"hljs-keyword\\">let</span> [dx,dy]=moves[idx<span class=\\"hljs-number\\">-1</span>]\\n      <span class=\\"hljs-keyword\\">let</span> nx=dx+x\\n      <span class=\\"hljs-keyword\\">let</span> ny=dy+y\\n      <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&lt;<span class=\\"hljs-number\\">0</span> || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">if</span>(hash[nx+<span class=\\"hljs-string\\">\' \'</span>+ny]!=<span class=\\"hljs-literal\\">null</span> &amp;&amp; hash[nx+<span class=\\"hljs-string\\">\' \'</span>+ny]&lt;=step)<span class=\\"hljs-keyword\\">continue</span>\\n      hash[nx+<span class=\\"hljs-string\\">\' \'</span>+ny]=step\\n      <span class=\\"hljs-keyword\\">if</span>(nx===m<span class=\\"hljs-number\\">-1</span> &amp;&amp; ny===n<span class=\\"hljs-number\\">-1</span>){\\n        minStep=<span class=\\"hljs-built_in\\">Math</span>.min(minStep,step)\\n      }\\n      <span class=\\"hljs-keyword\\">if</span>(step&lt;minStep)arr.push([nx,ny,grid[nx][ny],step])\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> minStep\\n};\\n</code></pre>\\n"],"querySlug":"minimum-cost-to-make-at-least-one-valid-path-in-a-grid","created_at":"2020-03-01","timeArr":[2020,2,1,12,20,29,0],"hasThinking":false,"content":"<p>给你一个 m x n 的网格图&nbsp;<code>grid</code>&nbsp;。&nbsp;<code>grid</code>&nbsp;中每个格子都有一个数字，对应着从该格子出发下一步走的方向。&nbsp;<code>grid[i][j]</code>&nbsp;中的数字可能为以下几种情况：</p>\\n\\n<ul>\\n\\t<li><strong>1</strong>&nbsp;，下一步往右走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j + 1]</code></li>\\n\\t<li><strong>2</strong>&nbsp;，下一步往左走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j - 1]</code></li>\\n\\t<li><strong>3</strong>&nbsp;，下一步往下走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i + 1][j]</code></li>\\n\\t<li><strong>4</strong>&nbsp;，下一步往上走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i - 1][j]</code></li>\\n</ul>\\n\\n<p>注意网格图中可能会有&nbsp;<strong>无效数字</strong>&nbsp;，因为它们可能指向&nbsp;<code>grid</code>&nbsp;以外的区域。</p>\\n\\n<p>一开始，你会从最左上角的格子&nbsp;<code>(0,0)</code>&nbsp;出发。我们定义一条&nbsp;<strong>有效路径</strong>&nbsp;为从格子&nbsp;<code>(0,0)</code>&nbsp;出发，每一步都顺着数字对应方向走，最终在最右下角的格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;结束的路径。有效路径&nbsp;<strong>不需要是最短路径</strong>&nbsp;。</p>\\n\\n<p>你可以花费&nbsp;<code>cost = 1</code>&nbsp;的代价修改一个格子中的数字，但每个格子中的数字&nbsp;<strong>只能修改一次</strong>&nbsp;。</p>\\n\\n<p>请你返回让网格图至少有一条有效路径的最小代价。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png\\" style=\\"height: 528px; width: 542px;\\"></p>\\n\\n<pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\\n<strong>输出：</strong>3\\n<strong>解释：</strong>你将从点 (0, 0) 出发。\\n到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)\\n总花费为 cost = 3.\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png\\" style=\\"height: 408px; width: 419px;\\"></p>\\n\\n<pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]\\n<strong>输出：</strong>0\\n<strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png\\" style=\\"height: 302px; width: 314px;\\"></p>\\n\\n<pre><strong>输入：</strong>grid = [[1,2],[4,3]]\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]\\n<strong>输出：</strong>3\\n</pre>\\n\\n<p><strong>示例 5：</strong></p>\\n\\n<pre><strong>输入：</strong>grid = [[4]]\\n<strong>输出：</strong>0\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>m == grid.length</code></li>\\n\\t<li><code>n == grid[i].length</code></li>\\n\\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\\n</ul>\\n","title":"1368. 使网格图至少有一条有效路径的最小代价","relatedTags":["广度优先搜索","图","数组","矩阵","最短路","堆（优先队列）"],"difficult":"Hard","lang":["javascript"],"uniqueID":"1368","slug":"1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid"}')}}]);