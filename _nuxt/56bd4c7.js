(window.webpackJsonp=window.webpackJsonp||[]).push([[837],{1635:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">grid</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{Node}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> construct = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">grid</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> m=grid.length,n=grid[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">return</span> create(<span class=\\"hljs-number\\">0</span>,m,<span class=\\"hljs-number\\">0</span>,n)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">create</span>(<span class=\\"hljs-params\\">m1,m2,n1,n2</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(m2-m1===<span class=\\"hljs-number\\">1</span> &amp;&amp; n2-n1===<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> Node(!!grid[m1][n1],<span class=\\"hljs-literal\\">true</span>)\\n    <span class=\\"hljs-keyword\\">let</span> root=<span class=\\"hljs-keyword\\">new</span> Node(<span class=\\"hljs-string\\">\'*\'</span>,<span class=\\"hljs-literal\\">false</span>)\\n    <span class=\\"hljs-keyword\\">let</span> sections=[[<span class=\\"hljs-string\\">\'topLeft\'</span>,[m1,(m1+m2)/<span class=\\"hljs-number\\">2</span>],[n1,(n1+n2)/<span class=\\"hljs-number\\">2</span>]],\\n                  [<span class=\\"hljs-string\\">\'topRight\'</span>,[m1,(m1+m2)/<span class=\\"hljs-number\\">2</span>],[(n1+n2)/<span class=\\"hljs-number\\">2</span>,n2]],\\n                  [<span class=\\"hljs-string\\">\'bottomLeft\'</span>,[(m1+m2)/<span class=\\"hljs-number\\">2</span>,m2],[n1,(n1+n2)/<span class=\\"hljs-number\\">2</span>]],\\n                  [<span class=\\"hljs-string\\">\'bottomRight\'</span>,[(m1+m2)/<span class=\\"hljs-number\\">2</span>,m2],[(n1+n2)/<span class=\\"hljs-number\\">2</span>,n2]]]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [prop,[x1,x2],[y1,y2]] <span class=\\"hljs-keyword\\">of</span> sections){\\n      root[prop]=create(x1,x2,y1,y2)\\n    }    \\n    <span class=\\"hljs-keyword\\">if</span>(root.topLeft.val!==<span class=\\"hljs-string\\">\'*\'</span> &amp;&amp; \\n       root.topLeft.val===root.topRight.val &amp;&amp;\\n       root.topLeft.val===root.bottomLeft.val &amp;&amp;\\n       root.topLeft.val===root.bottomRight.val){\\n      root.val=root.topLeft.val\\n      root.isLeaf=<span class=\\"hljs-literal\\">true</span>\\n      root.topLeft=<span class=\\"hljs-literal\\">null</span>\\n      root.topRight=<span class=\\"hljs-literal\\">null</span>\\n      root.bottomLeft=<span class=\\"hljs-literal\\">null</span>\\n      root.bottomRight=<span class=\\"hljs-literal\\">null</span>\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> root\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"construct-quad-tree","created_at":"2019-04-25","timeArr":[2019,3,25,23,47,49,0],"hasThinking":false,"content":"<p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p>\\n\\n<p>你需要返回能表示矩阵的 四叉树 的根结点。</p>\\n\\n<p>注意，当 <code>isLeaf</code> 为 <strong>False </strong>时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</p>\\n\\n<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>\\n\\n<ul>\\n\\t<li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>；</li>\\n\\t<li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li>\\n</ul>\\n\\n<pre>class Node {\\n    public boolean val;\\n&nbsp; &nbsp; public boolean isLeaf;\\n&nbsp; &nbsp; public Node topLeft;\\n&nbsp; &nbsp; public Node topRight;\\n&nbsp; &nbsp; public Node bottomLeft;\\n&nbsp; &nbsp; public Node bottomRight;\\n}</pre>\\n\\n<p>我们可以按以下步骤为二维区域构建四叉树：</p>\\n\\n<ol>\\n\\t<li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>\\n\\t<li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>\\n\\t<li>使用适当的子网格递归每个子节点。</li>\\n</ol>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\\" style=\\"height: 181px; width: 777px;\\"></p>\\n\\n<p>如果你想了解更多关于四叉树的内容，可以参考 <a href=\\"https://en.wikipedia.org/wiki/Quadtree\\">wiki</a> 。</p>\\n\\n<p><strong>四叉树格式：</strong></p>\\n\\n<p>输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p>\\n\\n<p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p>\\n\\n<p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表&nbsp;<code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0 </strong>。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/11/grid1.png\\" style=\\"height: 99px; width: 777px;\\"></p>\\n\\n<pre><strong>输入：</strong>grid = [[0,1],[1,0]]\\n<strong>输出：</strong>[[0,1],[1,0],[1,1],[1,1],[1,0]]\\n<strong>解释：</strong>此示例的解释如下：\\n请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/12/e1tree.png\\" style=\\"height: 186px; width: 777px;\\">\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/12/e2mat.png\\" style=\\"height: 343px; width: 777px;\\"></p>\\n\\n<pre><strong>输入：</strong>grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\\n<strong>输出：</strong>[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\\n<strong>解释：</strong>网格中的所有值都不相同。我们将网格划分为四个子网格。\\ntopLeft，bottomLeft 和 bottomRight 均具有相同的值。\\ntopRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。\\n解释如下图所示：\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/12/e2tree.png\\" style=\\"height: 328px; width: 777px;\\">\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>grid = [[1,1],[1,1]]\\n<strong>输出：</strong>[[1,1]]\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre><strong>输入：</strong>grid = [[0]]\\n<strong>输出：</strong>[[1,0]]\\n</pre>\\n\\n<p><strong>示例 5：</strong></p>\\n\\n<pre><strong>输入：</strong>grid = [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]\\n<strong>输出：</strong>[[0,1],[1,1],[1,0],[1,0],[1,1]]\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li><code>n == grid.length == grid[i].length</code></li>\\n\\t<li><code>n == 2^x</code> 其中 <code>0 &lt;= x &lt;= 6</code></li>\\n</ol>\\n","title":"427. 建立四叉树","relatedTags":["树","数组","分治","矩阵"],"difficult":"Middle","lang":["javascript"],"uniqueID":"427","slug":"427-Construct-Quad-Tree"}')}}]);