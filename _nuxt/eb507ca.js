(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{634:function(n){n.exports=JSON.parse('{"content":"<h3 id=\\"xie-zai-zui-qian\\">写在最前</h3>\\n<p>最近项目有个需求，获取函数参数名，听起来很简单，但有了ES6，参数和函数写法千奇百怪，在github上大概看了几个库，基本上都是正则，\\n对通用的写法能够覆盖，稍微越过边界，往往无法正确匹配。</p>\\n<p>于是就有了使用<code>AST</code>去进行覆盖查找的想法。</p>\\n<h3 id=\\"gai-nian\\">概念</h3>\\n<p>抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。</p>\\n<hr>\\n<h3 id=\\"wei-shen-mo-yao-yong-ast\\">为什么要用AST</h3>\\n<p>通过AST，我们可以对代码进行查找，看起来好像正则表达式也可以做到，那么为什么要用AST而不用正则？</p>\\n<p>就说从函数获取参数名，夸张点，如果有以下表达式：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">x</span>(<span class=\\"hljs-params\\">a=<span class=\\"hljs-number\\">5</span>,b=<span class=\\"hljs-string\\">\\"a\\"</span>,c=function(x=<span class=\\"hljs-number\\">1</span>,y</span>)</span>{<span class=\\"hljs-built_in\\">console</span>.log(x=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">i=<span class=\\"hljs-number\\">8</span>,j</span>)</span>{})},d={<span class=\\"hljs-attr\\">x</span>:<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-attr\\">y</span>:<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-attr\\">z</span>:<span class=\\"hljs-string\\">\'x=6\'</span>},e=<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span>=&gt;</span><span class=\\"hljs-number\\">7</span>,f=[<span class=\\"hljs-string\\">\'3=5\'</span>,<span class=\\"hljs-string\\">\'x.1\'</span>,<span class=\\"hljs-string\\">\'y,2\'</span>,<span class=\\"hljs-number\\">1</span>],g=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">x,y</span>)=&gt;</span>{<span class=\\"hljs-keyword\\">let</span> z=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">i,j=<span class=\\"hljs-number\\">6</span></span>)=&gt;</span>{}},h){}</code></pre></code></pre>\\n<p><code>参数是[a,b,c,d,e,f,g,h]</code></p>\\n<p>你确定还想用正则去匹配参数名称吗...</p>\\n<blockquote>\\n<p>AST是从代码的意义去编辑，而正则只能从代码的字面去编辑。</p>\\n</blockquote>\\n<p>以上夸张的函数，使用AST去分析，可以很轻松获取它的参数名。</p>\\n<hr>\\n<h3 id=\\"esprima\\">Esprima</h3>\\n<p>我们使用<a href=\\"http://esprima.org/demo/parse.html#\\">esprima</a>，一个可以将Javascript代码解析成抽象树的库。</p>\\n<p>首先我们需要安装它：</p>\\n<p><code>npm install esprima</code></p>\\n<p>接着调用：</p>\\n<p><code>const esprima=require(&#39;require&#39;&#39;)</code></p>\\n<p>接下来就是分析的时候了。</p>\\n<hr>\\n<h3 id=\\"yi-ge-jian-dan-de-ast-li-zi\\">一个简单的AST例子</h3>\\n<p>先来个简单的例子：\\n<code>function a(b){}</code></p>\\n<p>通过esprima解析后，生成结构图如下：</p>\\n<pre><code><pre class=\\"hljs\\"><code>{\\n    &quot;type&quot;: &quot;Program&quot;,\\n    &quot;body&quot;: [\\n        {   // 这个type表示这是一个函数表达式\\n            &quot;type&quot;: &quot;FunctionDeclaration&quot;,\\n            &quot;id&quot;: {\\n                &quot;type&quot;: &quot;Identifier&quot;,\\n                &quot;name&quot;: &quot;a&quot;\\n            },\\n            &quot;params&quot;: [\\n                {\\n                    // 参数数组内的Identifier代表参数\\n                    &quot;type&quot;: &quot;Identifier&quot;,\\n                    &quot;name&quot;: &quot;b&quot;\\n                }\\n            ],\\n            &quot;body&quot;: {\\n                &quot;type&quot;: &quot;BlockStatement&quot;,\\n                &quot;body&quot;: []\\n            },\\n            &quot;generator&quot;: false,\\n            &quot;expression&quot;: false,\\n            &quot;async&quot;: false\\n        }\\n    ],\\n    &quot;sourceType&quot;: &quot;script&quot;\\n}</code></pre></code></pre><p>思路：</p>\\n<ol>\\n<li><code>FunctionDeclaration</code>说明是一个函数表达式，进入<code>params</code>属性。</li>\\n<li>判断<code>params</code>中每一个的type是否为<code>Identifier</code>，在<code>params</code>属性下的<code>Identifier</code>就代表是参数。</li>\\n<li>找出name属性的值，结果为<code>[&#39;b&#39;]</code>。</li>\\n</ol>\\n<p>根据以上思路，我们可以写出一个简单的获取参数的方法了。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getParams</span>(<span class=\\"hljs-params\\">fn</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 此处分析的代码必须是字符串</span>\\n  <span class=\\"hljs-keyword\\">let</span> astEsprima=esprima.parseScript(fn.toString())\\n  <span class=\\"hljs-keyword\\">let</span> funcParams = []\\n  <span class=\\"hljs-keyword\\">let</span> node = astEsprima.body[<span class=\\"hljs-number\\">0</span>]\\n  <span class=\\"hljs-comment\\">// 找到type，进入params属性</span>\\n  <span class=\\"hljs-keyword\\">if</span> (node.type === <span class=\\"hljs-string\\">\\"FunctionDeclaration\\"</span>) funcParams = node.params\\n  <span class=\\"hljs-keyword\\">let</span> validParam=[]\\n  funcParams.forEach(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">obj</span>=&gt;</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(obj.type===<span class=\\"hljs-string\\">\\"Identifier\\"</span>)\\n      validParam.push(obj.name)\\n  })\\n  <span class=\\"hljs-keyword\\">return</span> validParam\\n}</code></pre></code></pre>\\n<p>测试一番，获取结果<code>[&quot;b&quot;]</code>，庆祝收工。</p>\\n<p>好吧，别高兴太早了，要知道函数的创建方法不下10种，而参数写法又有好几种...</p>\\n<p>以下是一部分的函数创建方法和参数写法</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">a</span>(<span class=\\"hljs-params\\">x</span>)</span>{}\\n\\n<span class=\\"hljs-comment\\">// 注意：第二条和第三条在AST中意义不同</span>\\n<span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x=<span class=\\"hljs-number\\">1</span></span>)</span>{}\\n\\na=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">...x</span>)</span>{}\\n\\n<span class=\\"hljs-keyword\\">let</span> a=<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">[x]=[<span class=\\"hljs-number\\">1</span>]</span>)=&gt;</span>{}\\n\\n<span class=\\"hljs-keyword\\">async</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">a</span>(<span class=\\"hljs-params\\">x</span>)</span>{}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> *<span class=\\"hljs-title\\">a</span>(<span class=\\"hljs-params\\">x</span>)</span>{}\\n\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">a</span></span>{\\n<span class=\\"hljs-keyword\\">constructor</span>(x){}\\n}\\n\\n<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Function</span> (<span class=\\"hljs-string\\">\'x\'</span>,<span class=\\"hljs-string\\">\'console.log(x)\'</span>)\\n\\n(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x</span>)</span>{}})()\\n\\n<span class=\\"hljs-built_in\\">eval</span>(<span class=\\"hljs-string\\">\\"(function(){return function(a,b){}})()\\"</span>)</code></pre></code></pre>\\n<p>有什么想法？如果你有发出&quot;我K&quot;的想法，那说明我这个装逼还算成功- -...</p>\\n<p>其实只需要分几种情况(很多写法的type都是一致的)，就可以完全渗入到以上所有的参数对象内部，再进行参数获取就是循环+判断解决的事了。</p>\\n<p>由于篇幅问题，这里不一一分析，只是将AST分析树所用的type和一些注意点。</p>\\n<h3 id=\\"han-shu-jie-gou\\">函数结构</h3>\\n<h4 id=\\"bian-liang-sheng-ming-yu-ju-he-biao-da-shi-yu-ju\\">变量声明语句和表达式语句</h4>\\n<p>上面注释中<code>let a=function(x=1){}</code>和<code>a=function(...x){}</code>是两种意义。</p>\\n<p>其中<code>let a=function(x=1){}</code>指的是变量声明语句，</p>\\n<p>对应的type是<code>VariableDeclaration</code>，需要进入它的初始值<code>init</code>就可以获取到函数所在的语法对象，它的type是<code>FunctionExpression</code>函数表达式，再去<code>params</code>中查找即可。</p>\\n<p>变量声明语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──VariableDeclaration....init\\n        ├──FunctionExpression.params</code></pre></code></pre><p>而<code>a=function(...x){}</code>是表达式语句，</p>\\n<p>对应的type是<code>ExpressionStatement</code>，需要进入它的表达式<code>expression</code>获取到表达式内部，这时我们要进入赋值表达式(<code>type为AssignmentExpression</code>)的右边(<code>right属性</code>)，\\n获取函数所在的语法对象，它的type同样也是<code>FunctionExpression</code>函数表达式。</p>\\n<p>表达式语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──ExpressionStatement.expression\\n        ├──AssignmentExpression.right\\n                ├──FunctionExpression.params</code></pre></code></pre><h4 id=\\"class-sheng-ming-he-function-gou-zao-han-shu\\">class声明和Function构造函数</h4>\\n<p>class声明对应的type有<code>ClassDeclaration</code>(class xx{...})或者<code>ClassExpression</code>(let x=class{...})，他们一个是声明一个是表达式，处理方式是相同的，\\n进入对象内部，找到kind为<code>constructor</code>的对象，获取参数数据。</p>\\n<p>class声明语句：</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──ClassDeclaration...body...\\n        ├──{kind:constructor}\\n                ├──FunctionExpression.params</code></pre></code></pre><p>Function构造函数对应的type是<code>NewExpression</code>或者<code>ClassExpression</code>，参数在属性<code>arguments</code>内部，但是Function的参数都是字符串，\\n而且最后一个参数一定是函数内部语句，因此对于Function构造函数，就是对字符串进行处理。</p>\\n<p>Function构造函数</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──NewExpression.arguments\\n        ├──{value:&lt;String&gt;}\\n         ----&gt;对字符串进行处理，分割参数</code></pre></code></pre><h4 id=\\"jian-tou-han-shu\\">箭头函数</h4>\\n<p>箭头函数type是<code>ArrowFunctionExpression</code>，也仅仅是名称不同，内部结构几乎一致。</p>\\n<p>函数结构的type就到此。</p>\\n<h3 id=\\"can-shu-jie-gou\\">参数结构</h3>\\n<p>参数的type有以下：</p>\\n<p><code>Identifier</code>：最终我们需要获取的参数值的type</p>\\n<p><code>Property</code>：当存在解构参数，例如<code>[a,b] or {x,y}</code></p>\\n<p><code>ArrayPattern</code>：存在解构参数并且是数组，例如<code>[a,b]</code></p>\\n<p><code>ObjectPattern</code>：存在解构参数并且是对象，例如<code>{x,y}</code></p>\\n<p><code>RestElement</code>：存在扩展运算符，例如<code>(...args)</code></p>\\n<p>我们只需要设置一个递归循环，思路和上面一样，一层进入另一层，在内部进行查找。</p>\\n<h3 id=\\"zong-jie\\">总结</h3>\\n<p>篇幅有限，就写这么多，接着做一个总结。</p>\\n<p>这篇讲的主旨只有1个，通过对AST树中每一个对象的type分析，type表示的是对应的代码的意义，也是代码的语义，例如</p>\\n<p><code>VariableDeclaration</code>内部一定会有<code>init</code>，为什么，因为变量声明是有初始值的，如果你不设置，那么就为<code>undefined</code></p>\\n<p>type远不止这次说的这么多，官网(或者Google)上有详细介绍。</p>\\n<hr>\\n<h3 id=\\"zui-hou\\">最后</h3>\\n<p><a href=\\"https://github.com/stonehank/get-function-params-with-ast\\"><code>AST获取函数参数</code>源代码在此</a>。</p>\\n<p>如果本文对你有所帮助，欢迎STAR，或者你对此有什么更好的想法，欢迎留言！</p>\\n<p>最重要如果发现了BUG或者漏匹配，请一定要告知(Issue/PR/留言)，感激不尽！</p>\\n","toc":[{"anchor":"xie-zai-zui-qian","level":3,"text":"写在最前"},{"anchor":"gai-nian","level":3,"text":"概念"},{"anchor":"wei-shen-mo-yao-yong-ast","level":3,"text":"为什么要用AST"},{"anchor":"esprima","level":3,"text":"Esprima"},{"anchor":"yi-ge-jian-dan-de-ast-li-zi","level":3,"text":"一个简单的AST例子"},{"anchor":"han-shu-jie-gou","level":3,"text":"函数结构"},{"anchor":"bian-liang-sheng-ming-yu-ju-he-biao-da-shi-yu-ju","level":4,"text":"变量声明语句和表达式语句"},{"anchor":"class-sheng-ming-he-function-gou-zao-han-shu","level":4,"text":"class声明和Function构造函数"},{"anchor":"jian-tou-han-shu","level":4,"text":"箭头函数"},{"anchor":"can-shu-jie-gou","level":3,"text":"参数结构"},{"anchor":"zong-jie","level":3,"text":"总结"},{"anchor":"zui-hou","level":3,"text":"最后"}],"relatedTags":null,"created_at":"2018-09-18","timeArr":[2018,8,18,0,0,0,0],"title":"如何通过AST树去获取函数参数名","uuid":"ddc3d1d8d6334cc464eb634a0d813d48c0d48776","summary":"<h4>写在最前</h4>\\n<p>最近项目有个需求，获取函数参数名，听起来很简单，但有了ES6，参数和函数写法千奇百怪，在github上大概看了几个库，基本上都是正则，\\n对通用的写法能够覆盖，稍微越过边界，往往无法正确匹配。</p>\\n<p>于是就有了使用<code>AST</code>去进行覆盖查找的想法。</p>\\n<h4>概念</h4>\\n<p>抽象语法树（abstract synta...</p>","slug":"ru-he-tong-guo-AST-shu-qu-huo-qu-han-shu-can-shu-ming","sha":"a7854a9c9c9dd7722bb525311af632ee5752fe47"}')}}]);