(window.webpackJsonp=window.webpackJsonp||[]).push([[1317],{2115:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">stones</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> removeStones = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">stones</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> N=stones.length, count=N\\n  <span class=\\"hljs-keyword\\">let</span> uf=<span class=\\"hljs-built_in\\">Array</span>(N).fill().map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">n,i</span>)=&gt;</span>i),\\n      weight=<span class=\\"hljs-built_in\\">Array</span>(N).fill(<span class=\\"hljs-number\\">1</span>)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">find</span>(<span class=\\"hljs-params\\">i</span>)</span>{\\n    <span class=\\"hljs-keyword\\">while</span>(i!==uf[i]){\\n      i=uf[i]\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> i\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">union</span>(<span class=\\"hljs-params\\">a,b</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> i=find(a),\\n        j=find(b)\\n    <span class=\\"hljs-keyword\\">if</span>(i===j)<span class=\\"hljs-keyword\\">return</span> \\n    <span class=\\"hljs-keyword\\">if</span>(weight[i]&lt;weight[j]){\\n      uf[i]=j\\n      weight[j]+=weight[i]\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      uf[j]=i\\n      weight[i]+=weight[j]\\n    }\\n    count--\\n  }\\n  \\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;stones.length<span class=\\"hljs-number\\">-1</span>;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [x1,y1]=stones[i]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=i+<span class=\\"hljs-number\\">1</span>;j&lt;stones.length;j++){\\n      <span class=\\"hljs-keyword\\">let</span> [x2,y2]=stones[j]\\n      <span class=\\"hljs-keyword\\">if</span>(x1===x2 || y1===y2){\\n        union(i,j)\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> N-count\\n};\\n</code></pre>\\n"],"querySlug":"most-stones-removed-with-same-row-or-column","created_at":"2019-04-11","timeArr":[2019,3,11,12,55,54,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>题目翻译的不太好，其实意思是这样的，<code>move</code>操作可以删除<code>1</code>个石头，条件是这个石头它所在的行或者列还有另一块石头，也就是说，\\n如果一块石头，它所在的行和列都没有其他石头了，它是不可以执行<code>move</code>操作的。</p>\\n<p>搞懂题意，就知道这是要求出连通分量<code>count</code>，两个石头只要它们的<code>x1===x2 || y1===y2</code>，就可以连通。</p>\\n<p>最后返回<code>stones.length-count</code>。</p>\\n","content":"<p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>\\n\\n<p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>\\n\\n<p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\n<strong>输出：</strong>5\\n<strong>解释：</strong>一种移除 5 块石头的方法如下所示：\\n1. 移除石头 [2,2] ，因为它和 [2,1] 同行。\\n2. 移除石头 [2,1] ，因为它和 [0,1] 同列。\\n3. 移除石头 [1,2] ，因为它和 [1,0] 同行。\\n4. 移除石头 [1,0] ，因为它和 [0,0] 同列。\\n5. 移除石头 [0,1] ，因为它和 [0,0] 同行。\\n石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\n<strong>输出：</strong>3\\n<strong>解释：</strong>一种移除 3 块石头的方法如下所示：\\n1. 移除石头 [2,2] ，因为它和 [2,0] 同行。\\n2. 移除石头 [2,0] ，因为它和 [0,0] 同列。\\n3. 移除石头 [0,2] ，因为它和 [0,0] 同行。\\n石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>stones = [[0,0]]\\n<strong>输出：</strong>0\\n<strong>解释：</strong>[0,0] 是平面上唯一一块石头，所以不可以移除它。</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= stones.length <= 1000</code></li>\\n\\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup></code></li>\\n\\t<li>不会有两块石头放在同一个坐标点上</li>\\n</ul>\\n","title":"947. 移除最多的同行或同列石头","relatedTags":["深度优先搜索","并查集","图"],"difficult":"Middle","lang":["javascript"],"uniqueID":"947","slug":"947-Most-Stones-Removed-with-Same-Row-or-Column"}')}}]);