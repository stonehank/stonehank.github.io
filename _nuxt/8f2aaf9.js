(window.webpackJsonp=window.webpackJsonp||[]).push([[737],{1535:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{void}</span> </span>Do not return anything, modify nums in-place instead.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> nextPermutation = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">swap</span>(<span class=\\"hljs-params\\">arr,i,j</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> t=arr[i]\\n    arr[i]=arr[j]\\n    arr[j]=t\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=nums.length<span class=\\"hljs-number\\">-2</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=i;k&lt;nums.length<span class=\\"hljs-number\\">-1</span>;k++){\\n      <span class=\\"hljs-keyword\\">if</span>(nums[i]&lt;nums[k+<span class=\\"hljs-number\\">1</span>]){\\n        <span class=\\"hljs-keyword\\">return</span> swap(nums,i,k+<span class=\\"hljs-number\\">1</span>)\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=i;k&lt;nums.length<span class=\\"hljs-number\\">-1</span>;k++){\\n      swap(nums,k,k+<span class=\\"hljs-number\\">1</span>)\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"next-permutation","created_at":"2019-03-11","timeArr":[2019,2,11,15,9,8,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>从最低位开始找(倒序遍历)；</p>\\n<ol>\\n<li>\\n<p>如果当前<code>nums[i]</code>的后面存在一个数<code>nums[k]&gt;nums[i]</code>，那么交换<code>i</code>和<code>k</code>就是当前下一个的排列。</p>\\n</li>\\n<li>\\n<p>如果不能存在这个数，那么说明<code>nums[i]</code>比它后面所有的数都大，要将它放到最末尾，通过插入排序的方法，将它与后面一个个交换直到末尾。</p>\\n</li>\\n</ol>\\n<p>也就是说，对于<code>nums[i]</code>，它后面的是一个递增序列，递增序列才能保证存在<code>条件1</code>的数<code>nums[k]</code>是一个比<code>nums[i]</code>大的最小值。</p>\\n","content":"<p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>\\n\\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\\n\\n<p>必须<strong><a href=\\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\\" target=\\"_blank\\"> 原地 </a></strong>修改，只允许使用额外常数空间。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [1,2,3]\\n<strong>输出：</strong>[1,3,2]\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [3,2,1]\\n<strong>输出：</strong>[1,2,3]\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [1,1,5]\\n<strong>输出：</strong>[1,5,1]\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [1]\\n<strong>输出：</strong>[1]\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\\n\\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\\n</ul>\\n","title":"31. 下一个排列","relatedTags":["数组","双指针"],"difficult":"Middle","lang":["javascript"],"uniqueID":"31","slug":"31-Next-Permutation"}')}}]);