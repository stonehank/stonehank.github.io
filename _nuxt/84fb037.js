(window.webpackJsonp=window.webpackJsonp||[]).push([[455],{1253:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">edges</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">t</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">target</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> frogPosition = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">n, edges, t, target</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> graph=<span class=\\"hljs-built_in\\">Array</span>(n+<span class=\\"hljs-number\\">1</span>).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>[])\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;edges.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [<span class=\\"hljs-keyword\\">from</span>,to]=edges[i]\\n    graph[<span class=\\"hljs-keyword\\">from</span>].push(to)\\n    graph[to].push(<span class=\\"hljs-keyword\\">from</span>)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> used=<span class=\\"hljs-built_in\\">Array</span>(n+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-literal\\">false</span>)\\n  used[<span class=\\"hljs-number\\">1</span>]=<span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">let</span> arr=[[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">1</span>]]\\n  <span class=\\"hljs-keyword\\">let</span> step=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">let</span> p=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">while</span>(step&lt;=t){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-comment\\">// console.log(arr)</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> [idx,percent]=arr.shift()\\n      <span class=\\"hljs-keyword\\">let</span> subList=graph[idx]\\n      <span class=\\"hljs-keyword\\">if</span>(subList){\\n        <span class=\\"hljs-keyword\\">let</span> validList=[]\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;subList.length;j++){\\n          <span class=\\"hljs-keyword\\">if</span>(used[subList[j]])<span class=\\"hljs-keyword\\">continue</span>\\n          used[subList[j]]=<span class=\\"hljs-literal\\">true</span>\\n          validList.push(subList[j])\\n        }\\n        <span class=\\"hljs-keyword\\">if</span>(validList.length===<span class=\\"hljs-number\\">0</span> &amp;&amp; idx===target)<span class=\\"hljs-keyword\\">return</span> percent\\n    \\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;validList.length;j++){\\n          <span class=\\"hljs-keyword\\">let</span> newPercent=percent/validList.length\\n          <span class=\\"hljs-keyword\\">if</span>(t===step &amp;&amp; validList[j]===target)<span class=\\"hljs-keyword\\">return</span> newPercent\\n          arr.push([validList[j],newPercent])\\n        }\\n      }\\n    }\\n    step++\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n};\\n</code></pre>\\n"],"querySlug":"frog-position-after-t-seconds","created_at":"2020-03-08","timeArr":[2020,2,8,11,44,24,0],"hasThinking":false,"content":"<p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>\\n\\n<ul>\\n\\t<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>\\n\\t<li>青蛙无法跳回已经访问过的顶点。</li>\\n\\t<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>\\n\\t<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>\\n</ul>\\n\\n<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 意味着存在一条直接连通 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 两个顶点的边。</p>\\n\\n<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/08/frog_2.png\\" style=\\"height: 236px; width: 350px;\\"></p>\\n\\n<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\\n<strong>输出：</strong>0.16666666666666666 \\n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 \\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/08/frog_3.png\\" style=\\"height: 236px; width: 350px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\\n<strong>输出：</strong>0.3333333333333333\\n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 \\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6\\n<strong>输出：</strong>0.16666666666666666\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 100</code></li>\\n\\t<li><code>edges.length == n-1</code></li>\\n\\t<li><code>edges[i].length == 2</code></li>\\n\\t<li><code>1 &lt;= edges[i][0], edges[i][1] &lt;= n</code></li>\\n\\t<li><code>1 &lt;= t&nbsp;&lt;= 50</code></li>\\n\\t<li><code>1 &lt;= target&nbsp;&lt;= n</code></li>\\n\\t<li>与准确值误差在 <code>10^-5</code> 之内的结果将被判定为正确。</li>\\n</ul>\\n","title":"1377. T 秒后青蛙的位置","relatedTags":["树","深度优先搜索","广度优先搜索","图"],"difficult":"Hard","lang":["javascript"],"uniqueID":"1377","slug":"1377-Frog-Position-After-T-Seconds"}')}}]);