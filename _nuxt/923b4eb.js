(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{1005:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">stones</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">K</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> mergeStones = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">stones, K</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> N=stones.length\\n  <span class=\\"hljs-keyword\\">if</span>((N<span class=\\"hljs-number\\">-1</span>) % (K<span class=\\"hljs-number\\">-1</span>)!==<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-keyword\\">let</span> dp=<span class=\\"hljs-built_in\\">Array</span>(N).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(N).fill(<span class=\\"hljs-number\\">0</span>))\\n  <span class=\\"hljs-keyword\\">let</span> prefix=<span class=\\"hljs-built_in\\">Array</span>(N+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;N;i++){\\n    prefix[i+<span class=\\"hljs-number\\">1</span>]=prefix[i]+stones[i]\\n  }\\n  \\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=K<span class=\\"hljs-number\\">-1</span>;i&lt;N;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;N-i;j++){\\n      <span class=\\"hljs-keyword\\">let</span> k=i+j\\n      dp[j][k]=<span class=\\"hljs-literal\\">Infinity</span>\\n      <span class=\\"hljs-comment\\">// console.log(j,k,\'----\')</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> l=j;l&lt;k;l+=K<span class=\\"hljs-number\\">-1</span>){\\n        dp[j][k] = <span class=\\"hljs-built_in\\">Math</span>.min(dp[j][k], dp[j][l] + dp[l + <span class=\\"hljs-number\\">1</span>][k]);\\n        <span class=\\"hljs-comment\\">// console.log(dp[j][k])</span>\\n      }\\n      <span class=\\"hljs-keyword\\">if</span>((k-j) % (K<span class=\\"hljs-number\\">-1</span>)===<span class=\\"hljs-number\\">0</span>){\\n        dp[j][k]+=prefix[k+<span class=\\"hljs-number\\">1</span>]-prefix[j]\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// console.log(dp)</span>\\n  <span class=\\"hljs-keyword\\">return</span> dp[<span class=\\"hljs-number\\">0</span>][N<span class=\\"hljs-number\\">-1</span>]\\n};\\n</code></pre>\\n","<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">mergeStones</span><span class=\\"hljs-params\\">(self, stones, K)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type stones: List[int]\\n        :type K: int\\n        :rtype: int\\n        \\"\\"\\"</span>\\n        N=len(stones)\\n        sums=[<span class=\\"hljs-number\\">0</span>]*(N+<span class=\\"hljs-number\\">1</span>)\\n        memo={}\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(N):\\n          sums[i+<span class=\\"hljs-number\\">1</span>]=sums[i]+stones[i]\\n        <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">dp</span><span class=\\"hljs-params\\">(i,j,m)</span>:</span>\\n          <span class=\\"hljs-keyword\\">if</span> i==j:\\n            <span class=\\"hljs-keyword\\">if</span> m==<span class=\\"hljs-number\\">1</span>:<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n            <span class=\\"hljs-keyword\\">return</span> float(<span class=\\"hljs-string\\">\'inf\'</span>)\\n          <span class=\\"hljs-keyword\\">if</span> m==<span class=\\"hljs-number\\">1</span>:\\n            <span class=\\"hljs-keyword\\">return</span> dp(i,j,K)+sums[j+<span class=\\"hljs-number\\">1</span>]-sums[i]\\n          <span class=\\"hljs-keyword\\">if</span> (i, j, m) <span class=\\"hljs-keyword\\">in</span> memo:\\n            <span class=\\"hljs-keyword\\">return</span> memo[i, j, m]\\n          res=float(<span class=\\"hljs-string\\">\'inf\'</span>)\\n          <span class=\\"hljs-keyword\\">for</span> mid <span class=\\"hljs-keyword\\">in</span> range(i,j,K<span class=\\"hljs-number\\">-1</span>):\\n            res=min(res,dp(i,mid,<span class=\\"hljs-number\\">1</span>)+dp(mid+<span class=\\"hljs-number\\">1</span>,j,m<span class=\\"hljs-number\\">-1</span>))\\n          memo[i, j, m] = res\\n          <span class=\\"hljs-keyword\\">return</span> res\\n        res=dp(<span class=\\"hljs-number\\">0</span>,N<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">1</span>)\\n        <span class=\\"hljs-keyword\\">if</span> res==float(<span class=\\"hljs-string\\">\'inf\'</span>):<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n        <span class=\\"hljs-keyword\\">return</span> res\\n</code></pre>\\n"],"querySlug":"minimum-cost-to-merge-stones","hasThinking":false,"content":"<p>有 <code>N</code> 堆石头排成一排，第 <code>i</code> 堆中有&nbsp;<code>stones[i]</code>&nbsp;块石头。</p>\\n\\n<p>每次<em>移动（move）</em>需要将<strong>连续的</strong>&nbsp;<code>K</code>&nbsp;堆石头合并为一堆，而这个移动的成本为这&nbsp;<code>K</code>&nbsp;堆石头的总数。</p>\\n\\n<p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 <code>-1</code> 。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>stones = [3,2,4,1], K = 2\\n<strong>输出：</strong>20\\n<strong>解释：</strong>\\n从 [3, 2, 4, 1] 开始。\\n合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。\\n合并 [4, 1]，成本为 5，剩下 [5, 5]。\\n合并 [5, 5]，成本为 10，剩下 [10]。\\n总成本 20，这是可能的最小值。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>stones = [3,2,4,1], K = 3\\n<strong>输出：</strong>-1\\n<strong>解释：</strong>任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>stones = [3,5,1,2,6], K = 3\\n<strong>输出：</strong>25\\n<strong>解释：</strong>\\n从 [3, 5, 1, 2, 6] 开始。\\n合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。\\n合并 [3, 8, 6]，成本为 17，剩下 [17]。\\n总成本 25，这是可能的最小值。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= stones.length &lt;= 30</code></li>\\n\\t<li><code>2 &lt;= K &lt;= 30</code></li>\\n\\t<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\\n</ul>\\n","title":"1000. 合并石头的最低成本","relatedTags":["数组","动态规划"],"difficult":"Hard","lang":["javascript","python"],"uniqueID":"1000","slug":"1000-Minimum-Cost-to-Merge-Stones"}')}}]);