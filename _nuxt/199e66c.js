(window.webpackJsonp=window.webpackJsonp||[]).push([[232],{1030:function(o){o.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">queries</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">pattern</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> camelMatch = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">queries, pattern</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> res=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;queries.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> word=queries[i],k=<span class=\\"hljs-number\\">0</span>,valid=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;word.length;j++){\\n      <span class=\\"hljs-keyword\\">if</span>(k&lt;pattern.length &amp;&amp; word[j]===pattern[k]){\\n        k++\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-regexp\\">/[A-Z]/</span>.test(word[j])){\\n        valid=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-keyword\\">break</span>\\n      }   \\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(valid &amp;&amp; k===pattern.length)res[i]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">else</span> res[i]=<span class=\\"hljs-literal\\">false</span>\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"camelcase-matching","created_at":"2019-04-07","timeArr":[2019,3,7,14,36,18,0],"hasThinking":false,"content":"<p>如果我们可以将<strong>小写字母</strong>插入模式串&nbsp;<code>pattern</code>&nbsp;得到待查询项&nbsp;<code>query</code>，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）</p>\\n\\n<p>给定待查询列表&nbsp;<code>queries</code>，和模式串&nbsp;<code>pattern</code>，返回由布尔值组成的答案列表&nbsp;<code>answer</code>。只有在待查项&nbsp;<code>queries[i]</code> 与模式串&nbsp;<code>pattern</code> 匹配时，&nbsp;<code>answer[i]</code>&nbsp;才为 <code>true</code>，否则为 <code>false</code>。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;\\n<strong>输出：</strong>[true,false,true,true,false]\\n<strong>示例：</strong>\\n&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。\\n&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.\\n&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;\\n<strong>输出：</strong>[true,false,true,false,false]\\n<strong>解释：</strong>\\n&quot;FooBar&quot; 可以这样生成：&quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.\\n&quot;FootBall&quot; 可以这样生成：&quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输出：</strong>queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;\\n<strong>输入：</strong>[false,true,false,false,false]\\n<strong>解释： </strong>\\n&quot;FooBarTest&quot; 可以这样生成：&quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= queries.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= pattern.length &lt;= 100</code></li>\\n\\t<li>所有字符串都仅由大写和小写英文字母组成。</li>\\n</ol>\\n","title":"1023. 驼峰式匹配","relatedTags":["字典树","双指针","字符串","字符串匹配"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1023","slug":"1023-Camelcase-Matching"}')}}]);