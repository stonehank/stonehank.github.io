(window.webpackJsonp=window.webpackJsonp||[]).push([[1037],{1835:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">forest</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> cutOffTree = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">forest</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> pq=[]\\n  <span class=\\"hljs-keyword\\">let</span> m=forest.length,n=forest[<span class=\\"hljs-number\\">0</span>].length\\n  <span class=\\"hljs-keyword\\">let</span> visited=<span class=\\"hljs-built_in\\">Array</span>(m).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(n).fill(<span class=\\"hljs-number\\">0</span>))\\n  <span class=\\"hljs-keyword\\">let</span> uniq=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> moves=[[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">-1</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>]]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;m;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;n;j++){\\n      <span class=\\"hljs-keyword\\">if</span>(forest[i][j]&gt;<span class=\\"hljs-number\\">1</span>){\\n        pq.push([forest[i][j],i,j])\\n      }\\n    }\\n  }\\n  pq.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>b[<span class=\\"hljs-number\\">0</span>]-a[<span class=\\"hljs-number\\">0</span>])\\n  <span class=\\"hljs-keyword\\">let</span> curPos=[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>],res=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(pq.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    uniq++\\n    <span class=\\"hljs-keyword\\">let</span> [h,x,y]=pq.pop()\\n    visited[curPos[<span class=\\"hljs-number\\">0</span>]][curPos[<span class=\\"hljs-number\\">1</span>]]=uniq\\n    <span class=\\"hljs-keyword\\">let</span> curSteps=bfs([curPos],[x,y])\\n    <span class=\\"hljs-keyword\\">if</span>(curSteps===<span class=\\"hljs-number\\">-1</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    res+=curSteps\\n    curPos=[x,y]\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">bfs</span>(<span class=\\"hljs-params\\">arr,[tx,ty]</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> step=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">let</span> len=arr.length,aux=[]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n        <span class=\\"hljs-keyword\\">let</span> [x,y]=arr[i]\\n        <span class=\\"hljs-keyword\\">if</span>(x===tx &amp;&amp; y===ty)<span class=\\"hljs-keyword\\">return</span> step\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [dx,dy] <span class=\\"hljs-keyword\\">of</span> moves){\\n          <span class=\\"hljs-keyword\\">let</span> nx=dx+x,ny=dy+y\\n          <span class=\\"hljs-keyword\\">if</span>(nx&lt;<span class=\\"hljs-number\\">0</span> || ny&lt;<span class=\\"hljs-number\\">0</span> || nx&gt;=m || ny&gt;=n)<span class=\\"hljs-keyword\\">continue</span>\\n          <span class=\\"hljs-keyword\\">if</span>(visited[nx][ny]===uniq)<span class=\\"hljs-keyword\\">continue</span>\\n          <span class=\\"hljs-keyword\\">if</span>(forest[nx][ny]===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>\\n          visited[nx][ny]=uniq\\n          aux.push([nx,ny])\\n        }\\n      }\\n      step++\\n      arr=aux\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"cut-off-trees-for-golf-event","created_at":"2019-04-15","timeArr":[2019,3,15,22,31,31,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>由于题目要求从低到高砍树，那么我们就可以使用<code>优先队列</code>或者直接用数组将树添加，最后再排序。</p>\\n<p>按照从低到高的顺序，构建一个<code>bfs</code>函数，其中参数1是当前的位置，参数2是目标位置，每次计算最短路径即可，如果当前无法到达目标点，\\n返回<code>-1</code>，否则当前位置更新为目标位置，继续下一个目标位置。</p>\\n","content":"<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p>\\n\\n<ul>\\n\\t<li><code>0</code> 表示障碍，无法触碰</li>\\n\\t<li><code>1</code> 表示地面，可以行走</li>\\n\\t<li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li>\\n</ul>\\n\\n<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>\\n\\n<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code>（即变为地面）。</p>\\n\\n<p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p>\\n\\n<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg\\" style=\\"width: 242px; height: 242px;\\" />\\n<pre>\\n<strong>输入：</strong>forest = [[1,2,3],[0,0,4],[7,6,5]]\\n<strong>输出：</strong>6\\n<strong>解释：</strong>沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg\\" style=\\"width: 242px; height: 242px;\\" />\\n<pre>\\n<strong>输入：</strong>forest = [[1,2,3],[0,0,0],[7,6,5]]\\n<strong>输出：</strong>-1\\n<strong>解释：</strong>由于中间一行被障碍阻塞，无法访问最下面一行中的树。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>forest = [[2,3,4],[0,0,5],[8,7,6]]\\n<strong>输出：</strong>6\\n<strong>解释：</strong>可以按与示例 1 相同的路径来砍掉所有的树。\\n(0,0) 位置的树，可以直接砍去，不用算步数。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>m == forest.length</code></li>\\n\\t<li><code>n == forest[i].length</code></li>\\n\\t<li><code>1 <= m, n <= 50</code></li>\\n\\t<li><code>0 <= forest[i][j] <= 10<sup>9</sup></code></li>\\n</ul>\\n","title":"675. 为高尔夫比赛砍树","relatedTags":["广度优先搜索","数组","矩阵","堆（优先队列）"],"difficult":"Hard","lang":["javascript"],"uniqueID":"675","slug":"675-Cut-Off-Trees-for-Golf-Event"}')}}]);