(window.webpackJsonp=window.webpackJsonp||[]).push([[682],{1480:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Initialize your data structure here.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> MyStack = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.queue1=[]\\n  <span class=\\"hljs-keyword\\">this</span>.queue2=[]\\n  <span class=\\"hljs-keyword\\">this</span>._top=<span class=\\"hljs-literal\\">null</span>\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Push element x onto stack. \\n * @param {number} x\\n * @return {void}\\n */</span>\\nMyStack.prototype.push = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x</span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.queue1.push(x)\\n  <span class=\\"hljs-keyword\\">this</span>._top=x\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Removes the element on top of the stack and returns that element.\\n * @return {number}\\n */</span>\\nMyStack.prototype.pop = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">while</span>(<span class=\\"hljs-keyword\\">this</span>.queue1.length&gt;<span class=\\"hljs-number\\">1</span>){\\n    <span class=\\"hljs-keyword\\">this</span>._top=<span class=\\"hljs-keyword\\">this</span>.queue1.shift()\\n    <span class=\\"hljs-keyword\\">this</span>.queue2.push(<span class=\\"hljs-keyword\\">this</span>._top)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> del=<span class=\\"hljs-keyword\\">this</span>.queue1.shift()\\n  <span class=\\"hljs-keyword\\">while</span>(<span class=\\"hljs-keyword\\">this</span>.queue2.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">this</span>.queue1.push(<span class=\\"hljs-keyword\\">this</span>.queue2.shift()) \\n  }\\n  <span class=\\"hljs-keyword\\">return</span> del\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Get the top element.\\n * @return {number}\\n */</span>\\nMyStack.prototype.top = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>._top\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Returns whether the stack is empty.\\n * @return {boolean}\\n */</span>\\nMyStack.prototype.empty = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.queue1.length===<span class=\\"hljs-number\\">0</span> &amp;&amp; <span class=\\"hljs-keyword\\">this</span>.queue2.length===<span class=\\"hljs-number\\">0</span>\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Your MyStack object will be instantiated and called as such:\\n * var obj = new MyStack()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.empty()\\n */</span>\\n</code></pre>\\n"],"querySlug":"implement-stack-using-queues","created_at":"2020-03-01","timeArr":[2020,2,1,16,3,12,0],"hasThinking":false,"content":"<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>\\n\\n<p>实现 <code>MyStack</code> 类：</p>\\n\\n<ul>\\n\\t<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>\\n\\t<li><code>int pop()</code> 移除并返回栈顶元素。</li>\\n\\t<li><code>int top()</code> 返回栈顶元素。</li>\\n\\t<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>注意：</strong></p>\\n\\n<ul>\\n\\t<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>\\n\\t<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>\\n[\\"MyStack\\", \\"push\\", \\"push\\", \\"top\\", \\"pop\\", \\"empty\\"]\\n[[], [1], [2], [], [], []]\\n<strong>输出：</strong>\\n[null, null, null, 2, 2, false]\\n\\n<strong>解释：</strong>\\nMyStack myStack = new MyStack();\\nmyStack.push(1);\\nmyStack.push(2);\\nmyStack.top(); // 返回 2\\nmyStack.pop(); // 返回 2\\nmyStack.empty(); // 返回 False\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= x <= 9</code></li>\\n\\t<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>\\n\\t<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶：</strong>你能否实现每种操作的均摊时间复杂度为 <code>O(1)</code> 的栈？换句话说，执行 <code>n</code> 个操作的总时间复杂度 <code>O(n)</code> ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。</p>\\n","title":"225. 用队列实现栈","relatedTags":["栈","设计","队列"],"difficult":"Easy","lang":["javascript"],"uniqueID":"225","slug":"225-Implement-Stack-using-Queues"}')}}]);