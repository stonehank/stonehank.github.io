(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{1111:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{void}</span> </span>Do not return anything, modify root in-place instead.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> flatten = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">let</span> l=root.left,\\n      r=root.right\\n  root.left=<span class=\\"hljs-literal\\">null</span>\\n  root.right=flatten(l)\\n  <span class=\\"hljs-keyword\\">let</span> node=root\\n  <span class=\\"hljs-keyword\\">while</span>(node.right)node=node.right\\n  node.right=flatten(r)\\n  <span class=\\"hljs-keyword\\">return</span> root\\n};\\n</code></pre>\\n"],"querySlug":"flatten-binary-tree-to-linked-list","created_at":"2019-03-18","timeArr":[2019,2,18,15,12,28,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>对于每个<code>root</code>节点，先将它的左子树和右子树分别保存为<code>l</code>和<code>r</code>；</p>\\n<p>接着继续<code>flatten</code>它的左子树，将<code>flatten(l)</code>的结果作为<code>root</code>的新的右子树，因为<code>flatten(l)</code>已经是一个平铺的树，因此可以沿着它的右子树一直找到最后一个节点<code>node</code>，然后将<code>root</code>原来的右子树<code>r</code>，作为<code>node</code>的右子树连接起来。</p>\\n","content":"<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>\\n\\n<ul>\\n\\t<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>\\n\\t<li>展开后的单链表应该与二叉树 <a href=\\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\\" target=\\"_blank\\"><strong>先序遍历</strong></a> 顺序相同。</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\\" style=\\"width: 500px; height: 226px;\\" />\\n<pre>\\n<strong>输入：</strong>root = [1,2,5,3,4,null,6]\\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>root = []\\n<strong>输出：</strong>[]\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>root = [0]\\n<strong>输出：</strong>[0]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>\\n\\t<li><code>-100 <= Node.val <= 100</code></li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>\\n","title":"114. 二叉树展开为链表","relatedTags":["栈","树","深度优先搜索","链表","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"114","slug":"114-Flatten-Binary-Tree-to-Linked-List"}')}}]);