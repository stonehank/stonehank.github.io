(window.webpackJsonp=window.webpackJsonp||[]).push([[1046],{1844:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">edges</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findRedundantDirectedConnection = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">edges</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={},graph=[],result,hashExist={}\\n  <span class=\\"hljs-keyword\\">let</span> marked=[],cycle=[],cycleHead=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">let</span> redun=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;edges.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [<span class=\\"hljs-keyword\\">from</span>,to]=edges[i]\\n    <span class=\\"hljs-comment\\">// 保证被删除后不会连接不到</span>\\n    hashExist[to]=<span class=\\"hljs-literal\\">true</span>\\n    hashExist[<span class=\\"hljs-keyword\\">from</span>]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-comment\\">// 构建图</span>\\n    <span class=\\"hljs-keyword\\">if</span>(!graph[<span class=\\"hljs-keyword\\">from</span>])graph[<span class=\\"hljs-keyword\\">from</span>]=[to]\\n    <span class=\\"hljs-keyword\\">else</span> graph[<span class=\\"hljs-keyword\\">from</span>].push(to)\\n    <span class=\\"hljs-comment\\">// 判断是否有2个父节点</span>\\n    <span class=\\"hljs-keyword\\">if</span>(!hash[to])hash[to]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">else</span> redun=to\\n  }\\n  \\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;graph.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(graph[i]==<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">if</span>(marked[i])<span class=\\"hljs-keyword\\">continue</span>\\n    findCircle(i,graph)\\n    <span class=\\"hljs-comment\\">// 存在环，处理的同时也要处理2个父节点</span>\\n    <span class=\\"hljs-keyword\\">if</span>(cycle.length&gt;<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=edges.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n        <span class=\\"hljs-keyword\\">let</span> [<span class=\\"hljs-keyword\\">from</span>,to]=edges[i]\\n        <span class=\\"hljs-keyword\\">if</span>(redun){\\n          <span class=\\"hljs-keyword\\">if</span>(cycle[<span class=\\"hljs-keyword\\">from</span>] &amp;&amp; cycle[to] &amp;&amp; to===redun)<span class=\\"hljs-keyword\\">return</span> edges[i]\\n        }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(cycle[<span class=\\"hljs-keyword\\">from</span>] &amp;&amp; cycle[to])<span class=\\"hljs-keyword\\">return</span> edges[i]\\n      }\\n      <span class=\\"hljs-keyword\\">break</span>\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 没有环的时候，处理2个父节点</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=edges.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n    <span class=\\"hljs-keyword\\">let</span> [<span class=\\"hljs-keyword\\">from</span>,to]=edges[i]\\n    <span class=\\"hljs-keyword\\">if</span>(to===redun &amp;&amp; hashExist[<span class=\\"hljs-keyword\\">from</span>] )<span class=\\"hljs-keyword\\">return</span> edges[i]\\n  }\\n  <span class=\\"hljs-comment\\">// 查找环</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">findCircle</span>(<span class=\\"hljs-params\\">v,graph,stack=[]</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> adjs=graph[v]\\n    <span class=\\"hljs-keyword\\">if</span>(!adjs)<span class=\\"hljs-keyword\\">return</span>\\n    marked[v]=<span class=\\"hljs-literal\\">true</span>\\n    stack[v]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> adj <span class=\\"hljs-keyword\\">of</span> adjs){\\n      <span class=\\"hljs-keyword\\">if</span>(!marked[adj]){\\n        findCircle(adj,graph,stack)\\n        <span class=\\"hljs-keyword\\">if</span>(cycle.length&gt;<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">break</span>\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(stack[adj]){\\n        cycleHead=adj\\n        cycle[adj]=<span class=\\"hljs-literal\\">true</span>\\n        cycle[v]=<span class=\\"hljs-literal\\">true</span>\\n        <span class=\\"hljs-keyword\\">return</span>\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(cycleHead!=<span class=\\"hljs-literal\\">null</span> &amp;&amp; cycle.length&gt;<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">if</span>(v!==cycleHead)cycle[v]=<span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-keyword\\">else</span> cycleHead=<span class=\\"hljs-literal\\">null</span>\\n    }\\n    stack[v]=<span class=\\"hljs-literal\\">false</span>\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"redundant-connection-ii","created_at":"2019-03-19","timeArr":[2019,2,19,22,54,22,0],"hasThinking":false,"content":"<p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>\\n\\n<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>\\n\\n<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[u<sub>i</sub>, v<sub>i</sub>]</code>，用以表示 <strong>有向 </strong>图中连接顶点 <code>u<sub>i</sub></code> 和顶点 <code>v<sub>i</sub></code> 的边，其中 <code>u<sub>i</sub></code> 是 <code>v<sub>i</sub></code> 的一个父节点。</p>\\n\\n<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg\\" style=\\"width: 222px; height: 222px;\\" />\\n<pre>\\n<strong>输入：</strong>edges = [[1,2],[1,3],[2,3]]\\n<strong>输出：</strong>[2,3]\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg\\" style=\\"width: 222px; height: 382px;\\" />\\n<pre>\\n<strong>输入：</strong>edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\\n<strong>输出：</strong>[4,1]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>n == edges.length</code></li>\\n\\t<li><code>3 <= n <= 1000</code></li>\\n\\t<li><code>edges[i].length == 2</code></li>\\n\\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\\n</ul>\\n","title":"685. 冗余连接 II","relatedTags":["深度优先搜索","广度优先搜索","并查集","图"],"difficult":"Hard","lang":["javascript"],"uniqueID":"685","slug":"685-Redundant-Connection-II"}')}}]);