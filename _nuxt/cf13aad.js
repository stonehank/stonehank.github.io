(window.webpackJsonp=window.webpackJsonp||[]).push([[955],{1753:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{Node}</span> <span class=\\"hljs-variable\\">quadTree1</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{Node}</span> <span class=\\"hljs-variable\\">quadTree2</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{Node}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> intersect = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">t1, t2</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(t1.isLeaf){\\n    <span class=\\"hljs-keyword\\">return</span> t1.val?t1:t2\\n  }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(t2.isLeaf){\\n    <span class=\\"hljs-keyword\\">return</span> t2.val?t2:t1\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> tl=intersect(t1.topLeft,t2.topLeft),\\n      tr=intersect(t1.topRight,t2.topRight),\\n      bl=intersect(t1.bottomLeft,t2.bottomLeft),\\n      br=intersect(t1.bottomRight,t2.bottomRight)\\n  <span class=\\"hljs-keyword\\">if</span>(tl.isLeaf &amp;&amp; tr.isLeaf &amp;&amp; bl.isLeaf &amp;&amp; br.isLeaf &amp;&amp; \\n     tl.val===tr.val &amp;&amp; tl.val===bl.val &amp;&amp; tl.val===br.val){\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> Node(tl.val,<span class=\\"hljs-literal\\">true</span>,<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-literal\\">null</span>,<span class=\\"hljs-literal\\">null</span>)\\n  }<span class=\\"hljs-keyword\\">else</span>{\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> Node(<span class=\\"hljs-literal\\">false</span>,<span class=\\"hljs-literal\\">false</span>,tl,tr,bl,br)\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"logical-or-of-two-binary-grids-represented-as-quad-trees","created_at":"2019-04-29","timeArr":[2019,3,29,22,30,33,0],"hasThinking":false,"content":"<p>二进制矩阵中的所有元素不是 <strong>0</strong> 就是 <strong>1 </strong>。</p>\\n\\n<p>给你两个四叉树，<code>quadTree1</code> 和 <code>quadTree2</code>。其中 <code>quadTree1</code> 表示一个 <code>n * n</code> 二进制矩阵，而 <code>quadTree2</code> 表示另一个 <code>n * n</code> 二进制矩阵。</p>\\n\\n<p>请你返回一个表示 <code>n * n</code> 二进制矩阵的四叉树，它是 <code>quadTree1</code> 和 <code>quadTree2</code> 所表示的两个二进制矩阵进行 <strong>按位逻辑或运算</strong> 的结果。</p>\\n\\n<p>注意，当 <code>isLeaf</code> 为 <strong>False </strong>时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</p>\\n\\n<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>\\n\\n<ul>\\n\\t<li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>；</li>\\n\\t<li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li>\\n</ul>\\n\\n<pre>\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n}</pre>\\n\\n<p>我们可以按以下步骤为二维区域构建四叉树：</p>\\n\\n<ol>\\n\\t<li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>\\n\\t<li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>\\n\\t<li>使用适当的子网格递归每个子节点。</li>\\n</ol>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\\" style=\\"height: 181px; width: 777px;\\" /></p>\\n\\n<p>如果你想了解更多关于四叉树的内容，可以参考 <a href=\\"https://en.wikipedia.org/wiki/Quadtree\\">wiki</a> 。</p>\\n\\n<p><strong>四叉树格式：</strong></p>\\n\\n<p>输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p>\\n\\n<p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p>\\n\\n<p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0 </strong>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/11/qt1.png\\" style=\\"height: 196px; width: 550px;\\" /> <img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/11/qt2.png\\" style=\\"height: 278px; width: 550px;\\" /></p>\\n\\n<pre>\\n<strong>输入：</strong>quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\\n<strong>输出：</strong>[[0,0],[1,1],[1,1],[1,1],[1,0]]\\n<strong>解释：</strong>quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。\\n如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。\\n注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/02/11/qtr.png\\" style=\\"height: 222px; width: 777px;\\" />\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>quadTree1 = [[1,0]]\\n, quadTree2 = [[1,0]]\\n<strong>输出：</strong>[[1,0]]\\n<strong>解释：</strong>两个数所表示的矩阵大小都为 1*1，值全为 0 \\n结果矩阵大小为 1*1，值全为 0 。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]]\\n, quadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]\\n<strong>输出：</strong>[[1,1]]\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]]\\n, quadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\\n<strong>输出：</strong>[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\\n</pre>\\n\\n<p><strong>示例 5：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\\n, quadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]\\n<strong>输出：</strong>[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>quadTree1</code> 和 <code>quadTree2</code> 都是符合题目要求的四叉树，每个都代表一个 <code>n * n</code> 的矩阵。</li>\\n\\t<li><code>n == 2^x</code> ，其中 <code>0 <= x <= 9</code>.</li>\\n</ul>\\n","title":"558. 四叉树交集","relatedTags":["树","分治"],"difficult":"Middle","lang":["javascript"],"uniqueID":"558","slug":"558-Logical-OR-of-Two-Binary-Grids-Represented-as-Quad-Trees"}')}}]);