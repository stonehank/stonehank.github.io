(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{1035:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{TreeNode}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> recoverFromPreorder = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> maxDeep=<span class=\\"hljs-number\\">0</span>,curDeep=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 重新构建S</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;S.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(S[i]===<span class=\\"hljs-string\\">\\"-\\"</span>)curDeep++\\n    <span class=\\"hljs-keyword\\">else</span>{\\n      maxDeep=<span class=\\"hljs-built_in\\">Math</span>.max(maxDeep,curDeep)\\n      curDeep=<span class=\\"hljs-number\\">0</span>\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> newMax=maxDeep+<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=maxDeep;i&gt;=<span class=\\"hljs-number\\">1</span>;i--){\\n    <span class=\\"hljs-keyword\\">let</span> r=<span class=\\"hljs-string\\">\'-\'</span>.repeat(i)\\n    S=S.replace(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">RegExp</span>(r,<span class=\\"hljs-string\\">\'g\'</span>),<span class=\\"hljs-string\\">\'#\'</span>.repeat(newMax-i))\\n  }\\n  S=<span class=\\"hljs-string\\">\\"#\\"</span>.repeat(newMax)+S\\n  \\n  <span class=\\"hljs-keyword\\">let</span> root=<span class=\\"hljs-keyword\\">new</span> TreeNode(<span class=\\"hljs-literal\\">null</span>)\\n  <span class=\\"hljs-comment\\">// 递归处理</span>\\n  resolve(S,<span class=\\"hljs-number\\">0</span>,root)\\n  <span class=\\"hljs-keyword\\">return</span> root.left\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">resolve</span>(<span class=\\"hljs-params\\">S,deep,root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> deepStr=<span class=\\"hljs-string\\">\\"#\\"</span>.repeat(newMax-deep)\\n    <span class=\\"hljs-keyword\\">let</span> sArr=S.split(deepStr)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;sArr.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(sArr[i]===<span class=\\"hljs-string\\">\'\'</span>)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">let</span> val=<span class=\\"hljs-string\\">\'\'</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;=sArr[i].length;j++){\\n        <span class=\\"hljs-comment\\">// 对每个分割后的元素遍历</span>\\n        <span class=\\"hljs-comment\\">// 找出最头上的数字，然后剩余部分继续递归处理</span>\\n        <span class=\\"hljs-keyword\\">if</span>(j===sArr[i].length || !<span class=\\"hljs-regexp\\">/\\\\d/</span>.test(sArr[i][j])){\\n          <span class=\\"hljs-keyword\\">if</span>(root.left==<span class=\\"hljs-literal\\">null</span>){\\n            root.left=<span class=\\"hljs-keyword\\">new</span> TreeNode(+val)\\n            resolve(sArr[i].substring(j),deep+<span class=\\"hljs-number\\">1</span>,root.left)\\n          }<span class=\\"hljs-keyword\\">else</span>{\\n            root.right=<span class=\\"hljs-keyword\\">new</span> TreeNode(+val)\\n            resolve(sArr[i].substring(j),deep+<span class=\\"hljs-number\\">1</span>,root.right)      \\n          }\\n          <span class=\\"hljs-keyword\\">break</span>\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n           val+=sArr[i][j]\\n        }\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"recover-a-tree-from-preorder-traversal","created_at":"2019-05-15","timeArr":[2019,4,15,14,45,2,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>自己的思路是这样的，首先找出最深的深度<code>maxDeep</code>，然后将字符串<code>S</code>的<code>-</code>数量反转，</p>\\n<p>例如：<code>1-2--3--4-6--7</code>就变成<code>###1##2#3#4##5#6</code>，为什么要做这一步，因为从多到少，我们可以每次直接<code>split</code>分割。</p>\\n<p>对于分割后的<code>sArr</code>，找出每一个元素的开头的数字，这个数字就是当前<code>root</code>的<code>val</code>，然后剩余的字符则为它的<code>left</code>或者<code>right</code>，递归处理即可。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{TreeNode}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> recoverFromPreorder = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> maxDeep=<span class=\\"hljs-number\\">0</span>,curDeep=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// 重新构建S</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;S.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(S[i]===<span class=\\"hljs-string\\">\\"-\\"</span>)curDeep++\\n    <span class=\\"hljs-keyword\\">else</span>{\\n      maxDeep=<span class=\\"hljs-built_in\\">Math</span>.max(maxDeep,curDeep)\\n      curDeep=<span class=\\"hljs-number\\">0</span>\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> newMax=maxDeep+<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=maxDeep;i&gt;=<span class=\\"hljs-number\\">1</span>;i--){\\n    <span class=\\"hljs-keyword\\">let</span> r=<span class=\\"hljs-string\\">\'-\'</span>.repeat(i)\\n    S=S.replace(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">RegExp</span>(r,<span class=\\"hljs-string\\">\'g\'</span>),<span class=\\"hljs-string\\">\'#\'</span>.repeat(newMax-i))\\n  }\\n  S=<span class=\\"hljs-string\\">\\"#\\"</span>.repeat(newMax)+S\\n  \\n  <span class=\\"hljs-keyword\\">let</span> root=<span class=\\"hljs-keyword\\">new</span> TreeNode(<span class=\\"hljs-literal\\">null</span>)\\n  <span class=\\"hljs-comment\\">// 递归处理</span>\\n  resolve(S,<span class=\\"hljs-number\\">0</span>,root)\\n  <span class=\\"hljs-keyword\\">return</span> root.left\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">resolve</span>(<span class=\\"hljs-params\\">S,deep,root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> deepStr=<span class=\\"hljs-string\\">\\"#\\"</span>.repeat(newMax-deep)\\n    <span class=\\"hljs-keyword\\">let</span> sArr=S.split(deepStr)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;sArr.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(sArr[i]===<span class=\\"hljs-string\\">\'\'</span>)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">let</span> val=<span class=\\"hljs-string\\">\'\'</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;=sArr[i].length;j++){\\n        <span class=\\"hljs-comment\\">// 对每个分割后的元素遍历</span>\\n        <span class=\\"hljs-comment\\">// 找出最头上的数字，然后剩余部分继续递归处理</span>\\n        <span class=\\"hljs-keyword\\">if</span>(j===sArr[i].length || !<span class=\\"hljs-regexp\\">/\\\\d/</span>.test(sArr[i][j])){\\n          <span class=\\"hljs-keyword\\">if</span>(root.left==<span class=\\"hljs-literal\\">null</span>){\\n            root.left=<span class=\\"hljs-keyword\\">new</span> TreeNode(+val)\\n            resolve(sArr[i].substring(j),deep+<span class=\\"hljs-number\\">1</span>,root.left)\\n          }<span class=\\"hljs-keyword\\">else</span>{\\n            root.right=<span class=\\"hljs-keyword\\">new</span> TreeNode(+val)\\n            resolve(sArr[i].substring(j),deep+<span class=\\"hljs-number\\">1</span>,root.right)      \\n          }\\n          <span class=\\"hljs-keyword\\">break</span>\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n           val+=sArr[i][j]\\n        }\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n<p>更简洁的代码是看<code>POST</code>的，利用一个<code>stack</code>不断将当前数字的节点压入栈，并且将当前节点作为<code>stack</code>最后一个节点的子节点，\\n如果发现当前<code>deep</code>大于<code>stack.length</code>，说明当前节点不再是<code>stack[stack.length-1]</code>这个节点的子节点，因此<code>stack.pop</code>，\\n直到<code>deep</code>不大于<code>stack.length</code>。</p>\\n","content":"<p>我们从二叉树的根节点 <code>root</code>&nbsp;开始进行深度优先搜索。</p>\\n\\n<p>在遍历中的每个节点处，我们输出&nbsp;<code>D</code>&nbsp;条短划线（其中&nbsp;<code>D</code>&nbsp;是该节点的深度），然后输出该节点的值。（<em>如果节点的深度为 <code>D</code>，则其直接子节点的深度为 <code>D + 1</code>。根节点的深度为 <code>0</code>）。</em></p>\\n\\n<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>\\n\\n<p>给出遍历输出&nbsp;<code>S</code>，还原树并返回其根节点&nbsp;<code>root</code>。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png\\" style=\\"height: 200px; width: 320px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>&quot;1-2--3--4-5--6--7&quot;\\n<strong>输出：</strong>[1,2,5,3,4,6,7]\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114101-pm.png\\" style=\\"height: 250px; width: 256px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>&quot;1-2--3---4-5--6---7&quot;\\n<strong>输出：</strong>[1,2,5,3,null,6,null,4,null,7]\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114955-pm.png\\" style=\\"height: 250px; width: 276px;\\"></p>\\n\\n<pre><strong>输入：</strong>&quot;1-401--349---90--88&quot;\\n<strong>输出：</strong>[1,401,null,349,88,90]\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>\\n\\t<li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li>\\n</ul>\\n","title":"1028. 从先序遍历还原二叉树","relatedTags":["树","深度优先搜索","字符串","二叉树"],"difficult":"Hard","lang":["javascript"],"uniqueID":"1028","slug":"1028-Recover-a-Tree-From-Preorder-Traversal"}')}}]);