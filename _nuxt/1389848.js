(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{709:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"jie-shao\\">介绍</h2>\\n<p><code>react-motion</code>是一个react的动画组件，只需要为UI元素设置一个弹力和阻力和目标位置，便可渲染出符合现实的弹性动画效果</p>\\n<p>算法：</p>\\n<p>弹性算法，算法本身(<a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.react-motion/src/stepper.js\\">stepper.js</a>)简单易懂</p>\\n<h2 id=\\"jie-gou\\">结构</h2>\\n<p>对每一个文件作用先大致说明</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──src\\n    ├──mapToZero.js             // 初始化目标的速度值为0\\n    ├──mergeDiff.js             // 对TransitionMotion的动画序列进行排序\\n    ├──Motion.js                // 单个目标动画的执行文件\\n    ├──presets.js               // 预定义的动画效果参数\\n    ├──react-motion.js          // 接口\\n    ├──reorderKeys.js           // 已经被移除\\n    ├──shouldStopAnimation.js   // 判断是否需要停止动画\\n    ├──spring.js                // 默认动画参数配置，只需要提供目标位置\\n    ├──StaggeredMotion.js       // 多个目标动画的执行文件\\n    ├──stepper.js               // 弹力动画的算法\\n    ├──stripStyle.js            // 提取传入的参数的位置值\\n    ├──TransitionMotion.js      // 目标进入和取消动画的处理\\n    ├──Types.js                 // 规定了type</code></pre>\\n</code></pre>\\n<p>模块分析跳转</p>\\n<p><a href=\\"#maptozero\\">mapToZero</a><br><a href=\\"#mergediff\\">mergeDiff</a><br><a href=\\"#motion\\">Motion</a><br><a href=\\"#presets\\">presets</a><br><a href=\\"#shouldstopanimation\\">shouldStopAnimation</a><br><a href=\\"#spring\\">spring</a><br><a href=\\"#staggeredmotion\\">StaggeredMotion</a><br><a href=\\"#stepper\\">stepper</a><br><a href=\\"#stripstyle\\">stripStyle</a><br><a href=\\"#transitionmotion\\">TransitionMotion</a>              </p>\\n<h2 id=\\"3-da-mo-kuai-gong-gong-fang-fa\\">3大模块+公共方法</h2>\\n<p>提供了3个主要模块，分别是<code>Motion</code>, <code>StaggeredMotion</code>, <code>TransitionMotion</code>，其中还会穿插一些公用方法，\\n有几个模块不去分析，因为它们很简单：</p>\\n<hr>\\n<h3 id=\\"presets\\">presets</h3>\\n<p>定义了几个常用效果的参数</p>\\n<hr>\\n<h3 id=\\"spring\\">spring</h3>\\n<p>提供了默认动画参数配置</p>\\n<p>调用<code>spring(x:100)</code>转换成<code>{x: {stiffness: 170, damping: 26, precision:0.01, val:100}}</code></p>\\n<hr>\\n<h3 id=\\"maptozero\\">mapToZero</h3>\\n<p>设置初始速度为0</p>\\n<p>将<code>{x: {val: 100, stiffness: 200, damping: 14}, y: 60}</code>转换成<code>{x: 0, y: 0}</code></p>\\n<hr>\\n<h3 id=\\"stripstyle\\">stripStyle</h3>\\n<p>提取传入的参数的位置值</p>\\n<p>将<code>{x: {val: 100, stiffness: 200, damping: 14}, y: 60}</code>转换成<code>{x: 100, y: 60}</code></p>\\n<p>解释几个变量：</p>\\n<pre><code><pre class=\\"hljs\\"><code>this.props.style: 这个并不是css的style，而是对动画的配置\\ncurrentStyle: 当前动画属性(例如height，width)状态\\ncurrentVelocitie: 当前动画属性速度\\nlastIdealStyle: 上一次动画属性状态\\nlastIdealVelocitie: 上一次动画属性速度</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"motion\\">Motion</h3>\\n<p>我们按它的生命周期函数的顺序分析</p>\\n<p>首先调用<code>defaultState</code>，它对传入的参数进行处理，\\n通过<a href=\\"#stripstyle\\">scriptStyle</a>转换成一个<code>位置值</code>和通过<a href=\\"#maptozero\\">mapToZero</a>转换成一个<code>速度值</code>，\\n整套算法就是建立在这两个属性之上</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">constructor</span>(props: MotionProps) {\\n  <span class=\\"hljs-keyword\\">super</span>(props);\\n  <span class=\\"hljs-keyword\\">this</span>.state = <span class=\\"hljs-keyword\\">this</span>.defaultState();\\n}\\n\\ndefaultState(): MotionState {\\n    <span class=\\"hljs-comment\\">// defaultStyles指定一个初始值，后续计算不处理它或者通过stripStyle处理</span>\\n    <span class=\\"hljs-keyword\\">const</span> {defaultStyle, style} = <span class=\\"hljs-keyword\\">this</span>.props;\\n    <span class=\\"hljs-keyword\\">const</span> currentStyle = defaultStyle || stripStyle(style);\\n    <span class=\\"hljs-comment\\">// 对每一个位置(x,y)，默认速度都为0</span>\\n    <span class=\\"hljs-keyword\\">const</span> currentVelocity = mapToZero(currentStyle);\\n    <span class=\\"hljs-keyword\\">return</span> {\\n      currentStyle,\\n      currentVelocity,\\n      <span class=\\"hljs-attr\\">lastIdealStyle</span>: currentStyle,\\n      <span class=\\"hljs-attr\\">lastIdealVelocity</span>: currentVelocity,\\n    };\\n  }</code></pre>\\n</code></pre>\\n<p>接下来，执行<code>startAnimationIfNecessary</code></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>componentDidMount() {\\n  <span class=\\"hljs-keyword\\">this</span>.prevTime = defaultNow();\\n  <span class=\\"hljs-keyword\\">this</span>.startAnimationIfNecessary();\\n}</code></pre>\\n</code></pre>\\n<p><code>startAnimationIfNecessary</code>使用了<code>raf</code>库，默认使用requestAnimationFrame，\\n它的几个重要点如下：</p>\\n<ol>\\n<li><p><a href=\\"#shouldstopanimation\\">shouldStopAnimation</a>检测是否停止动画</p>\\n</li>\\n<li><p>定义了几个变量</p>\\n<pre><code><pre class=\\"hljs\\"><code>1. currentTime     // 当前的时间戳\\n2. this.prevTime   // 上一帧的时间戳\\n3. timeDelta       // 当前帧消耗的时间\\n4. this.accumulatedTime \\n// 偏差值，例如当前帧消耗20ms，而规定的帧时间是16.7，那么偏差值就是3.3\\n// 这里偏差值后面会计算补充到当前位置，但是下一次计算的开始点不会包括偏差值\\n\\n一个例子：\\n假设规定的每帧时间是16.7，第一帧消耗了20ms，第二帧消耗了16.4ms\\n那么第一帧偏差值是3.3ms，行走的距离就是：\\n-----------&gt;  +   -&gt;  \\n16.7ms的距离   3.3ms距离\\n第二帧偏差值是3.3-0.3=3ms，距离是\\n            --------&gt;   +   -&gt;\\n       从16.7的位置开始    3ms的距离\\n       \\n5. framesToCatchUp // 可执行帧数\\n// 如果第一帧消耗15ms ，那么它的可执行帧数就是0，偏差值是15ms\\n</code></pre>\\n</code></pre>\\n</li>\\n<li><p>通过<a href=\\"#stepper\\">stepper</a>具体计算当前<code>位置值</code>和<code>速度值</code></p>\\n</li>\\n</ol>\\n<p>先看源码的动画计算的思想部分，这里不仅仅有<code>上一次的位置和速度</code>，\\n<code>本次的位置和速度</code>，还计算了<code>下一次的位置和速度</code>，之所以这么做是为了补上偏差值带来的误差：</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>startAnimationIfNecessary = (): <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">void</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">/* 定义和判断的部分省略... */</span>\\n  \\n     <span class=\\"hljs-comment\\">// 如果传入的style参数是数字，则直接设置，没有动画效果</span>\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> styleValue === <span class=\\"hljs-string\\">\'number\'</span>) {\\n      newCurrentStyle[key] = styleValue;\\n      newCurrentVelocity[key] = <span class=\\"hljs-number\\">0</span>;\\n      newLastIdealStyle[key] = styleValue;\\n      newLastIdealVelocity[key] = <span class=\\"hljs-number\\">0</span>;\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 上一次位置</span>\\n      <span class=\\"hljs-keyword\\">let</span> newLastIdealStyleValue = <span class=\\"hljs-keyword\\">this</span>.state.lastIdealStyle[key];\\n      <span class=\\"hljs-comment\\">// 上一次速度</span>\\n      <span class=\\"hljs-keyword\\">let</span> newLastIdealVelocityValue = <span class=\\"hljs-keyword\\">this</span>.state.lastIdealVelocity[key];\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; framesToCatchUp; i++) {\\n        <span class=\\"hljs-comment\\">// 通过上一次的位置和速度返回当前新的位置和速度</span>\\n        [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\\n          msPerFrame / <span class=\\"hljs-number\\">1000</span>,\\n          newLastIdealStyleValue,\\n          newLastIdealVelocityValue,\\n          styleValue.val,\\n          styleValue.stiffness,\\n          styleValue.damping,\\n          styleValue.precision,\\n        );\\n      }\\n      <span class=\\"hljs-comment\\">// 计算next(下一次的位置和速度)是为了计算偏差值所占有的速度和位置</span>\\n      <span class=\\"hljs-keyword\\">const</span> [nextIdealX, nextIdealV] = stepper(\\n        msPerFrame / <span class=\\"hljs-number\\">1000</span>,\\n        newLastIdealStyleValue,\\n        newLastIdealVelocityValue,\\n        styleValue.val,\\n        styleValue.stiffness,\\n        styleValue.damping,\\n        styleValue.precision,\\n      );\\n      <span class=\\"hljs-comment\\">// 通过偏差值计算当前实际位置，就是上面例如画的图</span>\\n      \\n      <span class=\\"hljs-comment\\">// 此次动画的位置=这一次执行帧数的位置+下一帧动画的位置*偏差值</span>\\n      newCurrentStyle[key] =\\n        newLastIdealStyleValue +\\n        (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\\n      <span class=\\"hljs-comment\\">// 此次动画的速度=这一次执行帧数的速度+下一帧动画的速度*偏差值</span>\\n      newCurrentVelocity[key] =\\n        newLastIdealVelocityValue +\\n        (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\\n      newLastIdealStyle[key] = newLastIdealStyleValue;\\n      newLastIdealVelocity[key] = newLastIdealVelocityValue;\\n    }\\n  }\\n\\n    <span class=\\"hljs-comment\\">/* ... */</span>\\n\\n  <span class=\\"hljs-keyword\\">this</span>.setState({\\n    <span class=\\"hljs-attr\\">currentStyle</span>: newCurrentStyle,\\n    <span class=\\"hljs-attr\\">currentVelocity</span>: newCurrentVelocity,\\n    <span class=\\"hljs-attr\\">lastIdealStyle</span>: newLastIdealStyle,\\n    <span class=\\"hljs-attr\\">lastIdealVelocity</span>: newLastIdealVelocity,\\n  });\\n\\n    <span class=\\"hljs-comment\\">// 递归调用，保持动画</span>\\n  <span class=\\"hljs-keyword\\">this</span>.startAnimationIfNecessary();\\n  });\\n};</code></pre>\\n</code></pre>\\n<p><a href=\\"#shouldstopanimation\\">shouldStopAnimation</a>和<a href=\\"#stepper\\">stepper</a>放到<code>Motion</code>后再去分析。</p>\\n<p>接着是<code>componentWillReceiveProps</code>，\\n这里有个<code>unreadPropStyle</code>和<code>clearUnreadPropStyle</code></p>\\n<p>先做一个大概解释：\\n<code>unreadPropStyle</code>的意义是当连续调用<code> x:0 --&gt;x:400 ---&gt;x:spring(0)</code>这种情况，\\n默认会跳过<code>x:400</code>，因为在<code>x:400</code>的raf调用之前，会触发<code>x:spring(0)</code>，但这时已经有<code>animationID(400那个触发的)</code>，\\n因此<code>x:spring(0)</code>的raf调用不会执行，但是它改变了当前Motion的style，因此<code>x:400</code>执行raf的时候，对比的是当前位置0，\\n和<code>x:spring(0)</code>的目标位置0，对比相等，因此不会触发动画</p>\\n<p>这里使用<code>unreadPropStyle</code>记录每一次的style值(当前帧的目标值)，在raf调用结束会清除<code>unreadPropStyle</code>的值，所以当检测到<code>unreadPropStyle</code>有值，\\n说明上一次的raf未结束就又触发新的，于是就进入<code>clearUnreadPropStyle</code></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>componentWillReceiveProps(props: MotionProps) {\\n    <span class=\\"hljs-comment\\">// 如果unreadPropStyle有值，说明config的值被设置成数字并且被跳过了，需要清除(也就是直接跳转到位置)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.unreadPropStyle != <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-comment\\">// 先检查是否有number的style，如果有就直接跳转到位置</span>\\n      <span class=\\"hljs-keyword\\">this</span>.clearUnreadPropStyle(<span class=\\"hljs-keyword\\">this</span>.unreadPropStyle);\\n    }\\n\\n    <span class=\\"hljs-keyword\\">this</span>.unreadPropStyle = props.style;\\n    <span class=\\"hljs-comment\\">// this.animationID == null 说明之前没有未结束的raf</span>\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.animationID == <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">this</span>.prevTime = defaultNow();\\n      <span class=\\"hljs-keyword\\">this</span>.startAnimationIfNecessary();\\n    }\\n  }</code></pre>\\n</code></pre>\\n<p><code>clearUnreadPropStyle</code>本身非常简单，就是查找style为number的，直接setState手动设定state</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>  clearUnreadPropStyle = (destStyle: Style): <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">void</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">let</span> dirty = <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-keyword\\">let</span> {currentStyle, currentVelocity, lastIdealStyle, lastIdealVelocity} = <span class=\\"hljs-keyword\\">this</span>.state;\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> key <span class=\\"hljs-keyword\\">in</span> destStyle) {\\n      <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">Object</span>.prototype.hasOwnProperty.call(destStyle, key)) {\\n        <span class=\\"hljs-keyword\\">continue</span>;\\n      }\\n\\n      <span class=\\"hljs-keyword\\">const</span> styleValue = destStyle[key];\\n      <span class=\\"hljs-comment\\">// 参数是number，直接赋值然后setState跳转</span>\\n      <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">typeof</span> styleValue === <span class=\\"hljs-string\\">\'number\'</span>) {\\n        <span class=\\"hljs-comment\\">// 当有多个属性，一次全部更新，而不是多次(每次更新一个)，防止重复获取</span>\\n        <span class=\\"hljs-keyword\\">if</span> (!dirty) {\\n          dirty = <span class=\\"hljs-literal\\">true</span>;\\n          currentStyle = {...currentStyle};\\n          currentVelocity = {...currentVelocity};\\n          lastIdealStyle = {...lastIdealStyle};\\n          lastIdealVelocity = {...lastIdealVelocity};\\n        }\\n        currentStyle[key] = styleValue;\\n        currentVelocity[key] = <span class=\\"hljs-number\\">0</span>;\\n        lastIdealStyle[key] = styleValue;\\n        lastIdealVelocity[key] = <span class=\\"hljs-number\\">0</span>;\\n      }\\n    }\\n    <span class=\\"hljs-comment\\">// dirty为true说明存在number的style</span>\\n    <span class=\\"hljs-keyword\\">if</span> (dirty) {\\n      <span class=\\"hljs-keyword\\">this</span>.setState({currentStyle, currentVelocity, lastIdealStyle, lastIdealVelocity});\\n    }\\n  };</code></pre>\\n</code></pre>\\n<p>接着是<code>componentWillUnmount</code>和<code>render</code>，清除raf的调用，返回唯一的children</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>componentWillUnmount() {\\n  <span class=\\"hljs-keyword\\">this</span>.unmounting = <span class=\\"hljs-literal\\">true</span>;\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.animationID != <span class=\\"hljs-literal\\">null</span>) {\\n    defaultRaf.cancel(<span class=\\"hljs-keyword\\">this</span>.animationID);\\n    <span class=\\"hljs-keyword\\">this</span>.animationID = <span class=\\"hljs-literal\\">null</span>;\\n  }\\n}\\n  <span class=\\"hljs-comment\\">// children是函数，有返回值并且是唯一的children</span>\\nrender(): ReactElement {\\n  <span class=\\"hljs-keyword\\">const</span> renderedChildren = <span class=\\"hljs-keyword\\">this</span>.props.children(<span class=\\"hljs-keyword\\">this</span>.state.currentStyle);\\n  <span class=\\"hljs-keyword\\">return</span> renderedChildren &amp;&amp; React.Children.only(renderedChildren);\\n}</code></pre>\\n</code></pre>\\n<p><code>Motion</code>介绍完毕，接下来是<code>shouldStopAnimation</code>和<code>stepper</code></p>\\n<hr>\\n<h3 id=\\"shouldstopanimation\\">shouldStopAnimation</h3>\\n<p>确定停止动画的条件：</p>\\n<ol>\\n<li>速度为0</li>\\n<li>目标为当前位置</li>\\n</ol>\\n<pre><code class=\\"language-ts\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">shouldStopAnimation</span>(<span class=\\"hljs-params\\">\\n  currentStyle: PlainStyle,\\n  style: Style,\\n  currentVelocity: Velocity,\\n</span>): <span class=\\"hljs-title\\">boolean</span> </span>{\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> key <span class=\\"hljs-keyword\\">in</span> style) {\\n    <span class=\\"hljs-comment\\">// 原型链的属性跳过</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">Object</span>.prototype.hasOwnProperty.call(style, key)) {\\n      <span class=\\"hljs-keyword\\">continue</span>;\\n    }\\n    <span class=\\"hljs-comment\\">// 速度不为0，返回false</span>\\n    <span class=\\"hljs-keyword\\">if</span> (currentVelocity[key] !== <span class=\\"hljs-number\\">0</span>) {\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n    }\\n    <span class=\\"hljs-keyword\\">const</span> styleValue = <span class=\\"hljs-keyword\\">typeof</span> style[key] === <span class=\\"hljs-string\\">\'number\'</span>\\n      ? style[key]\\n      : style[key].val;\\n    <span class=\\"hljs-comment\\">// 当前位置与目标位置不等，返回false</span>\\n    <span class=\\"hljs-comment\\">// 在stepper内部会通过设定的precision属性调整位置，例如精确度为0.1，那么0.9===1</span>\\n    <span class=\\"hljs-keyword\\">if</span> (currentStyle[key] !== styleValue) {\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n    }\\n  }\\n\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n}</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"stepper\\">stepper</h3>\\n<p>弹性动画的算法，内容不多，但是整个组件的核心</p>\\n<pre><code class=\\"language-ts\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-comment\\">/* ... */</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">stepper</span>(<span class=\\"hljs-params\\">\\n  <span class=\\"hljs-comment\\">// 每一帧所用秒数</span>\\n  secondPerFrame: <span class=\\"hljs-built_in\\">number</span>,\\n  <span class=\\"hljs-comment\\">// 当前位置</span>\\n  x: <span class=\\"hljs-built_in\\">number</span>,\\n  <span class=\\"hljs-comment\\">// 当前速度</span>\\n  v: <span class=\\"hljs-built_in\\">number</span>,\\n  <span class=\\"hljs-comment\\">// 目标位置</span>\\n  destX: <span class=\\"hljs-built_in\\">number</span>,\\n  <span class=\\"hljs-comment\\">// 弹性</span>\\n  k: <span class=\\"hljs-built_in\\">number</span>,\\n  <span class=\\"hljs-comment\\">// 阻力</span>\\n  b: <span class=\\"hljs-built_in\\">number</span>,\\n  <span class=\\"hljs-comment\\">// 精度(用于停止动画)</span>\\n  precision: <span class=\\"hljs-built_in\\">number</span></span>): [<span class=\\"hljs-title\\">number</span>, <span class=\\"hljs-title\\">number</span>] </span>{\\n  <span class=\\"hljs-comment\\">// 计算当前弹性力(离目标越近，弹性越小)</span>\\n  <span class=\\"hljs-keyword\\">const</span> Fspring = -k * (x - destX);\\n  <span class=\\"hljs-comment\\">// 计算当前阻力(速度越快，阻力越大)</span>\\n  <span class=\\"hljs-keyword\\">const</span> Fdamper = -b * v;\\n  <span class=\\"hljs-comment\\">// 当前加速度，忽略质量</span>\\n  <span class=\\"hljs-keyword\\">const</span> a = Fspring + Fdamper;\\n  <span class=\\"hljs-comment\\">// 新的速度</span>\\n  <span class=\\"hljs-keyword\\">const</span> newV = v + a * secondPerFrame;\\n  <span class=\\"hljs-comment\\">// 新的位置</span>\\n  <span class=\\"hljs-keyword\\">const</span> newX = x + newV * secondPerFrame;\\n  <span class=\\"hljs-comment\\">// 停止动画的条件，小于当前精度，则速度为0，位置为目标</span>\\n  <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-built_in\\">Math</span>.abs(newV) &lt; precision &amp;&amp; <span class=\\"hljs-built_in\\">Math</span>.abs(newX - destX) &lt; precision) {\\n    reusedTuple[<span class=\\"hljs-number\\">0</span>] = destX;\\n    reusedTuple[<span class=\\"hljs-number\\">1</span>] = <span class=\\"hljs-number\\">0</span>;\\n    <span class=\\"hljs-keyword\\">return</span> reusedTuple;\\n  }\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n}</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"staggeredmotion\\">StaggeredMotion</h3>\\n<p>这个一个多目标的动画处理，因此大体上就是遍历需要处理的动画，然后使用类似<code>Motion</code>的方法</p>\\n<p>还是根据生命周期函数分析</p>\\n<p>同样先调用<code>defaultState</code></p>\\n<pre><code class=\\"language-ts\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">constructor</span>(<span class=\\"hljs-params\\">props: StaggeredProps</span>) {\\n  <span class=\\"hljs-keyword\\">super</span>(props);\\n  <span class=\\"hljs-keyword\\">this</span>.state = <span class=\\"hljs-keyword\\">this</span>.defaultState();\\n}</code></pre>\\n</code></pre>\\n<p>这里有一点不同，styles必须是函数</p>\\n<pre><code class=\\"language-ts\\"><pre class=\\"hljs\\"><code> defaultState(): StaggeredMotionState {\\n    <span class=\\"hljs-keyword\\">const</span> {defaultStyles, styles} = <span class=\\"hljs-keyword\\">this</span>.props;\\n    <span class=\\"hljs-comment\\">// 与Motion不同之处，styles是个函数，接收上一次的styles，返回值是一个数组，里面包含每一个类似Motion的style个格式</span>\\n    <span class=\\"hljs-comment\\">// 例如：stylex=()=&gt;[{x:{stiffness:100,damping:10,val:100},</span>\\n    <span class=\\"hljs-comment\\">//                   {x:spring(50)},</span>\\n    <span class=\\"hljs-comment\\">//                   {x:500}}]</span>\\n    \\n    <span class=\\"hljs-comment\\">// 初始的lastIdealStyles是defaultStyles或者是styles()的返回值</span>\\n    <span class=\\"hljs-keyword\\">const</span> currentStyles: <span class=\\"hljs-built_in\\">Array</span>&lt;PlainStyle&gt; = defaultStyles || styles().map(stripStyle);\\n    <span class=\\"hljs-comment\\">// 对应的方向，值为0</span>\\n    <span class=\\"hljs-keyword\\">const</span> currentVelocities = currentStyles.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">currentStyle</span> =&gt;</span> mapToZero(currentStyle));\\n    <span class=\\"hljs-keyword\\">return</span> {\\n      currentStyles,\\n      currentVelocities,\\n      lastIdealStyles: currentStyles,\\n      lastIdealVelocities: currentVelocities,\\n    };\\n  }</code></pre>\\n</code></pre>\\n<p>接下来是<code>componentDidMount</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> componentDidMount() {\\n    <span class=\\"hljs-keyword\\">this</span>.prevTime = defaultNow();\\n    <span class=\\"hljs-keyword\\">this</span>.startAnimationIfNecessary();\\n  }</code></pre>\\n</code></pre>\\n<p><code>startAnimationIfNecessary</code>这里取消了onRest的调用，并且是通过遍历动画序列逐个计算，其他和<code>Motion</code>的类似</p>\\n<p>至于onRest的取消，引用官网解释：</p>\\n<blockquote>\\n<p>No onRest for StaggeredMotion because we haven&#39;t found a good semantics for it yet. Voice your support in the issues section.</p>\\n</blockquote>\\n<p>接着是<code>componentWillReceiveProps</code>，结构也是一样的</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> componentWillReceiveProps(props: StaggeredProps) {\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.unreadPropStyles != <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-comment\\">// previous props haven\'t had the chance to be set yet; set them here</span>\\n      <span class=\\"hljs-keyword\\">this</span>.clearUnreadPropStyle(<span class=\\"hljs-keyword\\">this</span>.unreadPropStyles);\\n    }\\n\\n    <span class=\\"hljs-keyword\\">this</span>.unreadPropStyles = props.styles(<span class=\\"hljs-keyword\\">this</span>.state.lastIdealStyles);\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.animationID == <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">this</span>.prevTime = defaultNow();\\n      <span class=\\"hljs-keyword\\">this</span>.startAnimationIfNecessary();\\n    }\\n  }</code></pre>\\n</code></pre>\\n<p><code>clearUnreadPropStyle</code>和<code>Motion</code>的意思一样，都是处理上一帧动画未结束就又触发的新的属性值，\\n只有一个要注意，当任意目标需要手动更新位置，所有目标都会<code>setState</code></p>\\n<p>接着<code>unmount</code>和<code>render</code>都和<code>Motion</code>无区别，就不多说了。</p>\\n<p>可以看出，<code>StaggeredMotion</code>和<code>Motion</code>其实就是一个模子里出来的，总结下它们的不同点：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>比较</th>\\n<th>StaggeredMotion</th>\\n<th>Motion</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>动画支持目标数</td>\\n<td>多个</td>\\n<td>1个</td>\\n</tr>\\n<tr>\\n<td>传入style</td>\\n<td>函数</td>\\n<td>Array</td>\\n</tr>\\n<tr>\\n<td>动画计算</td>\\n<td>遍历逐个计算</td>\\n<td>单个计算</td>\\n</tr>\\n<tr>\\n<td>UnreadPropStyle</td>\\n<td>任意更新全更新</td>\\n<td>单个目标更新</td>\\n</tr>\\n<tr>\\n<td>onRest</td>\\n<td>有</td>\\n<td>无</td>\\n</tr>\\n</tbody></table>\\n<hr>\\n<h3 id=\\"transitionmotion\\">TransitionMotion</h3>\\n<p>这是最复杂的一个动画组件，涉及到元素的新增和移除，基本架构和前2者类似，但新增了许多不同的变量名，当然都是有用的，\\n但也可能会看的比较乱，所以先排列出一些关键的变量，并说明它们是做什么用的</p>\\n<h4 id=\\"pai-xu-wen-ti\\">排序问题</h4>\\n<p>因为有添加和删除，那怎么判断动画的执行顺序，用到了拓扑排序的思想</p>\\n<p>例如：</p>\\n<p>旧的序列： <code>a -&gt; b -&gt; x</code>\\n新的序列： <code>c -&gt; b -&gt; d</code>\\n那么很显然 <code>a</code>和<code>c</code> 在<code>b</code>的前面执行， <code>x</code>和<code>d</code>在<code>b</code>的后面执行</p>\\n<p>那么<code>a</code>和<code>c</code>的顺序，<code>x</code>和<code>d</code>的顺序怎么判断\\n这里使用的是next默认在后面，即默认 <code>a -&gt; c</code> ，<code> x -&gt; d</code></p>\\n<h4 id=\\"transitionmotion-can-shu\\">TransitionMotion参数</h4>\\n<pre><code><pre class=\\"hljs\\"><code>* 即将新增元素的动画起点\\nwillEnter\\n----------------------------\\n* 即将移除元素的动画终点\\nwillLeave\\n----------------------------\\n* 已经移除的回调，无返回值\\ndidLeave\\n----------------------------\\n* old代表未排序的动画列表或者数据\\n例如：oldMergedPropsStyles就是未排序的mergedPropsStyles\\noldMergedPropsStyles\\noldCurrentStyles\\noldCurrentVelocities\\noldLastIdealStyles\\noldLastIdealVelocities\\n----------------------------\\n* new代表已经排序的动画列表或者数据\\n例如：newMergedPropsStyles就是已经排好序的mergedPropsStyles\\nnewMergedPropsStyles, \\nnewCurrentStyles, \\nnewCurrentVelocities, \\nnewLastIdealStyles, \\nnewLastIdealVelocities\\n----------------------------\\n以上的new和old后面变量名称的具体意思：\\n\\n* 当前动画属性列表(例如height，width)位置\\ncurrentStyles\\n----------------------------\\n* 当前动画属性列表速度\\ncurrentVelocities\\n----------------------------\\n* 上一次动画属性列表位置\\nlastIdealStyles \\n----------------------------\\n* 上一次动画属性列表速度\\nlastIdealVelocities \\n----------------------------\\n* 储存了key和data数据的当前动画列表\\nmergedPropsStyles\\n----------------------------\\n通过rehydrateStyles组合而成，\\n* 储存了key和data数据的目标动画列表\\ndestStyles\\n----------------------------</code></pre>\\n</code></pre>\\n<h4 id=\\"rehydratestyles\\">rehydrateStyles</h4>\\n<p><code>rehydrateStyles</code>是什么</p>\\n<p>当styles是函数的时候，接受一个参数是type为<code>TransitionPlainStyle</code>，返回本次的目标值</p>\\n<p>类似<code>{key: string, data?: any, style: PlainStyle}</code>，而它的内容则是上一次的位置，</p>\\n<p><code>mergedPropsStyles</code>的结构有key和data，但它的style有可能不是PlainStyle格式的，(有可能是<code>{stifiness:xx,damping:xxx...}</code>)</p>\\n<p>因此要通过<code>rehydrateStyles</code>创建这种格式</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">rehydrateStyles</span>(<span class=\\"hljs-params\\">\\n  mergedPropsStyles: Array&lt;TransitionStyle&gt;,\\n  unreadPropStyles: ?Array&lt;TransitionStyle&gt;,\\n  plainStyles: Array&lt;PlainStyle&gt;,\\n</span>): <span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">TransitionPlainStyle</span>&gt; </span>{\\n  <span class=\\"hljs-keyword\\">const</span> cUnreadPropStyles = unreadPropStyles;\\n  <span class=\\"hljs-comment\\">// 如果unreadPropStyles不存在，则通过mergedPropsStyles创建</span>\\n  <span class=\\"hljs-keyword\\">if</span> (cUnreadPropStyles == <span class=\\"hljs-literal\\">null</span>) {\\n    <span class=\\"hljs-keyword\\">return</span> mergedPropsStyles.map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">mergedPropsStyle, i</span>) =&gt;</span> ({\\n      <span class=\\"hljs-attr\\">key</span>: mergedPropsStyle.key,\\n      <span class=\\"hljs-attr\\">data</span>: mergedPropsStyle.data,\\n      <span class=\\"hljs-comment\\">// 这里style使用的是第三个参数的值，</span>\\n      <span class=\\"hljs-comment\\">// 这里计算动画时用的是lastIdealStyles，</span>\\n      <span class=\\"hljs-comment\\">// 而在render的时候用的是currentStyles</span>\\n      <span class=\\"hljs-attr\\">style</span>: plainStyles[i],\\n    }));\\n  }\\n  <span class=\\"hljs-comment\\">// 如果unreadPropStyles对应的key存在，则通过unreadPropStyles创建</span>\\n  <span class=\\"hljs-keyword\\">return</span> mergedPropsStyles.map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">mergedPropsStyle, i</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> j = <span class=\\"hljs-number\\">0</span>; j &lt; cUnreadPropStyles.length; j++) {\\n      <span class=\\"hljs-keyword\\">if</span> (cUnreadPropStyles[j].key === mergedPropsStyle.key) {\\n        <span class=\\"hljs-keyword\\">return</span> {\\n          <span class=\\"hljs-attr\\">key</span>: cUnreadPropStyles[j].key,\\n          <span class=\\"hljs-attr\\">data</span>: cUnreadPropStyles[j].data,\\n          <span class=\\"hljs-attr\\">style</span>: plainStyles[i],\\n        };\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">key</span>: mergedPropsStyle.key, <span class=\\"hljs-attr\\">data</span>: mergedPropsStyle.data, <span class=\\"hljs-attr\\">style</span>: plainStyles[i]};\\n  });\\n}</code></pre>\\n</code></pre>\\n<p>还是按照流程走，</p>\\n<p>首先是<code>constructor</code></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">constructor</span>(props: TransitionProps) {\\n    <span class=\\"hljs-keyword\\">super</span>(props);\\n    <span class=\\"hljs-keyword\\">this</span>.state = <span class=\\"hljs-keyword\\">this</span>.defaultState();\\n  }</code></pre>\\n</code></pre>\\n<p>跳到<code>defaultState</code></p>\\n<p>这里用到了<a href=\\"#stripstyle\\">stripStyle</a>，<a href=\\"#mergeandsync\\">mergeAndSync</a></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>  defaultState(): TransitionMotionState {\\n    <span class=\\"hljs-keyword\\">const</span> {defaultStyles, styles, willEnter, willLeave, didLeave} = <span class=\\"hljs-keyword\\">this</span>.props;\\n    <span class=\\"hljs-comment\\">// styles可以是对象也可以是函数，将动画目标数据赋值给destStyles</span>\\n    <span class=\\"hljs-keyword\\">const</span> destStyles: <span class=\\"hljs-built_in\\">Array</span>&lt;TransitionStyle&gt; = <span class=\\"hljs-keyword\\">typeof</span> styles === <span class=\\"hljs-string\\">\'function\'</span> ? styles(defaultStyles) : styles;\\n    <span class=\\"hljs-comment\\">// 初始化oldMergedPropsStyles为defaultStyles或者destStyles</span>\\n    <span class=\\"hljs-keyword\\">let</span> oldMergedPropsStyles: <span class=\\"hljs-built_in\\">Array</span>&lt;TransitionStyle&gt;;\\n    <span class=\\"hljs-keyword\\">if</span> (defaultStyles == <span class=\\"hljs-literal\\">null</span>) {\\n      oldMergedPropsStyles = destStyles;\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      oldMergedPropsStyles = (defaultStyles: any).map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">defaultStyleCell</span> =&gt;</span> {\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; destStyles.length; i++) {\\n          <span class=\\"hljs-keyword\\">if</span> (destStyles[i].key === defaultStyleCell.key) {\\n            <span class=\\"hljs-keyword\\">return</span> destStyles[i];\\n          }\\n        }\\n        <span class=\\"hljs-keyword\\">return</span> defaultStyleCell;\\n      });\\n    }\\n    <span class=\\"hljs-comment\\">// 通过stripStyle计算出当前位置和速度</span>\\n    <span class=\\"hljs-keyword\\">const</span> oldCurrentStyles = defaultStyles == <span class=\\"hljs-literal\\">null</span>\\n      ? destStyles.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">s</span> =&gt;</span> stripStyle(s.style))\\n      : (defaultStyles: any).map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">s</span> =&gt;</span> stripStyle(s.style));\\n    <span class=\\"hljs-keyword\\">const</span> oldCurrentVelocities = defaultStyles == <span class=\\"hljs-literal\\">null</span>\\n      ? destStyles.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">s</span> =&gt;</span> mapToZero(s.style))\\n      : defaultStyles.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">s</span> =&gt;</span> mapToZero(s.style));\\n    <span class=\\"hljs-keyword\\">const</span> [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(\\n      (willEnter: any),\\n      (willLeave: any),\\n      (didLeave: any),\\n      oldMergedPropsStyles,\\n      destStyles,\\n      oldCurrentStyles,\\n      oldCurrentVelocities,\\n      oldCurrentStyles, \\n      oldCurrentVelocities, \\n    );\\n    <span class=\\"hljs-keyword\\">return</span> {\\n      currentStyles,\\n      currentVelocities,\\n      lastIdealStyles,\\n      lastIdealVelocities,\\n      mergedPropsStyles,\\n    };\\n  }</code></pre>\\n</code></pre>\\n<p>接着是<code>componentDidMount</code>，内部调用了<code>startAnimationIfNecessary</code></p>\\n<p>这里用到了<a href=\\"#rehydratestyles\\">rehydrateStyles</a>和<a href=\\"#mergeandsync\\">mergeAndSync</a></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>startAnimationIfNecessary = (): <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">void</span> =&gt;</span> {\\n  <span class=\\"hljs-comment\\">/* ... */</span>\\n\\n  <span class=\\"hljs-keyword\\">const</span> propStyles = <span class=\\"hljs-keyword\\">this</span>.props.styles;\\n  <span class=\\"hljs-comment\\">// 通过rehydrateStyles计算destStyles</span>\\n  <span class=\\"hljs-comment\\">// 如果styles是函数，destStyles就是根据上一次的动画数据通过styles函数计算出本次的目标位置</span>\\n  <span class=\\"hljs-comment\\">// 如果styles不是函数，destStyles就是styles，也就是本次动画目标位置</span>\\n  <span class=\\"hljs-keyword\\">let</span> destStyles: <span class=\\"hljs-built_in\\">Array</span>&lt;TransitionStyle&gt; = <span class=\\"hljs-keyword\\">typeof</span> propStyles === <span class=\\"hljs-string\\">\'function\'</span>\\n    ? propStyles(rehydrateStyles(\\n      <span class=\\"hljs-keyword\\">this</span>.state.mergedPropsStyles,\\n      <span class=\\"hljs-keyword\\">this</span>.unreadPropStyles,\\n      <span class=\\"hljs-keyword\\">this</span>.state.lastIdealStyles,\\n    ))\\n    : propStyles;\\n  \\n  <span class=\\"hljs-comment\\">/* 省略：判断是否需要停止动画，计算当前动画帧和偏差值... */</span>\\n  \\n  <span class=\\"hljs-comment\\">// 将旧的动画数据(未排序)转换成新的动画数据(已排序)</span>\\n  <span class=\\"hljs-keyword\\">let</span> [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities] = mergeAndSync(\\n    (<span class=\\"hljs-keyword\\">this</span>.props.willEnter: any),\\n    (<span class=\\"hljs-keyword\\">this</span>.props.willLeave: any),\\n    (<span class=\\"hljs-keyword\\">this</span>.props.didLeave: any),\\n    <span class=\\"hljs-keyword\\">this</span>.state.mergedPropsStyles,\\n    destStyles,\\n    <span class=\\"hljs-keyword\\">this</span>.state.currentStyles,\\n    <span class=\\"hljs-keyword\\">this</span>.state.currentVelocities,\\n    <span class=\\"hljs-keyword\\">this</span>.state.lastIdealStyles,\\n    <span class=\\"hljs-keyword\\">this</span>.state.lastIdealVelocities,\\n  );\\n  \\n  <span class=\\"hljs-comment\\">// 对newMergedPropsStyles逐个计算</span>\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; newMergedPropsStyles.length; i++) {\\n    <span class=\\"hljs-comment\\">/* 省略：与StaggeredMotion流程一致... */</span>\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这里的<a href=\\"#mergeandsync\\">mergeAndSync</a>我们第一次遇到，它是<code>TransitionMotion</code>组件的重点，\\n对动画序列进行排序和提取当前每一个动画的位置和速度</p>\\n<h4 id=\\"mergeandsync\\">mergeAndSync</h4>\\n<p>代码长，参数也很多，再次回顾下每个参数代表的<a href=\\"#transitionmotion-can-shu\\">意思</a></p>\\n<p>这里调用了<a href=\\"#mergediff\\">mergeDiff</a>，它的功能就是对要进行的动画进行先后排序，具体怎么做后面再说，先知道它的功能</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">mergeAndSync</span>(<span class=\\"hljs-params\\">\\n  willEnter: WillEnter,\\n  willLeave: WillLeave,\\n  didLeave: DidLeave,\\n  oldMergedPropsStyles: Array&lt;TransitionStyle&gt;,\\n  destStyles: Array&lt;TransitionStyle&gt;,\\n  oldCurrentStyles: Array&lt;PlainStyle&gt;,\\n  oldCurrentVelocities: Array&lt;Velocity&gt;,\\n  oldLastIdealStyles: Array&lt;PlainStyle&gt;,\\n  oldLastIdealVelocities: Array&lt;Velocity&gt;,\\n</span>): [<span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">TransitionStyle</span>&gt;, <span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">PlainStyle</span>&gt;, <span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">Velocity</span>&gt;, <span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">PlainStyle</span>&gt;, <span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">Velocity</span>&gt;] </span>{\\n  <span class=\\"hljs-comment\\">// 对要进行的动画进行先后排序(拓扑排序思想)</span>\\n  <span class=\\"hljs-keyword\\">const</span> newMergedPropsStyles = mergeDiff(\\n    oldMergedPropsStyles,\\n    destStyles,\\n    <span class=\\"hljs-comment\\">// 参数3 是执行删除的动作，无删除动画则直接删除，有删除动画的还需要进入到动画排序</span>\\n    (oldIndex, oldMergedPropsStyle) =&gt; {\\n      <span class=\\"hljs-keyword\\">const</span> leavingStyle = willLeave(oldMergedPropsStyle);\\n      <span class=\\"hljs-comment\\">// 无willLeave动画，直接调用didLeave</span>\\n      <span class=\\"hljs-keyword\\">if</span> (leavingStyle == <span class=\\"hljs-literal\\">null</span>) {\\n        didLeave({ <span class=\\"hljs-attr\\">key</span>: oldMergedPropsStyle.key, <span class=\\"hljs-attr\\">data</span>: oldMergedPropsStyle.data });\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n      }\\n      <span class=\\"hljs-comment\\">// 判断需要停止动画，调用didLeave</span>\\n      <span class=\\"hljs-keyword\\">if</span> (shouldStopAnimation(\\n          oldCurrentStyles[oldIndex],\\n          leavingStyle,\\n          oldCurrentVelocities[oldIndex])) {\\n        didLeave({ <span class=\\"hljs-attr\\">key</span>: oldMergedPropsStyle.key, <span class=\\"hljs-attr\\">data</span>: oldMergedPropsStyle.data });\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>;\\n      }\\n      <span class=\\"hljs-comment\\">// 有willLeave并且动画还未停止，返回删除动画</span>\\n      <span class=\\"hljs-keyword\\">return</span> {<span class=\\"hljs-attr\\">key</span>: oldMergedPropsStyle.key, <span class=\\"hljs-attr\\">data</span>: oldMergedPropsStyle.data, <span class=\\"hljs-attr\\">style</span>: leavingStyle};\\n    },\\n  );\\n\\n  <span class=\\"hljs-keyword\\">let</span> newCurrentStyles = [];\\n  <span class=\\"hljs-keyword\\">let</span> newCurrentVelocities = [];\\n  <span class=\\"hljs-keyword\\">let</span> newLastIdealStyles = [];\\n  <span class=\\"hljs-keyword\\">let</span> newLastIdealVelocities = [];\\n  <span class=\\"hljs-comment\\">// 注意！！此处newMergedPropsStyles已经是排好序的动画序列</span>\\n  <span class=\\"hljs-comment\\">// 后面的就是填充上面这个4个变量了(根据排好的顺序)</span>\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; newMergedPropsStyles.length; i++) {\\n    <span class=\\"hljs-keyword\\">const</span> newMergedPropsStyleCell = newMergedPropsStyles[i];\\n    <span class=\\"hljs-keyword\\">let</span> foundOldIndex = <span class=\\"hljs-literal\\">null</span>;\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> j = <span class=\\"hljs-number\\">0</span>; j &lt; oldMergedPropsStyles.length; j++) {\\n      <span class=\\"hljs-keyword\\">if</span> (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {\\n        foundOldIndex = j;\\n        <span class=\\"hljs-keyword\\">break</span>;\\n      }\\n    }\\n    <span class=\\"hljs-comment\\">// 无旧的全是新增，创建新的数据</span>\\n    <span class=\\"hljs-keyword\\">if</span> (foundOldIndex == <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">const</span> plainStyle = willEnter(newMergedPropsStyleCell);\\n      newCurrentStyles[i] = plainStyle;\\n      newLastIdealStyles[i] = plainStyle;\\n\\n      <span class=\\"hljs-keyword\\">const</span> velocity = mapToZero(newMergedPropsStyleCell.style);\\n      newCurrentVelocities[i] = velocity;\\n      newLastIdealVelocities[i] = velocity;\\n      <span class=\\"hljs-comment\\">// 有旧的target更新或者删除，使用旧的数据作为新排序的数据</span>\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];\\n      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];\\n      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];\\n      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">/*\\n  * newMergedPropsStyles：已经排好序的动画序列\\n  * newCurrentStyles：已经排好序的目前的位置\\n  * newCurrentVelocities：已经排好序的目前的速度\\n  * newLastIdealStyles：已经排好序的旧的位置\\n  * newLastIdealVelocities：已经排好序的旧的速度\\n  * */</span>\\n  <span class=\\"hljs-keyword\\">return</span> [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities];\\n}</code></pre>\\n</code></pre>\\n<p>接着<code>componentWillReceiveProps</code>调用了<code>clearUnreadPropStyle</code></p>\\n<p>这里用到了<a href=\\"#mergeandsync\\">mergeAndSync</a></p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>clearUnreadPropStyle = (unreadPropStyles: <span class=\\"hljs-built_in\\">Array</span>&lt;TransitionStyle&gt;): <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">void</span> =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// 对动画序列进行合并及排序</span>\\n  <span class=\\"hljs-keyword\\">let</span> [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(\\n    (<span class=\\"hljs-keyword\\">this</span>.props.willEnter: any),\\n    (<span class=\\"hljs-keyword\\">this</span>.props.willLeave: any),\\n    (<span class=\\"hljs-keyword\\">this</span>.props.didLeave: any),\\n    <span class=\\"hljs-keyword\\">this</span>.state.mergedPropsStyles,\\n    unreadPropStyles,\\n    <span class=\\"hljs-keyword\\">this</span>.state.currentStyles,\\n    <span class=\\"hljs-keyword\\">this</span>.state.currentVelocities,\\n    <span class=\\"hljs-keyword\\">this</span>.state.lastIdealStyles,\\n    <span class=\\"hljs-keyword\\">this</span>.state.lastIdealVelocities,\\n  );\\n  <span class=\\"hljs-comment\\">/* 省略：如果是number，直接赋值为目标值... */</span>\\n  \\n  <span class=\\"hljs-comment\\">// 没有使用dirty判断</span>\\n  <span class=\\"hljs-keyword\\">this</span>.setState({\\n    currentStyles,\\n    currentVelocities,\\n    mergedPropsStyles,\\n    lastIdealStyles,\\n    lastIdealVelocities,\\n  });\\n}</code></pre>\\n</code></pre>\\n<p>这里没有和之前2个组件一样使用if(dirty)</p>\\n<p>因为每一个style的data即便属性值不是number，也有可能存在新的属性</p>\\n<p>最后便是<code>componentUnmount</code>和<code>render</code>了</p>\\n<p>1个要注意的地方，同样在render的时候调用了<code>rehydrateStyles</code>，\\n说明这个组件的<code>this.props.children</code>接受的参数格式和<code>this.props.styles</code>接受的参数格式一样</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code>  componentWillUnmount() {\\n    <span class=\\"hljs-keyword\\">this</span>.unmounting = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.animationID != <span class=\\"hljs-literal\\">null</span>) {\\n      defaultRaf.cancel(<span class=\\"hljs-keyword\\">this</span>.animationID);\\n      <span class=\\"hljs-keyword\\">this</span>.animationID = <span class=\\"hljs-literal\\">null</span>;\\n    }\\n  }\\n\\n  render(): ReactElement {\\n    <span class=\\"hljs-comment\\">// 通过currentStyles转化为children参数需要的格式</span>\\n    <span class=\\"hljs-keyword\\">const</span> hydratedStyles = rehydrateStyles(\\n      <span class=\\"hljs-keyword\\">this</span>.state.mergedPropsStyles,\\n      <span class=\\"hljs-keyword\\">this</span>.unreadPropStyles,\\n      <span class=\\"hljs-keyword\\">this</span>.state.currentStyles,\\n    );\\n    <span class=\\"hljs-keyword\\">const</span> renderedChildren = <span class=\\"hljs-keyword\\">this</span>.props.children(hydratedStyles);\\n    <span class=\\"hljs-keyword\\">return</span> renderedChildren &amp;&amp; React.Children.only(renderedChildren);\\n  }</code></pre>\\n</code></pre>\\n<p>三大模块都结束了，其中穿插着各种方法也介绍完了，除了<code>mergeDiff</code></p>\\n<hr>\\n<h3 id=\\"mergediff\\">mergeDiff</h3>\\n<p>对<a href=\\"#pai-xu-wen-ti\\">排序问题</a>的具体操作</p>\\n<pre><code class=\\"language-jsx\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">mergeDiff</span>(<span class=\\"hljs-params\\">\\n  prev: Array&lt;TransitionStyle&gt;,\\n  next: Array&lt;TransitionStyle&gt;,\\n  onRemove: (prevIndex: number, prevStyleCell: TransitionStyle</span>) =&gt; ?<span class=\\"hljs-title\\">TransitionStyle</span>\\n): <span class=\\"hljs-title\\">Array</span>&lt;<span class=\\"hljs-title\\">TransitionStyle</span>&gt; </span>{\\n  <span class=\\"hljs-comment\\">// 保存初始index的顺序，后面排序比较时使用</span>\\n  <span class=\\"hljs-keyword\\">let</span> prevKeyIndex: {[key: string]: number} = {};\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; prev.length; i++) {\\n    prevKeyIndex[prev[i].key] = i;\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> nextKeyIndex: {[key: string]: number} = {};\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; next.length; i++) {\\n    nextKeyIndex[next[i].key] = i;\\n  }\\n\\n  <span class=\\"hljs-comment\\">// 先保存所有next中的动画序列，再去处理prev中的 </span>\\n  <span class=\\"hljs-keyword\\">let</span> ret = [];\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; next.length; i++) {\\n    ret[i] = next[i];\\n  }\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; prev.length; i++) {\\n    <span class=\\"hljs-comment\\">// prev中有key的属性，而next中这个属性名无key，说明是要删除的</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">Object</span>.prototype.hasOwnProperty.call(nextKeyIndex, prev[i].key)) {\\n      <span class=\\"hljs-comment\\">// 如果已经删除，返回null，如果正在执行删除动画，返回状态</span>\\n      <span class=\\"hljs-keyword\\">const</span> fill = onRemove(i, prev[i]);\\n      <span class=\\"hljs-keyword\\">if</span> (fill != <span class=\\"hljs-literal\\">null</span>) {\\n        <span class=\\"hljs-comment\\">// 添加进ret</span>\\n        ret.push(fill);\\n      }\\n    }\\n  }\\n\\n  <span class=\\"hljs-comment\\">// ret就是所有要进行的动画，现在进行排序(4种情况，其实是3种，3和4相反)</span>\\n  <span class=\\"hljs-keyword\\">return</span> ret.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a, b</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">const</span> nextOrderA = nextKeyIndex[a.key];\\n    <span class=\\"hljs-keyword\\">const</span> nextOrderB = nextKeyIndex[b.key];\\n    <span class=\\"hljs-keyword\\">const</span> prevOrderA = prevKeyIndex[a.key];\\n    <span class=\\"hljs-keyword\\">const</span> prevOrderB = prevKeyIndex[b.key];\\n\\n    <span class=\\"hljs-comment\\">// 1. a,b都在next，按next的位置排序</span>\\n    <span class=\\"hljs-keyword\\">if</span> (nextOrderA != <span class=\\"hljs-literal\\">null</span> &amp;&amp; nextOrderB != <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">return</span> nextKeyIndex[a.key] - nextKeyIndex[b.key];\\n    <span class=\\"hljs-comment\\">// 2. a,b都在prev，按prev的位置排序</span>\\n    } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (prevOrderA != <span class=\\"hljs-literal\\">null</span> &amp;&amp; prevOrderB != <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-keyword\\">return</span> prevKeyIndex[a.key] - prevKeyIndex[b.key];\\n    <span class=\\"hljs-comment\\">// 3. a在next，b在prev</span>\\n    } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (nextOrderA != <span class=\\"hljs-literal\\">null</span>) {\\n      <span class=\\"hljs-comment\\">// 采取找中间值的办法，</span>\\n      <span class=\\"hljs-comment\\">// 例如</span>\\n      <span class=\\"hljs-comment\\">// 旧的：a, b, x</span>\\n      <span class=\\"hljs-comment\\">// 新的：c, b, d</span>\\n      <span class=\\"hljs-comment\\">// 初始ret顺序为： c-&gt;b-&gt;d-&gt;a-&gt;x</span>\\n      <span class=\\"hljs-comment\\">// a和x都不在新的里面，因此</span>\\n      <span class=\\"hljs-comment\\">// 如果判断 a 和 d 的顺序，找中间值 b， a&lt;b， d&gt;b， 因此 a-&gt;b-&gt;d</span>\\n      <span class=\\"hljs-comment\\">// 如果判断 x 和 d 的顺序，没有中间值，因此按照next放在后面  x-&gt;d</span>\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; next.length; i++) {\\n        <span class=\\"hljs-keyword\\">const</span> pivot = next[i].key;\\n        <span class=\\"hljs-comment\\">// prev没有这个中间值，跳过</span>\\n        <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">Object</span>.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {\\n          <span class=\\"hljs-keyword\\">continue</span>;\\n        }\\n        <span class=\\"hljs-comment\\">// next和prev都存在，判断之前的位置关系</span>\\n        <span class=\\"hljs-keyword\\">if</span> (nextOrderA &lt; nextKeyIndex[pivot] &amp;&amp; prevOrderB &gt; prevKeyIndex[pivot]) {\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>;\\n        } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (nextOrderA &gt; nextKeyIndex[pivot] &amp;&amp; prevOrderB &lt; prevKeyIndex[pivot]) {\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n        }\\n      }\\n      <span class=\\"hljs-comment\\">// 默认为next放后面</span>\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n    }\\n    <span class=\\"hljs-comment\\">// 4. b在next, a在prev, 和第3种情况相反</span>\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; next.length; i++) {\\n      <span class=\\"hljs-keyword\\">const</span> pivot = next[i].key;\\n      <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-built_in\\">Object</span>.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {\\n        <span class=\\"hljs-keyword\\">continue</span>;\\n      }\\n      <span class=\\"hljs-keyword\\">if</span> (nextOrderB &lt; nextKeyIndex[pivot] &amp;&amp; prevOrderA &gt; prevKeyIndex[pivot]) {\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n      } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (nextOrderB &gt; nextKeyIndex[pivot] &amp;&amp; prevOrderA &lt; prevKeyIndex[pivot]) {\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>;\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>;\\n  });\\n}</code></pre>\\n</code></pre>\\n<p>所有<code>react-motion</code>的分析就到此为止！</p>\\n<hr>\\n<p>react-motion流程导图\\n<img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-motion/react-motion.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"jie-shao","level":2,"text":"介绍"},{"anchor":"jie-gou","level":2,"text":"结构"},{"anchor":"3-da-mo-kuai-gong-gong-fang-fa","level":2,"text":"3大模块+公共方法"},{"anchor":"presets","level":3,"text":"presets"},{"anchor":"spring","level":3,"text":"spring"},{"anchor":"maptozero","level":3,"text":"mapToZero"},{"anchor":"stripstyle","level":3,"text":"stripStyle"},{"anchor":"motion","level":3,"text":"Motion"},{"anchor":"shouldstopanimation","level":3,"text":"shouldStopAnimation"},{"anchor":"stepper","level":3,"text":"stepper"},{"anchor":"staggeredmotion","level":3,"text":"StaggeredMotion"},{"anchor":"transitionmotion","level":3,"text":"TransitionMotion"},{"anchor":"pai-xu-wen-ti","level":4,"text":"排序问题"},{"anchor":"transitionmotion-can-shu","level":4,"text":"TransitionMotion参数"},{"anchor":"rehydratestyles","level":4,"text":"rehydrateStyles"},{"anchor":"mergeandsync","level":4,"text":"mergeAndSync"},{"anchor":"mergediff","level":3,"text":"mergeDiff"}],"relatedTags":["react","源码","算法"],"created_at":"2021-08-08","timeArr":[2021,7,8,11,45,40,0],"title":"源码阅读-react-motion","uuid":"f7719af5b1eadd4423c1b00da230569e16d39662","summary":"<h4>介绍</h4>\\n<p><code>react-motion</code>是一个react的动画组件，只需要为UI元素设置一个弹力和阻力和目标位置，便可渲染出符合现实的弹性动画效果</p>\\n<p>算法：</p>\\n<p>弹性算法，算法本身([stepper.js](https://github.com/stonehank/sourcecode-analysis/blob/ma...</p>","slug":"source-code-react-motion","sha":"b8d21fe030902ab5d37cc67bc1955e0e28545c9c"}')}}]);