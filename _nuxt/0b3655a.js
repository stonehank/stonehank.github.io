(window.webpackJsonp=window.webpackJsonp||[]).push([[1275],{2073:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">board</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> snakesAndLadders = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">board</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> N=board.length\\n  <span class=\\"hljs-keyword\\">let</span> moves=[<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-number\\">5</span>,<span class=\\"hljs-number\\">6</span>]\\n  <span class=\\"hljs-keyword\\">let</span> visited=<span class=\\"hljs-built_in\\">Array</span>(N*N+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-literal\\">false</span>)\\n  visited[<span class=\\"hljs-number\\">1</span>]=<span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">let</span> arr=[<span class=\\"hljs-number\\">1</span>], step=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> num=arr.shift()\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> n =<span class=\\"hljs-number\\">1</span>;n&lt;=<span class=\\"hljs-number\\">6</span>;n++){\\n        <span class=\\"hljs-keyword\\">let</span> curNum=num+n\\n        <span class=\\"hljs-keyword\\">if</span>(curNum&gt;N*N)<span class=\\"hljs-keyword\\">break</span>\\n        <span class=\\"hljs-keyword\\">if</span>(curNum===N*N)<span class=\\"hljs-keyword\\">return</span> step+<span class=\\"hljs-number\\">1</span>\\n        <span class=\\"hljs-keyword\\">if</span>(visited[curNum])<span class=\\"hljs-keyword\\">continue</span>\\n        visited[curNum]=<span class=\\"hljs-literal\\">true</span>\\n        <span class=\\"hljs-keyword\\">let</span> [x,y]=num2Pos(curNum)\\n        <span class=\\"hljs-keyword\\">if</span>(board[x][y]!==<span class=\\"hljs-number\\">-1</span>){\\n          <span class=\\"hljs-keyword\\">if</span>(board[x][y]===N*N)<span class=\\"hljs-keyword\\">return</span> step+<span class=\\"hljs-number\\">1</span>\\n          arr.push(board[x][y])\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n          arr.push(curNum)\\n        }\\n      }\\n    }\\n    step++\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">num2Pos</span>(<span class=\\"hljs-params\\">num</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> delta=num<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">let</span> dx=<span class=\\"hljs-built_in\\">Math</span>.floor(delta/N)\\n    <span class=\\"hljs-keyword\\">let</span> y=delta % N,x=N-dx<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">if</span>(dx % <span class=\\"hljs-number\\">2</span>===<span class=\\"hljs-number\\">1</span>)y=N-y<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">return</span> [x,y]\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"snakes-and-ladders","created_at":"2019-04-16","timeArr":[2019,3,16,19,53,50,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>由于每一次爬梯上升或者下降的位置都是以棋盘编号显示，因此我们需要一种方法<code>num2Pos</code>能将编号转换为<code>横纵坐标</code>，然后从编号<code>1</code>开始，\\n每次分别判断<code>+1</code>，<code>+2</code>，<code>+3</code>，<code>+4</code>，<code>+5</code>，<code>+6</code>后6种情况的编号应该是多少</p>\\n<p>如果编号<code>num</code>超过了<code>N*N</code>，说明越界了，<code>continue</code>；</p>\\n<p>如果编号不是<code>-1</code>，那么说明这个位置是需要跳转的，更新编号为跳转的编号；</p>\\n<p>如果编号已经达到<code>N*N</code>，说明到达终点，返回步数。</p>\\n<p>最终无法完成返回<code>-1</code>。</p>\\n","content":"<p>N x N 的棋盘 <code>board</code> 上，按从 <code>1</code> 到 <code>N*N</code> 的数字给方格编号，编号<strong> 从左下角开始</strong>，每一行交替方向。</p>\\n\\n<p>例如，一块 6 x 6 大小的棋盘，编号如下：</p>\\n\\n<pre>\\n<img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/31/snakes.png\\" style=\\"height: 200px; width: 254px;\\" />\\n</pre>\\n\\n<p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。</p>\\n\\n<p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p>\\n\\n<p>每一回合，玩家需要从当前方格 <code>x</code> 开始出发，按下述要求前进：</p>\\n\\n<ul>\\n\\t<li>选定目标方格：从编号为 <code>x+1</code>，<code>x+2</code>，<code>x+3</code>，<code>x+4</code>，<code>x+5</code>，或者 <code>x+6</code> 的方格中选出一个作为目标方格 <code>s</code> ，目标方格的编号 <code><= N*N</code>。\\n\\n\\t<ul>\\n\\t\\t<li>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 <code>[x+1, x+6]</code> 之间。</li>\\n\\t</ul>\\n\\t</li>\\n\\t<li>传送玩家：如果目标方格 <code>S</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>S</code> 。 </li>\\n</ul>\\n\\n<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p>\\n\\n<p>返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[\\n[-1,-1,-1,-1,-1,-1],\\n[-1,-1,-1,-1,-1,-1],\\n[-1,-1,-1,-1,-1,-1],\\n[-1,35,-1,-1,13,-1],\\n[-1,-1,-1,-1,-1,-1],\\n[-1,15,-1,-1,-1,-1]]\\n<strong>输出：</strong>4\\n<strong>解释：</strong>\\n首先，从方格 1 [第 5 行，第 0 列] 开始。\\n你决定移动到方格 2，并必须爬过梯子移动到到方格 15。\\n然后你决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13。\\n然后你决定移动到方格 14，且必须通过梯子移动到方格 35。\\n然后你决定移动到方格 36, 游戏结束。\\n可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>2 <= board.length = board[0].length <= 20</code></li>\\n\\t<li><code>board[i][j]</code> 介于 <code>1</code> 和 <code>N*N</code> 之间或者等于 <code>-1</code>。</li>\\n\\t<li>编号为 <code>1</code> 的方格上没有蛇或梯子。</li>\\n\\t<li>编号为 <code>N*N</code> 的方格上没有蛇或梯子。</li>\\n</ul>\\n","title":"909. 蛇梯棋","relatedTags":["广度优先搜索","数组","矩阵"],"difficult":"Middle","lang":["javascript"],"uniqueID":"909","slug":"909-Snakes-and-Ladders"}')}}]);