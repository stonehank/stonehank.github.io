(window.webpackJsonp=window.webpackJsonp||[]).push([[1116],{1914:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">L</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">R</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> countPrimeSetBits = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">L, R</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> primes = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Set</span>([<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-number\\">5</span>,<span class=\\"hljs-number\\">7</span>,<span class=\\"hljs-number\\">11</span>,<span class=\\"hljs-number\\">13</span>,<span class=\\"hljs-number\\">17</span>,<span class=\\"hljs-number\\">19</span>]);\\n  <span class=\\"hljs-keyword\\">let</span> cache={},res=<span class=\\"hljs-number\\">0</span>;\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=L;i&lt;=R;i++){\\n    <span class=\\"hljs-keyword\\">let</span> bc=<span class=\\"hljs-number\\">0</span>,tmp=i;\\n    <span class=\\"hljs-keyword\\">while</span>(tmp) {\\n      bc++;\\n      tmp = tmp &amp; (tmp - <span class=\\"hljs-number\\">1</span>);\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(primes.has(bc))res++\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"prime-number-of-set-bits-in-binary-representation","created_at":"2019-04-22","timeArr":[2019,3,22,13,38,11,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>首先定义一个<code>primes</code>保存<code>20</code>以内的质数(因为最大的数字不超过20位)，接着对每一个数字<code>i</code>，求出<code>1</code>的数量，然后检查是否质数。</p>\\n<p>一个优化点是通过<code>n &amp; (n-1)</code>，计算出一个数<code>n</code>的二进制中<code>1</code>的数量。</p>\\n<p>通过<code>n&amp;(n-1)</code>，每次可以减少这个数二进制中最右边的<code>1</code>。</p>\\n","content":"<p>给定两个整数&nbsp;<code>L</code>&nbsp;和&nbsp;<code>R</code>&nbsp;，找到闭区间&nbsp;<code>[L, R]</code>&nbsp;范围内，计算置位位数为质数的整数个数。</p>\\n\\n<p>（注意，计算置位代表二进制表示中1的个数。例如&nbsp;<code>21</code>&nbsp;的二进制表示&nbsp;<code>10101</code>&nbsp;有 3 个计算置位。还有，1 不是质数。）</p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> L = 6, R = 10\\n<strong>输出:</strong> 4\\n<strong>解释:</strong>\\n6 -&gt; 110 (2 个计算置位，2 是质数)\\n7 -&gt; 111 (3 个计算置位，3 是质数)\\n9 -&gt; 1001 (2 个计算置位，2 是质数)\\n10-&gt; 1010 (2 个计算置位，2 是质数)\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> L = 10, R = 15\\n<strong>输出:</strong> 5\\n<strong>解释:</strong>\\n10 -&gt; 1010 (2 个计算置位, 2 是质数)\\n11 -&gt; 1011 (3 个计算置位, 3 是质数)\\n12 -&gt; 1100 (2 个计算置位, 2 是质数)\\n13 -&gt; 1101 (3 个计算置位, 3 是质数)\\n14 -&gt; 1110 (3 个计算置位, 3 是质数)\\n15 -&gt; 1111 (4 个计算置位, 4 不是质数)\\n</pre>\\n\\n<p><strong>注意:</strong></p>\\n\\n<ol>\\n\\t<li><code>L, R</code>&nbsp;是&nbsp;<code>L &lt;= R</code>&nbsp;且在&nbsp;<code>[1, 10^6]</code>&nbsp;中的整数。</li>\\n\\t<li><code>R - L</code>&nbsp;的最大值为 10000。</li>\\n</ol>\\n","title":"762. 二进制表示中质数个计算置位","relatedTags":["位运算","数学"],"difficult":"Easy","lang":["javascript"],"uniqueID":"762","slug":"762-Prime-Number-of-Set-Bits-in-Binary-Representation"}')}}]);