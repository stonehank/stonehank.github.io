(window.webpackJsonp=window.webpackJsonp||[]).push([[1243],{2041:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">K</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> decodeAtIndex = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S, K</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> count=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> str=<span class=\\"hljs-string\\">\'\'</span>,stack=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;=S.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(i===S.length || <span class=\\"hljs-regexp\\">/\\\\d/</span>.test(S[i])){\\n      <span class=\\"hljs-keyword\\">if</span>(str!==<span class=\\"hljs-string\\">\'\'</span>){\\n        stack.push(str)\\n        count+=str.length\\n        str=<span class=\\"hljs-string\\">\'\'</span>  \\n        <span class=\\"hljs-keyword\\">if</span>(i===S.length)<span class=\\"hljs-keyword\\">break</span>\\n      }\\n      stack.push(S[i])\\n      count*=S[i]\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      str+=S[i]\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(count&gt;=K){\\n      <span class=\\"hljs-keyword\\">break</span>\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> dfs(stack,count,K)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">stack,count,K</span>)</span>{\\n    <span class=\\"hljs-comment\\">// console.log(stack,count,K)</span>\\n    <span class=\\"hljs-keyword\\">if</span>(K===<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=stack.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n        <span class=\\"hljs-keyword\\">if</span>(!<span class=\\"hljs-regexp\\">/\\\\d/</span>.test(stack[i])){\\n          <span class=\\"hljs-keyword\\">return</span> stack[i][stack[i].length<span class=\\"hljs-number\\">-1</span>]\\n        }\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> lastDel=<span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-keyword\\">while</span>(stack.length&gt;<span class=\\"hljs-number\\">0</span> &amp;&amp; count&gt;=K){\\n      lastDel=stack.pop()\\n      <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-regexp\\">/\\\\d/</span>.test(lastDel)){\\n        count/=lastDel\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        count-=lastDel.length\\n      }\\n      <span class=\\"hljs-comment\\">// console.log(lastDel,count)</span>\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-regexp\\">/\\\\d/</span>.test(lastDel)){\\n      <span class=\\"hljs-keyword\\">return</span> dfs(stack,count,K % count)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">return</span> lastDel[K-count<span class=\\"hljs-number\\">-1</span>]\\n    }\\n  }\\n\\n};\\n</code></pre>\\n"],"querySlug":"decoded-string-at-index","created_at":"2019-04-17","timeArr":[2019,3,17,17,13,30,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>首先计算长度<code>preLen</code>(遇到字母<code>+1</code>，遇到数字<code>*num</code>)，一旦<code>preLen</code>大于等于<code>K</code>，停止计算长度。</p>\\n<p>从上面停止的位置返回，</p>\\n<p>发现数字<code>preLen/=num</code>，并且更新<code>K %=preLen</code>；</p>\\n<p>发现是字符串，如果<code>K % N===0</code>说明结果就是当前字符，返回即可，否则<code>preLen--</code>。</p>\\n","content":"<p>给定一个编码字符串 <code>S</code>。请你找出<em> </em><strong>解码字符串</strong> 并将其写入磁带。解码时，从编码字符串中<strong> 每次读取一个字符 </strong>，并采取以下步骤：</p>\\n\\n<ul>\\n\\t<li>如果所读的字符是字母，则将该字母写在磁带上。</li>\\n\\t<li>如果所读的字符是数字（例如 <code>d</code>），则整个当前磁带总共会被重复写&nbsp;<code>d-1</code> 次。</li>\\n</ul>\\n\\n<p>现在，对于给定的编码字符串 <code>S</code> 和索引 <code>K</code>，查找并返回解码字符串中的第&nbsp;<code>K</code>&nbsp;个字母。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>S = &quot;leet2code3&quot;, K = 10\\n<strong>输出：</strong>&quot;o&quot;\\n<strong>解释：</strong>\\n解码后的字符串为 &quot;leetleetcodeleetleetcodeleetleetcode&quot;。\\n字符串中的第 10 个字母是 &quot;o&quot;。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>S = &quot;ha22&quot;, K = 5\\n<strong>输出：</strong>&quot;h&quot;\\n<strong>解释：</strong>\\n解码后的字符串为 &quot;hahahaha&quot;。第 5 个字母是 &quot;h&quot;。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>S = &quot;a2345678999999999999999&quot;, K = 1\\n<strong>输出：</strong>&quot;a&quot;\\n<strong>解释：</strong>\\n解码后的字符串为 &quot;a&quot; 重复 8301530446056247680 次。第 1 个字母是 &quot;a&quot;。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= S.length &lt;= 100</code></li>\\n\\t<li><code>S</code>&nbsp;只包含小写字母与数字 <code>2</code> 到 <code>9</code> 。</li>\\n\\t<li><code>S</code>&nbsp;以字母开头。</li>\\n\\t<li><code>1 &lt;= K &lt;= 10^9</code></li>\\n\\t<li>题目保证 <code>K</code> 小于或等于解码字符串的长度。</li>\\n\\t<li>解码后的字符串保证少于&nbsp;<code>2^63</code>&nbsp;个字母。</li>\\n</ul>\\n","title":"880. 索引处的解码字符串","relatedTags":["栈","字符串"],"difficult":"Middle","lang":["javascript"],"uniqueID":"880","slug":"880-Decoded-String-at-Index"}')}}]);