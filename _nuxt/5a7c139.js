(window.webpackJsonp=window.webpackJsonp||[]).push([[1071],{1869:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">path</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> simplifyPath = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">path</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> stack=[]\\n  <span class=\\"hljs-keyword\\">let</span> pathArr=path.split(<span class=\\"hljs-string\\">\'/\'</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;pathArr.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(pathArr[i]===<span class=\\"hljs-string\\">\'\'</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">if</span>(pathArr[i]===<span class=\\"hljs-string\\">\'.\'</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">if</span>(pathArr[i]===<span class=\\"hljs-string\\">\'..\'</span>){\\n      stack.pop()\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      stack.push(<span class=\\"hljs-string\\">\'/\'</span>+pathArr[i])\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">if</span>(stack.length===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-string\\">\'/\'</span>\\n  <span class=\\"hljs-keyword\\">return</span> stack.join(<span class=\\"hljs-string\\">\'\'</span>)\\n};\\n</code></pre>\\n"],"querySlug":"simplify-path","created_at":"2019-03-22","timeArr":[2019,2,22,19,31,13,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>先以<code>/</code>分割<code>path</code>。</p>\\n<p>用<code>stack</code>保存当前的路径，遇到<code>..</code>，则回退一级<code>stack.pop()</code>，如果不是<code>.</code>也不是<code>\'\'</code>，那么将当前路径名添加到<code>stack</code>。</p>\\n<p>最后再转换为字符串，开头添加<code>/</code>后返回结果。</p>\\n","content":"<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径 </strong>（以 <code>\'/\'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\\n\\n<p class=\\"MachineTrans-lang-zh-CN\\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>\'//\'</code>）都被视为单个斜杠 <code>\'/\'</code> 。 对于此问题，任何其他格式的点（例如，<code>\'...\'</code>）均被视为文件/目录名称。</p>\\n\\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\\n\\n<ul>\\n\\t<li>始终以斜杠 <code>\'/\'</code> 开头。</li>\\n\\t<li>两个目录名之间必须只有一个斜杠 <code>\'/\'</code> 。</li>\\n\\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>\'/\'</code> 结尾。</li>\\n\\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>\'.\'</code> 或 <code>\'..\'</code>）。</li>\\n</ul>\\n\\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>path = \\"/home/\\"\\n<strong>输出：</strong>\\"/home\\"\\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>path = \\"/../\\"\\n<strong>输出：</strong>\\"/\\"\\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>path = \\"/home//foo/\\"\\n<strong>输出：</strong>\\"/home/foo\\"\\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>path = \\"/a/./b/../../c/\\"\\n<strong>输出：</strong>\\"/c\\"\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= path.length <= 3000</code></li>\\n\\t<li><code>path</code> 由英文字母，数字，<code>\'.\'</code>，<code>\'/\'</code> 或 <code>\'_\'</code> 组成。</li>\\n\\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\\n</ul>\\n","title":"71. 简化路径","relatedTags":["栈","字符串"],"difficult":"Middle","lang":["javascript"],"uniqueID":"71","slug":"71-Simplify-Path"}')}}]);