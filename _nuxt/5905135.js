(window.webpackJsonp=window.webpackJsonp||[]).push([[674],{1472:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">buildings</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[][]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> getSkyline = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">buildings</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> vertexes=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;buildings.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [s,e,h]=buildings[i]\\n    vertexes.push([s,h,<span class=\\"hljs-number\\">0</span>],[e,h,<span class=\\"hljs-number\\">1</span>])\\n  }\\n  vertexes.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>{\\n    <span class=\\"hljs-comment\\">// 默认按从小到大排序</span>\\n    <span class=\\"hljs-keyword\\">if</span>(a[<span class=\\"hljs-number\\">0</span>]&lt;b[<span class=\\"hljs-number\\">0</span>])<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(a[<span class=\\"hljs-number\\">0</span>]&gt;b[<span class=\\"hljs-number\\">0</span>])<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-comment\\">// 都是S，从大到小</span>\\n      <span class=\\"hljs-keyword\\">if</span>(a[<span class=\\"hljs-number\\">2</span>]===<span class=\\"hljs-number\\">0</span> &amp;&amp; b[<span class=\\"hljs-number\\">2</span>]===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> b[<span class=\\"hljs-number\\">1</span>]-a[<span class=\\"hljs-number\\">1</span>]\\n      <span class=\\"hljs-comment\\">// 都是E，从小到大</span>\\n      <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(a[<span class=\\"hljs-number\\">2</span>]===<span class=\\"hljs-number\\">1</span> &amp;&amp; b[<span class=\\"hljs-number\\">2</span>]===<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> a[<span class=\\"hljs-number\\">1</span>]-b[<span class=\\"hljs-number\\">1</span>]\\n      <span class=\\"hljs-comment\\">// 一个S一个E，先S后E</span>\\n      <span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-keyword\\">if</span>(a[<span class=\\"hljs-number\\">2</span>]===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n        <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>\\n      }\\n    }\\n  })\\n  <span class=\\"hljs-keyword\\">let</span> pq=[],max=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> result=[]\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">bsEnd</span>(<span class=\\"hljs-params\\">arr,n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> lo=<span class=\\"hljs-number\\">0</span>,hi=arr.length<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">while</span>(lo&lt;hi){\\n      <span class=\\"hljs-keyword\\">let</span> mid=<span class=\\"hljs-built_in\\">Math</span>.floor((lo+hi)/<span class=\\"hljs-number\\">2</span>)\\n      <span class=\\"hljs-keyword\\">if</span>(arr[mid]&lt;n)lo=mid+<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">else</span> hi=mid\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> hi\\n  }  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">insert</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(pq.length===<span class=\\"hljs-number\\">0</span> || n&gt;=pq[pq.length<span class=\\"hljs-number\\">-1</span>]){\\n      pq.push(n)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      pq.splice(bsEnd(pq,n),<span class=\\"hljs-number\\">0</span>,n)\\n    }\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">remove</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    pq.splice(bsEnd(pq,n),<span class=\\"hljs-number\\">1</span>)\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getMax</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(pq.length===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">return</span> pq[pq.length<span class=\\"hljs-number\\">-1</span>]\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;vertexes.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [x,y,state]=vertexes[i]\\n    <span class=\\"hljs-keyword\\">if</span>(state===<span class=\\"hljs-number\\">0</span>){\\n      insert(y)\\n      <span class=\\"hljs-keyword\\">if</span>(y&gt;max){\\n        max=y\\n        result.push([x,y])\\n      }\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      remove(y)\\n      <span class=\\"hljs-keyword\\">let</span> curMax=getMax()\\n      <span class=\\"hljs-keyword\\">if</span>(y===max &amp;&amp; curMax!==max){\\n        max=curMax\\n        result.push([x,max])\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> result\\n};\\n</code></pre>\\n"],"querySlug":"the-skyline-problem","created_at":"2019-04-22","timeArr":[2019,3,22,15,34,30,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>重新构建建筑顶点数组，内部格式为<code>[x,y,state]</code>，<code>x</code>代表横坐标，<code>y</code>代表纵坐标，<code>state</code>代表当前是上升还是下降。</p>\\n<p>按<code>x</code>从小到大排序。</p>\\n<p>使用<code>优先队列</code>，添加每一个的高度<code>y</code>，并且维护一个变量<code>max</code>，用来保存当前顶点的最高的<code>y</code>。</p>\\n<p>当<code>state</code>表示上升时，首先添加<code>y</code>到优先队列<code>pq</code>，</p>\\n<p>如果当前的<code>y&gt;max</code>，说明有一幢房子超过原来最高的，需要添加当前的<code>[x,y]</code>；</p>\\n<p>如果当前<code>y&lt;=max</code>，说明这幢房子和原来最高的叠加了；</p>\\n<p>当<code>state</code>表示下降时，首先从<code>pq</code>中删除匹配的<code>y</code>。</p>\\n<p>如果当前<code>y===max</code>，说明最高的房子就到这个<code>x</code>为止，检查<code>pq</code>中的下一个最大的<code>y</code>，并且更新<code>max</code>，添加结果，如果不存在，则为0。</p>\\n<p>如果当前<code>y&lt;max</code>，说明这个被最高的房子遮挡住的一幢房子就到此<code>x</code>，不必再做任何事情。</p>\\n<p>排序时有3个边界情况：</p>\\n<ol>\\n<li>\\n<p>当<code>x</code>相同，并且同为<code>上升</code>状态，<code>y</code>更大的排前面，优先处理它那么<code>y</code>更小的就会被忽略。</p>\\n</li>\\n<li>\\n<p>当<code>x</code>相同，并且同为<code>下降</code>状态，<code>y</code>更小的排前面。</p>\\n</li>\\n<li>\\n<p>当<code>x</code>相同，一个<code>上升</code>，一个<code>下降</code>，那么先处理<code>上升</code>状态的房子，因为这种情况就是2幢房子合并在一起，下降的点可以忽略。</p>\\n</li>\\n</ol>\\n","content":"<p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的<strong> 天际线</strong> 。</p>\\n\\n<p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p>\\n\\n<ul>\\n\\t<li><code>left<sub>i</sub></code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。</li>\\n\\t<li><code>right<sub>i</sub></code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。</li>\\n\\t<li><code>height<sub>i</sub></code> 是第 <code>i</code> 座建筑物的高度。</li>\\n</ul>\\n\\n<p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式 <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code> ，并按 <strong>x 坐标 </strong>进行 <strong>排序</strong> 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点，<code>y</code> 坐标始终为 <code>0</code> ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>\\n\\n<p><strong>注意：</strong>输出天际线中不得有连续的相同高度的水平线。例如 <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\\" style=\\"width: 800px; height: 331px;\\" />\\n<pre>\\n<strong>输入：</strong>buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\\n<strong>输出：</strong>[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\\n<strong>解释：</strong>\\n图 A<strong> </strong>显示输入的所有建筑物的位置和高度，\\n图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>buildings = [[0,2,3],[2,5,3]]\\n<strong>输出：</strong>[[0,3],[5,0]]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= buildings.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>0 <= left<sub>i</sub> < right<sub>i</sub> <= 2<sup>31</sup> - 1</code></li>\\n\\t<li><code>1 <= height<sub>i</sub> <= 2<sup>31</sup> - 1</code></li>\\n\\t<li><code>buildings</code> 按 <code>left<sub>i</sub></code> 非递减排序</li>\\n</ul>\\n","title":"218. 天际线问题","relatedTags":["树状数组","线段树","数组","分治","有序集合","扫描线","堆（优先队列）"],"difficult":"Hard","lang":["javascript"],"uniqueID":"218","slug":"218-The-Skyline-Problem"}')}}]);