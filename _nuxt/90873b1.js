(window.webpackJsonp=window.webpackJsonp||[]).push([[855],{1653:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">points</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> numberOfBoomerangs = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">points</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;points.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [x1,y1]=points[i]\\n    <span class=\\"hljs-keyword\\">let</span> m=<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Map</span>()\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;points.length;j++){\\n      <span class=\\"hljs-keyword\\">if</span>(i===j)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">let</span> [x2,y2]=points[j]\\n      <span class=\\"hljs-keyword\\">let</span> dis=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)\\n      <span class=\\"hljs-keyword\\">if</span>(!m.has(dis))m.set(dis,<span class=\\"hljs-number\\">1</span>)\\n      <span class=\\"hljs-keyword\\">else</span> m.set(dis,m.get(dis)+<span class=\\"hljs-number\\">1</span>)\\n    }\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k <span class=\\"hljs-keyword\\">of</span> m){\\n      <span class=\\"hljs-keyword\\">let</span> v=k[<span class=\\"hljs-number\\">1</span>]\\n      res+=v*(v<span class=\\"hljs-number\\">-1</span>)\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"number-of-boomerangs","created_at":"2019-04-05","timeArr":[2019,3,5,16,27,49,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>双重循环，对每一个<code>points[i]</code>，通过<code>hash</code>找出其他<code>point</code>和它有多少个相同距离的。</p>\\n<p>对每一个<code>hash[k]</code>，执行<code>hash[k]*(hash[k]-1)</code>添加到结果。</p>\\n<p>例如：某一个点<code>p</code>，与它距离为4的有<code>3</code>个点，与它距离为7的有<code>5</code>个点；</p>\\n<p>那么距离4的<code>3</code>个点的组合就有<code>(1+2)*2</code>种，距离7的<code>5</code>个点的组合有<code>(1+2+3+4)*2</code>种</p>\\n<p>通过<code>等差序列</code>累加公式， <code>1+2+3+4+5+..+n=(1+n)*n/2</code>，因此<code>n</code>个点的组合就有<code>(1+n-1) * (n-1)/2 *2</code>，化简即为<code>n*(n-1)</code>。</p>\\n","content":"<p>给定平面上<em> </em><code>n</code><em> </em>对 <strong>互不相同</strong> 的点 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。<strong>回旋镖</strong> 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p>\\n\\n<p>返回平面上所有回旋镖的数量。</p>\\n \\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>points = [[0,0],[1,0],[2,0]]\\n<strong>输出：</strong>2\\n<strong>解释：</strong>两个回旋镖为 <strong>[[1,0],[0,0],[2,0]]</strong> 和 <strong>[[1,0],[2,0],[0,0]]</strong>\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>points = [[1,1],[2,2],[3,3]]\\n<strong>输出：</strong>2\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>points = [[1,1]]\\n<strong>输出：</strong>0\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>n == points.length</code></li>\\n\\t<li><code>1 <= n <= 500</code></li>\\n\\t<li><code>points[i].length == 2</code></li>\\n\\t<li><code>-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup></code></li>\\n\\t<li>所有点都 <strong>互不相同</strong></li>\\n</ul>\\n","title":"447. 回旋镖的数量","relatedTags":["数组","哈希表","数学"],"difficult":"Middle","lang":["javascript"],"uniqueID":"447","slug":"447-Number-of-Boomerangs"}')}}]);