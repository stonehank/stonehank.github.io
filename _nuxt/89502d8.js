(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{557:function(n){n.exports=JSON.parse('{"content":"<p>KMP算法中，当对应的字符不匹配时，需要对前一个索引进行回溯</p>\\n<p>一般写法是：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcNext</span>(<span class=\\"hljs-params\\">str,pat</span>)</span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">if</span>(str[k]!==str[j]){\\n    <span class=\\"hljs-comment\\">// 有些会写成k=next[k]，原理是一样的</span>\\n    <span class=\\"hljs-comment\\">// 这里k表示，所对应当前正在进行对比的索引</span>\\n    <span class=\\"hljs-comment\\">// k=next[k-1]表示找到k的前一位的公共匹配前后缀的数量，作为新的对比索引</span>\\n    k=next[k<span class=\\"hljs-number\\">-1</span>]\\n  }\\n}</code></pre></code></pre>\\n<p><img src=\\"/article/img/KPM%E5%9B%BE%E8%A7%A3.png\\" alt=\\"\\"></p>\\n<p>图中，当K和J不能匹配时，A和B是已经匹配的公共前后缀</p>\\n<p>因此A和B是完全相等</p>\\n<p>A内部的A1,A2是已经匹配的公共前后缀</p>\\n<p>B内部的B1,B2是已经匹配的公共前后缀</p>\\n<p>因此A1===A2===B1===B2</p>\\n<p>要想找到可能和J匹配的最大公共前后缀，只能找A的前缀(因为A的后缀连着k，而k不相等，所以k不能用了，只能找它前面的)，与J进行比较</p>\\n<p>也就是从<code>next[k-1]</code>开始匹配</p>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcNext</span>(<span class=\\"hljs-params\\">str</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>,k=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> next=[]\\n  next[<span class=\\"hljs-number\\">0</span>]=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(i &lt; str.length){\\n    <span class=\\"hljs-comment\\">// 不相等时</span>\\n    <span class=\\"hljs-keyword\\">if</span>(str[i]!==str[k]){\\n      <span class=\\"hljs-comment\\">// 如果k已经是0了(最小就是0)，直接设置成0</span>\\n      <span class=\\"hljs-keyword\\">if</span>(k===<span class=\\"hljs-number\\">0</span>)next[i++]=k\\n        <span class=\\"hljs-comment\\">// 否则就回溯到前一个公共前缀的位置</span>\\n      <span class=\\"hljs-keyword\\">else</span> {\\n        k=next[k<span class=\\"hljs-number\\">-1</span>]\\n      }\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-comment\\">// 相等，就直接在k的索引上+1，表示匹配的length</span>\\n      next[i]=k+<span class=\\"hljs-number\\">1</span>\\n      i++;\\n      k++;\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> next\\n}\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">kpm</span>(<span class=\\"hljs-params\\">str,pat</span>)</span>{\\n  <span class=\\"hljs-keyword\\">if</span>(pat.length===<span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> next=calcNext(pat)\\n  <span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>,j=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(i&lt;str.length ){\\n    <span class=\\"hljs-keyword\\">if</span>(str[i]===pat[j]){\\n      i++;j++\\n      <span class=\\"hljs-comment\\">// j===pat.length说明已经匹配成功</span>\\n      <span class=\\"hljs-keyword\\">if</span>(j===pat.length) <span class=\\"hljs-keyword\\">return</span> i-j\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(j===<span class=\\"hljs-number\\">0</span>){\\n        i++\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        j=next[j<span class=\\"hljs-number\\">-1</span>]\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n}</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-09","timeArr":[2018,7,9,0,0,0,0],"title":"KMP回溯分析","uuid":"d19b06a421c09a6a7e3d012ce39d42cf0cfc380b","summary":"<p>KMP算法中，当对应的字符不匹配时，需要对前一个索引进行回溯</p>\\n<p>一般写法是：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcNext</span>(<span class=\\"hljs-params\\">str,pat</span>)</span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-keyword\\">if</span>(str[k]!==str[j]){\\n    <span class=\\"hljs-comment\\">// 有些会写成k=next[k]，原理是一样的</span>\\n    <span class=\\"hljs-comment\\">// 这里k表示，所对应当前正在进行对比的...</span></code></pre>","slug":"KMP-hui-su-fen-xi","sha":"dcb12fd298b9d963db9b1d4b12cbff7da94227bc"}')}}]);