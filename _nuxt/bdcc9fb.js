(window.webpackJsonp=window.webpackJsonp||[]).push([[1214],{2012:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">A</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">B</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> kSimilarity = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">A, B</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(A===B)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">let</span> arr=[[B,<span class=\\"hljs-number\\">0</span>]]\\n  hash[B]=<span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">let</span> step=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> [cur,id]=arr.shift()\\n      <span class=\\"hljs-comment\\">// 对cur构建每个字母的索引</span>\\n      <span class=\\"hljs-keyword\\">let</span> letter2Idx={}\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;cur.length;i++){\\n        <span class=\\"hljs-keyword\\">if</span>(letter2Idx[cur[i]]==<span class=\\"hljs-literal\\">null</span>)letter2Idx[cur[i]]=[i]\\n        <span class=\\"hljs-keyword\\">else</span> letter2Idx[cur[i]].push(i)\\n      }\\n      <span class=\\"hljs-comment\\">// 找到从当前索引id开始，第一个不相符的索引</span>\\n      <span class=\\"hljs-keyword\\">while</span>(cur[id]===A[id])id++\\n      <span class=\\"hljs-keyword\\">let</span> swapIdxes=letter2Idx[A[id]]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;swapIdxes.length;j++){\\n        <span class=\\"hljs-keyword\\">let</span> swapId=swapIdxes[j]\\n        <span class=\\"hljs-keyword\\">if</span>(swapId&lt;=id)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-comment\\">// 交换得到新的字符串</span>\\n        <span class=\\"hljs-keyword\\">let</span> newStr=cur.substring(<span class=\\"hljs-number\\">0</span>,id)+cur[swapId]+\\n            cur.substring(id+<span class=\\"hljs-number\\">1</span>,swapId)+cur[id]+\\n            cur.substring(swapId+<span class=\\"hljs-number\\">1</span>)\\n        <span class=\\"hljs-keyword\\">if</span>(newStr===A)<span class=\\"hljs-keyword\\">return</span> step+<span class=\\"hljs-number\\">1</span>\\n        <span class=\\"hljs-keyword\\">if</span>(hash[newStr])<span class=\\"hljs-keyword\\">continue</span>\\n        hash[newStr]=<span class=\\"hljs-literal\\">true</span>\\n        arr.push([newStr,id+<span class=\\"hljs-number\\">1</span>])\\n      }\\n    }\\n    step++\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"k-similar-strings","created_at":"2019-04-16","timeArr":[2019,3,16,13,52,46,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这道题基本思想是<code>bfs</code>，也就是每次交换一对，然后不断遍历，但如果任意交换会<code>TLE</code>，优化的思路有2个：</p>\\n<ol>\\n<li>\\n<p><code>arr</code>初始值为<code>B</code>，对<code>arr</code>遍历每个字符串<code>arr[i]</code>，都新建一个<code>letter2Idx</code>保存<code>arr[i]</code>每个字母的索引，并且找到第一个与<code>B</code>不相符的索引，\\n替换它，返回一个新的字符串<code>newStr</code>，如果<code>hash[newStr]</code>不存在，则继续添加到<code>arr</code>中遍历。</p>\\n<p>例如 <code>arr[i]=&quot;abca&quot;，B=&quot;acba&quot;</code>，那么第一个不相符的就是索引<code>1</code>，<code>arr[i][1]=&quot;b&quot;, B[1]=&quot;c&quot;</code>，因此遍历<code>letter2Idx[&quot;c&quot;]</code>并且交换<code>arr[i]</code>中的<code>&quot;b&quot;</code>和<code>&quot;c&quot;</code>，\\n这里的<code>letter2Idx[&quot;c&quot;]</code>是一个保存了所有<code>&quot;c&quot;</code>的位置的数组。</p>\\n<p>接着下一次就从索引<code>3</code>开始检查。</p>\\n</li>\\n</ol>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">A</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">B</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> kSimilarity = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">A, B</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(A===B)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">let</span> arr=[[B,<span class=\\"hljs-number\\">0</span>]]\\n  hash[B]=<span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">let</span> step=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">while</span>(arr.length&gt;<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">let</span> len=arr.length\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;len;i++){\\n      <span class=\\"hljs-keyword\\">let</span> [cur,id]=arr.shift()\\n      <span class=\\"hljs-comment\\">// 对cur构建每个字母的索引</span>\\n      <span class=\\"hljs-keyword\\">let</span> letter2Idx={}\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;cur.length;i++){\\n        <span class=\\"hljs-keyword\\">if</span>(letter2Idx[cur[i]]==<span class=\\"hljs-literal\\">null</span>)letter2Idx[cur[i]]=[i]\\n        <span class=\\"hljs-keyword\\">else</span> letter2Idx[cur[i]].push(i)\\n      }\\n      <span class=\\"hljs-comment\\">// 找到从当前索引id开始，第一个不相符的索引</span>\\n      <span class=\\"hljs-keyword\\">while</span>(cur[id]===A[id])id++\\n      <span class=\\"hljs-keyword\\">let</span> swapIdxes=letter2Idx[A[id]]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;swapIdxes.length;j++){\\n        <span class=\\"hljs-keyword\\">let</span> swapId=swapIdxes[j]\\n        <span class=\\"hljs-keyword\\">if</span>(swapId&lt;=id)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-comment\\">// 交换得到新的字符串</span>\\n        <span class=\\"hljs-keyword\\">let</span> newStr=cur.substring(<span class=\\"hljs-number\\">0</span>,id)+cur[swapId]+\\n            cur.substring(id+<span class=\\"hljs-number\\">1</span>,swapId)+cur[id]+\\n            cur.substring(swapId+<span class=\\"hljs-number\\">1</span>)\\n        <span class=\\"hljs-keyword\\">if</span>(newStr===A)<span class=\\"hljs-keyword\\">return</span> step+<span class=\\"hljs-number\\">1</span>\\n        <span class=\\"hljs-keyword\\">if</span>(hash[newStr])<span class=\\"hljs-keyword\\">continue</span>\\n        hash[newStr]=<span class=\\"hljs-literal\\">true</span>\\n        arr.push([newStr,id+<span class=\\"hljs-number\\">1</span>])\\n      }\\n    }\\n    step++\\n  }\\n};\\n</code></pre>\\n<ol start=\\"2\\">\\n<li>同样是交换第一个不相符的字母，交换成功后，<code>cur[i]</code>一定和<code>A[i]</code>相等，这时候检查<code>cur[j]</code>和<code>A[j]</code>是否相等，\\n如果两者相等，说明这是一个完美的交换，将<code>newStr</code>添加到<code>arr</code>的头部，下一次继续遍历它(相当于对它进行<code>dfs</code>)。</li>\\n</ol>\\n","content":"<p>如果可以通过将 <code>A</code> 中的两个小写字母精确地交换位置 <code>K</code> 次得到与 <code>B</code> 相等的字符串，我们称字符串&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;的相似度为 <code>K</code>（<code>K</code>&nbsp;为非负整数）。</p>\\n\\n<p>给定两个字母异位词&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;，返回 <code>A</code> 和 <code>B</code>&nbsp;的相似度 <code>K</code> 的最小值。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>A = &quot;ab&quot;, B = &quot;ba&quot;\\n<strong>输出：</strong>1\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>A = &quot;abc&quot;, B = &quot;bca&quot;\\n<strong>输出：</strong>2\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>A = &quot;abac&quot;, B = &quot;baca&quot;\\n<strong>输出：</strong>2\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre><strong>输入：</strong>A = &quot;aabc&quot;, B = &quot;abca&quot;\\n<strong>输出：</strong>2</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= A.length == B.length &lt;= 20</code></li>\\n\\t<li><code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;只包含集合&nbsp;<code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>&nbsp;中的小写字母。</li>\\n</ol>\\n","title":"854. 相似度为 K 的字符串","relatedTags":["广度优先搜索","字符串"],"difficult":"Hard","lang":["javascript"],"uniqueID":"854","slug":"854-K-Similar-Strings"}')}}]);