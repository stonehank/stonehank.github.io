(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{582:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"yue-du-qian-ti\\">阅读前提</h2>\\n<ol>\\n<li>有rxjs基础，对<code>Observable</code>, <code>Subject</code>,<code>pipe</code>和一些操作符(例如<code>filter</code>,<code>map</code>,<code>merge</code>,<code>mergeMap</code>)执行流程有基本了解，最起码遇到不清楚有去查阅的动力</li>\\n<li>比较熟悉<code>redux</code>中间件的写法，否则像<code>createEpicMiddleware.js</code>中的这一段会搞不清楚<pre><code><pre class=\\"hljs\\"><code> return next =&gt; {\\n   return action =&gt; {</code></pre></code></pre> 关于redux也可以查阅我之前写的<a href=\\"https://github.com/stonehank/sourcecode-analysis/tree/master/source-code.redux\\">redux源码注释</a></li>\\n</ol>\\n<h2 id=\\"mu-lu-jie-gou\\">目录结构</h2>\\n<pre><code><pre class=\\"hljs\\"><code>src/\\n├──utils/\\n    ├──console.js\\n├── ActionsObservable.js    // 自定义的类，继承Observable, 绑定了操作符的链式调用\\n├── combineEpics.js         // \\n├── createEpicMiddleware.js // 调用可生成redux的中间件, 通过run绑定需要执行的流\\n├── index.js                // 对外接口\\n├── operators.js            // 自定义的流操作方法, 目前只有ofType\\n├── StateObservable.js      // 自定义的类，继承Observable, 用于保存当前state</code></pre></code></pre><h2 id=\\"yuan-ma-fen-xi\\">源码分析</h2>\\n<p>index.js：公开接口，略</p>\\n<hr>\\n<h3 id=\\"actionobservablejs\\">ActionObservable.js</h3>\\n<p>继承了<code>Observable</code>类</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">ActionsObservable</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Observable</span></span></code></pre></code></pre>\\n<p>定义了两个静态函数，用调用的对象包装了原来的<code>of</code>和<code>from</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">of</span>(...actions) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-keyword\\">this</span>(<span class=\\"hljs-keyword\\">of</span>(...actions));\\n  }\\n  <span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">from</span>(actions, scheduler) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-keyword\\">this</span>(<span class=\\"hljs-keyword\\">from</span>(actions, scheduler));\\n  }</code></pre></code></pre>\\n<p>构造函数，定义了<code>source</code>属性为参数，这个属性用来绑定操作符的链式调用</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">constructor</span>(actionsSubject) {\\n    <span class=\\"hljs-keyword\\">super</span>();\\n    <span class=\\"hljs-keyword\\">this</span>.source = actionsSubject;\\n  }</code></pre></code></pre>\\n<p>这里重写了父类(Observable)的<code>lift</code>，先看一下父类的<code>lift</code>是怎样的</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> observable = <span class=\\"hljs-keyword\\">new</span> Observable();\\nobservable.source = <span class=\\"hljs-keyword\\">this</span>;\\nobservable.operator = operator;\\n<span class=\\"hljs-keyword\\">return</span> observable;</code></pre></code></pre>\\n<p>可以看到改动就在于原来的用<code>new Observable</code>，这里使用<code>new ActionObservable()</code>，其他都是一模一样，\\n封装成<code>ActionObservable</code>类的意义，统一类型，方便后面的链式绑定</p>\\n<p><code>lift</code>在<code>pipe</code>的时候会用到，其实这都是rxjs源码调用的方式()</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>lift(operator) {\\n <span class=\\"hljs-keyword\\">const</span> observable = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(<span class=\\"hljs-keyword\\">this</span>);\\n observable.operator = operator;\\n <span class=\\"hljs-keyword\\">return</span> observable;\\n}</code></pre></code></pre>\\n<p>定义了一个操作方法<code>ofType</code>，具体见operators</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  ofType(...keys) {\\n    <span class=\\"hljs-keyword\\">return</span> ofType(...keys)(<span class=\\"hljs-keyword\\">this</span>);\\n  }</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"combineepicsjs\\">combineEpics.js</h3>\\n<p>将多个epic合并成1个epic，就是分别执行每一个epic(绑定用户定义的操作符)，然后将每一个结果的流用merge合并</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 引入merge</span>\\n<span class=\\"hljs-keyword\\">import</span> { merge } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs\'</span>;\\n\\n<span class=\\"hljs-comment\\">/**\\n  Merges all epics into a single one.\\n */</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> combineEpics = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...epics</span>) =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// 通过merge操作符合并多个epic执行后的output$流</span>\\n  <span class=\\"hljs-comment\\">// ...epics是多个epic</span>\\n  <span class=\\"hljs-keyword\\">const</span> merger = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...args</span>) =&gt;</span> merge(\\n    ...epics.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">epic</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 执行每一个epic，确保有返回值，此处执行就是绑定了用户自定义操作符的步骤</span>\\n      <span class=\\"hljs-keyword\\">const</span> output$ = epic(...args);\\n      <span class=\\"hljs-keyword\\">if</span> (!output$) {\\n        <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">`combineEpics: one of the provided Epics \\"<span class=\\"hljs-subst\\">${epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>}</span>\\" does not return a stream. Double check you\\\\\'re not missing a return statement!`</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 返回结果，最后进行merge合并</span>\\n      <span class=\\"hljs-keyword\\">return</span> output$;\\n    })\\n  );\\n\\n  <span class=\\"hljs-comment\\">// Technically the `name` property on Function\'s are supposed to be read-only.</span>\\n  <span class=\\"hljs-comment\\">// While some JS runtimes allow it anyway (so this is useful in debugging)</span>\\n  <span class=\\"hljs-comment\\">// some actually throw an exception when you attempt to do so.</span>\\n  <span class=\\"hljs-keyword\\">try</span> {\\n    <span class=\\"hljs-built_in\\">Object</span>.defineProperty(merger, <span class=\\"hljs-string\\">\'name\'</span>, {\\n      <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">`combineEpics(<span class=\\"hljs-subst\\">${epics.map(epic =&gt; epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>).join(<span class=\\"hljs-string\\">\', \'</span>)}</span>)`</span>,\\n    });\\n  } <span class=\\"hljs-keyword\\">catch</span> (e) {}\\n\\n  <span class=\\"hljs-keyword\\">return</span> merger;\\n};</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"createepicmiddlewarejs\\">createEpicMiddleware.js</h3>\\n<p>一、提示目前参数不在接受<code>rootEpic</code>，而是使用<code>epicMiddleware.run(rootEpic)</code>，这里<code>epicMiddleware</code>就是执行<code>createEpicMiddleware</code>的返回值</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; <span class=\\"hljs-keyword\\">typeof</span> options === <span class=\\"hljs-string\\">\'function\'</span>) {\\n    <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">\'Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\\\n\\\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware\'</span>);\\n  }\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n}</code></pre></code></pre>\\n<p>二、这一定义了几个重要变量(流)，这里一个重要问题</p>\\n<pre><code><pre class=\\"hljs\\"><code>1. rxjs内部的source是什么(在ActionObservable内部出现)\\n2. rxjs内部的operator是什么(在ActionObservable内部出现)\\nA：source定义了操作符执行的流向，operator定义了操作符是什么操作符，这两者结合使用来进行链式绑定</code></pre></code></pre><p>接着看注释</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-comment\\">// 定义一个Subject，绑定内部操作流，通过调用epic$.next()，也就是`epicMiddleware.run`来初始化action$的绑定</span>\\n  <span class=\\"hljs-keyword\\">const</span> epic$ = <span class=\\"hljs-keyword\\">new</span> Subject();\\n  <span class=\\"hljs-keyword\\">let</span> store;\\n  <span class=\\"hljs-comment\\">// 作为redux的中间件，其中epicMiddleware是返回值作为外部API</span>\\n  <span class=\\"hljs-keyword\\">const</span> epicMiddleware = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">_store</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 当在开发环境并且多次使用不同的 createEpicMiddleware返回值，会提出警告(避免重复执行多次)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; store) {\\n      <span class=\\"hljs-comment\\">// https://github.com/redux-observable/redux-observable/issues/389</span>\\n      <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./utils/console\'</span>).warn(<span class=\\"hljs-string\\">\'this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\\\n\\\\nLearn more: https://goo.gl/2GQ7Da\'</span>);\\n    }\\n    store = _store;\\n    <span class=\\"hljs-comment\\">// 定义一个Subject，绑定了队列调度器 (后面这个用来绑定所有操作流)</span>\\n    <span class=\\"hljs-keyword\\">const</span> actionSubject$ = <span class=\\"hljs-keyword\\">new</span> Subject().pipe(\\n      <span class=\\"hljs-comment\\">// todo 调度器，看了一些资料，还有有点模糊</span>\\n      observeOn(queueScheduler)\\n    );\\n    <span class=\\"hljs-comment\\">//  定义一个Subject，绑定了队列调度器 (后面这个用来对比当前store，防止重复渲染)</span>\\n    <span class=\\"hljs-keyword\\">const</span> stateSubject$ = <span class=\\"hljs-keyword\\">new</span> Subject().pipe(\\n      observeOn(queueScheduler)\\n    );\\n    <span class=\\"hljs-comment\\">// 定义一个ActionsObservable，用来绑定用户定义的操作流</span>\\n    <span class=\\"hljs-keyword\\">const</span> action$ = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(actionSubject$);\\n    <span class=\\"hljs-comment\\">// 定义一个StateObservable，内部改写了Observable的_subscribe方法，并且让stateSubject$绑定了value对比操作，就是简单的引用对比`===`</span>\\n    <span class=\\"hljs-keyword\\">const</span> state$ = <span class=\\"hljs-keyword\\">new</span> StateObservable(stateSubject$, store.getState());\\n\\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n  }\\n}</code></pre></code></pre>\\n<p>三、这里是核心，所有流和操作符的绑定就是在此内部进行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n\\n  <span class=\\"hljs-comment\\">// pipe操作符</span>\\n<span class=\\"hljs-keyword\\">const</span> result$ = epic$.pipe(\\n  <span class=\\"hljs-comment\\">// 对发射源逐个处理</span>\\n  map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">epic</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 如果配置有 dependencies 就放置到第三个参数中</span>\\n    <span class=\\"hljs-keyword\\">const</span> output$ = <span class=\\"hljs-string\\">\'dependencies\'</span> <span class=\\"hljs-keyword\\">in</span> options\\n      ? epic(action$, state$, options.dependencies)\\n      : epic(action$, state$);\\n    <span class=\\"hljs-comment\\">// 无返回值，报错，应该要返回一个不同的流</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!output$) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">`Your root Epic \\"<span class=\\"hljs-subst\\">${epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>}</span>\\" does not return a stream. Double check you\\\\\'re not missing a return statement!`</span>);\\n    }\\n    <span class=\\"hljs-comment\\">// output$ 是一个ActionObservable类型的流</span>\\n    <span class=\\"hljs-keyword\\">return</span> output$;\\n  }),\\n  <span class=\\"hljs-comment\\">// 对所有外部流，绑定队列调度并且使用mergeMap重新subscribe</span>\\n  mergeMap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">output$</span> =&gt;</span>\\n    <span class=\\"hljs-keyword\\">from</span>(output$).pipe(\\n      subscribeOn(queueScheduler),\\n      observeOn(queueScheduler)\\n    )\\n  )\\n);\\n\\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n}\\n</code></pre></code></pre>\\n<p>四、epic执行主要流程，<code>dispatch(action$)</code>--&gt; <code>actionSubject$.next(action)</code>--&gt;经过一系列操作符--&gt;最后到达底层<code>dispatch(state)</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n<span class=\\"hljs-comment\\">/*...*/</span>\\n\\n<span class=\\"hljs-comment\\">// 订阅 dispatch，此处将dispath作为流执行的最底层</span>\\nresult$.subscribe(store.dispatch);\\n\\n<span class=\\"hljs-comment\\">// 返回的格式是按照redux中间件的格式</span>\\n<span class=\\"hljs-comment\\">// 里面的内容都是运行时redux里dispatch后会执行的流程</span>\\n<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">next</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 此处先截取next(action)</span>\\n    <span class=\\"hljs-keyword\\">const</span> result = next(action);\\n    <span class=\\"hljs-comment\\">// 先执行 stateSubject$.next 可以保证state的更新</span>\\n    stateSubject$.next(store.getState());\\n    <span class=\\"hljs-comment\\">// 操作符按步骤执行，此时的actionSubject$已经绑定了所有的操作符</span>\\n    actionSubject$.next(action);\\n    <span class=\\"hljs-keyword\\">return</span> result;\\n  };\\n};\\n<span class=\\"hljs-comment\\">// run方法，通过epic$的next方法初始化action(见第三)，从而绑定用户自定义的操作符</span>\\nepicMiddleware.run = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">rootEpic</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; !store) {\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./utils/console\'</span>).warn(<span class=\\"hljs-string\\">\'epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.\'</span>);\\n  }\\n    <span class=\\"hljs-comment\\">// rootEpic就是用户自定义的操作符</span>\\n  epic$.next(rootEpic);\\n};\\n<span class=\\"hljs-keyword\\">return</span> epicMiddleware;\\n}</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"operatorsjs\\">operators.js</h3>\\n<p>定义了<code>ofType</code>，其实就是一个filter</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 引入filter</span>\\n<span class=\\"hljs-keyword\\">import</span> { filter } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs/operators\'</span>;\\n<span class=\\"hljs-comment\\">// 这里type就是传给epic的action的type的值，key就是用户自定义需要过滤的值</span>\\n<span class=\\"hljs-keyword\\">const</span> keyHasType = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">type, key</span>) =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> type === key || <span class=\\"hljs-keyword\\">typeof</span> key === <span class=\\"hljs-string\\">\'function\'</span> &amp;&amp; type === key.toString();\\n};\\n<span class=\\"hljs-comment\\">// source就是调用ofType的流，也就是createEpicMiddleware里的action$</span>\\n<span class=\\"hljs-comment\\">// 结果只有返回true才会继续链式调用</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> ofType = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...keys</span>) =&gt;</span> <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">source</span>) =&gt;</span> source.pipe(\\n  filter(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">{ type }</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">const</span> len = keys.length;\\n    <span class=\\"hljs-keyword\\">if</span> (len === <span class=\\"hljs-number\\">1</span>) {\\n      <span class=\\"hljs-keyword\\">return</span> keyHasType(type, keys[<span class=\\"hljs-number\\">0</span>]);\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; len; i++) {\\n        <span class=\\"hljs-keyword\\">if</span> (keyHasType(type, keys[i])) {\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n        }\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  })\\n);</code></pre></code></pre>\\n<hr>\\n<h3 id=\\"stateobservablejs\\">StateObservable.js</h3>\\n<p>继承<code>Observable</code>，定义了一个保存状态的类，里面改写了父类(<code>Observable</code>)的<code>_subscribe</code>(作用不太清楚)，\\n并且定义了一个保存当前数据状态的函数，通过stateSubject(也就是createEpicMiddleware里面的<code>stateSubject$</code>)的<code>subscribe</code>绑定到底层</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> { Observable, Subject } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs\'</span>;\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">StateObservable</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Observable</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(stateSubject, initialState) {\\n    <span class=\\"hljs-comment\\">// 调用父类构造函数，改写父类的_subscribe</span>\\n    <span class=\\"hljs-comment\\">// todo 作用？</span>\\n    <span class=\\"hljs-keyword\\">super</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">subscriber</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">const</span> subscription = <span class=\\"hljs-keyword\\">this</span>.__notifier.subscribe(subscriber);\\n      <span class=\\"hljs-keyword\\">if</span> (subscription &amp;&amp; !subscription.closed) {\\n        subscriber.next(<span class=\\"hljs-keyword\\">this</span>.value);\\n      }\\n      <span class=\\"hljs-keyword\\">return</span> subscription;\\n    });\\n\\n    <span class=\\"hljs-keyword\\">this</span>.value = initialState;\\n     <span class=\\"hljs-keyword\\">this</span>.__notifier = <span class=\\"hljs-keyword\\">new</span> Subject();\\n      <span class=\\"hljs-comment\\">// 绑定一个引用比较的状态函数</span>\\n     <span class=\\"hljs-keyword\\">this</span>.__subscription = stateSubject.subscribe(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">value</span> =&gt;</span> {\\n       <span class=\\"hljs-keyword\\">if</span> (value !== <span class=\\"hljs-keyword\\">this</span>.value) {\\n         <span class=\\"hljs-keyword\\">this</span>.value = value;\\n         <span class=\\"hljs-keyword\\">this</span>.__notifier.next(value);\\n       }\\n     });\\n   }\\n }</code></pre></code></pre>\\n<p>源码就到此分析完了，看到这里可能还是一头雾水，知道是什么也只是概念上的知道，对整个流程还是没有头绪</p>\\n<p><a href=\\"https://github.com/stonehank/sourcecode-analysis/blob/master/source-code.redux-observable/README.md\\">查看更多关于流程分析</a></p>\\n","toc":[{"anchor":"yue-du-qian-ti","level":2,"text":"阅读前提"},{"anchor":"mu-lu-jie-gou","level":2,"text":"目录结构"},{"anchor":"yuan-ma-fen-xi","level":2,"text":"源码分析"},{"anchor":"actionobservablejs","level":3,"text":"ActionObservable.js"},{"anchor":"combineepicsjs","level":3,"text":"combineEpics.js"},{"anchor":"createepicmiddlewarejs","level":3,"text":"createEpicMiddleware.js"},{"anchor":"operatorsjs","level":3,"text":"operators.js"},{"anchor":"stateobservablejs","level":3,"text":"StateObservable.js"}],"relatedTags":null,"created_at":"2018-07-31","timeArr":[2018,6,31,0,0,0,0],"title":"从源码理解redux-observable","uuid":"11c12164597745ff2b79b9aa256465683ed63ab6","summary":"<h4>阅读前提：</h4>\\n<ol>\\n<li>有rxjs基础，对<code>Observable</code>, <code>Subject</code>,<code>pipe</code>和一些操作符(例如<code>filter</code>,<code>map</code>,<code>merge</code>,<code>mergeMap</code>)执行流程有基本了解，最起码遇到不清楚有去查阅的动力</li>\\n<li>比较熟悉<code>redux</code>中间件的写法，否则像`createEpicMidd...</li>\\n</ol>","slug":"cong-yuan-ma-li-jie-redux-observable","sha":"6e85cade1d479e41467fc8f31c7cce1b2d0eca18"}')}}]);