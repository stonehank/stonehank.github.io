(window.webpackJsonp=window.webpackJsonp||[]).push([[952],{1750:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">wall</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> leastBricks = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">wall</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={},maxCross=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;wall.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> sum=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;wall[i].length<span class=\\"hljs-number\\">-1</span>;j++){\\n      sum+=wall[i][j]\\n      <span class=\\"hljs-keyword\\">if</span>(hash[sum]==<span class=\\"hljs-literal\\">null</span>)hash[sum]=<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">else</span> hash[sum]++\\n      maxCross=<span class=\\"hljs-built_in\\">Math</span>.max(maxCross,hash[sum])\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> wall.length-maxCross\\n  \\n};\\n</code></pre>\\n"],"querySlug":"brick-wall","created_at":"2019-04-06","timeArr":[2019,3,6,11,54,46,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>要找出穿过的墙最少的垂线，就是要找出能穿过空隙最多的垂线，而不难发现，这些空隙就是每一行砖的前缀和；</p>\\n<p>例如某一行砖：<code>[1,3,2,3,5]</code>，那么它的空隙位置就是<code>[1,4,6,9,14]</code>。</p>\\n<p>题目说明头尾不能用，因此每一行的前缀和只需要遍历到<code>wall[i].length-1</code>。</p>\\n<p>因此，题目转化成找频率最多的<code>前缀和</code>，用<code>hash</code>保存每一行的前缀和，最后返回<code>wall.length-maxCross</code>。</p>\\n","content":"<p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p>\\n\\n<p>你现在要画一条 <strong>自顶向下 </strong>的、穿过 <strong>最少 </strong>砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>\\n\\n<p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\\" style=\\"width: 493px; height: 577px;\\" />\\n<pre>\\n<strong>输入：</strong>wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\\n<strong>输出：</strong>2\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>wall = [[1],[1],[1]]\\n<strong>输出：</strong>3\\n</pre>\\n \\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>n == wall.length</code></li>\\n\\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\\n\\t<li><code>1 <= wall[i].length <= 10<sup>4</sup></code></li>\\n\\t<li><code>1 <= sum(wall[i].length) <= 2 * 10<sup>4</sup></code></li>\\n\\t<li>对于每一行 <code>i</code> ，<code>sum(wall[i])</code> 是相同的</li>\\n\\t<li><code>1 <= wall[i][j] <= 2<sup>31</sup> - 1</code></li>\\n</ul>\\n","title":"554. 砖墙","relatedTags":["数组","哈希表"],"difficult":"Middle","lang":["javascript"],"uniqueID":"554","slug":"554-Brick-Wall"}')}}]);