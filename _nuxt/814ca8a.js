(window.webpackJsonp=window.webpackJsonp||[]).push([[1100],{1898:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">grid</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> cherryPickup = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">grid</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> r=grid.length\\n  <span class=\\"hljs-keyword\\">let</span> moves=[[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>],[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">-1</span>]]\\n  <span class=\\"hljs-keyword\\">let</span> mem=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;r;i++){\\n    mem[i]=[]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;r;j++){\\n      mem[i][j]=[]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">0</span>;k&lt;r;k++){\\n        mem[i][j][k]=-<span class=\\"hljs-literal\\">Infinity</span>\\n      }\\n    }\\n  }\\n\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max(dfs(r<span class=\\"hljs-number\\">-1</span>,r<span class=\\"hljs-number\\">-1</span>,r<span class=\\"hljs-number\\">-1</span>),<span class=\\"hljs-number\\">0</span>)\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">x1,y1,x2</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> y2=x1+y1-x2\\n    <span class=\\"hljs-keyword\\">if</span>(x1===<span class=\\"hljs-number\\">0</span> &amp;&amp; y1===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> grid[<span class=\\"hljs-number\\">0</span>][<span class=\\"hljs-number\\">0</span>]\\n    <span class=\\"hljs-keyword\\">if</span>(x1&lt;<span class=\\"hljs-number\\">0</span> || y1&lt;<span class=\\"hljs-number\\">0</span> || x2&lt;<span class=\\"hljs-number\\">0</span> || y2&lt;<span class=\\"hljs-number\\">0</span>  )<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">if</span>(grid[x1][y1]&lt;<span class=\\"hljs-number\\">0</span> || grid[x2][y2]&lt;<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">if</span>(mem[x1][y1][x2]!==-<span class=\\"hljs-literal\\">Infinity</span>)<span class=\\"hljs-keyword\\">return</span> mem[x1][y1][x2]\\n\\n    <span class=\\"hljs-keyword\\">let</span> res=-<span class=\\"hljs-literal\\">Infinity</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [dx1,dy1] <span class=\\"hljs-keyword\\">of</span> moves){\\n      <span class=\\"hljs-keyword\\">let</span> np1x=dx1+x1,np1y=dy1+y1\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [dx2,dy2] <span class=\\"hljs-keyword\\">of</span> moves){\\n        <span class=\\"hljs-keyword\\">let</span> np2x=dx2+x2\\n        res=<span class=\\"hljs-built_in\\">Math</span>.max(res,dfs(np1x,np1y,np2x))\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(res&lt;<span class=\\"hljs-number\\">0</span>){\\n      mem[x1][y1][x2]=<span class=\\"hljs-number\\">-1</span>\\n      <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(grid[x1][y1]===<span class=\\"hljs-number\\">1</span>) res++\\n    <span class=\\"hljs-keyword\\">if</span>(grid[x2][y2]===<span class=\\"hljs-number\\">1</span>) res++\\n    <span class=\\"hljs-keyword\\">if</span>(grid[x1][y1]===<span class=\\"hljs-number\\">1</span> &amp;&amp; x1===x2 &amp;&amp; y1===y2)res--\\n    \\n    mem[x1][y1][x2]=res\\n    <span class=\\"hljs-keyword\\">return</span> res\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"cherry-pickup","created_at":"2019-03-07","timeArr":[2019,2,7,19,36,24,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这道题初一看有点像<code>路径最大和</code>问题，但细想不能这么做，因为走完第一次，摘取的樱桃会消失，\\n因此子问题互相有影响。</p>\\n<p>思路：</p>\\n<ol>\\n<li>走2次，由于走完第一次，摘取的樱桃会消失，因此不能使用单程DP*2，因为子问题互相有影响。</li>\\n<li>可以看成是2个人一起从左上走到右下，或者从右下走到左上。</li>\\n<li>由于2个人是同步行走，因此任何一方超出规则，都视为无效路径。</li>\\n<li>当他们走到同一格，只能摘取1个樱桃。</li>\\n<li>使用mem记录他们走过的格子不必重复计算，复杂度从指数降到3次方</li>\\n</ol>\\n","content":"<p>一个N x N的网格<code>(grid)</code>&nbsp;代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p>\\n\\n<ul>\\n\\t<li>0 表示这个格子是空的，所以你可以穿过它。</li>\\n\\t<li>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>\\n\\t<li>-1 表示这个格子里有荆棘，挡着你的路。</li>\\n</ul>\\n\\n<p>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p>\\n\\n<ul>\\n\\t<li>从位置&nbsp;(0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；</li>\\n\\t<li>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；</li>\\n\\t<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；</li>\\n\\t<li>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。</li>\\n</ul>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> grid =\\n[[0, 1, -1],\\n [1, 0, -1],\\n [1, 1,  1]]\\n<strong>输出:</strong> 5\\n<strong>解释：</strong> \\n玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。\\n在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。\\n接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。\\n在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。\\n</pre>\\n\\n<p><strong>说明:</strong></p>\\n\\n<ul>\\n\\t<li><code>grid</code> 是一个&nbsp;<code>N</code> * <code>N</code> 的二维数组，N的取值范围是<code>1 &lt;= N &lt;= 50</code>。</li>\\n\\t<li>每一个&nbsp;<code>grid[i][j]</code> 都是集合&nbsp;<code>{-1, 0, 1}</code>其中的一个数。</li>\\n\\t<li>可以保证起点&nbsp;<code>grid[0][0]</code>&nbsp;和终点&nbsp;<code>grid[N-1][N-1]</code>&nbsp;的值都不会是 -1。</li>\\n</ul>\\n","title":"741. 摘樱桃","relatedTags":["数组","动态规划","矩阵"],"difficult":"Hard","lang":["javascript"],"uniqueID":"741","slug":"741-Cherry-Pickup"}')}}]);