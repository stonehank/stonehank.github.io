(window.webpackJsonp=window.webpackJsonp||[]).push([[705],{1503:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> removeDuplicates = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n    nums.unshift(<span class=\\"hljs-literal\\">null</span>)\\n    <span class=\\"hljs-keyword\\">let</span> last=<span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-keyword\\">let</span> idx=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;nums.length;i++){\\n        <span class=\\"hljs-keyword\\">if</span>(nums[i]==last)<span class=\\"hljs-keyword\\">continue</span>\\n        nums[idx++]=nums[i]\\n        last=nums[i]\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> idx\\n};\\n</code></pre>\\n"],"querySlug":"remove-duplicates-from-sorted-array","created_at":"2021-04-18","timeArr":[2021,3,18,9,39,54,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>对<code>nums</code>进行原地重排序，设定一个索引<code>k</code>，表示当前需要改变的位置，从<code>k=0</code>开始，如果发现有效(不重复)，则<code>nums[k++]=nums[i]</code>。</p>\\n<p>最终前<code>k</code>位的都是无重复的数字。</p>\\n","content":"<p>给你一个有序数组 <code>nums</code> ，请你<strong><a href=\\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\\" target=\\"_blank\\"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>\\n\\n<p>不要使用额外的数组空间，你必须在 <strong><a href=\\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\\" target=\\"_blank\\">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>\\n\\n<p> </p>\\n\\n<p><strong>说明:</strong></p>\\n\\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\\n\\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\\n\\n<p>你可以想象内部操作如下:</p>\\n\\n<pre>\\n// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\\nint len = removeDuplicates(nums);\\n\\n// 在函数里修改输入数组对于调用者是可见的。\\n// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。\\nfor (int i = 0; i < len; i++) {\\n    print(nums[i]);\\n}\\n</pre>\\n \\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [1,1,2]\\n<strong>输出：</strong>2, nums = [1,2]\\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>2</code></strong> ，并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2 </code></strong><code>。</code>不需要考虑数组中超出新长度后面的元素。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [0,0,1,1,1,2,2,3,3,4]\\n<strong>输出：</strong>5, nums = [0,1,2,3,4]\\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>5</code></strong> ， 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong> 。不需要考虑数组中超出新长度后面的元素。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>0 <= nums.length <= 3 * 10<sup>4</sup></code></li>\\n\\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\\n\\t<li><code>nums</code> 已按升序排列</li>\\n</ul>\\n\\n<p> </p>\\n","title":"26. 删除有序数组中的重复项","relatedTags":["数组","双指针"],"difficult":"Easy","lang":["javascript"],"uniqueID":"26","slug":"26-Remove-Duplicates-from-Sorted-Array"}')}}]);