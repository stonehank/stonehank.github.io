(window.webpackJsonp=window.webpackJsonp||[]).push([[742],{1540:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> removeDuplicateLetters = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(s.length&lt;=<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> s\\n  <span class=\\"hljs-keyword\\">let</span> hash=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-number\\">0</span>), idxes=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-literal\\">null</span>)\\n  <span class=\\"hljs-comment\\">// 记录字母的频率</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;s.length;i++)hash[s.charCodeAt(i)<span class=\\"hljs-number\\">-97</span>]++\\n  <span class=\\"hljs-comment\\">// 保留1个记录频率</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">26</span>;i++)<span class=\\"hljs-keyword\\">if</span>(hash[i]&gt;<span class=\\"hljs-number\\">0</span>)hash[i]--\\n  <span class=\\"hljs-comment\\">// 记录字母出现的第一个位置</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=s.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--)idxes[s.charCodeAt(i)<span class=\\"hljs-number\\">-97</span>]=i\\n  <span class=\\"hljs-comment\\">// 从最小到最大检查每一个字母</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">26</span>;i++){\\n    <span class=\\"hljs-keyword\\">let</span> pos=idxes[i],valid=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">let</span> temp=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-keyword\\">if</span>(pos==<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;pos;j++){\\n      <span class=\\"hljs-keyword\\">let</span> code=s.charCodeAt(j)<span class=\\"hljs-number\\">-97</span>\\n      temp[code]++\\n      <span class=\\"hljs-keyword\\">if</span>(temp[code]&gt;hash[code]){\\n        valid=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-keyword\\">break</span>\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(!valid)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">let</span> newStr=<span class=\\"hljs-string\\">\'\'</span>,cur=<span class=\\"hljs-built_in\\">String</span>.fromCharCode(i+<span class=\\"hljs-number\\">97</span>)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=pos+<span class=\\"hljs-number\\">1</span>;i&lt;s.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(s[i]===cur)<span class=\\"hljs-keyword\\">continue</span>\\n      newStr+=s[i]\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> s[pos]+removeDuplicateLetters(newStr)\\n  }    \\n};\\n</code></pre>\\n"],"querySlug":"remove-duplicate-letters","created_at":"2019-04-13","timeArr":[2019,3,13,0,58,14,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>对于<code>s</code>，我们记录它能被删除的字母的个数<code>hash</code>，再记录每一个字母的第一个出现的索引<code>idxes</code>。</p>\\n<p>从<code>0</code>到<code>26</code>，以递增的方式来检测，如果第<code>i</code>个字母它对应的在<code>s</code>中的索引的前面所有字母都能被删除，\\n那么说明这个第<code>i</code>个字母可以作为最前面那一个字母，因为是从<code>0</code>到<code>26</code>，因此它一定是第一个的最小值。</p>\\n<p>接着对后面的字符串删除当前选中的字母，然后重新构建一个<code>newStr</code>，递归执行。</p>\\n<p>总的来说，就是每次从<code>0</code>到<code>26</code>的顺序找出一个字母作为头部，接着递归剩下的。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> removeDuplicateLetters = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(s.length&lt;=<span class=\\"hljs-number\\">1</span>)<span class=\\"hljs-keyword\\">return</span> s\\n  <span class=\\"hljs-keyword\\">let</span> hash=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-number\\">0</span>), idxes=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-literal\\">null</span>)\\n  <span class=\\"hljs-comment\\">// 记录字母的频率</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;s.length;i++)hash[s.charCodeAt(i)<span class=\\"hljs-number\\">-97</span>]++\\n  <span class=\\"hljs-comment\\">// 保留1个记录频率</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">26</span>;i++)<span class=\\"hljs-keyword\\">if</span>(hash[i]&gt;<span class=\\"hljs-number\\">0</span>)hash[i]--\\n  <span class=\\"hljs-comment\\">// 记录字母出现的第一个位置</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=s.length<span class=\\"hljs-number\\">-1</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--)idxes[s.charCodeAt(i)<span class=\\"hljs-number\\">-97</span>]=i\\n  <span class=\\"hljs-comment\\">// 从最小到最大检查每一个字母</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;<span class=\\"hljs-number\\">26</span>;i++){\\n    <span class=\\"hljs-keyword\\">let</span> pos=idxes[i],valid=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">let</span> temp=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-keyword\\">if</span>(pos==<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;pos;j++){\\n      <span class=\\"hljs-keyword\\">let</span> code=s.charCodeAt(j)<span class=\\"hljs-number\\">-97</span>\\n      temp[code]++\\n      <span class=\\"hljs-keyword\\">if</span>(temp[code]&gt;hash[code]){\\n        valid=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-keyword\\">break</span>\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(!valid)<span class=\\"hljs-keyword\\">continue</span>\\n    <span class=\\"hljs-keyword\\">let</span> newStr=<span class=\\"hljs-string\\">\'\'</span>,cur=<span class=\\"hljs-built_in\\">String</span>.fromCharCode(i+<span class=\\"hljs-number\\">97</span>)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=pos+<span class=\\"hljs-number\\">1</span>;i&lt;s.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(s[i]===cur)<span class=\\"hljs-keyword\\">continue</span>\\n      newStr+=s[i]\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> s[pos]+removeDuplicateLetters(newStr)\\n  }    \\n};\\n</code></pre>\\n<hr>\\n<p>优化版：</p>\\n<p>记录所有字母的频率，不需要记录每个字母第一个出现的索引，而是遍历<code>s</code>，<code>hash[s[i]]</code>不断减一，\\n并且不断筛选最小的字母的索引<code>minLetterIdx</code>，如果发现<code>hash[s[i]]===0</code>，说明有一种字母即将消失，\\n选择这段范围内的最小字母<code>s[minLetterIdx]</code>作为头部，然后继续递归处理剩下的字符串。</p>\\n","content":"<p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>\\n\\n<p><strong>注意：</strong>该题与 1081 <a href=\\"https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters\\">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong><code>s = \\"bcabc\\"</code>\\n<strong>输出<code>：</code></strong><code>\\"abc\\"</code>\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong><code>s = \\"cbacdcbc\\"</code>\\n<strong>输出：</strong><code>\\"acdb\\"</code></pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>s</code> 由小写英文字母组成</li>\\n</ul>\\n","title":"316. 去除重复字母","relatedTags":["栈","贪心","字符串","单调栈"],"difficult":"Middle","lang":["javascript"],"uniqueID":"316","slug":"316-Remove-Duplicate-Letters"}')}}]);