(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{598:function(e){e.exports=JSON.parse('{"content":"<p><a href=\\"https://leetcode.com/problems/maximum-product-of-word-lengths/\\">原题目</a>：\\n给定一个字符串数组，找到长度的最大值<code>length(word[i]) * length(word[j])</code>，其中两个单词中的字母无相同。您可以假定每个单词只包含小写字母。如果没有这两个词，返回0。</p>\\n<p>例：</p>\\n<pre><code><pre class=\\"hljs\\"><code>Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]\\nOutput: 16 \\nExplanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.</code></pre></code></pre><p>解析：\\n这题肯定要进行交叉对比(2个for循环)，但最关键的就是对比过程，也就是判断2个字符串是否存在相同的字符。</p>\\n<p>如果使用<code>indexOf</code>或者数组下标记录都会造成时间复杂度大幅提升，看了他人的答案发现使用的是位操作符<code>&lt;&lt;</code>，<code>|</code>和<code>&amp;</code>，而且是在交叉对比之前进行预处理，交叉对比的时候只需要简单的判断<code>pretreate[i] &amp; pretreate[j]===0</code>便可，</p>\\n<p>因为使用后效率提升太多，解析并且记录一下。</p>\\n<p>先解释<code>val |= (1 &lt;&lt; (word.charCodeAt(i)-aCode))</code>：</p>\\n<ul>\\n<li><p><code>word.charCodeAt(i)-aCode</code>这个很好懂，也就是a对应0，b对应1...这里的0,1数字代表的是<br>二进制1后面的位数。</p>\\n</li>\\n<li><p><code>1&lt;&lt;0</code>，<code>1&lt;&lt;1</code>是什么呢？</p>\\n<p>  1在二进制中(32位)就是<code>00000000000000000000000000000001</code>，<code>&lt;&lt;</code>是左移1位，</p>\\n<p>  那么<code>1&lt;&lt;0</code>还是<code>1</code>，<code>1&lt;&lt;1</code>就是(前面的零省略)<code>10</code>，<code>1&lt;&lt;2</code>就是<code>100</code>，<code>1&lt;&lt;3</code>就是<code>1000</code>，</p>\\n<p>  于是可知</p>\\n<p>  <code>a</code>就是<code>1</code>，</p>\\n<p>  <code>b</code>是<code>10</code>，</p>\\n<p>  <code>c</code>是<code>100</code>...</p>\\n<p>  <code>z</code>是<code>10000000000000000000000000</code>(25个0)。</p>\\n</li>\\n<li><p><code>|</code>是按位或：二进制编码中，每一位两者其中一个为1，则为1，否则，则为0，</p>\\n<p>   因此 <code>val |=</code>就是对每一个字符合并，例如</p>\\n<p>   <code>ab</code> 是 <code>00010|00001</code>=&gt;<code>00011</code>，</p>\\n<p>   <code>f</code> 是 <code>100000</code>，</p>\\n<p>   <code>ffff</code> 也是 <code>100000</code>，</p>\\n<p>   <code>big</code>是 <code>101000010</code>，</p>\\n<p>   <code>axdg</code>是<code>100000000000000001001001</code>。</p>\\n</li>\\n<li><p><code>&amp;</code>，按位与，二进制编码中，每一位两者都为1，则为1，否则，则为0，</p>\\n<p>  例1：<code>axdg</code>和<code>oigd</code>要判断是否有重复：</p>\\n<pre><code><pre class=\\"hljs\\"><code>  axdg是：100000000000000001001001\\n\\n  oifd是：         100000100101000\\n\\n  &amp; 后：  000000000000000000001000  </code></pre></code></pre><p>  因为第4位都为1，所以最后不为0，也可得知重复的就是字母表第4位：<code>d</code>。</p>\\n<p>  &nbsp;</p>\\n<p>  例2：<code>axdg</code>和<code>lkmk</code>要判断是否有重复：</p>\\n<p>  结果为0，说明无重复。</p>\\n<pre><code><pre class=\\"hljs\\"><code>  axdg是：100000000000000001001001\\n\\n  lkmk是：           1110000000000\\n\\n  &amp; 后：  000000000000000000000000  </code></pre></code></pre><p>总结：这种方法使用了二进制数字的位数作为保存字符的手段，相比起数组，散列表等，速度更快，在保存量较小(&lt;=32)优势非常明显。</p>\\n</li>\\n</ul>\\n<p>代码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">words</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> maxProduct = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">words</span>) </span>{\\n    <span class=\\"hljs-keyword\\">let</span> aCode=<span class=\\"hljs-string\\">\'a\'</span>.charCodeAt(<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">compute</span>(<span class=\\"hljs-params\\">word</span>)</span>{\\n        <span class=\\"hljs-keyword\\">let</span> val=<span class=\\"hljs-number\\">0</span>\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;word.length;i++){\\n            val |= (<span class=\\"hljs-number\\">1</span> &lt;&lt; (word.charCodeAt(i)-aCode))\\n        }\\n        <span class=\\"hljs-keyword\\">return</span> val\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> pretreatment=[]\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;words.length;i++){\\n        pretreatment[i]=compute(words[i])\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> maxSum=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;words.length<span class=\\"hljs-number\\">-1</span>;i++){\\n        <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=i+<span class=\\"hljs-number\\">1</span>;j&lt;words.length;j++){\\n            <span class=\\"hljs-keyword\\">let</span> len1=words[i].length,len2=words[j].length\\n            <span class=\\"hljs-keyword\\">if</span>(len1*len2&gt;maxSum &amp;&amp; (pretreatment[i] &amp; pretreatment[j])===<span class=\\"hljs-number\\">0</span>){\\n                 maxSum=len1*len2\\n            }\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> maxSum\\n};</code></pre></code></pre>\\n","toc":[],"relatedTags":null,"created_at":"2018-09-06","timeArr":[2018,8,6,0,0,0,0],"title":"关于位操作符应用的算法题","uuid":"c8b2b19bf52484de902c2d4d23a44ed8b158ab18","summary":"<p><a href=\\"https://leetcode.com/problems/maximum-product-of-word-lengths/\\">原题目</a>：\\n给定一个字符串数组，找到长度的最大值<code>length(word[i]) * length(word[j])</code>，其中两个单词中的字母无相同。您可以假定每个单词只包含小写字母。如果没有...</p>","slug":"guan-yu-wei-cao-zuo-fu-ying-yong-de-suan-fa-ti","sha":"7963f582de66e6e2582fb61249dbba57221190fe"}')}}]);