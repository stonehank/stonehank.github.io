(window.webpackJsonp=window.webpackJsonp||[]).push([[1065],{1863:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> KthLargest = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">k, nums</span>) </span>{\\n  nums.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>b-a)\\n  \\n  <span class=\\"hljs-keyword\\">let</span> pq=nums.slice(<span class=\\"hljs-number\\">0</span>,k)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">insert</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(pq.length===<span class=\\"hljs-number\\">0</span> || pq[<span class=\\"hljs-number\\">0</span>]&lt;=n){\\n      pq.unshift(n)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">let</span> lo=<span class=\\"hljs-number\\">0</span>,hi=pq.length\\n      <span class=\\"hljs-keyword\\">while</span>(lo&lt;hi){\\n        <span class=\\"hljs-keyword\\">let</span> mid=<span class=\\"hljs-built_in\\">Math</span>.floor((lo+hi)/<span class=\\"hljs-number\\">2</span>)\\n        <span class=\\"hljs-keyword\\">if</span>(pq[mid]&gt;n)lo=mid+<span class=\\"hljs-number\\">1</span>\\n        <span class=\\"hljs-keyword\\">else</span> hi=mid\\n      }\\n      pq.splice(hi,<span class=\\"hljs-number\\">0</span>,n)      \\n    }\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">delMin</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> pq.pop()\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getMin</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> pq[pq.length<span class=\\"hljs-number\\">-1</span>]\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.pq=pq\\n  <span class=\\"hljs-keyword\\">this</span>.insert=insert\\n  <span class=\\"hljs-keyword\\">this</span>.delMin=delMin\\n  <span class=\\"hljs-keyword\\">this</span>.getMin=getMin\\n  <span class=\\"hljs-keyword\\">this</span>.k=k\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {number} val\\n * @return {number}\\n */</span>\\nKthLargest.prototype.add = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">val</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.pq.length&lt;<span class=\\"hljs-keyword\\">this</span>.k){\\n    <span class=\\"hljs-keyword\\">this</span>.insert(val)\\n  }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(val&gt;<span class=\\"hljs-keyword\\">this</span>.getMin()){\\n    <span class=\\"hljs-keyword\\">this</span>.delMin()\\n    <span class=\\"hljs-keyword\\">this</span>.insert(val)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.getMin()\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your KthLargest object will be instantiated and called as such:\\n * var obj = new KthLargest(k, nums)\\n * var param_1 = obj.add(val)\\n */</span>\\n</code></pre>\\n"],"querySlug":"kth-largest-element-in-a-stream","created_at":"2019-04-22","timeArr":[2019,3,22,20,10,32,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>使用优先队列只需要维护从大到小的前<code>k</code>个数字即可。</p>\\n<p>每次调用<code>add</code>时，如果当前<code>pq</code>不足<code>k</code>，需要添加进<code>pq</code>。</p>\\n<p>否则，如果新加的<code>val</code>比最小的一个数还小，则直接返回当前最小的数字。</p>\\n<p>如果新加的<code>val</code>更大，那么需要先删除原队列中最小的一个，在添加，最后再返回当前最小的数字。</p>\\n","content":"<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\\n\\n<p>请实现 <code>KthLargest</code> 类：</p>\\n\\n<ul>\\n\\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\\n\\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>\\n[\\"KthLargest\\", \\"add\\", \\"add\\", \\"add\\", \\"add\\", \\"add\\"]\\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\\n<strong>输出：</strong>\\n[null, 4, 5, 5, 8, 8]\\n\\n<strong>解释：</strong>\\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\\nkthLargest.add(3);   // return 4\\nkthLargest.add(5);   // return 5\\nkthLargest.add(10);  // return 5\\nkthLargest.add(9);   // return 8\\nkthLargest.add(4);   // return 8\\n</pre>\\n\\n<p> </p>\\n<strong>提示：</strong>\\n\\n<ul>\\n\\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\\n\\t<li><code>0 <= nums.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\\n\\t<li><code>-10<sup>4</sup> <= val <= 10<sup>4</sup></code></li>\\n\\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\\n\\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\\n</ul>\\n","title":"703. 数据流中的第 K 大元素","relatedTags":["树","设计","二叉搜索树","二叉树","数据流","堆（优先队列）"],"difficult":"Easy","lang":["javascript"],"uniqueID":"703","slug":"703-Kth-Largest-Element-in-a-Stream"}')}}]);