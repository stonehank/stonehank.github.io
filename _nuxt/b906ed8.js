(window.webpackJsonp=window.webpackJsonp||[]).push([[1166],{1964:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> xorGame = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> XOR = nums.reduce(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">val, n</span>) =&gt;</span> val ^ n, <span class=\\"hljs-number\\">0</span>);\\n  <span class=\\"hljs-keyword\\">if</span> (XOR === <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n    \\n  <span class=\\"hljs-keyword\\">let</span> isAlice = <span class=\\"hljs-literal\\">true</span>;\\n  <span class=\\"hljs-keyword\\">while</span>(XOR !== <span class=\\"hljs-number\\">0</span>) {\\n    <span class=\\"hljs-keyword\\">const</span> toPick = nums.findIndex(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">n</span> =&gt;</span> n !==XOR);\\n    <span class=\\"hljs-keyword\\">if</span>(toPick ===<span class=\\"hljs-number\\">-1</span>) <span class=\\"hljs-keyword\\">break</span>;\\n    XOR^=nums[toPick]\\n    nums.splice(toPick, <span class=\\"hljs-number\\">1</span>);\\n    isAlice = !isAlice;\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> !isAlice;\\n};\\n</code></pre>\\n"],"querySlug":"chalkboard-xor-game","created_at":"2019-04-02","timeArr":[2019,3,2,16,32,16,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这道题用了3种解法，</p>\\n<p>解法一：<code>Recursion With Memo</code></p>\\n<p>对<code>小红</code>和<code>小明</code>他们各自每一轮面对的<code>XOR</code>值进行储存，分别储存在<code>memA</code>和<code>memB</code>内(这里必须分开储存，否则会有冲突)。</p>\\n<p>函数内部遍历<code>nums</code>，使用<code>used</code>记录已经判断过的索引，对其余的每一个进行判断。</p>\\n<p>虽然能<code>Accept</code>，但也是<code>2000+ms</code>，不算一个太好的解决方案。</p>\\n<p>解法二：<code>Greedy</code></p>\\n<p>每一轮只找到当前这一轮不会输的<strong>第一个</strong>选项，接着更新<code>XOR</code>值，更新<code>nums</code>数组(删除这一次的选项)。</p>\\n<p>直到最后<code>XOR===0</code>，当前轮的玩家就是胜利者。</p>\\n<p>解法三：<code>Mathematical</code></p>\\n<p>只要满足初始<code>XOR</code>为0，或者<code>nums</code>的长度为偶数，直接<code>return true</code>。</p>\\n","content":"<p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p>\\n\\n<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>\\n\\n<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> nums = [1, 1, 2]\\n<strong>输出:</strong> false\\n<strong>解释:</strong> \\nAlice 有两个选择: 擦掉数字 1 或 2。\\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= N <= 1000</code></li>\\n\\t<li><code>0 <= nums[i] <= 2^16</code></li>\\n</ul>\\n","title":"810. 黑板异或游戏","relatedTags":["位运算","脑筋急转弯","数组","数学","博弈"],"difficult":"Hard","lang":["javascript"],"uniqueID":"810","slug":"810-Chalkboard-XOR-Game"}')}}]);