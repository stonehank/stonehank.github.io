(window.webpackJsonp=window.webpackJsonp||[]).push([[1115],{1913:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> makeLargestSpecial = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S</span>) </span>{\\n  <span class=\\"hljs-comment\\">// aux记录S中的趋势，为1 则+1，为0则-1</span>\\n  <span class=\\"hljs-keyword\\">let</span> aux=<span class=\\"hljs-built_in\\">Array</span>(S.length+<span class=\\"hljs-number\\">1</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;S.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(S[i]===<span class=\\"hljs-string\\">\\"1\\"</span>) aux[i+<span class=\\"hljs-number\\">1</span>]=aux[i]+<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> aux[i+<span class=\\"hljs-number\\">1</span>]=aux[i]<span class=\\"hljs-number\\">-1</span>\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> range=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;aux.length;i++){\\n    <span class=\\"hljs-comment\\">// 当尾巴为0，可能是特殊子串</span>\\n    <span class=\\"hljs-keyword\\">if</span>(S[i<span class=\\"hljs-number\\">-1</span>]===<span class=\\"hljs-string\\">\\"0\\"</span>){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;i;j++){\\n        <span class=\\"hljs-comment\\">// 找到趋势数字相同的，而且头部必须是1</span>\\n        <span class=\\"hljs-keyword\\">if</span>(aux[j]===aux[i]){\\n          <span class=\\"hljs-keyword\\">if</span>(S[j]===<span class=\\"hljs-string\\">\\"0\\"</span>)<span class=\\"hljs-keyword\\">continue</span>\\n          <span class=\\"hljs-comment\\">// 判断这个子串是否合法的特殊子串，合法的添加当前子串头尾到range</span>\\n          <span class=\\"hljs-keyword\\">let</span> ones=<span class=\\"hljs-number\\">0</span>,valid=<span class=\\"hljs-literal\\">true</span>\\n          <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=j+<span class=\\"hljs-number\\">1</span>;k&lt;=i;k++){\\n            <span class=\\"hljs-keyword\\">if</span>(S[k<span class=\\"hljs-number\\">-1</span>]===<span class=\\"hljs-string\\">\\"1\\"</span>) ones++\\n            <span class=\\"hljs-keyword\\">else</span> ones--\\n            <span class=\\"hljs-keyword\\">if</span>(ones&lt;<span class=\\"hljs-number\\">0</span>){\\n              valid=<span class=\\"hljs-literal\\">false</span>\\n              <span class=\\"hljs-keyword\\">break</span>\\n            }\\n          }\\n          <span class=\\"hljs-keyword\\">if</span>(valid)range.push([j,i<span class=\\"hljs-number\\">-1</span>])\\n        }\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// hash记录当前range中所有头部</span>\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;range.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(hash[range[i][<span class=\\"hljs-number\\">0</span>]]==<span class=\\"hljs-literal\\">null</span>)hash[range[i][<span class=\\"hljs-number\\">0</span>]]=[i]\\n    <span class=\\"hljs-keyword\\">else</span> hash[range[i][<span class=\\"hljs-number\\">0</span>]].push(i)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> maxS=S\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;range.length;i++){\\n    <span class=\\"hljs-comment\\">// 如果当前子串存在连续子串，则尝试swap，并且找到最大的一次swap</span>\\n    <span class=\\"hljs-keyword\\">if</span>(hash[range[i][<span class=\\"hljs-number\\">1</span>]+<span class=\\"hljs-number\\">1</span>]){\\n      <span class=\\"hljs-keyword\\">let</span> cur=range[i],nxts=hash[range[i][<span class=\\"hljs-number\\">1</span>]+<span class=\\"hljs-number\\">1</span>]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> nid <span class=\\"hljs-keyword\\">of</span> nxts){\\n        <span class=\\"hljs-keyword\\">let</span> nxt=range[nid]\\n        <span class=\\"hljs-keyword\\">let</span> newS=swap(cur[<span class=\\"hljs-number\\">0</span>],cur[<span class=\\"hljs-number\\">1</span>],nxt[<span class=\\"hljs-number\\">0</span>],nxt[<span class=\\"hljs-number\\">1</span>])\\n        <span class=\\"hljs-keyword\\">if</span>(newS&gt;maxS){\\n          maxS=newS\\n        }    \\n      }\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 可能还存在继续swap成为更大，递归调用</span>\\n  <span class=\\"hljs-keyword\\">if</span>(maxS!==S)<span class=\\"hljs-keyword\\">return</span> makeLargestSpecial(maxS)\\n  <span class=\\"hljs-keyword\\">return</span> maxS\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">swap</span>(<span class=\\"hljs-params\\">l1,r1,l2,r2</span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> S.substring(<span class=\\"hljs-number\\">0</span>,l1)+S.substring(l2,r2+<span class=\\"hljs-number\\">1</span>)+S.substring(l1,r1+<span class=\\"hljs-number\\">1</span>)+S.substring(r2+<span class=\\"hljs-number\\">1</span>)\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"special-binary-string","created_at":"2019-03-26","timeArr":[2019,2,26,23,6,51,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>题目给出<code>特殊二进制字符串</code>必须是<code>0</code>和<code>1</code>相等，并且前缀<code>1</code>的数量大于<code>0</code>的数量。</p>\\n<p>因此可以定义一个<code>aux</code>，当遇到<code>1</code>则<code>++</code>，遇到<code>0</code>则<code>--</code>，这么做能方便我们找出<code>1</code>和<code>0</code>相等的字符串，并且当<code>aux[i]===0</code>时，</p>\\n<p>一定是一个合法的特殊子串。</p>\\n<p>遍历<code>aux</code>，找出所有合法的特殊子串，递归执行这个子串。</p>\\n<p>最后返回的结果按从大到小排序，并且返回合并值。</p>\\n","content":"<p>特殊的二进制序列是具有以下两个性质的二进制序列：</p>\\n\\n<ul>\\n\\t<li>0 的数量与 1 的数量相等。</li>\\n\\t<li>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。</li>\\n</ul>\\n\\n<p>给定一个特殊的二进制序列&nbsp;<code>S</code>，以字符串形式表示。定义一个<em>操作 </em>为首先选择&nbsp;<code>S</code>&nbsp;的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)</p>\\n\\n<p>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？</p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> S = &quot;11011000&quot;\\n<strong>输出:</strong> &quot;11100100&quot;\\n<strong>解释:</strong>\\n将子串 &quot;10&quot; （在S[1]出现） 和 &quot;1100&quot; （在S[3]出现）进行交换。\\n这是在进行若干次操作后按字典序排列最大的结果。\\n</pre>\\n\\n<p><strong>说明:</strong></p>\\n\\n<ol>\\n\\t<li><code>S</code>&nbsp;的长度不超过&nbsp;<code>50</code>。</li>\\n\\t<li><code>S</code>&nbsp;保证为一个满足上述定义的<em>特殊 </em>的二进制序列。</li>\\n</ol>\\n","title":"761. 特殊的二进制序列","relatedTags":["递归","字符串"],"difficult":"Hard","lang":["javascript"],"uniqueID":"761","slug":"761-Special-Binary-String"}')}}]);