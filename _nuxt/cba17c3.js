(window.webpackJsonp=window.webpackJsonp||[]).push([[729],{1527:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">words</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findSubstring = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s, words</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={},head={}\\n  <span class=\\"hljs-keyword\\">let</span> eachLen=<span class=\\"hljs-number\\">0</span>,allLen=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> w <span class=\\"hljs-keyword\\">of</span> words){\\n    eachLen=w.length\\n    allLen+=w.length\\n    head[w[<span class=\\"hljs-number\\">0</span>]]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">if</span>(hash[w]==<span class=\\"hljs-literal\\">null</span>)hash[w]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> hash[w]++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;=s.length-allLen;i++){\\n    <span class=\\"hljs-keyword\\">let</span> used={}\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=i;j&lt;allLen+i;j+=eachLen){\\n      <span class=\\"hljs-keyword\\">if</span>(!head[s[j]])<span class=\\"hljs-keyword\\">break</span>\\n      <span class=\\"hljs-keyword\\">let</span> checkWord=s.substring(j,j+eachLen)\\n      <span class=\\"hljs-keyword\\">if</span>(!hash[checkWord])<span class=\\"hljs-keyword\\">break</span>\\n      <span class=\\"hljs-keyword\\">if</span>(!used[checkWord])used[checkWord]=<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">else</span> used[checkWord]++\\n      <span class=\\"hljs-keyword\\">if</span>(used[checkWord]&gt;hash[checkWord])<span class=\\"hljs-keyword\\">break</span>\\n      <span class=\\"hljs-keyword\\">if</span>(j===allLen+i-eachLen)res.push(i)\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"substring-with-concatenation-of-all-words","created_at":"2019-03-22","timeArr":[2019,2,22,0,4,41,0],"hasThinking":true,"thinking":"<hr>\\n<p>两种思路，</p>\\n<p>一：因为题目提示了<code>words</code>内的长度都相等，因此，我们先用2个<code>hash</code>分别保存<code>words</code>内部单词的重复数量和每个单词的首字母，\\n并且去除单词的长度<code>eachLen</code>和所有单词总长度<code>allLen</code>。</p>\\n<p>遍历<code>s</code>，一旦发现存在匹配首字母，我们可以根据<code>eachLen</code>来判断当前单词是否存在<code>words</code>中，如果存在，记录它的次数，\\n一旦发现它的次数&gt;原<code>words</code>中次数，相当于失败。</p>\\n<p>如果当遍历了<code>allLen</code>的长度后，说明成功，记录这时候的<code>索引</code>。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[]}</span> <span class=\\"hljs-variable\\">words</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findSubstring = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s, words</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={},head={}\\n  <span class=\\"hljs-keyword\\">let</span> eachLen=<span class=\\"hljs-number\\">0</span>,allLen=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> w <span class=\\"hljs-keyword\\">of</span> words){\\n    eachLen=w.length\\n    allLen+=w.length\\n    head[w[<span class=\\"hljs-number\\">0</span>]]=<span class=\\"hljs-literal\\">true</span>\\n    <span class=\\"hljs-keyword\\">if</span>(hash[w]==<span class=\\"hljs-literal\\">null</span>)hash[w]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> hash[w]++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=[]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;=s.length-allLen;i++){\\n    <span class=\\"hljs-keyword\\">let</span> used={}\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=i;j&lt;allLen+i;j+=eachLen){\\n      <span class=\\"hljs-keyword\\">if</span>(!head[s[j]])<span class=\\"hljs-keyword\\">break</span>\\n      <span class=\\"hljs-keyword\\">let</span> checkWord=s.substring(j,j+eachLen)\\n      <span class=\\"hljs-keyword\\">if</span>(!hash[checkWord])<span class=\\"hljs-keyword\\">break</span>\\n      <span class=\\"hljs-keyword\\">if</span>(!used[checkWord])used[checkWord]=<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">else</span> used[checkWord]++\\n      <span class=\\"hljs-keyword\\">if</span>(used[checkWord]&gt;hash[checkWord])<span class=\\"hljs-keyword\\">break</span>\\n      <span class=\\"hljs-keyword\\">if</span>(j===allLen+i-eachLen)res.push(i)\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n<p>二：不需要管<code>words</code>内的长度是否相等，我们使用简化的<code>tire</code>记录<code>words</code>内的所有字母，当到一个单词的最后一个字母时，\\n使用一个<code>idx</code>属性保存这个单词在<code>words</code>内的索引，同时也用一个<code>hash</code>保存`words·内部单词的重复数量。</p>\\n<p>遍历<code>s</code>，不断判断每一个字母是否符合<code>tire</code>，如果发现存在<code>tire.idx</code>说明一个单词判断到最尾部，这时，记录一下这个单词的使用次数，\\n如果发现使用次数&gt;原<code>words</code>内的次数，失败。</p>\\n<p>如果当遍历了<code>allLen</code>的长度后，说明成功，记录这时候的<code>索引</code>。</p>\\n","content":"<p>给定一个字符串 <code>s</code><strong> </strong>和一些 <strong>长度相同</strong> 的单词 <code>words</code><strong> 。</strong>找出 <code>s</code><strong> </strong>中恰好可以由 <code>words</code><strong> </strong>中所有单词串联形成的子串的起始位置。</p>\\n\\n<p>注意子串要与 <code>words</code><strong> </strong>中的单词完全匹配，<strong>中间不能有其他字符 </strong>，但不需要考虑 <code>words</code><strong> </strong>中单词串联的顺序。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"barfoothefoobarman\\", words = [\\"foo\\",\\"bar\\"]\\n<strong>输出：</strong><code>[0,9]</code>\\n<strong>解释：</strong>\\n从索引 0 和 9 开始的子串分别是 \\"barfoo\\" 和 \\"foobar\\" 。\\n输出的顺序不重要, [9,0] 也是有效答案。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"wordgoodgoodgoodbestword\\", words = [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]\\n<code><strong>输出：</strong>[]</code>\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"barfoofoobarthefoobarman\\", words = [\\"bar\\",\\"foo\\",\\"the\\"]\\n<strong>输出：</strong>[6,9,12]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>s</code> 由小写英文字母组成</li>\\n\\t<li><code>1 <= words.length <= 5000</code></li>\\n\\t<li><code>1 <= words[i].length <= 30</code></li>\\n\\t<li><code>words[i]</code> 由小写英文字母组成</li>\\n</ul>\\n","title":"30. 串联所有单词的子串","relatedTags":["哈希表","字符串","滑动窗口"],"difficult":"Hard","lang":["javascript"],"uniqueID":"30","slug":"30-Substring-with-Concatenation-of-All-Words"}')}}]);