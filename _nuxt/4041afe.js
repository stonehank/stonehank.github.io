(window.webpackJsonp=window.webpackJsonp||[]).push([[728],{1526:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> lengthOfLongestSubstring = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> maxLen=<span class=\\"hljs-number\\">0</span>,curLen=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;s.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> cur=s[i]\\n    <span class=\\"hljs-keyword\\">if</span>(hash[cur]==<span class=\\"hljs-literal\\">null</span>){\\n      curLen++\\n      hash[cur]=i\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">let</span> dupliDis=i-hash[cur]\\n      <span class=\\"hljs-comment\\">// 上一个与当前字符重复的不在curLen范围内</span>\\n      <span class=\\"hljs-keyword\\">if</span>(dupliDis&gt;curLen)curLen++\\n      maxLen=<span class=\\"hljs-built_in\\">Math</span>.max(maxLen,curLen)\\n      <span class=\\"hljs-comment\\">// 如果上一个重复字符不在curLen范围内，则curLen不变，只是更新当前字符的hash</span>\\n      curLen=<span class=\\"hljs-built_in\\">Math</span>.min(curLen,dupliDis)\\n      hash[cur]=i\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Math</span>.max(maxLen,curLen)\\n};\\n</code></pre>\\n"],"querySlug":"longest-substring-without-repeating-characters","created_at":"2019-03-21","timeArr":[2019,2,21,14,43,46,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>定义一个<code>startIdx</code>，表示当前从哪个索引开始检查，遍历<code>s</code>，并且通过<code>map</code>保存当前检查的字母，</p>\\n<p>如果当前字母在<code>map</code>中存在，并且它对应的索引在<code>startIdx</code>之后，说明这个字母在当前的检查范围内重复了，需要更新<code>startIdx</code>；</p>\\n<p>如果这个字母对应的索引在<code>startIdx</code>之前，说明虽然重复，但不在当前检查范围内，因此不需任何操作。</p>\\n","content":"<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串 </strong>的长度。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>s = \\"abcabcbb\\"\\n<strong>输出: </strong>3 \\n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>\\"abc\\"，所以其</code>长度为 3。\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>s = \\"bbbbb\\"\\n<strong>输出: </strong>1\\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\\"b\\"</code>，所以其长度为 1。\\n</pre>\\n\\n<p><strong>示例 3:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>s = \\"pwwkew\\"\\n<strong>输出: </strong>3\\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\\"wke\\"</code>，所以其长度为 3。\\n     请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>\\"pwke\\"</code> 是一个<em>子序列，</em>不是子串。\\n</pre>\\n\\n<p><strong>示例 4:</strong></p>\\n\\n<pre>\\n<strong>输入: </strong>s = \\"\\"\\n<strong>输出: </strong>0\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>0 <= s.length <= 5 * 10<sup>4</sup></code></li>\\n\\t<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\\n</ul>\\n","title":"3. 无重复字符的最长子串","relatedTags":["哈希表","字符串","滑动窗口"],"difficult":"Middle","lang":["javascript"],"uniqueID":"3","slug":"3-Longest-Substring-Without-Repeating-Characters"}')}}]);