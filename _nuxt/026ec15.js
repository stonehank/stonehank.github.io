(window.webpackJsonp=window.webpackJsonp||[]).push([[1119],{1917:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">row</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> minSwapsCouples = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">row</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 暴力+mem</span>\\n  <span class=\\"hljs-keyword\\">let</span> memo={}\\n  <span class=\\"hljs-keyword\\">return</span> dfs(row,<span class=\\"hljs-number\\">0</span>)\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">row,idx</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(idx===row.length)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">if</span>(memo[idx]!=<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">return</span> memo[idx]\\n    <span class=\\"hljs-keyword\\">let</span> left=row[idx],left_p=<span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-keyword\\">if</span>(left/<span class=\\"hljs-number\\">2</span>===<span class=\\"hljs-built_in\\">Math</span>.floor(left/<span class=\\"hljs-number\\">2</span>)){\\n      left_p=left+<span class=\\"hljs-number\\">1</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      left_p=left<span class=\\"hljs-number\\">-1</span>\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> swapTimes=<span class=\\"hljs-literal\\">Infinity</span>,\\n        swap_idx=row.indexOf(left_p)\\n    <span class=\\"hljs-keyword\\">if</span>(swap_idx===idx+<span class=\\"hljs-number\\">1</span>){\\n      swapTimes=dfs(row,idx+<span class=\\"hljs-number\\">2</span>)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      swap(row,swap_idx,idx+<span class=\\"hljs-number\\">1</span>)\\n      swapTimes=<span class=\\"hljs-number\\">1</span>+dfs(row,idx+<span class=\\"hljs-number\\">2</span>)\\n    }\\n    memo[idx]=swapTimes\\n    <span class=\\"hljs-keyword\\">return</span> swapTimes\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">swap</span>(<span class=\\"hljs-params\\">arr,i,j</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> t=arr[i]\\n    arr[i]=arr[j]\\n    arr[j]=t\\n  }\\n      \\n};\\n</code></pre>\\n"],"querySlug":"couples-holding-hands","created_at":"2019-04-14","timeArr":[2019,3,14,23,27,16,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>2种思路，一种是<code>贪心+暴力解+记忆</code>，即每次对于索引<code>2i</code>，只去交换<code>2i+1</code>的数字，使得<code>2i+1</code>的数字能匹配<code>2i</code>。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">row</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> minSwapsCouples = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">row</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 暴力+mem</span>\\n  <span class=\\"hljs-keyword\\">let</span> memo={}\\n  <span class=\\"hljs-keyword\\">return</span> dfs(row,<span class=\\"hljs-number\\">0</span>)\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">row,idx</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(idx===row.length)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">if</span>(memo[idx]!=<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">return</span> memo[idx]\\n    <span class=\\"hljs-keyword\\">let</span> left=row[idx],left_p=<span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-keyword\\">if</span>(left/<span class=\\"hljs-number\\">2</span>===<span class=\\"hljs-built_in\\">Math</span>.floor(left/<span class=\\"hljs-number\\">2</span>)){\\n      left_p=left+<span class=\\"hljs-number\\">1</span>\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      left_p=left<span class=\\"hljs-number\\">-1</span>\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> swapTimes=<span class=\\"hljs-literal\\">Infinity</span>,\\n        swap_idx=row.indexOf(left_p)\\n    <span class=\\"hljs-keyword\\">if</span>(swap_idx===idx+<span class=\\"hljs-number\\">1</span>){\\n      swapTimes=dfs(row,idx+<span class=\\"hljs-number\\">2</span>)\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      swap(row,swap_idx,idx+<span class=\\"hljs-number\\">1</span>)\\n      swapTimes=<span class=\\"hljs-number\\">1</span>+dfs(row,idx+<span class=\\"hljs-number\\">2</span>)\\n    }\\n    memo[idx]=swapTimes\\n    <span class=\\"hljs-keyword\\">return</span> swapTimes\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">swap</span>(<span class=\\"hljs-params\\">arr,i,j</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> t=arr[i]\\n    arr[i]=arr[j]\\n    arr[j]=t\\n  }\\n};\\n</code></pre>\\n<p>另一种方式是<code>union find</code>，对于<code>N</code>对情侣，最多只需要交换<code>N-1</code>次，因此遍历<code>rows</code>，对于当前<code>2i</code>和<code>2i+1</code>不匹配的，将它们<code>union</code>，\\n并且交换次数<code>+1</code>，后续如果还能遇到这两组，由于之前已经<code>union</code>了，因此不会重复计算交换次数。</p>\\n","content":"<p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p>\\n\\n<p>人和座位用&nbsp;<code>0</code>&nbsp;到&nbsp;<code>2N-1</code>&nbsp;的整数表示，情侣们按顺序编号，第一对是&nbsp;<code>(0, 1)</code>，第二对是&nbsp;<code>(2, 3)</code>，以此类推，最后一对是&nbsp;<code>(2N-2, 2N-1)</code>。</p>\\n\\n<p>这些情侣的初始座位&nbsp;&nbsp;<code>row[i]</code>&nbsp;是由最初始坐在第 i 个座位上的人决定的。</p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> row = [0, 2, 1, 3]\\n<strong>输出:</strong> 1\\n<strong>解释:</strong> 我们只需要交换row[1]和row[2]的位置即可。\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> row = [3, 2, 0, 1]\\n<strong>输出:</strong> 0\\n<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。\\n</pre>\\n\\n<p><strong>说明:</strong></p>\\n\\n<ol>\\n\\t<li><code>len(row)</code> 是偶数且数值在&nbsp;<code>[4, 60]</code>范围内。</li>\\n\\t<li>可以保证<code>row</code> 是序列&nbsp;<code>0...len(row)-1</code>&nbsp;的一个全排列。</li>\\n</ol>\\n","title":"765. 情侣牵手","relatedTags":["贪心","深度优先搜索","广度优先搜索","并查集","图"],"difficult":"Hard","lang":["javascript"],"uniqueID":"765","slug":"765-Couples-Holding-Hands"}')}}]);