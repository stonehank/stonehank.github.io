(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{681:function(n){n.exports=JSON.parse('{"content":"<blockquote>\\n<p><a href=\\"https://github.com/szimek/signature_pad\\">signature_pad</a>一个基于Canvas的平滑手写画板工具</p>\\n</blockquote>\\n<hr>\\n<h4 id=\\"yi-xie-jie-shao\\">一些介绍</h4>\\n<p>实现手写有多种方式。</p>\\n<p>一种比较容易做出的是对鼠标移动轨迹画点，再将两点之间以<code>直线</code>相连，最后再进行平滑处理，这种方案不需要什么算法支持，但同样，它面对一个性能和美观的抉择，打的点多，密集，性能相对较低，但更加美观，视觉上更平滑；</p>\\n<p>此处用的另一种方案，画贝塞尔曲线。</p>\\n<p>由于<code>canvas</code>没有默认的画出贝塞尔曲线方法，因此曲线是通过不断画出<code>一个个点</code>形成的，那么问题来了，这些点谁来定？</p>\\n<p>这里使用了贝塞尔曲线的一系列算法，包括<code>求控制点</code>，<code>求长度</code>，<code>计算当前点的大小</code>，最后用<code>canvas</code>画出每一个确定位置的点。</p>\\n<h4 id=\\"can-shu-ji-pei-zhi-jie-shao\\">参数及配置介绍</h4>\\n<p>提供的可配置参数如下</p>\\n<pre><code><pre class=\\"hljs\\"><code>export interface IOptions {\\n  // 点的大小(不是线条)\\n  dotSize?: number | (() =&gt; number);\\n  // 最粗的线条宽度\\n  minWidth?: number;\\n  // 最细的线条宽度\\n  maxWidth?: number;\\n  // 最小间隔距离(这个距离用贝塞尔曲线填充)\\n  minDistance?: number;\\n  // 背景色\\n  backgroundColor?: string;\\n  // 笔颜色\\n  penColor?: string;\\n  // 节流的间隔\\n  throttle?: number;\\n  // 当前画笔速度的计算率，默认0.7，意思就是 当前速度=当前实际速度*0.7+上一次速度*0.3\\n  velocityFilterWeight?: number;\\n  // 初始回调\\n  onBegin?: (event: MouseEvent | Touch) =&gt; void;\\n  // 结束回调\\n  onEnd?: (event: MouseEvent | Touch) =&gt; void;\\n}</code></pre></code></pre><p>这里要注意的是并没有<code>线条粗细</code>这个选项，因为这里面的粗细不等线条都是通过一个个大小不同的点构造而成；</p>\\n<p><code>throttle</code>这个配置可以参考<code>loadsh</code>或者<code>underscore</code>的<code>_.throttle</code>，功能一致，就是为了提高性能。</p>\\n<h4 id=\\"zhu-ce-shi-jian\\">注册事件</h4>\\n<p>在<code>constructor</code>内部，除了配置传入的参数外，就是注册事件。</p>\\n<p>这里优先使用了<a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent\\">PointerEvent</a>触点事件，<code>PointerEvent</code>可以说是触摸以及点击事件的一个统一，如果设备支持，不需要再分别为<code>mouse</code>和<code>touch</code>写两套事件了。</p>\\n<h4 id=\\"zhuang-tai-shu-ju-chu-cun\\">状态数据储存</h4>\\n<p>状态开关：</p>\\n<ul>\\n<li><p><code>this._mouseButtonDown</code></p>\\n<p>  当执行<code>move</code>事件时，会检查此状态，只有在<code>true</code>的情况下才会执行。</p>\\n</li>\\n</ul>\\n<p>数据储存分为2种格式：</p>\\n<ol>\\n<li><p><code>pointGroup</code></p>\\n<p> 这是当前笔画的点的一个集合，内部储存了当前笔画的颜色<code>color</code>和所有的点<code>points&lt;Array&gt;</code>。</p>\\n</li>\\n<li><p><code>this._data</code></p>\\n<p> 这是一个储存所有笔画的栈，格式为<code>[pointGroup, pointGroup, ..., pointGroup]</code>，当需要执行<code>undo</code>的时候，只需要删除<code>this._data</code>中的最后一条数据。</p>\\n</li>\\n</ol>\\n<h4 id=\\"shi-jian-liu-cheng-ji-fang-fa\\">事件流程及方法</h4>\\n<h5 id=\\"mousedown-shi-jian\\"><code>mouseDown</code>事件</h5>\\n<p>当鼠标(触点)按下时，改变状态<code>this._mouseButtonDown = true</code>，调用<code>onBegin</code>回调，创建当前笔画的一个新的集合，然后对<strong>当前点执行更新</strong>。</p>\\n<h5 id=\\"mousemove-shi-jian\\"><code>mouseMove</code>事件</h5>\\n<p>首先检查<code>this._mouseButtonDown</code>状态，对<strong>当前点执行更新</strong>。</p>\\n<h5 id=\\"mouseup-shi-jian\\"><code>mouseUp</code>事件</h5>\\n<p>改变状态<code>this._mouseButtonDown = false;</code>，调用<code>onEnd</code>回调，对<strong>当前点执行更新</strong>。</p>\\n<p>可以看到，上面的每一个事件内部都调用对当前点执行更新的方法。</p>\\n<h5 id=\\"dian-de-geng-xin-fang-fa-_strokeupdate\\">点的更新方法<code>_strokeUpdate</code></h5>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>private _strokeUpdate(event: MouseEvent | Touch): <span class=\\"hljs-keyword\\">void</span> {\\n    <span class=\\"hljs-comment\\">// 获取当前触点的位置</span>\\n    <span class=\\"hljs-keyword\\">const</span> x = event.clientX;\\n    <span class=\\"hljs-keyword\\">const</span> y = event.clientY;\\n\\n    <span class=\\"hljs-comment\\">// 创建点</span>\\n    <span class=\\"hljs-keyword\\">const</span> point = <span class=\\"hljs-keyword\\">this</span>._createPoint(x, y);\\n    <span class=\\"hljs-comment\\">// 调出最后一个点集</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPointGroup = <span class=\\"hljs-keyword\\">this</span>._data[<span class=\\"hljs-keyword\\">this</span>._data.length - <span class=\\"hljs-number\\">1</span>];\\n    <span class=\\"hljs-comment\\">// 获取最后一个点集的点的数组</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPoints = lastPointGroup.points;\\n    <span class=\\"hljs-comment\\">// 如果存在上一个点，获取上一个点</span>\\n    <span class=\\"hljs-keyword\\">const</span> lastPoint =\\n      lastPoints.length &gt; <span class=\\"hljs-number\\">0</span> &amp;&amp; lastPoints[lastPoints.length - <span class=\\"hljs-number\\">1</span>];\\n    <span class=\\"hljs-comment\\">// 判断上一个点到当前点是否太近(也就是小于配置的最小间隔距离)</span>\\n    <span class=\\"hljs-keyword\\">const</span> isLastPointTooClose = lastPoint\\n      ? point.distanceTo(lastPoint) &lt;= <span class=\\"hljs-keyword\\">this</span>.minDistance\\n      : <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-comment\\">// 调出点集的颜色</span>\\n    <span class=\\"hljs-keyword\\">const</span> color = lastPointGroup.color;\\n\\n    <span class=\\"hljs-comment\\">// Skip this point if it\'s too close to the previous one</span>\\n    <span class=\\"hljs-comment\\">// 存在上一个点但是太近，跳过，其余的执行</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!lastPoint || !(lastPoint &amp;&amp; isLastPointTooClose)) {\\n      <span class=\\"hljs-comment\\">// 向上一次的点数组中添加当前点，并且生成一个新的贝塞尔曲线实例</span>\\n      <span class=\\"hljs-comment\\">// 包括4个点 （初始点，2个控制点，结束点）</span>\\n      <span class=\\"hljs-comment\\">// 初始宽度，最终宽度</span>\\n      <span class=\\"hljs-keyword\\">const</span> curve = <span class=\\"hljs-keyword\\">this</span>._addPoint(point);\\n\\n      <span class=\\"hljs-comment\\">// 如果不存在lastPoint，即当前点是第一个点</span>\\n      <span class=\\"hljs-keyword\\">if</span> (!lastPoint) {\\n        <span class=\\"hljs-comment\\">// 画一个点</span>\\n        <span class=\\"hljs-keyword\\">this</span>._drawDot({ color, point });\\n      <span class=\\"hljs-comment\\">// 如果存在lastPoint 并且能形成一个贝塞尔曲线实例(3个点以上)</span>\\n      } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> (curve) {\\n        <span class=\\"hljs-comment\\">// 画出参数中curve实例中两点之间的曲线</span>\\n        <span class=\\"hljs-keyword\\">this</span>._drawCurve({ color, curve });\\n      }\\n      <span class=\\"hljs-comment\\">// 添加到当前笔画的点数组</span>\\n      lastPoints.push({\\n        <span class=\\"hljs-attr\\">time</span>: point.time,\\n        <span class=\\"hljs-attr\\">x</span>: point.x,\\n        <span class=\\"hljs-attr\\">y</span>: point.y,\\n      });\\n    }\\n  }</code></pre></code></pre>\\n<p>这个方法前面就是一系列判断</p>\\n<ul>\\n<li><p>判断是否是第一个点</p>\\n</li>\\n<li><p>判断是否能加入点的集合(满足点的最小间隔)</p>\\n</li>\\n<li><p>判断是否能画出贝塞尔曲线(满足至少3个点)</p>\\n<p>  对于能画出贝塞尔曲线的点，执行算法，求出<code>Besier</code>实例，包括4个点<code>初始点</code>，<code>结束点</code>，<code>控制点1</code>，<code>控制点2</code>以及当前曲线中线条的的<code>初始宽度</code>和<code>结束宽度</code>。</p>\\n<p>  具体如何算的，请参考源码<code>src/bezier.ts</code>和<a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">这篇文章</a>。</p>\\n</li>\\n</ul>\\n<p>对于能画出贝塞尔曲线的，对已经求出的<code>Bezier</code>实例，执行<code>this._drawCurve</code>，否则执行<code>this._drawDot</code></p>\\n<h5 id=\\"hua-dian-de-fang-fa-this_drawdot\\">画点的方法<code>this._drawDot</code></h5>\\n<p>获取配置中的<code>dotSize</code>，执行<code>canvas</code>画点。</p>\\n<h5 id=\\"hua-xian-de-fang-fa-this__drawcurve\\">画线的方法<code>this.__drawCurve</code></h5>\\n<ol>\\n<li><p>求出当前<code>Bezier</code>实例<code>初始点</code>和<code>结束点</code>之间的距离，这个距离不是直线距离，而是贝塞尔曲线距离。</p>\\n</li>\\n<li><p>对这个距离进行扩展，例如，计算得到距离为<code>50</code>，那就扩展为<code>100</code>个点，即我需要在<code>50</code>这个距离内画出<code>100</code>个点；</p>\\n<p> 这么做可以保证在正常或者稍微快速的书写中，不出现断层。</p>\\n</li>\\n<li><p>接着又是<a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">算法</a>，目的是求出这个距离内的每一个点的大小，这是一个变化值，是的粗细变化更加平滑。</p>\\n</li>\\n<li><p>最后同样是<code>canvas</code>画点。</p>\\n</li>\\n</ol>\\n<p>以上就是整个基本流程。</p>\\n<h4 id=\\"zong-jie\\">总结</h4>\\n<p>阅读一遍后，这个库说白就是基础的事件操作+贝塞尔曲线算法，但是，它内部的代码格式非常清晰，<code>细粒度+代码复用</code>使得维护起来非常方便。</p>\\n<p>同时可以对贝塞尔曲线有一个更深层的了解(算法还是没法手撕囧)，但起码有一个比较完整的思路；</p>\\n<p>一些可以借鉴的东西：</p>\\n<ul>\\n<li><a href=\\"#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6\\">PointerEvent的优势</a></li>\\n<li>canvas+贝塞尔曲线</li>\\n<li>节流<code>throttle</code>的写法(参考源码src/throttle.ts)</li>\\n<li><a href=\\"#%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98\\">数据结构及实现<code>undo</code>的方案</a></li>\\n</ul>\\n<blockquote>\\n<p>贝塞尔曲线算法资料：</p>\\n<ul>\\n<li><a href=\\"https://medium.com/square-corner-blog/smoother-signatures-be64515adb33\\">https://medium.com/square-corner-blog/smoother-signatures-be64515adb33</a></li>\\n<li><a href=\\"https://www.lemoda.net/maths/bezier-length/index.html\\">https://www.lemoda.net/maths/bezier-length/index.html</a></li>\\n</ul>\\n</blockquote>\\n<hr>\\n<blockquote>\\n<p><a href=\\"https://segmentfault.com/blog/souce-code\\"><strong>源码阅读专栏</strong></a>对一些中小型热门项目进行源码阅读和分析，对其整体做出导图，以便快速了解内部关系及执行顺序。\\n当前源码(带注释)，以及更多源码阅读内容：<a href=\\"https://github.com/stonehank/sourcecode-analysis\\">https://github.com/stonehank/sourcecode-analysis</a>，欢迎<code>fork</code>，求:star:</p>\\n</blockquote>\\n","toc":[{"anchor":"yi-xie-jie-shao","level":4,"text":"一些介绍"},{"anchor":"can-shu-ji-pei-zhi-jie-shao","level":4,"text":"参数及配置介绍"},{"anchor":"zhu-ce-shi-jian","level":4,"text":"注册事件"},{"anchor":"zhuang-tai-shu-ju-chu-cun","level":4,"text":"状态数据储存"},{"anchor":"shi-jian-liu-cheng-ji-fang-fa","level":4,"text":"事件流程及方法"},{"anchor":"mousedown-shi-jian","level":5,"text":"<code>mouseDown</code>事件"},{"anchor":"mousemove-shi-jian","level":5,"text":"<code>mouseMove</code>事件"},{"anchor":"mouseup-shi-jian","level":5,"text":"<code>mouseUp</code>事件"},{"anchor":"dian-de-geng-xin-fang-fa-_strokeupdate","level":5,"text":"点的更新方法<code>_strokeUpdate</code>"},{"anchor":"hua-dian-de-fang-fa-this_drawdot","level":5,"text":"画点的方法<code>this._drawDot</code>"},{"anchor":"hua-xian-de-fang-fa-this__drawcurve","level":5,"text":"画线的方法<code>this.__drawCurve</code>"},{"anchor":"zong-jie","level":4,"text":"总结"}],"relatedTags":null,"created_at":"2019-06-18","timeArr":[2019,5,18,0,0,0,0],"title":"源码阅读-signature_pad","uuid":"70c0ac44839743166637d895a36548085cbfc645","summary":"<p><a href=\\"https://github.com/szimek/signature_pad\\">signature_pad</a>一个基于Canvas的平滑手写画板工具</p>","slug":"yuan-ma-yue-du-signature_pad","sha":"feecc3d4a25186c780dc6453dc129b62bca69809"}')}}]);