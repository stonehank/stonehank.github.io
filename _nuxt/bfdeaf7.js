(window.webpackJsonp=window.webpackJsonp||[]).push([[914],{1712:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{TreeNode}</span> <span class=\\"hljs-variable\\">root</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findFrequentTreeSum = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">root</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!root)<span class=\\"hljs-keyword\\">return</span> []\\n  <span class=\\"hljs-keyword\\">let</span> hash={},ans=[]\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">calcTreeSum</span>(<span class=\\"hljs-params\\">root</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> sum=root.val\\n    <span class=\\"hljs-keyword\\">if</span>(root.left)sum+=calcTreeSum(root.left)\\n    <span class=\\"hljs-keyword\\">if</span>(root.right)sum+=calcTreeSum(root.right)\\n    <span class=\\"hljs-keyword\\">if</span>(!hash[sum])hash[sum]=<span class=\\"hljs-number\\">1</span>\\n    <span class=\\"hljs-keyword\\">else</span> hash[sum]++\\n    <span class=\\"hljs-keyword\\">if</span>(hash[sum]&gt;max){\\n      max=hash[sum]\\n      ans=[sum]\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(hash[sum]===max){\\n      ans.push(sum)\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> sum\\n  }\\n  calcTreeSum(root)\\n  <span class=\\"hljs-keyword\\">return</span> ans\\n};\\n</code></pre>\\n"],"querySlug":"most-frequent-subtree-sum","created_at":"2019-03-19","timeArr":[2019,2,19,10,44,56,0],"hasThinking":false,"content":"<p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\\n\\n<p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong><br>\\n输入:</p>\\n\\n<pre>  5\\n /  \\\\\\n2   -3\\n</pre>\\n\\n<p>返回&nbsp;[2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。</p>\\n\\n<p><strong>示例&nbsp;2：</strong><br>\\n输入：</p>\\n\\n<pre>  5\\n /  \\\\\\n2   -5\\n</pre>\\n\\n<p>返回&nbsp;[2]，只有 2 出现两次，-5 只出现 1 次。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong>&nbsp;假设任意子树元素和均可以用 32 位有符号整数表示。</p>\\n","title":"508. 出现次数最多的子树元素和","relatedTags":["树","深度优先搜索","哈希表","二叉树"],"difficult":"Middle","lang":["javascript"],"uniqueID":"508","slug":"508-Most-Frequent-Subtree-Sum"}')}}]);