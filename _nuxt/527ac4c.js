(window.webpackJsonp=window.webpackJsonp||[]).push([[874],{1672:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">maxChoosableInteger</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">desiredTotal</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> canIWin = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">maxChoosableInteger, desiredTotal</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-built_in\\">Math</span>.max.apply(<span class=\\"hljs-built_in\\">Math</span>,maxChoosableInteger),\\n      min=<span class=\\"hljs-built_in\\">Math</span>.min.apply(<span class=\\"hljs-built_in\\">Math</span>,maxChoosableInteger)\\n  <span class=\\"hljs-keyword\\">if</span>(desiredTotal % (max+min)===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n};\\n</code></pre>\\n","<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">canIWin</span><span class=\\"hljs-params\\">(self, maxChoosableInteger, desiredTotal)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \\"\\"\\"</span>\\n        <span class=\\"hljs-keyword\\">if</span> desiredTotal==<span class=\\"hljs-number\\">0</span>:<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">True</span>\\n        sums=<span class=\\"hljs-number\\">0</span>\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(<span class=\\"hljs-number\\">1</span>,maxChoosableInteger+<span class=\\"hljs-number\\">1</span>):\\n          sums+=i\\n        <span class=\\"hljs-keyword\\">if</span> sums&lt;desiredTotal:<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">False</span>\\n        memo={}\\n        status=[<span class=\\"hljs-literal\\">True</span>]*(maxChoosableInteger+<span class=\\"hljs-number\\">1</span>)\\n        \\n        <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">select</span><span class=\\"hljs-params\\">(status,total)</span>:</span>\\n          <span class=\\"hljs-keyword\\">if</span> total&lt;=<span class=\\"hljs-number\\">0</span>:<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">False</span>\\n          <span class=\\"hljs-keyword\\">if</span> (status) <span class=\\"hljs-keyword\\">in</span> memo:\\n            <span class=\\"hljs-keyword\\">return</span> memo[status]\\n          \\n          <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(<span class=\\"hljs-number\\">1</span>,maxChoosableInteger+<span class=\\"hljs-number\\">1</span>):\\n            cur=<span class=\\"hljs-number\\">1</span>&lt;&lt;i\\n            <span class=\\"hljs-keyword\\">if</span> cur &amp; status!=<span class=\\"hljs-number\\">0</span>:<span class=\\"hljs-keyword\\">continue</span>\\n            <span class=\\"hljs-comment\\"># if not status[i]:continue</span>\\n            <span class=\\"hljs-comment\\"># status[i]=False</span>\\n            nxt=select(status | cur,total-i)\\n            <span class=\\"hljs-comment\\"># status[i]=True</span>\\n            <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">not</span> nxt:\\n              memo[status]=<span class=\\"hljs-literal\\">True</span>\\n              <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">True</span>\\n          memo[status]=<span class=\\"hljs-literal\\">False</span>\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">False</span>\\n\\n        <span class=\\"hljs-keyword\\">return</span> select(<span class=\\"hljs-number\\">1</span>,desiredTotal)\\n</code></pre>\\n"],"querySlug":"can-i-win","hasThinking":true,"thinking":"<hr>\\n<p>两个玩家可以轮流从公共整数池中抽取从<code>1</code>到<code>M</code>的整数（不放回），直到累计整数和&gt;=<code>T</code>。</p>\\n<p>思路：</p>\\n<ol>\\n<li>由于双方都是最佳表现，因此可以使用同一个递归公式。</li>\\n<li>当前玩家获胜的前提有2个：一是当前回合我能凑齐整数<code>T</code>，二是下一回合对手会输。</li>\\n<li>如果当前玩家未获胜，到了下一回合对手玩家的胜利也同样是以上两点。</li>\\n</ol>\\n<p>根据以上可以轻松写出递归思路：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> canIWin = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">maxChoosableInteger, desiredTotal</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(desiredTotal&lt;=maxChoosableInteger)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">if</span>(desiredTotal&gt;maxChoosableInteger*(maxChoosableInteger+<span class=\\"hljs-number\\">1</span>)/<span class=\\"hljs-number\\">2</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-keyword\\">let</span> used=<span class=\\"hljs-built_in\\">Array</span>(maxChoosableInteger).fill(<span class=\\"hljs-literal\\">false</span>)\\n  <span class=\\"hljs-keyword\\">return</span> canWin(desiredTotal,used)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">canWin</span>(<span class=\\"hljs-params\\">total</span>)</span>{\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;maxChoosableInteger;++i){\\n      <span class=\\"hljs-keyword\\">if</span>(used[i])<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-comment\\">// 当总数小于选中的数 或者 对方输了，就能判定为胜利</span>\\n      used[i]=<span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-keyword\\">if</span>(total&lt;=i+<span class=\\"hljs-number\\">1</span> || !canWin(total-(i+<span class=\\"hljs-number\\">1</span>))){\\n        used[i]=<span class=\\"hljs-literal\\">false</span>; <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n      }<span class=\\"hljs-keyword\\">else</span> used[i]=<span class=\\"hljs-literal\\">false</span>\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  }\\n};\\n</code></pre>\\n<p>这一段代码思路很清楚，但是<code>TLE</code>，因为全部完成是一个阶乘的数量级，考虑两个状态，</p>\\n<ol>\\n<li>A先选3，B选1</li>\\n<li>A先选1，B选3</li>\\n</ol>\\n<p>这两个状态选的顺序不同，但是结果是完全一致的，因此我们减少对状态的保存。</p>\\n<p>我们使用<code>[]</code>保存状态，使用<code>JSON.stringify</code>获取状态属性。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> canIWin = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">maxChoosableInteger, desiredTotal</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(desiredTotal&lt;=maxChoosableInteger)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>\\n  <span class=\\"hljs-keyword\\">if</span>(desiredTotal&gt;maxChoosableInteger*(maxChoosableInteger+<span class=\\"hljs-number\\">1</span>)/<span class=\\"hljs-number\\">2</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n  <span class=\\"hljs-keyword\\">let</span> m={}\\n  <span class=\\"hljs-keyword\\">let</span> used=<span class=\\"hljs-built_in\\">Array</span>(maxChoosableInteger).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">return</span> canWin(desiredTotal,used)\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">canWin</span>(<span class=\\"hljs-params\\">total</span>)</span>{\\n    <span class=\\"hljs-comment\\">// 存在状态直接读取</span>\\n    <span class=\\"hljs-keyword\\">if</span> (m[<span class=\\"hljs-built_in\\">JSON</span>.stringify(used)]!=<span class=\\"hljs-literal\\">null</span>) <span class=\\"hljs-keyword\\">return</span> m[<span class=\\"hljs-built_in\\">JSON</span>.stringify(used)];\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;maxChoosableInteger;++i){\\n      <span class=\\"hljs-keyword\\">if</span>(used[i])<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-comment\\">// 当总数小于选中的数 或者 对方输了，就能判定为胜利</span>\\n      used[i]=<span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-keyword\\">if</span>(total&lt;=i+<span class=\\"hljs-number\\">1</span> || !canWin(total-(i+<span class=\\"hljs-number\\">1</span>))){\\n        used[i]=<span class=\\"hljs-literal\\">false</span>\\n        <span class=\\"hljs-comment\\">// 保存获胜状态</span>\\n        m[<span class=\\"hljs-built_in\\">JSON</span>.stringify(used)] = <span class=\\"hljs-literal\\">true</span>;\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n      }\\n      used[i]=<span class=\\"hljs-literal\\">false</span>\\n    }\\n    <span class=\\"hljs-comment\\">// 保存失败状态</span>\\n    m[<span class=\\"hljs-built_in\\">JSON</span>.stringify(used)] = <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  }\\n};\\n</code></pre>\\n<p>这一段代码能通过，但也可以视为<code>TLE</code>，因为耗时<code>2500~3000ms</code>，原因是使用<code>JSON.stringify</code>太消耗资源。</p>\\n<p>我们需要一个更简洁有效的保存方式——<code>位</code>。</p>\\n<p>使用位来保存当前状态的好处：</p>\\n<ol>\\n<li>不用考虑顺序，只要存在就可以跳过</li>\\n<li>节省空间</li>\\n<li>整体可以作为一个数字，也可以作为一个状态属性，例如<code>00011111</code>既可以表示后5位使用了，也可以用数字<code>31</code>保存这个状态。</li>\\n</ol>\\n","content":"<p>在 &quot;100 game&quot; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到或超过 100 的玩家，即为胜者。</p>\\n\\n<p>如果我们将游戏规则改为 &ldquo;玩家不能重复使用整数&rdquo; 呢？</p>\\n\\n<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>\\n\\n<p>给定一个整数&nbsp;<code>maxChoosableInteger</code>&nbsp;（整数池中可选择的最大数）和另一个整数&nbsp;<code>desiredTotal</code>（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p>\\n\\n<p>你可以假设&nbsp;<code>maxChoosableInteger</code>&nbsp;不会大于 20，&nbsp;<code>desiredTotal</code>&nbsp;不会大于 300。</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre><strong>输入：</strong>\\nmaxChoosableInteger = 10\\ndesiredTotal = 11\\n\\n<strong>输出：</strong>\\nfalse\\n\\n<strong>解释：\\n</strong>无论第一个玩家选择哪个整数，他都会失败。\\n第一个玩家可以选择从 1 到 10 的整数。\\n如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。\\n第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.\\n同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\\n</pre>\\n","title":"464. 我能赢吗","relatedTags":["位运算","记忆化搜索","数学","动态规划","状态压缩","博弈"],"difficult":"Middle","lang":["javascript","python"],"uniqueID":"464","slug":"464-Can-I-Win"}')}}]);