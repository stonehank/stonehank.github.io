(window.webpackJsonp=window.webpackJsonp||[]).push([[1255],{2053:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">A</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> sumSubseqWidths = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">A</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> MOD=<span class=\\"hljs-number\\">1e9</span>+<span class=\\"hljs-number\\">7</span>\\n  A.sort(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a-b)\\n  <span class=\\"hljs-keyword\\">let</span> leftPow=<span class=\\"hljs-built_in\\">Array</span>(A.length).fill(<span class=\\"hljs-number\\">1</span>),\\n      rightPow=<span class=\\"hljs-built_in\\">Array</span>(A.length).fill(<span class=\\"hljs-number\\">1</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;A.length;i++){\\n    leftPow[i]=(leftPow[i<span class=\\"hljs-number\\">-1</span>]*<span class=\\"hljs-number\\">2</span>)%MOD\\n  }\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=A.length<span class=\\"hljs-number\\">-2</span>;i&gt;=<span class=\\"hljs-number\\">0</span>;i--){\\n    rightPow[i]=(rightPow[i+<span class=\\"hljs-number\\">1</span>]*<span class=\\"hljs-number\\">2</span>)%MOD\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>,p=<span class=\\"hljs-number\\">1</span>;i&lt;A.length;i++,p=(p&lt;&lt;<span class=\\"hljs-number\\">1</span>) % MOD){\\n    res=(res + A[i]*leftPow[i]-A[i]*rightPow[i]) % MOD\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"sum-of-subsequence-widths","created_at":"2019-03-16","timeArr":[2019,2,16,13,31,43,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>因为这里只是要求子序列内部的最大最小值，因此子序列的顺序是没有影响的，可以先执行排序。</p>\\n<p>最初的想法是，对每一项<code>A[i]</code>，找出当它作为最小值时，能贡献的宽度和，但这么做内部也要遍历一遍剩下的数。\\n最终时间复杂度是<code>O(N^2)</code>，不符合要求。</p>\\n<p>其实对于每一项<code>A[i]</code>，我们不需要再去遍历它之后的数字。</p>\\n<p>因为这个数组已经排好序，这个数<code>A[i]</code>后面的所有数组成的序列，一定存在<code>2^len-i-1</code>个子序列以<code>A[i]</code>为最小值；</p>\\n<p>同样，这个数<code>A[i]</code>前面的所有数组成的序列，也一定存在<code>2^i</code>个子序列以<code>A[i]</code>为最大值；</p>\\n<p>找出它作为最小值时的序列数，和它作为最大值的序列数，这两个数分别乘上<code>A[i]</code>，也就是<code>A[i]</code>能贡献的作为最大值和最小值的总和。</p>\\n<p>因此<code>res+=A[i]* (2^i) - A[i]*(2^(len-i-1))</code></p>\\n<p>但还有一个要注意，我们不能直接使用<code>Math.pow</code>，因为长度和<code>A[i]</code>最多有<code>20000</code>，<code>Math.pow(20000,20000)</code>是会溢出的。</p>\\n<p>因此需要2个数组保存<code>pow</code>，见代码。</p>\\n","content":"<p>给定一个整数数组 <code>A</code> ，考虑 <code>A</code> 的所有非空子序列。</p>\\n\\n<p>对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。</p>\\n\\n<p>返回 A 的所有子序列的宽度之和。</p>\\n\\n<p>由于答案可能非常大，请<strong>返回答案模 10^9+7</strong>。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre><strong>输入：</strong>[2,1,3]\\n<strong>输出：</strong>6\\n<strong>解释：\\n</strong>子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。\\n相应的宽度是 0，0，0，1，1，2，2 。\\n这些宽度之和是 6 。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= A.length &lt;= 20000</code></li>\\n\\t<li><code>1 &lt;= A[i] &lt;= 20000</code></li>\\n</ul>\\n","title":"891. 子序列宽度之和","relatedTags":["数组","数学","排序"],"difficult":"Hard","lang":["javascript"],"uniqueID":"891","slug":"891-Sum-of-Subsequence-Widths"}')}}]);