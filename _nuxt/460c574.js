(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{577:function(n){n.exports=JSON.parse('{"content":"<p>最近遇到的，目的是通过粒子动画渲染图片</p>\\n<p>图片大小为500*300，并且粒子动画细度为1，也就是粒子总量为15万，并且当动画完成后，图片能完整清晰的显示出来</p>\\n<p>最初尝试15万个粒子同时运动，结果标签页直接崩溃了，意料之中...</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> py = <span class=\\"hljs-number\\">0</span>; py &lt; targetH; py ++) {\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> px = <span class=\\"hljs-number\\">0</span>; px &lt; targetW; px ++) {\\n      <span class=\\"hljs-keyword\\">let</span> rgba4 = (px + py * targetW) * <span class=\\"hljs-number\\">4</span> - <span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">if</span>(rgba4&lt;<span class=\\"hljs-number\\">0</span>)rgba4=<span class=\\"hljs-number\\">3</span>\\n      <span class=\\"hljs-keyword\\">const</span> rgba3=rgba4<span class=\\"hljs-number\\">-1</span>,rgba2=rgba3<span class=\\"hljs-number\\">-1</span>,rgba1=rgba2<span class=\\"hljs-number\\">-1</span>;\\n      <span class=\\"hljs-keyword\\">const</span> opacity = imgData.data[rgba4];\\n      <span class=\\"hljs-keyword\\">if</span> (opacity === <span class=\\"hljs-number\\">255</span>) {\\n        <span class=\\"hljs-keyword\\">const</span> opts={\\n          <span class=\\"hljs-attr\\">cur</span>:[px,py],\\n          <span class=\\"hljs-attr\\">end</span>:[px,py],\\n          <span class=\\"hljs-attr\\">color</span>:[imgData.data[rgba1],imgData.data[rgba2],imgData.data[rgba3],imgData.data[rgba4]],\\n           <span class=\\"hljs-comment\\">/* 省略：一些其他参数 */</span>\\n         }\\n         <span class=\\"hljs-comment\\">/* 省略：对当前时间戳的处理 */</span>\\n         <span class=\\"hljs-comment\\">/* 省略：对动画的处理 */</span>\\n         ctx.fillStyle = <span class=\\"hljs-string\\">`rgba(<span class=\\"hljs-subst\\">${rgba1}</span>, <span class=\\"hljs-subst\\">${rgba2}</span>, <span class=\\"hljs-subst\\">${rgba3}</span>,<span class=\\"hljs-subst\\">${rgba4}</span>`</span>\\n         ctx.fillRect(curX, curY, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>);\\n      }\\n    }\\n  }</code></pre></code></pre>\\n<hr>\\n<p>后来考虑离屏吧，规定每个离屏承载量为1000(保证fps)，这么一来，75个<code>离屏canvas</code>，开始动画...奔溃了...</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createAssignParticles</span>(<span class=\\"hljs-params\\">allParticles</span>)</span>{\\n  <span class=\\"hljs-comment\\">// 定义每个离屏承载量</span>\\n  <span class=\\"hljs-keyword\\">const</span> eachPanelParticles=<span class=\\"hljs-number\\">1000</span>\\n  <span class=\\"hljs-keyword\\">const</span> assignedParticles=[]\\n  <span class=\\"hljs-keyword\\">const</span> panelsSize=<span class=\\"hljs-built_in\\">Math</span>.ceil(allParticles.length/eachPanelParticles)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;panelsSize;i++){\\n    <span class=\\"hljs-comment\\">// 创建离屏canvas</span>\\n    <span class=\\"hljs-keyword\\">const</span>  canvas = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">\'canvas\'</span>);\\n    canvas.width=<span class=\\"hljs-built_in\\">window</span>.outerWidth\\n    canvas.height=<span class=\\"hljs-built_in\\">window</span>.outerHeight;\\n    <span class=\\"hljs-keyword\\">const</span> ctx=canvas.getContext(<span class=\\"hljs-string\\">\'2d\'</span>)\\n    <span class=\\"hljs-comment\\">// 后渲染的在上层</span>\\n    ctx.globalCompositeOperation=<span class=\\"hljs-string\\">\'destination-over\'</span>\\n    <span class=\\"hljs-comment\\">// 取消抗锯齿</span>\\n    ctx.imageSmoothingEnabled = <span class=\\"hljs-literal\\">false</span>;\\n    ctx.mozImageSmoothingEnabled = <span class=\\"hljs-literal\\">false</span>;\\n    ctx.webkitImageSmoothingEnabled = <span class=\\"hljs-literal\\">false</span>;\\n    assignedParticles[i]={\\n      <span class=\\"hljs-attr\\">sourceArr</span>:[],\\n      canvas,\\n      ctx,\\n    }\\n  }\\n  <span class=\\"hljs-comment\\">// 乱序将每个粒子平均插入每个离屏canvas</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;allParticles.length;i++){\\n    <span class=\\"hljs-keyword\\">const</span> putInWhichPanel=<span class=\\"hljs-built_in\\">Math</span>.floor(<span class=\\"hljs-built_in\\">Math</span>.random()*(panelsSize<span class=\\"hljs-number\\">-0.01</span>))\\n    assignedParticles[putInWhichPanel].sourceArr.push(allParticles[i])\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> assignedParticles\\n}\\n\\n<span class=\\"hljs-comment\\">// 执行动画函数内部</span>\\n<span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;assignedParticles.length;i++){\\n  <span class=\\"hljs-keyword\\">let</span> cur=assignedParticles[i].sourceArr\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;cur.length;j++){\\n     <span class=\\"hljs-comment\\">/* 省略：对当前时间戳的处理 */</span>\\n     <span class=\\"hljs-comment\\">/* 省略：对动画的处理 */</span>\\n     ctx.fillStyle = <span class=\\"hljs-string\\">`rgba(<span class=\\"hljs-subst\\">${rgba1}</span>, <span class=\\"hljs-subst\\">${rgba2}</span>, <span class=\\"hljs-subst\\">${rgba3}</span>,<span class=\\"hljs-subst\\">${rgba4}</span>`</span>\\n     ctx.fillRect(curX, curY, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>);\\n  }\\n}</code></pre></code></pre>\\n<p>毕竟同时运动的总量还是15万个粒子...</p>\\n<p>既然不能同时运动，那么就分批运动总行了吧</p>\\n<hr>\\n<p>每个<code>离屏canvas</code>执行完毕，递归调用下一个<code>离屏canvas</code>，但这样又出现一个新的问题，</p>\\n<p>如果每个<code>离屏canvas</code>执行后，清除显示用的画布，那么动画只是会出现每一个离屏的动画，上一个离屏动画的结果并未保存。</p>\\n<p>如果不清除显示的画布，那么每个<code>离屏canvas</code>会有轨迹，造成模糊(虽然也挺好看，但不是需要的效果)。</p>\\n<p><img src=\\"/article/img/%E5%B8%A6%E8%BD%A8%E8%BF%B9.png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> raf <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'raf\'</span>\\n<span class=\\"hljs-keyword\\">import</span> {spiral,fadeIn,explode} <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./animations-control/core\'</span>\\n<span class=\\"hljs-keyword\\">import</span> stopIfNeed <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./animations-control/stopIfNeed\'</span>\\n<span class=\\"hljs-keyword\\">import</span> lastRenders <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'./animations-control/lastRenders\'</span>\\n\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">play</span>(<span class=\\"hljs-params\\">assignedParticles,c_showMotion,ctx_showMotion,options,doneCallBack</span>)</span>{\\n  <span class=\\"hljs-comment\\">/* 省略：获取会用到的参数*/</span>\\n  <span class=\\"hljs-keyword\\">let</span> allParticlesIdx=<span class=\\"hljs-number\\">0</span>\\n  recursionExec(allParticlesIdx)\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>  <span class=\\"hljs-title\\">recursionExec</span>(<span class=\\"hljs-params\\">allParticlesIdx</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> arrs=assignedParticles[allParticlesIdx].sourceArr\\n    <span class=\\"hljs-keyword\\">let</span> ctx=assignedParticles[allParticlesIdx].ctx\\n    <span class=\\"hljs-keyword\\">let</span> canvas=assignedParticles[allParticlesIdx].canvas\\n    <span class=\\"hljs-keyword\\">let</span> doneNum=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">let</span> rafHandle\\n    <span class=\\"hljs-keyword\\">let</span> msPerFrame=<span class=\\"hljs-number\\">1000</span>/<span class=\\"hljs-number\\">60</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">startIfNeed</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n      rafHandle= raf(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">playing</span>(<span class=\\"hljs-params\\">timestamp</span>)</span>{\\n       <span class=\\"hljs-comment\\">/* 省略：判断当前离屏canvas是否结束 */</span>\\n\\n       <span class=\\"hljs-comment\\">// 执行当前离屏canvas</span>\\n      ctx.clearRect(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>, canvasW, canvasH)\\n      ctx.beginPath();\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> k = <span class=\\"hljs-number\\">0</span>; k &lt; arrs.length; k++) {\\n        <span class=\\"hljs-keyword\\">let</span> {cur,end} = arrs[k]\\n        <span class=\\"hljs-comment\\">/* 省略：判断当前粒子是否需要停止*/</span>\\n        <span class=\\"hljs-comment\\">/* 省略：对当前时间戳的处理 */</span>\\n        <span class=\\"hljs-comment\\">/* 省略：对动画的处理 */</span>\\n\\n        ctx.fillStyle = <span class=\\"hljs-string\\">`rgba(<span class=\\"hljs-subst\\">${rgba1}</span>, <span class=\\"hljs-subst\\">${rgba2}</span>, <span class=\\"hljs-subst\\">${rgba3}</span>,<span class=\\"hljs-subst\\">${rgba4}</span>`</span>\\n        ctx.fillRect( curX,  curY, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">1</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 此处ctx_showMotion是显示用的canvas，</span>\\n      <span class=\\"hljs-comment\\">// 如果不使用clearRect，那么会出现轨迹</span>\\n      <span class=\\"hljs-comment\\">// 如果使用clearRect，那么每次执行的动画结果不会被保存</span>\\n      <span class=\\"hljs-comment\\">// ctx_showMotion.clearRect(0,0,canvasW,canvasH)</span>\\n      ctx_showMotion.drawImage(canvas ,<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>,)\\n\\n        raf(playing)\\n      })\\n      ctx_storeStatus.drawImage(c_showMotion,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>)\\n    }\\n    startIfNeed()\\n  }\\n}</code></pre></code></pre>\\n<hr>\\n<p>最后考虑用2张画布显示，第一个清除并且显示当前<code>离屏canvas</code>，第二个用来保存第一个的结果</p>\\n<pre><code><pre class=\\"hljs\\"><code>      /* 省略：前面参数多了一个ctx_storeStatus，其他一致 */\\n        ctx.fillStyle = `rgba(${rgba1}, ${rgba2}, ${rgba3},${rgba4}`\\n        ctx.fillRect( curX,  curY, 1, 1);\\n      }\\n      // 此处ctx_showMotion是显示用的canvas，\\n      // 如果不使用clearRect，那么会出现轨迹\\n      // 如果使用clearRect，那么每次执行的动画结果不会被保存\\n      // ctx_showMotion.clearRect(0,0,canvasW,canvasH)\\n      ctx_showMotion.drawImage(canvas ,0, 0,)\\n        raf(playing)\\n      })\\n      // 专门用于保存ctx_showMotion处理结果的canvas画布\\n      ctx_storeStatus.drawImage(c_showMotion,0,0)\\n    }\\n    startIfNeed()\\n  }\\n}</code></pre></code></pre><p>最终效果如下：</p>\\n<p><img src=\\"/article/img/spiral.gif\\" alt=\\"\\"></p>\\n<p>可以看到fps平均在45-50之间</p>\\n<hr>\\n<p>总结：</p>\\n<p>充分利用canvas的画布，将对粒子进行<code>fill</code>的动画转换成对<code>离屏canvas</code>进行<code>drawImage</code>的处理</p>\\n","toc":[],"relatedTags":null,"created_at":"2018-08-26","timeArr":[2018,7,26,0,0,0,0],"title":"canvas执行15万粒子的动画","uuid":"7d5b714624c6bcfe8c2c66acd5114f3f547fbb49","summary":"<p>最近遇到的，目的是通过粒子动画渲染图片</p>\\n<p>图片大小为500*300，并且粒子动画细度为1，也就是粒子总量为15万，并且当动画完成后，图片能完整清晰的显示出来</p>\\n<p>最初尝试15万个粒子同时运动，结果标签页直接崩溃了，意料之中...</p>\\n<pre class=\\"hljs\\"><code> <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> py = <span class=\\"hljs-number\\">0</span>; py &lt; targetH; py ++) ...</code></pre>","slug":"canvas-zhi-xing-15-wan-li-zi-de-dong-hua","sha":"742860bdc0a8dc633fd2c91feb13e60b00f46229"}')}}]);