(window.webpackJsonp=window.webpackJsonp||[]).push([[690],{1488:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Initialize your data structure here.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> MyQueue = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.stack1=[]\\n  <span class=\\"hljs-keyword\\">this</span>.stack2=[]\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Push element x to the back of queue. \\n * @param {number} x\\n * @return {void}\\n */</span>\\nMyQueue.prototype.push = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x</span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.stack1.push(x)\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Removes the element from in front of queue and returns that element.\\n * @return {number}\\n */</span>\\nMyQueue.prototype.pop = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.peek()\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.stack2.pop()\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Get the front element.\\n * @return {number}\\n */</span>\\nMyQueue.prototype.peek = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.stack2.length===<span class=\\"hljs-number\\">0</span>){\\n    <span class=\\"hljs-keyword\\">while</span>(<span class=\\"hljs-keyword\\">this</span>.stack1.length&gt;<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">this</span>.stack2.push(<span class=\\"hljs-keyword\\">this</span>.stack1.pop())\\n    }    \\n  }\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.stack2[<span class=\\"hljs-keyword\\">this</span>.stack2.length<span class=\\"hljs-number\\">-1</span>]\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * Returns whether the queue is empty.\\n * @return {boolean}\\n */</span>\\nMyQueue.prototype.empty = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">this</span>.stack1.length===<span class=\\"hljs-number\\">0</span> &amp;&amp; <span class=\\"hljs-keyword\\">this</span>.stack2.length===<span class=\\"hljs-number\\">0</span> \\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your MyQueue object will be instantiated and called as such:\\n * var obj = new MyQueue()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.peek()\\n * var param_4 = obj.empty()\\n */</span>\\n</code></pre>\\n"],"querySlug":"implement-queue-using-stacks","created_at":"2019-04-17","timeArr":[2019,3,17,9,58,48,0],"hasThinking":false,"content":"<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>\\n\\n<p>实现 <code>MyQueue</code> 类：</p>\\n\\n<ul>\\n\\t<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>\\n\\t<li><code>int pop()</code> 从队列的开头移除并返回元素</li>\\n\\t<li><code>int peek()</code> 返回队列开头的元素</li>\\n\\t<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>说明：</strong></p>\\n\\n<ul>\\n\\t<li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>\\n\\t<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶：</strong></p>\\n\\n<ul>\\n\\t<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>\\n[\\"MyQueue\\", \\"push\\", \\"push\\", \\"peek\\", \\"pop\\", \\"empty\\"]\\n[[], [1], [2], [], [], []]\\n<strong>输出：</strong>\\n[null, null, null, 1, 1, false]\\n\\n<strong>解释：</strong>\\nMyQueue myQueue = new MyQueue();\\nmyQueue.push(1); // queue is: [1]\\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\\nmyQueue.peek(); // return 1\\nmyQueue.pop(); // return 1, queue is [2]\\nmyQueue.empty(); // return false\\n</pre>\\n\\n<ul>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= x <= 9</code></li>\\n\\t<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>\\n\\t<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>\\n</ul>\\n","title":"232. 用栈实现队列","relatedTags":["栈","设计","队列"],"difficult":"Easy","lang":["javascript"],"uniqueID":"232","slug":"232-Implement-Queue-using-Stacks"}')}}]);