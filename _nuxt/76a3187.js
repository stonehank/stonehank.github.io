(window.webpackJsonp=window.webpackJsonp||[]).push([[942],{1740:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> singleNonDuplicate = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> l=<span class=\\"hljs-number\\">0</span>,r=nums.length<span class=\\"hljs-number\\">-1</span>\\n  <span class=\\"hljs-keyword\\">while</span>(l&lt;=r){\\n    <span class=\\"hljs-keyword\\">let</span> mid=<span class=\\"hljs-built_in\\">Math</span>.floor((l+r)/<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">let</span> cur=nums[mid],\\n        pre=mid&gt;<span class=\\"hljs-number\\">0</span> ? nums[mid<span class=\\"hljs-number\\">-1</span>] : <span class=\\"hljs-literal\\">null</span>,\\n        nxt=mid&lt;nums.length<span class=\\"hljs-number\\">-1</span> ? nums[mid+<span class=\\"hljs-number\\">1</span>] : <span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-keyword\\">if</span>(cur!==pre &amp;&amp; cur!==nxt){\\n      <span class=\\"hljs-keyword\\">return</span> cur\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(mid % <span class=\\"hljs-number\\">2</span>===<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">if</span>(cur===nxt)l=mid+<span class=\\"hljs-number\\">1</span>\\n      <span class=\\"hljs-keyword\\">else</span> r=mid<span class=\\"hljs-number\\">-1</span>\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(mid % <span class=\\"hljs-number\\">2</span>===<span class=\\"hljs-number\\">1</span>){\\n      <span class=\\"hljs-keyword\\">if</span>(cur===nxt)r=mid<span class=\\"hljs-number\\">-1</span>\\n      <span class=\\"hljs-keyword\\">else</span> l=mid+<span class=\\"hljs-number\\">1</span>\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"single-element-in-a-sorted-array","created_at":"2019-04-30","timeArr":[2019,3,30,10,28,30,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>由于有限制时间复杂度<code>O(logN)</code>，最先联想到的就是<code>二分法</code>。</p>\\n<p>如何确定查找的顺序呢，首先查找<code>nums</code>中索引中间的值<code>mid</code>，检查这个值，</p>\\n<ul>\\n<li>\\n<p>如果它既不和前面的数相等，也不和后面的数相等，那就是单独的数，返回即可；</p>\\n</li>\\n<li>\\n<p>检查索引是否偶数，因为如果前面不存在单独的数，那么一对相同的数中，前面那个的索引一定是偶数，\\n如果已经出现了单独的数，那么前面的索引一定是奇数。</p>\\n</li>\\n<li>\\n<p>如果是偶数并且当前数是一对中的第一个，说明单独的数还未出现，继续向后找；如果当前数是第二个，那么说明单独的数已经出现了，向前找。</p>\\n</li>\\n<li>\\n<p>同样，如果是奇数，则和上面相反。</p>\\n</li>\\n</ul>\\n","content":"<p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> nums = [1,1,2,3,3,4,4,8,8]\\n<strong>输出:</strong> 2\\n</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre>\\n<strong>输入:</strong> nums =  [3,3,7,7,10,11,11]\\n<strong>输出:</strong> 10\\n</pre>\\n\\n<p> </p>\\n\\n<p><meta charset=\\"UTF-8\\" /></p>\\n\\n<p><strong>提示:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\\n\\t<li><code>0 <= nums[i] <= 10<sup>5</sup></code></li>\\n</ul>\\n\\n<p> </p>\\n\\n<p><strong>进阶:</strong> 采用的方案可以在 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度中运行吗？</p>\\n","title":"540. 有序数组中的单一元素","relatedTags":["数组","二分查找"],"difficult":"Middle","lang":["javascript"],"uniqueID":"540","slug":"540-Single-Element-in-a-Sorted-Array"}')}}]);