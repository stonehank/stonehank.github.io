(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{574:function(n){n.exports=JSON.parse('{"content":"<h2 id=\\"bable-cha-jian-bian-xie-yi-xie-zong-jie\\">BABLE插件编写一些总结</h2>\\n<ol>\\n<li><p>babel-plugin总是先于babel-presets执行，但实际上它们是并行执行，因此如果需要编写一个有依赖的babel插件，其实就是\\n race模式。<a href=\\"https://jamie.build/babel-plugin-ordering.html\\">https://jamie.build/babel-plugin-ordering.html</a></p>\\n<p> 这么做是为了节省编译时间，有一个选项，<code>passPerPreset</code>可以单线程执行编译，但是这会影响性能，因此后续可能废弃。</p>\\n<p> 比较好的方法是，如果需要最先获取源代码AST，</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code> visitor:{\\n  <span class=\\"hljs-attr\\">Program</span>:{\\n    <span class=\\"hljs-string\\">\\"enter\\"</span>:<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">path</span>)</span>{   \\n      path.traverse({\\n        <span class=\\"hljs-comment\\">//...</span>\\n      })\\n    }\\n  }\\n }\\n</code></pre></code></pre>\\n</li>\\n<li><p>对于<code>t.XXXXX()</code>，括号内部只需要填写需要的属性即可</p>\\n</li>\\n<li><p>在<code>AST</code>树中要获取某个变量或者参数的引用，非常困难，因为有各种情况，包括</p>\\n<ul>\\n<li><p>定义变量</p>\\n</li>\\n<li><p>参数赋值</p>\\n</li>\\n<li><p>import</p>\\n</li>\\n<li><p>属性获取</p>\\n</li>\\n<li><p>for循环的index\\n...</p>\\n<p>上述所有情况还能互相叠加，要将所有都覆盖，是很大的工程，因此尽量只对字面去修改，不要追溯。</p>\\n</li>\\n</ul>\\n</li>\\n<li><p>如果项目动态编译的情况很多，那么AST静态编译效果可能不太好。</p>\\n</li>\\n</ol>\\n","toc":[{"anchor":"bable-cha-jian-bian-xie-yi-xie-zong-jie","level":2,"text":"BABLE插件编写一些总结"}],"relatedTags":null,"created_at":"2018-09-24","timeArr":[2018,8,24,0,0,0,0],"title":"babel插件的一些总结","uuid":"ca04d014d61ce50791c49363dae3a3d3ae3b1e54","summary":"<h4>BABLE插件编写一些总结</h4>\\n<ol>\\n<li>\\n<p>babel-plugin总是先于babel-presets执行，但实际上它们是并行执行，因此如果需要编写一个有依赖的babel插件，其实就是\\nrace模式。https://jamie.build/babel-plugin-ordering.html</p>\\n<p>这么做是为...</p>\\n</li>\\n</ol>","slug":"babel-cha-jian-de-yi-xie-zong-jie","sha":"35b77bbafb93c7b66d99747c168be81a28ee84aa"}')}}]);