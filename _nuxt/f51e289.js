(window.webpackJsonp=window.webpackJsonp||[]).push([[799],{1597:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">input</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> lengthLongestPath = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">input</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> arr=input.split(<span class=\\"hljs-string\\">\'\\\\n\'</span>)\\n  <span class=\\"hljs-keyword\\">let</span> used=<span class=\\"hljs-built_in\\">Array</span>(arr.length).fill(<span class=\\"hljs-literal\\">false</span>) \\n  <span class=\\"hljs-keyword\\">let</span> maxLen=<span class=\\"hljs-number\\">0</span>\\n  dfs(<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-literal\\">false</span>,<span class=\\"hljs-string\\">\'\'</span>)\\n  <span class=\\"hljs-keyword\\">return</span> maxLen\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">len,startIdx,nxtCount,hasFile,str</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(hasFile)maxLen=<span class=\\"hljs-built_in\\">Math</span>.max(maxLen,len)\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=startIdx;i&lt;arr.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(used[i])<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">let</span> curS=arr[i]\\n      <span class=\\"hljs-keyword\\">let</span> curCount=<span class=\\"hljs-number\\">0</span>,isFile=<span class=\\"hljs-literal\\">false</span>,s=<span class=\\"hljs-string\\">\'\'</span>\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;curS.length;j++){\\n        <span class=\\"hljs-keyword\\">if</span>(curS[j]===<span class=\\"hljs-string\\">\'\\\\t\'</span>)curCount++\\n        <span class=\\"hljs-keyword\\">else</span>{\\n          <span class=\\"hljs-keyword\\">if</span>(curS[j]===<span class=\\"hljs-string\\">\'.\'</span>)isFile=<span class=\\"hljs-literal\\">true</span>\\n          s+=curS[j]\\n        }\\n      }   \\n      <span class=\\"hljs-keyword\\">if</span>(curCount&lt;nxtCount)<span class=\\"hljs-keyword\\">return</span> \\n      <span class=\\"hljs-keyword\\">if</span>(hasFile &amp;&amp; isFile)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">if</span>(curCount===nxtCount){\\n        used[i]=<span class=\\"hljs-literal\\">true</span>\\n        dfs(len+s.length+<span class=\\"hljs-number\\">1</span>,i+<span class=\\"hljs-number\\">1</span>,nxtCount+<span class=\\"hljs-number\\">1</span>,hasFile || isFile,str+<span class=\\"hljs-string\\">\'/\'</span>+s)\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"longest-absolute-file-path","created_at":"2019-04-27","timeArr":[2019,3,27,0,2,41,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p><code>dfs</code>递归遍历，定义几个参数：</p>\\n<ul>\\n<li><code>len</code>：当前路径的长度</li>\\n<li><code>startIdx</code>：从哪个索引开始查找下一个路径</li>\\n<li><code>nxtCount</code>：下一个路径中<code>\\\\t</code>应该有多少才符合要求</li>\\n<li><code>hasFile</code>：当前路径是否存在文件</li>\\n</ul>\\n<p>在递归时，除了从当前<code>arr[i]</code>中找到多少个<code>\\\\t</code>，并且检查是否和<code>nxtCount</code>匹配外，还要注意，</p>\\n<ol>\\n<li>\\n<p>如果当前<code>\\\\t</code>的数量小于<code>nxtCount</code>，更少的<code>\\\\t</code>说明后面将会是一个新的路径，而不是当前路径的继续，直接<code>return</code>；</p>\\n</li>\\n<li>\\n<p>如果当前的路径存在<code>.</code>，说明是一个文件，但如果参数<code>hasFile</code>为<code>true</code>，说明已经存在文件了，两个文件在一起不符合要求，<code>continue</code>；</p>\\n</li>\\n<li>\\n<p>如果<code>nxtCount</code>和当前路径的<code>\\\\t</code>数量相同，说明下一个路径是有效的，继续<code>dfs</code>递归，注意通过一个<code>hash</code>保存下当前的索引，以避免后续新路径的重复计算。</p>\\n</li>\\n</ol>\\n","content":"<p>假设文件系统如下图所示：</p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg\\" style=\\"width: 681px; height: 322px;\\" /></p>\\n\\n<p>这里将 <code>dir</code> 作为根目录中的唯一目录。<code>dir</code> 包含两个子目录 <code>subdir1</code> 和 <code>subdir2</code> 。<code>subdir1</code> 包含文件 <code>file1.ext</code> 和子目录 <code>subsubdir1</code>；<code>subdir2</code> 包含子目录 <code>subsubdir2</code>，该子目录下包含文件 <code>file2.ext</code> 。</p>\\n\\n<p>在文本格式中，如下所示(⟶表示制表符)：</p>\\n\\n<pre>\\ndir\\n⟶ subdir1\\n⟶ ⟶ file1.ext\\n⟶ ⟶ subsubdir1\\n⟶ subdir2\\n⟶ ⟶ subsubdir2\\n⟶ ⟶ ⟶ file2.ext\\n</pre>\\n\\n<p>如果是代码表示，上面的文件系统可以写为 <code>\\"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\\"</code> 。<code>\'\\\\n\'</code> 和 <code>\'\\\\t\'</code> 分别是换行符和制表符。</p>\\n\\n<p>文件系统中的每个文件和文件夹都有一个唯一的 <strong>绝对路径</strong> ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 <code>\'/\'</code> 连接。上面例子中，指向 <code>file2.ext</code> 的绝对路径是 <code>\\"dir/subdir2/subsubdir2/file2.ext\\"</code> 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 <code>name.extension</code> 的格式，其中名称和扩展名由字母、数字和/或空格组成。</p>\\n\\n<p>给定一个以上述格式表示文件系统的字符串 <code>input</code> ，返回文件系统中 <strong>指向文件的最长绝对路径</strong> 的长度。 如果系统中没有文件，返回 <code>0</code>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg\\" style=\\"width: 401px; height: 202px;\\" />\\n<pre>\\n<strong>输入：</strong>input = \\"dir\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext\\"\\n<strong>输出：</strong>20\\n<strong>解释：</strong>只有一个文件，绝对路径为 \\"dir/subdir2/file.ext\\" ，路径长度 20\\n路径 \\"dir/subdir1\\" 不含任何文件\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg\\" style=\\"width: 641px; height: 322px;\\" />\\n<pre>\\n<strong>输入：</strong>input = \\"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext\\"\\n<strong>输出：</strong>32\\n<strong>解释：</strong>存在两个文件：\\n\\"dir/subdir1/file1.ext\\" ，路径长度 21\\n\\"dir/subdir2/subsubdir2/file2.ext\\" ，路径长度 32\\n返回 32 ，因为这是最长的路径</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>input = \\"a\\"\\n<strong>输出：</strong>0\\n<strong>解释：</strong>不存在任何文件</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>input = \\"file1.txt\\\\nfile2.txt\\\\nlongfile.txt\\"\\n<strong>输出：</strong>12\\n<strong>解释：</strong>根目录下有 3 个文件。\\n因为根目录中任何东西的绝对路径只是名称本身，所以答案是 \\"longfile.txt\\" ，路径长度为 12\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= input.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>input</code> 可能包含小写或大写的英文字母，一个换行符 <code>\'\\\\n\'</code>，一个指表符 <code>\'\\\\t\'</code>，一个点 <code>\'.\'</code>，一个空格 <code>\' \'</code>，和数字。</li>\\n</ul>\\n","title":"388. 文件的最长绝对路径","relatedTags":["栈","深度优先搜索","字符串"],"difficult":"Middle","lang":["javascript"],"uniqueID":"388","slug":"388-Longest-Absolute-File-Path"}')}}]);