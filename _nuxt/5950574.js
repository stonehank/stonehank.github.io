(window.webpackJsonp=window.webpackJsonp||[]).push([[1060],{1858:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">positions</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> fallingSquares = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">positions</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> res=[]\\n  <span class=\\"hljs-keyword\\">let</span> last=[[<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-literal\\">Infinity</span>,<span class=\\"hljs-number\\">0</span>]]\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;positions.length;i++){\\n    <span class=\\"hljs-keyword\\">let</span> [s,h]=positions[i]\\n    <span class=\\"hljs-keyword\\">let</span> cur=[s,s+h,h]\\n    <span class=\\"hljs-keyword\\">let</span> itv=[],temp=[],j=<span class=\\"hljs-number\\">0</span>,hasDone=<span class=\\"hljs-literal\\">false</span>\\n    <span class=\\"hljs-keyword\\">for</span>(;j&lt;last.length;j++){\\n      <span class=\\"hljs-keyword\\">let</span> pre=last[j]\\n      <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">0</span>]&gt;=pre[<span class=\\"hljs-number\\">1</span>]){\\n        itv.push(pre)\\n      }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">1</span>]&lt;=pre[<span class=\\"hljs-number\\">0</span>]){\\n        <span class=\\"hljs-keyword\\">break</span>\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-comment\\">// 存在叠加的区间</span>\\n        hasDone=<span class=\\"hljs-literal\\">true</span>\\n        <span class=\\"hljs-comment\\">// cur的起点位置更后，分割pre区间</span>\\n        <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">0</span>]&gt;=pre[<span class=\\"hljs-number\\">0</span>]){\\n          <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">0</span>]&gt;pre[<span class=\\"hljs-number\\">0</span>]){\\n            temp.push([pre[<span class=\\"hljs-number\\">0</span>],cur[<span class=\\"hljs-number\\">0</span>],pre[<span class=\\"hljs-number\\">2</span>]])\\n          }\\n          temp.push([cur[<span class=\\"hljs-number\\">0</span>],cur[<span class=\\"hljs-number\\">1</span>],cur[<span class=\\"hljs-number\\">2</span>]+pre[<span class=\\"hljs-number\\">2</span>]])\\n          <span class=\\"hljs-keyword\\">if</span>(pre[<span class=\\"hljs-number\\">1</span>]&gt;cur[<span class=\\"hljs-number\\">1</span>]){\\n            temp.push([cur[<span class=\\"hljs-number\\">1</span>],pre[<span class=\\"hljs-number\\">1</span>],pre[<span class=\\"hljs-number\\">2</span>]])\\n          }\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n          <span class=\\"hljs-comment\\">// pre起点的位置更后，分割cur</span>\\n          <span class=\\"hljs-keyword\\">if</span>(temp.length&gt;<span class=\\"hljs-number\\">0</span>){\\n            temp[temp.length<span class=\\"hljs-number\\">-1</span>][<span class=\\"hljs-number\\">2</span>]=<span class=\\"hljs-built_in\\">Math</span>.max(pre[<span class=\\"hljs-number\\">2</span>]+cur[<span class=\\"hljs-number\\">2</span>],temp[temp.length<span class=\\"hljs-number\\">-1</span>][<span class=\\"hljs-number\\">2</span>])\\n          }<span class=\\"hljs-keyword\\">else</span>{\\n            temp.push([cur[<span class=\\"hljs-number\\">0</span>],cur[<span class=\\"hljs-number\\">1</span>],pre[<span class=\\"hljs-number\\">2</span>]+cur[<span class=\\"hljs-number\\">2</span>]])\\n          }\\n          <span class=\\"hljs-keyword\\">if</span>(cur[<span class=\\"hljs-number\\">1</span>]&lt;pre[<span class=\\"hljs-number\\">1</span>])temp.push([cur[<span class=\\"hljs-number\\">1</span>],pre[<span class=\\"hljs-number\\">1</span>],pre[<span class=\\"hljs-number\\">2</span>]])\\n        }\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(hasDone){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-number\\">0</span>;k&lt;temp.length;k++){\\n        itv.push(temp[k])\\n      }    \\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k=j;k&lt;last.length;k++){\\n        itv.push(last[k])\\n      }\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-comment\\">// 如果没有任何之前的区间与当前区间叠加</span>\\n      itv.push(cur)\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [s,e,h] <span class=\\"hljs-keyword\\">of</span> itv){\\n      max=<span class=\\"hljs-built_in\\">Math</span>.max(max,h)\\n    }\\n    res.push(max)\\n    last=itv\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"falling-squares","created_at":"2019-04-29","timeArr":[2019,3,29,15,35,59,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>思路上有点像<code>区间的合并和分割</code>，但是需要一个额外的状态，高度。</p>\\n<p>对于每一个<code>positions[i]</code>，将它构造成<code>[start,end,height]</code>，也就是从<code>start</code>开始到<code>end</code>，这一段区间的高度都是<code>height</code>。</p>\\n<p>遍历<code>positions</code>，对于每一个<code>positions[i]</code>，不需要精确地计算出合并或者分割后的连续区间</p>\\n<p>构建一个<code>cache</code>，保存之前的区间，然后对当前的区间<code>cur</code>，找到之前的区间<code>cache[i]</code>与<code>cur</code>存在叠加的，那么他们的最高高度一定是两个区间的高度和，\\n找出最大的高度和<code>max</code>，更新<code>cur[2]+=max</code>，将<code>cur</code>添加到<code>cache</code>。</p>\\n","content":"<p>在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。</p>\\n\\n<p>第 <code>i</code> 个掉落的方块（<code>positions[i] = (left, side_length)</code>）是正方形，其中&nbsp;<code>left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。</code></p>\\n\\n<p>每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。</p>\\n\\n<p>方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，<code>因为只有底边才具有粘性。</code></p>\\n\\n<p>&nbsp;</p>\\n\\n<p>返回一个堆叠高度列表&nbsp;<code>ans</code> 。每一个堆叠高度&nbsp;<code>ans[i]</code>&nbsp;表示在通过&nbsp;<code>positions[0], positions[1], ..., positions[i]</code>&nbsp;表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<pre><strong>输入:</strong> [[1, 2], [2, 3], [6, 1]]\\n<strong>输出:</strong> [2, 5, 5]\\n<strong>解释:\\n\\n</strong>第一个方块 <code>positions[0] = [1, 2] </code>掉落：\\n<code>_aa\\n_aa\\n-------\\n</code>方块最大高度为 2 。\\n\\n第二个方块 <code>positions[1] = [2, 3] </code>掉落：\\n<code>__aaa\\n__aaa\\n__aaa\\n_aa__\\n_aa__\\n--------------\\n</code>方块最大高度为5。\\n大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。\\n\\n第三个方块 <code>positions[1] = [6, 1] </code>掉落：\\n<code>__aaa\\n__aaa\\n__aaa\\n_aa\\n_aa___a\\n-------------- \\n</code>方块最大高度为5。\\n\\n因此，我们返回结果<code>[2, 5, 5]。</code>\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<pre><strong>输入:</strong> [[100, 100], [200, 100]]\\n<strong>输出:</strong> [100, 100]\\n<strong>解释:</strong> 相邻的方块不会过早地卡住，只有它们的底部边缘才能粘在表面上。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>注意:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= positions.length &lt;= 1000</code>.</li>\\n\\t<li><code>1 &lt;= positions[i][0] &lt;= 10^8</code>.</li>\\n\\t<li><code>1 &lt;= positions[i][1] &lt;= 10^6</code>.</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n","title":"699. 掉落的方块","relatedTags":["线段树","数组","有序集合"],"difficult":"Hard","lang":["javascript"],"uniqueID":"699","slug":"699-Falling-Squares"}')}}]);