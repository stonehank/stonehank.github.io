(window.webpackJsonp=window.webpackJsonp||[]).push([[1259],{2057:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code>\\n<span class=\\"hljs-keyword\\">var</span> FreqStack = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> pq=[]\\n  <span class=\\"hljs-keyword\\">this</span>.freq={}\\n  <span class=\\"hljs-keyword\\">this</span>.insert=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(pq.length===<span class=\\"hljs-number\\">0</span> || <span class=\\"hljs-keyword\\">this</span>.freq[n]&gt;=pq[pq.length<span class=\\"hljs-number\\">-1</span>][<span class=\\"hljs-number\\">1</span>]){\\n      pq.push([n,<span class=\\"hljs-keyword\\">this</span>.freq[n]])\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">let</span> idx=bsFront(pq,<span class=\\"hljs-keyword\\">this</span>.freq[n])\\n      <span class=\\"hljs-comment\\">// console.log(pq,n,this.freq[n],idx)</span>\\n      <span class=\\"hljs-keyword\\">if</span>(pq[idx][<span class=\\"hljs-number\\">1</span>]===<span class=\\"hljs-keyword\\">this</span>.freq[n])idx++\\n      pq.splice(idx,<span class=\\"hljs-number\\">0</span>,[n,<span class=\\"hljs-keyword\\">this</span>.freq[n]])\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.delMax=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{\\n    <span class=\\"hljs-keyword\\">return</span> pq.pop()\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">bsFront</span>(<span class=\\"hljs-params\\">arr,n</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> lo=<span class=\\"hljs-number\\">0</span>,hi=arr.length<span class=\\"hljs-number\\">-1</span>\\n    <span class=\\"hljs-keyword\\">while</span>(lo&lt;hi){\\n      <span class=\\"hljs-keyword\\">let</span> mid=<span class=\\"hljs-built_in\\">Math</span>.ceil((lo+hi)/<span class=\\"hljs-number\\">2</span>)\\n      <span class=\\"hljs-keyword\\">if</span>(arr[mid][<span class=\\"hljs-number\\">1</span>]&gt;n)hi=mid<span class=\\"hljs-number\\">-1</span>\\n      <span class=\\"hljs-keyword\\">else</span> lo=mid\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> lo\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.pq=pq\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * @param {number} x\\n * @return {void}\\n */</span>\\nFreqStack.prototype.push = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">x</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-keyword\\">this</span>.freq[x]==<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">this</span>.freq[x]=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">this</span>.freq[x]++\\n  <span class=\\"hljs-keyword\\">this</span>.insert(x)\\n};\\n\\n<span class=\\"hljs-comment\\">/**\\n * @return {number}\\n */</span>\\nFreqStack.prototype.pop = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> del=<span class=\\"hljs-keyword\\">this</span>.delMax()\\n  <span class=\\"hljs-keyword\\">this</span>.freq[del[<span class=\\"hljs-number\\">0</span>]]--\\n  <span class=\\"hljs-keyword\\">return</span> del[<span class=\\"hljs-number\\">0</span>]\\n};\\n\\n<span class=\\"hljs-comment\\">/** \\n * Your FreqStack object will be instantiated and called as such:\\n * var obj = Object.create(FreqStack).createNew()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n */</span>\\n</code></pre>\\n"],"querySlug":"maximum-frequency-stack","created_at":"2019-04-08","timeArr":[2019,3,8,0,8,22,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>2种方式实现</p>\\n<ol>\\n<li><code>优先队列</code></li>\\n</ol>\\n<p>在优先队列内部，保存了<code>x</code>的频率和插入顺序，频率大的优先，频率相同按插入顺序排。</p>\\n<p>其中<code>compare</code>函数如下：</p>\\n<pre class=\\"hljs\\"><code>if (this.freq[a] != this.freq[b]) return this.freq[b] - this.freq[a]\\nreturn b.pushIndex - a.pushIndex;\\n</code></pre>\\n<p>然后<code>push</code>和<code>pop</code>只需要简单的处理<code>this.freq[x]</code>的增加和减少，还有<code>优先队列</code>的<code>insert</code>和<code>delMax</code></p>\\n<ol start=\\"2\\">\\n<li><code>Map+Stack</code></li>\\n</ol>\\n<p>对每一个频率段，我们都创建一个<code>stack</code>，在这个<code>stack</code>内，完全按照栈的方式排序。</p>\\n<p>最终这个<code>map</code>如下：</p>\\n<pre class=\\"hljs\\"><code>{\\n  1:[3,5,7,9],\\n  2:[1,2,3,4],\\n  ...\\n}\\n</code></pre>\\n<p>其中<code>key</code>就是频率，<code>val</code>就是对应的栈，注意的是，当一个数，例如这里的<code>3</code>，原来频率是2，现在又<code>push</code>一次，\\n频率变为3，但不需要从<code>map[2]</code>中删除它，只需要改变<code>3</code>这个数字的频率<code>this.freq[3]=3</code></p>\\n<p>之后我们就从<code>map[this.freq[3]]</code>去获取，当它被<code>pop</code>后，同样改变<code>this.freq[3]--</code>。</p>\\n<p>最后，需要记录一个最大频率的值<code>this.maxFreq</code>，当<code>push</code>时，比较当前值的频率，判断是否更新；</p>\\n<p>当<code>pop</code>时，如果当前频率<code>stack.length===0</code>，则说明最大频率已经刚刚被<code>pop</code>，需要<code>maxFreq--</code>。</p>\\n","content":"<p>实现 <code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p>\\n\\n<p><code>FreqStack</code>&nbsp;有两个函数：</p>\\n\\n<ul>\\n\\t<li><code>push(int x)</code>，将整数&nbsp;<code>x</code>&nbsp;推入栈中。</li>\\n\\t<li><code>pop()</code>，它<strong>移除</strong>并返回栈中出现最频繁的元素。\\n\\t<ul>\\n\\t\\t<li>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li>\\n\\t</ul>\\n\\t</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例：</strong></p>\\n\\n<pre><strong>输入：</strong>\\n[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],\\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\\n<strong>输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]\\n<strong>解释：</strong>\\n执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：\\n\\npop() -&gt; 返回 5，因为 5 是出现频率最高的。\\n栈变成 [5,7,5,7,4]。\\n\\npop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。\\n栈变成 [5,7,5,4]。\\n\\npop() -&gt; 返回 5 。\\n栈变成 [5,7,4]。\\n\\npop() -&gt; 返回 4 。\\n栈变成 [5,7]。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>对&nbsp;<code>FreqStack.push(int x)</code>&nbsp;的调用中&nbsp;<code>0 &lt;= x &lt;= 10^9</code>。</li>\\n\\t<li>如果栈的元素数目为零，则保证不会调用&nbsp; <code>FreqStack.pop()</code>。</li>\\n\\t<li>单个测试样例中，对&nbsp;<code>FreqStack.push</code>&nbsp;的总调用次数不会超过&nbsp;<code>10000</code>。</li>\\n\\t<li>单个测试样例中，对&nbsp;<code>FreqStack.pop</code>&nbsp;的总调用次数不会超过&nbsp;<code>10000</code>。</li>\\n\\t<li>所有测试样例中，对&nbsp;<code>FreqStack.push</code>&nbsp;和 <code>FreqStack.pop</code>&nbsp;的总调用次数不会超过&nbsp;<code>150000</code>。</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n","title":"895. 最大频率栈","relatedTags":["栈","设计","哈希表","有序集合"],"difficult":"Hard","lang":["javascript"],"uniqueID":"895","slug":"895-Maximum-Frequency-Stack"}')}}]);