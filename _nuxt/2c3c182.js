(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{631:function(e){e.exports=JSON.parse('{"content":"<ul>\\n<li>之前的项目架构写法<pre><code><pre class=\\"hljs\\"><code>product/\\n├── product.js\\n├── constant.js\\n├── productActions.js\\n├── productReducers.js\\n...\\nwidget/\\n├── widget.js\\n├── constant.js\\n├── widgetActions.js\\n├── widgetReducers.js\\n...\\nlogin/\\n├── login.js\\n├── constant.js\\n├── loginActions.js\\n├── reducers.js\\n  ├──index.js\\n  ├──someReducer2.js\\n  ├──someReducer1.js\\n          ...\\n...\\ngallery/\\n├── gallery.js\\n├── constant.js\\n├── action/\\n  ├──someAction1.js\\n  ├──someAction2.js\\n          ...\\n├── galleryReducers.js\\n...</code></pre></code></pre>除了这种类似按功能划分，还有其他，例如dump/smart component等</li>\\n</ul>\\n<p>这些有一个特点，划分的很细，而且很抽象，基本上面对任何功能，都是同一套模板，但你也有可能面对一个简单的逻辑，确去查找了4-5个文件</p>\\n<h2 id=\\"ya-zi-lei-xing-de-xie-fa\\">鸭子类型的写法</h2>\\n<pre><code><pre class=\\"hljs\\"><code>duck/\\n├── product.js\\n├── login.js\\n├── gallery.js\\n├── widget.js\\n...</code></pre></code></pre><p>就是将每个功能板块的action,reducer等合并到一起，但需要遵守几个规则：</p>\\n<ol>\\n<li>必须 export default 函数名为 reducer() 的 reducer</li>\\n<li>必须 作为函数 export 它的 action creators</li>\\n<li>必须 把 action types 定义成形为 npm-module-or-app/reducer/ACTION_TYPE 的字符串</li>\\n<li>如果有外部的reducer需要监听这个action type，或者作为可重用的库发布时， 可以 用 UPPER_SNAKE_CASE 形式 export 它的 action types。</li>\\n</ol>\\n<p>其中第三条是必须规定这么写type</p>\\n<p><code>const LOAD   = &#39;my-app/widgets/LOAD&#39;</code></p>\\n<p>以路径的方式定义type</p>\\n<p>至于原因还不太理解，可能是当应用复杂的时候也能正确区分每一个type，而且路径命名比较好找？</p>\\n<p>当遵守了以上规则，其duck内部文件内容就有点类似金字塔形状了，</p>\\n<pre><code><pre class=\\"hljs\\"><code>├──product.js (export default combineReducer(...))\\n\\n             combineReducer\\n                   |    \\n             reducer reducer\\n            /      |       \\\\\\n        action action action action\\n        /          |           \\\\\\n    type type type type type type type type\\n</code></pre></code></pre><p>这种结构当我们针对某个功能进行阅读或者修改，确实方便（都在一个文件内部），性能也相对会提升（不会那么多调用）</p>\\n<p>但是个人认为项目大到一定程度，某个功能的文件内容多到一定程度，还是需要分割，或许可以写成：</p>\\n<pre><code><pre class=\\"hljs\\"><code>duck/\\n├── product\\n    ├── productActions.js\\n    ├── productReducers.js\\n    ├── productTypes.js\\n├── login.js\\n├── gallery.js\\n├── widget.js\\n...</code></pre></code></pre><p>这种混合模式可能比较适合。</p>\\n","toc":[{"anchor":"ya-zi-lei-xing-de-xie-fa","level":2,"text":"鸭子类型的写法"}],"relatedTags":null,"created_at":"2018-06-15","timeArr":[2018,5,15,0,0,0,0],"title":"redux的鸭子类型","uuid":"4a83e73cdbfb044bbcaeec9d58a931ead5069ff7","summary":"<ul>\\n<li>之前的项目架构写法</li>\\n</ul>\\n<pre class=\\"hljs\\"><code>product/\\n├── product.js\\n├── constant.js\\n├── productActions.js\\n├── productReducers.js\\n...\\nwidget/\\n├── widget.js\\n├── constant.js\\n├── widgetActions...</code></pre>","slug":"redux-de-ya-zi-lei-xing","sha":"fb8d734075bef018a7449f06ddd06ffbb203848f"}')}}]);