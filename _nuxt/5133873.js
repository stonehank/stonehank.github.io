(window.webpackJsonp=window.webpackJsonp||[]).push([[1414],{701:function(e){e.exports=JSON.parse('{"content":"<blockquote>\\n<p><code>react-waypoint</code>用于监控元素是否出现在用户定义的视口范围内。</p>\\n</blockquote>\\n<h3 id=\\"chu-shi\\">初识</h3>\\n<p>源码逻辑写的并不复杂，这里基本就不放源码，主要概述一下源码做了些什么事情。</p>\\n<p>此源码内部相关知识</p>\\n<ul>\\n<li><code>onNextTick</code>作用和如何定义</li>\\n<li><code>getBoundingClientRect</code>的使用</li>\\n<li><code>getComputedStyle</code>的作用</li>\\n<li><code>addEventListener</code>中<code>{passive:true}</code>的作用</li>\\n<li><code>React.cloneElement</code>的使用</li>\\n<li>如果用户传递的是<code>React组件</code>不是<code>DOM</code>，需要编写<code>ForwardRef</code>或者<code>InnerRef</code></li>\\n</ul>\\n<h3 id=\\"zheng-ti-liu-cheng\\">整体流程</h3>\\n<hr>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>componentWillMount() {\\n  ensureChildrenIsValid(<span class=\\"hljs-keyword\\">this</span>.props.children);\\n}\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">ensureChildrenIsValid</span>(<span class=\\"hljs-params\\">children</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (children) {\\n    <span class=\\"hljs-keyword\\">try</span> {\\n      React.Children.only(children);\\n    } <span class=\\"hljs-keyword\\">catch</span> (e) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(errorMessage);\\n    }\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>这里组件加载前就通过<code>React.Children.only</code>检查用户传入的<code>children</code>，保证必须唯一的子元素，并且不能是<code>TEXT</code></p>\\n<hr>\\n<p>在<code>componentDidMount</code>内部，</p>\\n<ul>\\n<li><p>使用了<code>onNextTick</code>， 一个将任务加入队列执行的方案，通过<code>setTimeout(()=&gt;{},0)</code>的使用：</p>\\n<ol>\\n<li>可以在任务开始前停止。</li>\\n<li>确保<code>ref</code>能完全获取。</li>\\n<li>任务之间不会冲突。</li>\\n</ol>\\n</li>\\n</ul>\\n<p><code>onNextTick</code>源码不复杂，却很实用。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">let</span> timeout;\\n<span class=\\"hljs-keyword\\">const</span> timeoutQueue = [];\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">onNextTick</span>(<span class=\\"hljs-params\\">cb</span>) </span>{\\n  <span class=\\"hljs-comment\\">// 放入队列</span>\\n  timeoutQueue.push(cb);\\n  <span class=\\"hljs-keyword\\">if</span> (!timeout) {\\n    timeout = setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n      timeout = <span class=\\"hljs-literal\\">null</span>;\\n      <span class=\\"hljs-keyword\\">let</span> item;\\n      <span class=\\"hljs-comment\\">// eslint-disable-next-line no-cond-assign</span>\\n      <span class=\\"hljs-keyword\\">while</span> (item = timeoutQueue.shift()) {\\n        item();\\n      }\\n    }, <span class=\\"hljs-number\\">0</span>);\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> isSubscribed = <span class=\\"hljs-literal\\">true</span>;\\n  <span class=\\"hljs-comment\\">// 返回一个取消函数</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">unsubscribe</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (!isSubscribed) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n    isSubscribed = <span class=\\"hljs-literal\\">false</span>;\\n    <span class=\\"hljs-keyword\\">const</span> index = timeoutQueue.indexOf(cb);\\n    <span class=\\"hljs-comment\\">// 需要取消的任务已经执行完毕，发挥</span>\\n    <span class=\\"hljs-keyword\\">if</span> (index === <span class=\\"hljs-number\\">-1</span>) {\\n      <span class=\\"hljs-keyword\\">return</span>;\\n    }\\n    timeoutQueue.splice(index, <span class=\\"hljs-number\\">1</span>);\\n    <span class=\\"hljs-comment\\">// 如果任务队列无任务 并且 计时器还存在，清除计时器</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!timeoutQueue.length &amp;&amp; timeout) {\\n      clearTimeout(timeout);\\n      timeout = <span class=\\"hljs-literal\\">null</span>;\\n    }\\n  };\\n}</code></pre>\\n</code></pre>\\n<ul>\\n<li><p>确认ref能有效获取到children</p>\\n<p>  通过<code>ref</code>获取子元素的<code>DOM</code></p>\\n<ul>\\n<li>子元素是<code>DOM</code>（最容易获取）</li>\\n<li>子元素是组件，尝试通过<code>ForwardRef</code>获取，如果子组件不是<code>ForwardRef</code>，通过<code>innerRef</code>获取</li>\\n</ul>\\n</li>\\n<li><p>父元素获取</p>\\n<p>  通过子元素的<code>parentNode</code>向上遍历，直到找到<code>overflow</code>为<code>auto</code>或者<code>scroll</code>，否则设置为<code>window</code></p>\\n<p>  通过<code>getComputedStyle</code>去获取<code>overflow</code>的值。（此处并不完美，依赖用户自觉）</p>\\n</li>\\n<li><p>绑定<code>scroll</code>和<code>resize</code></p>\\n<p>  选项<code>{passive:true}</code>，这能让浏览器在处理事件时不去检测是否存在<code>preventDefault</code>，事件处理更加流畅。</p>\\n</li>\\n</ul>\\n<hr>\\n<p>接着是<code>_handleScroll</code>，即事件绑定的方法</p>\\n<ol>\\n<li><p>内部存在<code>_getBounds</code>和<code>getCurrentPosition</code>，作用是判断子元素是否出现在规定范围内</p>\\n<ol>\\n<li>用户定义2个属性：<code>topOffset</code>和<code>bottomOffset</code>，可以理解为<code>上边线</code>和<code>下边线</code></li>\\n<li>通过<code>getBoundingClientRect</code>，计算出<code>子元素</code>顶端和底端到<code>视口</code>顶端的距离</li>\\n<li>通过<code>上/下边线</code>和<code>父元素</code>的高度和<code>父元素</code>顶端到视口顶端的距离，计算出<code>上/下边线</code>分别距离视口顶端的距离</li>\\n<li>对比以上2个数据，分别赋予当前<code>子元素</code>的4种位置状态：<code>invisible</code>，<code>inside</code>，<code>below</code>，<code>above</code></li>\\n</ol>\\n</li>\\n<li><p>通过保存当前位置，每次事件后对比与上一次的位置关系，执行对应的<code>enter</code>和<code>leave</code>钩子函数。</p>\\n<p> 一个亮点：<code>fireOnRapidScroll</code>，用于判断是否急速滑动。</p>\\n<p> 如果<code>scroll</code>执行过快，有可能子元素上一次事件还在<code>below</code>，这一次已经是<code>above</code>，当出现这样的情况，\\n 会强制执行<code>enter</code>和<code>leave</code>事件。</p>\\n</li>\\n</ol>\\n<hr>\\n<p>最后是<code>render</code></p>\\n<p>当组件接收到<code>this.props.children</code>，并且<code>children</code>本身是一个组件时，无法直接在上面添加属性的，\\n因为不能这么写<code>&lt;this.props.children prop={xxx} /&gt;</code>。</p>\\n<p>例如：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>&lt;App&gt;\\n  &lt;Child /&gt;\\n&lt;<span class=\\"hljs-regexp\\">/App&gt;</span></code></pre>\\n</code></pre>\\n<p>在不改变输入格式的情况，使用<code>React.cloneElement</code>可以修改它的属性，当然原理是复制，意思是内存中存在2个<code>children</code>了。</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">return</span> (\\n  React.cloneElement(<span class=\\"hljs-keyword\\">this</span>.props.children,{<span class=\\"hljs-attr\\">extraProp</span>:<span class=\\"hljs-number\\">1</span>})\\n)</code></pre>\\n</code></pre>\\n<hr>\\n<p>可能存在的缺陷：</p>\\n<p>当存在一个很长的<code>ul</code>列表，而给<code>ul</code>添加了<code>overflow:auto</code>，但并未设置<code>height</code>，这时<code>ul</code>并不是一个滚动组件，\\n真正的滚动还是触发在<code>window</code>，但<code>waypoint</code>会因为存在属性<code>overflow:auto</code>，而将<code>ul</code>认为是滚动组件父元素。</p>\\n<p><a href=\\"https://codesandbox.io/s/ly9y4v9m5m\\">例子</a></p>\\n<hr>\\n<p>一张导图作为结尾：</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.react-waypoint/react-waypoint.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"chu-shi","level":3,"text":"初识"},{"anchor":"zheng-ti-liu-cheng","level":3,"text":"整体流程"}],"relatedTags":["源码","react"],"created_at":"2018-12-28","timeArr":[2018,11,28,19,30,43,0],"title":"源码阅读-react-waypoint","uuid":"ba215dff0ae6956dac40be3d218cd6ab5cd3c533","summary":"<p><code>react-waypoint</code>用于监控元素是否出现在用户定义的视口范围内。</p>","slug":"source-code-react-waypoint","sha":"f2384a371e4ab1abe1998ae1eb32ea5bed8a7ca9"}')}}]);