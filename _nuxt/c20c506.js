(window.webpackJsonp=window.webpackJsonp||[]).push([[1018],{1816:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{TreeNode}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> constructMaximumBinaryTree = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(nums.length===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">let</span> max=-<span class=\\"hljs-literal\\">Infinity</span>,maxID=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n    <span class=\\"hljs-keyword\\">if</span>(nums[i]&gt;max){\\n      max=nums[i]\\n      maxID=i\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> root=<span class=\\"hljs-keyword\\">new</span> TreeNode(max)\\n  root.left=constructMaximumBinaryTree(nums.slice(<span class=\\"hljs-number\\">0</span>,maxID))\\n  root.right=constructMaximumBinaryTree(nums.slice(maxID+<span class=\\"hljs-number\\">1</span>))\\n  <span class=\\"hljs-keyword\\">return</span> root\\n};\\n</code></pre>\\n"],"querySlug":"maximum-binary-tree","created_at":"2019-03-19","timeArr":[2019,2,19,15,48,22,0],"hasThinking":false,"content":"<p>给定一个不含重复元素的整数数组 <code>nums</code> 。一个以此数组直接递归构建的 <strong>最大二叉树</strong> 定义如下：</p>\\n\\n<ol>\\n\\t<li>二叉树的根是数组 <code>nums</code> 中的最大元素。</li>\\n\\t<li>左子树是通过数组中 <strong>最大值左边部分</strong> 递归构造出的最大二叉树。</li>\\n\\t<li>右子树是通过数组中 <strong>最大值右边部分</strong> 递归构造出的最大二叉树。</li>\\n</ol>\\n\\n<p>返回有给定数组 <code>nums</code> 构建的 <strong>最大二叉树 </strong>。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\\" style=\\"width: 302px; height: 421px;\\" />\\n<pre>\\n<strong>输入：</strong>nums = [3,2,1,6,0,5]\\n<strong>输出：</strong>[6,3,5,null,2,0,null,null,1]\\n<strong>解释：</strong>递归调用如下所示：\\n- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\\n    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\\n        - 空数组，无子节点。\\n        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\\n            - 空数组，无子节点。\\n            - 只有一个元素，所以子节点是一个值为 1 的节点。\\n    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\\n        - 只有一个元素，所以子节点是一个值为 0 的节点。\\n        - 空数组，无子节点。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\\" style=\\"width: 182px; height: 301px;\\" />\\n<pre>\\n<strong>输入：</strong>nums = [3,2,1]\\n<strong>输出：</strong>[3,null,2,null,1]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= nums.length <= 1000</code></li>\\n\\t<li><code>0 <= nums[i] <= 1000</code></li>\\n\\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\\n</ul>\\n","title":"654. 最大二叉树","relatedTags":["栈","树","数组","分治","二叉树","单调栈"],"difficult":"Middle","lang":["javascript"],"uniqueID":"654","slug":"654-Maximum-Binary-Tree"}')}}]);