(window.webpackJsonp=window.webpackJsonp||[]).push([[756],{1554:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string[][]}</span> <span class=\\"hljs-variable\\">tickets</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{string[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> findItinerary = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">tickets</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={},len=tickets.length\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [<span class=\\"hljs-keyword\\">from</span>,to] <span class=\\"hljs-keyword\\">of</span> tickets){\\n    <span class=\\"hljs-keyword\\">if</span>(hash[<span class=\\"hljs-keyword\\">from</span>]==<span class=\\"hljs-literal\\">null</span>)hash[<span class=\\"hljs-keyword\\">from</span>]=[to]\\n    <span class=\\"hljs-keyword\\">else</span> hash[<span class=\\"hljs-keyword\\">from</span>].push(to)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> visited={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> k <span class=\\"hljs-keyword\\">in</span> hash){\\n    visited[k]=[]\\n    hash[k].sort()\\n  }\\n  <span class=\\"hljs-comment\\">// console.log(hash)</span>\\n  \\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">v,itinerary,len</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(res)<span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">if</span>(len===<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-comment\\">// console.log(1)</span>\\n      <span class=\\"hljs-keyword\\">return</span> res=itinerary.slice()\\n    }\\n    <span class=\\"hljs-keyword\\">let</span> adj=hash[v]\\n    <span class=\\"hljs-keyword\\">if</span>(adj){\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;adj.length;i++){\\n        <span class=\\"hljs-keyword\\">if</span>(visited[v][i])<span class=\\"hljs-keyword\\">continue</span>\\n        visited[v][i]=<span class=\\"hljs-literal\\">true</span>\\n        itinerary.push(adj[i])\\n        len--\\n        dfs(adj[i],itinerary,len)\\n        len++\\n        itinerary.pop()\\n        visited[v][i]=<span class=\\"hljs-literal\\">false</span>\\n      }\\n    }\\n  }\\n  dfs(<span class=\\"hljs-string\\">\'JFK\'</span>,[<span class=\\"hljs-string\\">\'JFK\'</span>],len)\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"reconstruct-itinerary","created_at":"2019-04-09","timeArr":[2019,3,9,10,52,29,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>可以将这个问题先转换成图的格式<code>graph</code>，对其内部每一个<code>graph[i]</code>排序，然后再认为这是一个可以用<code>拓扑排序</code>解决的问题，\\n因为每一次的<code>to</code>都必须先经过前面的<code>from</code>。</p>\\n","content":"<p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>\\n\\n<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>\\n\\n<ul>\\n\\t<li>例如，行程 <code>[\\"JFK\\", \\"LGA\\"]</code> 与 <code>[\\"JFK\\", \\"LGB\\"]</code> 相比就更小，排序更靠前。</li>\\n</ul>\\n\\n<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg\\" style=\\"width: 382px; height: 222px;\\" />\\n<pre>\\n<strong>输入：</strong>tickets = [[\\"MUC\\",\\"LHR\\"],[\\"JFK\\",\\"MUC\\"],[\\"SFO\\",\\"SJC\\"],[\\"LHR\\",\\"SFO\\"]]\\n<strong>输出：</strong>[\\"JFK\\",\\"MUC\\",\\"LHR\\",\\"SFO\\",\\"SJC\\"]\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg\\" style=\\"width: 222px; height: 230px;\\" />\\n<pre>\\n<strong>输入：</strong>tickets = [[\\"JFK\\",\\"SFO\\"],[\\"JFK\\",\\"ATL\\"],[\\"SFO\\",\\"ATL\\"],[\\"ATL\\",\\"JFK\\"],[\\"ATL\\",\\"SFO\\"]]\\n<strong>输出：</strong>[\\"JFK\\",\\"ATL\\",\\"JFK\\",\\"SFO\\",\\"ATL\\",\\"SFO\\"]\\n<strong>解释：</strong>另一种有效的行程是 [\\"JFK\\",\\"SFO\\",\\"ATL\\",\\"JFK\\",\\"ATL\\",\\"SFO\\"] ，但是它字典排序更大更靠后。\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= tickets.length <= 300</code></li>\\n\\t<li><code>tickets[i].length == 2</code></li>\\n\\t<li><code>from<sub>i</sub>.length == 3</code></li>\\n\\t<li><code>to<sub>i</sub>.length == 3</code></li>\\n\\t<li><code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 由大写英文字母组成</li>\\n\\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\\n</ul>\\n","title":"332. 重新安排行程","relatedTags":["深度优先搜索","图","欧拉回路"],"difficult":"Middle","lang":["javascript"],"uniqueID":"332","slug":"332-Reconstruct-Itinerary"}')}}]);