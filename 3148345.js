(window.webpackJsonp=window.webpackJsonp||[]).push([[496],{1294:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">n</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">edges</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{boolean[]}</span> <span class=\\"hljs-variable\\">hasApple</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> minTime = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">n, edges, hasApple</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> graph=<span class=\\"hljs-built_in\\">Array</span>(n).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span>[])\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> [f,t] <span class=\\"hljs-keyword\\">of</span> edges){\\n    graph[f].push(t)\\n    graph[t].push(f)\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">let</span> used={}\\n  <span class=\\"hljs-keyword\\">let</span> res=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">// console.log(graph)</span>\\n  dfs(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">return</span> res\\n\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">findHasApple</span>(<span class=\\"hljs-params\\">idx,parent</span>)</span>{\\n    <span class=\\"hljs-comment\\">// console.log(idx,parent)</span>\\n    <span class=\\"hljs-keyword\\">if</span>(hash[idx]!=<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">return</span> hash[idx]\\n    <span class=\\"hljs-keyword\\">let</span> has=hasApple[idx]\\n    <span class=\\"hljs-keyword\\">if</span>(has){\\n      hash[idx]=has\\n      <span class=\\"hljs-keyword\\">return</span> has\\n    }\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;graph[idx].length;i++){\\n      <span class=\\"hljs-keyword\\">let</span> nxtIdx=graph[idx][i]\\n      <span class=\\"hljs-keyword\\">if</span>(nxtIdx===parent)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-comment\\">// console.log(nxtIdx,idx)</span>\\n      <span class=\\"hljs-keyword\\">if</span>(findHasApple(nxtIdx,idx)){\\n        has=<span class=\\"hljs-literal\\">true</span>\\n        <span class=\\"hljs-keyword\\">break</span>\\n      }\\n    }\\n    hash[idx]=has\\n    <span class=\\"hljs-keyword\\">return</span> has\\n  }\\n  \\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">dfs</span>(<span class=\\"hljs-params\\">idx,parent</span>)</span>{\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;graph[idx].length;i++){\\n      <span class=\\"hljs-keyword\\">let</span> subIdx=graph[idx][i]\\n      <span class=\\"hljs-keyword\\">if</span>(subIdx===parent)<span class=\\"hljs-keyword\\">continue</span>\\n      <span class=\\"hljs-keyword\\">if</span>(findHasApple(subIdx,idx)){\\n        res+=<span class=\\"hljs-number\\">2</span>\\n        dfs(subIdx,idx)\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"minimum-time-to-collect-all-apples-in-a-tree","created_at":"2020-05-10","timeArr":[2020,4,10,11,28,17,0],"hasThinking":false,"content":"<p>给你一棵有&nbsp;<code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从&nbsp;<strong>节点 0&nbsp;</strong>出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>\\n\\n<p>无向树的边由&nbsp;<code>edges</code>&nbsp;给出，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示有一条边连接&nbsp;<code>from</code>&nbsp;和&nbsp;<code>to<sub>i</sub></code> 。除此以外，还有一个布尔数组&nbsp;<code>hasApple</code> ，其中&nbsp;<code>hasApple[i] = true</code>&nbsp;代表节点&nbsp;<code>i</code>&nbsp;有一个苹果，否则，节点&nbsp;<code>i</code>&nbsp;没有苹果。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_1.png\\" style=\\"height: 212px; width: 300px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\\n<strong>输出：</strong>8 \\n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<p><strong><img alt=\\"\\" src=\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_2.png\\" style=\\"height: 212px; width: 300px;\\"></strong></p>\\n\\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\\n<strong>输出：</strong>6\\n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\\n<strong>输出：</strong>0\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\\n\\t<li><code>edges.length == n-1</code></li>\\n\\t<li><code>edges[i].length == 2</code></li>\\n\\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n-1</code></li>\\n\\t<li><code>from<sub>i</sub>&nbsp;&lt; to<sub>i</sub></code></li>\\n\\t<li><code>hasApple.length == n</code></li>\\n</ul>\\n","title":"1443. 收集树上所有苹果的最少时间","relatedTags":["树","深度优先搜索","广度优先搜索","哈希表"],"difficult":"Middle","lang":["javascript"],"uniqueID":"1443","slug":"1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"}')}}]);