(window.webpackJsonp=window.webpackJsonp||[]).push([[686],{1484:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> majorityElement = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> cand1=<span class=\\"hljs-literal\\">null</span>,cand2=<span class=\\"hljs-literal\\">null</span>,c1=<span class=\\"hljs-number\\">0</span>,c2=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> num <span class=\\"hljs-keyword\\">of</span> nums){\\n    <span class=\\"hljs-keyword\\">if</span>(num===cand1)c1++\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(num===cand2)c2++\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(c1===<span class=\\"hljs-number\\">0</span>){cand1=num;c1++}\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(c2===<span class=\\"hljs-number\\">0</span>){cand2=num;c2++}\\n    <span class=\\"hljs-keyword\\">else</span>{c1--;c2--}\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> count1=<span class=\\"hljs-number\\">0</span>,count2=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> num <span class=\\"hljs-keyword\\">of</span> nums){\\n    <span class=\\"hljs-keyword\\">if</span>(num===cand1)count1++\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(num===cand2)count2++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> res=[],limit=<span class=\\"hljs-built_in\\">Math</span>.floor(nums.length/<span class=\\"hljs-number\\">3</span>)\\n  <span class=\\"hljs-keyword\\">if</span>(count1&gt;limit)res.push(cand1)\\n  <span class=\\"hljs-keyword\\">if</span>(count2&gt;limit)res.push(cand2)\\n  <span class=\\"hljs-keyword\\">return</span> res\\n};\\n</code></pre>\\n"],"querySlug":"majority-element-ii","created_at":"2019-03-13","timeArr":[2019,2,13,11,29,16,0],"hasThinking":true,"thinking":"<hr>\\n<p>一般想到的是时间<code>O(N)</code>，空间<code>O(N)</code>的hash记录，或者时间<code>O(NlogN)</code>，空间<code>O(1)</code>的排序。</p>\\n<p>但这里使用了<code>Majority Vote algorithm</code>(多数投票算法)。</p>\\n<hr>\\n<h4>Majority Vote algorithm算法介绍</h4>\\n<p><code>Majority Vote algorithm</code>本来是用于计算存在的数量超过<strong>二分之一</strong>的值。</p>\\n<p>它维护了2个变量，<code>candidate</code>记录当前最有可能的值，<code>count</code>记录当前<code>candidate</code>的一个数量值，这个数量值有点&quot;缓冲&quot;的感觉，\\n只要<code>count</code>不为0，那么<code>candidate</code>就不会变，到最后，如果<code>count</code>为0，说明存在一个或者多个数将<code>candidate</code>抵消了，返回<code>null</code>。</p>\\n<p>但是也不能说<code>count</code>大于0一定就是答案，也有例外，例如<code>[0,2,0,4,3]</code>，当第一次遍历完成，结果是<code>candidate:3</code>，<code>count:1</code>，但\\n很明显，<code>3</code>并不是我们所需要的。</p>\\n<p>因此需要第二次遍历，这次就是简单的对<code>candidate</code>数量进行统计，判断它是否一个有效值。</p>\\n<p>代码：</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">mostVote</span>(<span class=\\"hljs-params\\">nums</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> candidate=<span class=\\"hljs-literal\\">null</span>,count=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(count===<span class=\\"hljs-number\\">0</span>){ candidate=nums[i]; count++ }\\n      <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(nums[i]===candidate) count++\\n      <span class=\\"hljs-keyword\\">else</span> count--\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(count===<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>\\n    <span class=\\"hljs-keyword\\">let</span> c=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;nums.length;i++){\\n      <span class=\\"hljs-keyword\\">if</span>(nums[i]===candidate)c++\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(c&gt;<span class=\\"hljs-built_in\\">Math</span>.floor(nums.length/<span class=\\"hljs-number\\">2</span>))<span class=\\"hljs-keyword\\">return</span> candidate\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">null</span>\\n  }\\n</code></pre>\\n<hr>\\n<p>回到<code>leetcode</code>这道题，我们会求出大于<code>1/2</code>的，那么<code>1/3</code>的怎么求呢？</p>\\n<p>其实很简单，因为最多只有2个，多维护一组变量就可以解决。</p>\\n","content":"<p>给定一个大小为 <em>n </em>的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>\\n\\n<p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[3,2,3]\\n<strong>输出：</strong>[3]</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [1]\\n<strong>输出：</strong>[1]\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>[1,1,1,3,3,2,2,2]\\n<strong>输出：</strong>[1,2]</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= nums.length <= 5 * 10<sup>4</sup></code></li>\\n\\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\\n</ul>\\n","title":"229. 求众数 II","relatedTags":["数组","哈希表","计数","排序"],"difficult":"Middle","lang":["javascript"],"uniqueID":"229","slug":"229-Majority-Element-II"}')}}]);