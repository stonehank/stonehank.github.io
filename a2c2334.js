(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{711:function(e){e.exports=JSON.parse('{"content":"<h2 id=\\"yue-du-qian-ti\\">阅读前提</h2>\\n<ol>\\n<li>有rxjs基础，对<code>Observable</code>, <code>Subject</code>,<code>pipe</code>和一些操作符(例如<code>filter</code>,<code>map</code>,<code>merge</code>,<code>mergeMap</code>)执行流程有基本了解，最起码遇到不清楚有去查阅的动力</li>\\n<li>比较熟悉<code>redux</code>中间件的写法，否则像<code>createEpicMiddleware.js</code>中的这一段会搞不清楚<pre><code><pre class=\\"hljs\\"><code>return next =&gt; {\\n  return action =&gt; {</code></pre>\\n</code></pre>\\n 关于redux也可以查阅我之前写的<a href=\\"https://github.com/stonehank/sourcecode-analysis/tree/master/source-code.redux\\">redux源码注释</a></li>\\n</ol>\\n<h2 id=\\"mu-lu-jie-gou\\">目录结构</h2>\\n<pre><code><pre class=\\"hljs\\"><code>src/\\n├──utils/\\n    ├──console.js\\n├── ActionsObservable.js    // 自定义的类，继承Observable, 绑定了操作符的链式调用\\n├── combineEpics.js         // \\n├── createEpicMiddleware.js // 调用可生成redux的中间件, 通过run绑定需要执行的流\\n├── index.js                // 对外接口\\n├── operators.js            // 自定义的流操作方法, 目前只有ofType\\n├── StateObservable.js      // 自定义的类，继承Observable, 用于保存当前state</code></pre>\\n</code></pre>\\n<h2 id=\\"yuan-ma-fen-xi\\">源码分析</h2>\\n<p>index.js：公开接口，略</p>\\n<hr>\\n<h3 id=\\"actionobservablejs\\">ActionObservable.js</h3>\\n<p>继承了<code>Observable</code>类</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">ActionsObservable</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Observable</span></span></code></pre>\\n</code></pre>\\n<p>定义了两个静态函数，用调用的对象包装了原来的<code>of</code>和<code>from</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">of</span>(...actions) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-keyword\\">this</span>(<span class=\\"hljs-keyword\\">of</span>(...actions));\\n  }\\n  <span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">from</span>(actions, scheduler) {\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-keyword\\">this</span>(<span class=\\"hljs-keyword\\">from</span>(actions, scheduler));\\n  }</code></pre>\\n</code></pre>\\n<p>构造函数，定义了<code>source</code>属性为参数，这个属性用来绑定操作符的链式调用</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  <span class=\\"hljs-keyword\\">constructor</span>(actionsSubject) {\\n    <span class=\\"hljs-keyword\\">super</span>();\\n    <span class=\\"hljs-keyword\\">this</span>.source = actionsSubject;\\n  }</code></pre>\\n</code></pre>\\n<p>这里重写了父类(Observable)的<code>lift</code>，先看一下父类的<code>lift</code>是怎样的</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">var</span> observable = <span class=\\"hljs-keyword\\">new</span> Observable();\\nobservable.source = <span class=\\"hljs-keyword\\">this</span>;\\nobservable.operator = operator;\\n<span class=\\"hljs-keyword\\">return</span> observable;</code></pre>\\n</code></pre>\\n<p>可以看到改动就在于原来的用<code>new Observable</code>，这里使用<code>new ActionObservable()</code>，其他都是一模一样，\\n封装成<code>ActionObservable</code>类的意义，统一类型，方便后面的链式绑定</p>\\n<p><code>lift</code>在<code>pipe</code>的时候会用到，其实这都是rxjs源码调用的方式()</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>lift(operator) {\\n <span class=\\"hljs-keyword\\">const</span> observable = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(<span class=\\"hljs-keyword\\">this</span>);\\n observable.operator = operator;\\n <span class=\\"hljs-keyword\\">return</span> observable;\\n}</code></pre>\\n</code></pre>\\n<p>定义了一个操作方法<code>ofType</code>，具体见operators</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  ofType(...keys) {\\n    <span class=\\"hljs-keyword\\">return</span> ofType(...keys)(<span class=\\"hljs-keyword\\">this</span>);\\n  }</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"combineepicsjs\\">combineEpics.js</h3>\\n<p>将多个epic合并成1个epic，就是分别执行每一个epic(绑定用户定义的操作符)，然后将每一个结果的流用merge合并</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 引入merge</span>\\n<span class=\\"hljs-keyword\\">import</span> { merge } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs\'</span>;\\n\\n<span class=\\"hljs-comment\\">/**\\n  Merges all epics into a single one.\\n */</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> combineEpics = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...epics</span>) =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// 通过merge操作符合并多个epic执行后的output$流</span>\\n  <span class=\\"hljs-comment\\">// ...epics是多个epic</span>\\n  <span class=\\"hljs-keyword\\">const</span> merger = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...args</span>) =&gt;</span> merge(\\n    ...epics.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">epic</span> =&gt;</span> {\\n      <span class=\\"hljs-comment\\">// 执行每一个epic，确保有返回值，此处执行就是绑定了用户自定义操作符的步骤</span>\\n      <span class=\\"hljs-keyword\\">const</span> output$ = epic(...args);\\n      <span class=\\"hljs-keyword\\">if</span> (!output$) {\\n        <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">`combineEpics: one of the provided Epics \\"<span class=\\"hljs-subst\\">${epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>}</span>\\" does not return a stream. Double check you\\\\\'re not missing a return statement!`</span>);\\n      }\\n      <span class=\\"hljs-comment\\">// 返回结果，最后进行merge合并</span>\\n      <span class=\\"hljs-keyword\\">return</span> output$;\\n    })\\n  );\\n\\n  <span class=\\"hljs-comment\\">// Technically the `name` property on Function\'s are supposed to be read-only.</span>\\n  <span class=\\"hljs-comment\\">// While some JS runtimes allow it anyway (so this is useful in debugging)</span>\\n  <span class=\\"hljs-comment\\">// some actually throw an exception when you attempt to do so.</span>\\n  <span class=\\"hljs-keyword\\">try</span> {\\n    <span class=\\"hljs-built_in\\">Object</span>.defineProperty(merger, <span class=\\"hljs-string\\">\'name\'</span>, {\\n      <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">`combineEpics(<span class=\\"hljs-subst\\">${epics.map(epic =&gt; epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>).join(<span class=\\"hljs-string\\">\', \'</span>)}</span>)`</span>,\\n    });\\n  } <span class=\\"hljs-keyword\\">catch</span> (e) {}\\n\\n  <span class=\\"hljs-keyword\\">return</span> merger;\\n};</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"createepicmiddlewarejs\\">createEpicMiddleware.js</h3>\\n<p>一、提示目前参数不在接受<code>rootEpic</code>，而是使用<code>epicMiddleware.run(rootEpic)</code>，这里<code>epicMiddleware</code>就是执行<code>createEpicMiddleware</code>的返回值</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; <span class=\\"hljs-keyword\\">typeof</span> options === <span class=\\"hljs-string\\">\'function\'</span>) {\\n    <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">\'Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\\\n\\\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware\'</span>);\\n  }\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n}</code></pre>\\n</code></pre>\\n<p>二、这一定义了几个重要变量(流)，这里一个重要问题</p>\\n<pre><code><pre class=\\"hljs\\"><code>1. rxjs内部的source是什么(在ActionObservable内部出现)\\n2. rxjs内部的operator是什么(在ActionObservable内部出现)\\nA：source定义了操作符执行的流向，operator定义了操作符是什么操作符，这两者结合使用来进行链式绑定</code></pre>\\n</code></pre>\\n<p>接着看注释</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  <span class=\\"hljs-comment\\">// 定义一个Subject，绑定内部操作流，通过调用epic$.next()，也就是`epicMiddleware.run`来初始化action$的绑定</span>\\n  <span class=\\"hljs-keyword\\">const</span> epic$ = <span class=\\"hljs-keyword\\">new</span> Subject();\\n  <span class=\\"hljs-keyword\\">let</span> store;\\n  <span class=\\"hljs-comment\\">// 作为redux的中间件，其中epicMiddleware是返回值作为外部API</span>\\n  <span class=\\"hljs-keyword\\">const</span> epicMiddleware = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">_store</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 当在开发环境并且多次使用不同的 createEpicMiddleware返回值，会提出警告(避免重复执行多次)</span>\\n    <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; store) {\\n      <span class=\\"hljs-comment\\">// https://github.com/redux-observable/redux-observable/issues/389</span>\\n      <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./utils/console\'</span>).warn(<span class=\\"hljs-string\\">\'this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\\\n\\\\nLearn more: https://goo.gl/2GQ7Da\'</span>);\\n    }\\n    store = _store;\\n    <span class=\\"hljs-comment\\">// 定义一个Subject，绑定了队列调度器 (后面这个用来绑定所有操作流)</span>\\n    <span class=\\"hljs-keyword\\">const</span> actionSubject$ = <span class=\\"hljs-keyword\\">new</span> Subject().pipe(\\n      <span class=\\"hljs-comment\\">// todo 调度器，看了一些资料，还有有点模糊</span>\\n      observeOn(queueScheduler)\\n    );\\n    <span class=\\"hljs-comment\\">//  定义一个Subject，绑定了队列调度器 (后面这个用来对比当前store，防止重复渲染)</span>\\n    <span class=\\"hljs-keyword\\">const</span> stateSubject$ = <span class=\\"hljs-keyword\\">new</span> Subject().pipe(\\n      observeOn(queueScheduler)\\n    );\\n    <span class=\\"hljs-comment\\">// 定义一个ActionsObservable，用来绑定用户定义的操作流</span>\\n    <span class=\\"hljs-keyword\\">const</span> action$ = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(actionSubject$);\\n    <span class=\\"hljs-comment\\">// 定义一个StateObservable，内部改写了Observable的_subscribe方法，并且让stateSubject$绑定了value对比操作，就是简单的引用对比`===`</span>\\n    <span class=\\"hljs-keyword\\">const</span> state$ = <span class=\\"hljs-keyword\\">new</span> StateObservable(stateSubject$, store.getState());\\n    \\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n  }\\n}</code></pre>\\n</code></pre>\\n<p>三、这里是核心，所有流和操作符的绑定就是在此内部进行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n  <span class=\\"hljs-comment\\">/*...*/</span>\\n  \\n  <span class=\\"hljs-comment\\">// pipe操作符</span>\\n<span class=\\"hljs-keyword\\">const</span> result$ = epic$.pipe(\\n  <span class=\\"hljs-comment\\">// 对发射源逐个处理</span>\\n  map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">epic</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 如果配置有 dependencies 就放置到第三个参数中</span>\\n    <span class=\\"hljs-keyword\\">const</span> output$ = <span class=\\"hljs-string\\">\'dependencies\'</span> <span class=\\"hljs-keyword\\">in</span> options\\n      ? epic(action$, state$, options.dependencies)\\n      : epic(action$, state$);\\n    <span class=\\"hljs-comment\\">// 无返回值，报错，应该要返回一个不同的流</span>\\n    <span class=\\"hljs-keyword\\">if</span> (!output$) {\\n      <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">TypeError</span>(<span class=\\"hljs-string\\">`Your root Epic \\"<span class=\\"hljs-subst\\">${epic.name || <span class=\\"hljs-string\\">\'&lt;anonymous&gt;\'</span>}</span>\\" does not return a stream. Double check you\\\\\'re not missing a return statement!`</span>);\\n    }\\n    <span class=\\"hljs-comment\\">// output$ 是一个ActionObservable类型的流</span>\\n    <span class=\\"hljs-keyword\\">return</span> output$;\\n  }),\\n  <span class=\\"hljs-comment\\">// 对所有外部流，绑定队列调度并且使用mergeMap重新subscribe</span>\\n  mergeMap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">output$</span> =&gt;</span>\\n    <span class=\\"hljs-keyword\\">from</span>(output$).pipe(\\n      subscribeOn(queueScheduler),\\n      observeOn(queueScheduler)\\n    )\\n  )\\n);\\n\\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n}\\n</code></pre>\\n</code></pre>\\n<p>四、epic执行主要流程，<code>dispatch(action$)</code>--&gt; <code>actionSubject$.next(action)</code>--&gt;经过一系列操作符--&gt;最后到达底层<code>dispatch(state)</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createEpicMiddleware</span>(<span class=\\"hljs-params\\">options = {}</span>) </span>{\\n<span class=\\"hljs-comment\\">/*...*/</span>\\n\\n<span class=\\"hljs-comment\\">// 订阅 dispatch，此处将dispath作为流执行的最底层</span>\\nresult$.subscribe(store.dispatch);\\n\\n<span class=\\"hljs-comment\\">// 返回的格式是按照redux中间件的格式</span>\\n<span class=\\"hljs-comment\\">// 里面的内容都是运行时redux里dispatch后会执行的流程</span>\\n<span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">next</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">action</span> =&gt;</span> {\\n    <span class=\\"hljs-comment\\">// 此处先截取next(action)</span>\\n    <span class=\\"hljs-keyword\\">const</span> result = next(action);\\n    <span class=\\"hljs-comment\\">// 先执行 stateSubject$.next 可以保证state的更新</span>\\n    stateSubject$.next(store.getState());\\n    <span class=\\"hljs-comment\\">// 操作符按步骤执行，此时的actionSubject$已经绑定了所有的操作符</span>\\n    actionSubject$.next(action);\\n    <span class=\\"hljs-keyword\\">return</span> result;\\n  };\\n};\\n<span class=\\"hljs-comment\\">// run方法，通过epic$的next方法初始化action(见第三)，从而绑定用户自定义的操作符</span>\\nepicMiddleware.run = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">rootEpic</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">if</span> (process.env.NODE_ENV !== <span class=\\"hljs-string\\">\'production\'</span> &amp;&amp; !store) {\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./utils/console\'</span>).warn(<span class=\\"hljs-string\\">\'epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.\'</span>);\\n  }\\n    <span class=\\"hljs-comment\\">// rootEpic就是用户自定义的操作符</span>\\n  epic$.next(rootEpic);\\n};\\n<span class=\\"hljs-keyword\\">return</span> epicMiddleware;\\n}</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"operatorsjs\\">operators.js</h3>\\n<p>定义了<code>ofType</code>，其实就是一个filter</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">// 引入filter</span>\\n<span class=\\"hljs-keyword\\">import</span> { filter } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs/operators\'</span>;\\n<span class=\\"hljs-comment\\">// 这里type就是传给epic的action的type的值，key就是用户自定义需要过滤的值</span>\\n<span class=\\"hljs-keyword\\">const</span> keyHasType = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">type, key</span>) =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">return</span> type === key || <span class=\\"hljs-keyword\\">typeof</span> key === <span class=\\"hljs-string\\">\'function\'</span> &amp;&amp; type === key.toString();\\n};\\n<span class=\\"hljs-comment\\">// source就是调用ofType的流，也就是createEpicMiddleware里的action$</span>\\n<span class=\\"hljs-comment\\">// 结果只有返回true才会继续链式调用</span>\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">const</span> ofType = <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">...keys</span>) =&gt;</span> <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">source</span>) =&gt;</span> source.pipe(\\n  filter(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">{ type }</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">const</span> len = keys.length;\\n    <span class=\\"hljs-keyword\\">if</span> (len === <span class=\\"hljs-number\\">1</span>) {\\n      <span class=\\"hljs-keyword\\">return</span> keyHasType(type, keys[<span class=\\"hljs-number\\">0</span>]);\\n    } <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; len; i++) {\\n        <span class=\\"hljs-keyword\\">if</span> (keyHasType(type, keys[i])) {\\n          <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">true</span>;\\n        }\\n      }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>;\\n  })\\n);</code></pre>\\n</code></pre>\\n<hr>\\n<h3 id=\\"stateobservablejs\\">StateObservable.js</h3>\\n<p>继承<code>Observable</code>，定义了一个保存状态的类，里面改写了父类(<code>Observable</code>)的<code>_subscribe</code>(作用不太清楚)，\\n并且定义了一个保存当前数据状态的函数，通过stateSubject(也就是createEpicMiddleware里面的<code>stateSubject$</code>)的<code>subscribe</code>绑定到底层</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">import</span> { Observable, Subject } <span class=\\"hljs-keyword\\">from</span> <span class=\\"hljs-string\\">\'rxjs\'</span>;\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">StateObservable</span> <span class=\\"hljs-keyword\\">extends</span> <span class=\\"hljs-title\\">Observable</span> </span>{\\n  <span class=\\"hljs-keyword\\">constructor</span>(stateSubject, initialState) {\\n    <span class=\\"hljs-comment\\">// 调用父类构造函数，改写父类的_subscribe</span>\\n    <span class=\\"hljs-comment\\">// todo 作用？</span>\\n    <span class=\\"hljs-keyword\\">super</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">subscriber</span> =&gt;</span> {\\n      <span class=\\"hljs-keyword\\">const</span> subscription = <span class=\\"hljs-keyword\\">this</span>.__notifier.subscribe(subscriber);\\n      <span class=\\"hljs-keyword\\">if</span> (subscription &amp;&amp; !subscription.closed) {\\n        subscriber.next(<span class=\\"hljs-keyword\\">this</span>.value);\\n      }\\n      <span class=\\"hljs-keyword\\">return</span> subscription;\\n    });\\n    \\n    <span class=\\"hljs-keyword\\">this</span>.value = initialState;\\n     <span class=\\"hljs-keyword\\">this</span>.__notifier = <span class=\\"hljs-keyword\\">new</span> Subject();\\n      <span class=\\"hljs-comment\\">// 绑定一个引用比较的状态函数</span>\\n     <span class=\\"hljs-keyword\\">this</span>.__subscription = stateSubject.subscribe(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">value</span> =&gt;</span> {\\n       <span class=\\"hljs-keyword\\">if</span> (value !== <span class=\\"hljs-keyword\\">this</span>.value) {\\n         <span class=\\"hljs-keyword\\">this</span>.value = value;\\n         <span class=\\"hljs-keyword\\">this</span>.__notifier.next(value);\\n       }\\n     });\\n   }\\n }</code></pre>\\n</code></pre>\\n<p>源码就到此分析完了，看到这里可能还是一头雾水，知道是什么也只是概念上的知道，对整个流程还是没有头绪，\\n接着，会对几个关键流程源码分析和画出导图</p>\\n<p>这些流程基本都是rxjs源码的东西，为什么要对rxjs源码进行分析，只有这样才能正确掌握<code>redux-observable</code>的整个流程</p>\\n<blockquote>\\n<p>PS：rxjs源码真让人看的头大</p>\\n</blockquote>\\n<h2 id=\\"liu-cheng-fen-xi\\">流程分析</h2>\\n<hr>\\n<h3 id=\\"pipe\\">pipe</h3>\\n<p>首先是<code>pipe</code>，<code>pipe</code>在rxjs源码中到底做了些什么</p>\\n<p>这里处理了参数，然后调用<code>pipeFromArray</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">pipe</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">var</span> fns = [];\\n    <span class=\\"hljs-comment\\">// 遍历参数合并为数组的形式</span>\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">var</span> _i = <span class=\\"hljs-number\\">0</span>; _i &lt; <span class=\\"hljs-built_in\\">arguments</span>.length; _i++) {\\n        fns[_i] = <span class=\\"hljs-built_in\\">arguments</span>[_i];\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> pipeFromArray(fns);\\n}</code></pre>\\n</code></pre>\\n<p><code>pipeFromArray</code>是做什么用呢，看最后一句，当参数大于1个时，会执行<code>reduce</code>方法，这不就是compose</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">pipeFromArray</span>(<span class=\\"hljs-params\\">fns</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (!fns) {\\n        <span class=\\"hljs-keyword\\">return</span> noop;\\n    }\\n    <span class=\\"hljs-keyword\\">if</span> (fns.length === <span class=\\"hljs-number\\">1</span>) {\\n        <span class=\\"hljs-keyword\\">return</span> fns[<span class=\\"hljs-number\\">0</span>];\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">piped</span>(<span class=\\"hljs-params\\">input</span>) </span>{\\n        <span class=\\"hljs-keyword\\">return</span> fns.reduce(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">prev, fn</span>) </span>{ <span class=\\"hljs-keyword\\">return</span> fn(prev); }, input);\\n    };\\n}</code></pre>\\n</code></pre>\\n<p>也就是将<code>action$.pipe(oper1,oper2,oper3)</code>转换成\\n<code>oper3(oper2(oper1(action$)))</code></p>\\n<p>那么<code>oper1(action$)</code>又是什么</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code><span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">filterOperatorFunction</span>(<span class=\\"hljs-params\\">source</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> source.lift(<span class=\\"hljs-keyword\\">new</span> FilterOperator(predicate, thisArg));\\n};</code></pre>\\n</code></pre>\\n<p><code>oper1(action$)</code>也就是<code>action$.lift(oper1)</code>，这里不去管操作符的构造函数</p>\\n<p>而<code>source</code>表示操作符的链式的下一个指向，这里是一个<code>ActionObservable</code>类，还记得前面吗，<code>ActionObservable</code>重写了lift方法</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>  lift(operator) {\\n    <span class=\\"hljs-keyword\\">const</span> observable = <span class=\\"hljs-keyword\\">new</span> ActionsObservable(<span class=\\"hljs-keyword\\">this</span>);\\n    <span class=\\"hljs-comment\\">// operator能表示具体当前操作符</span>\\n    observable.operator = operator;\\n    <span class=\\"hljs-keyword\\">return</span> observable;\\n  }</code></pre>\\n</code></pre>\\n<p>它也会创建新的<code>ActionObservable</code>，并且加入<code>source</code>和<code>operator</code>，这次的<code>source</code>又作为下一次lift的<code>source</code>，这就构成了链式</p>\\n<p><code>pipe</code>流程图</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.redux-observable/redux-observable-pipe.png\\" alt=\\"\\"></p>\\n<hr>\\n<h3 id=\\"subscribe\\">subscribe</h3>\\n<p>接着是<code>subscribe</code>，它的参数会转换成Subscriber类，作为最底层的执行操作</p>\\n<p>这里提出了几个属性，而且分清楚<code>subscribe</code>和<code>Subscriber</code>，前者是类似订阅，动词；后者是一种结构</p>\\n<pre><code><pre class=\\"hljs\\"><code>1. source: 见上面pipe，执行list时添加的一个属性，表示操作符的链式的下一个指向\\n\\n2. operator: 见上面pipe，执行list的时添加一个属性，表示具体当前操作符\\n\\n3. destination: 它的作用是链式连接每一个操作符的Subscriber\\n例如：a,b,c 3个操作符\\naSubscriber.destination=bSubscriber\\nbSubscriber.destination=cSubscriber\\ncSubscriber.destination=SafeSubscriber(作为最底层)</code></pre>\\n</code></pre>\\n<p>源码：</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>Observable.prototype.subscribe = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">observerOrNext, error, complete</span>) </span>{\\n    <span class=\\"hljs-comment\\">// operator就是通过pipe后的具体当前操作符</span>\\n    <span class=\\"hljs-keyword\\">var</span> operator = <span class=\\"hljs-keyword\\">this</span>.operator;\\n    <span class=\\"hljs-comment\\">// 这里是将参数 （next,error,complete）转换成Subscriber的类，它的destination是SafeSubscriber</span>\\n    <span class=\\"hljs-keyword\\">var</span> sink = toSubscriber(observerOrNext, error, complete);\\n    <span class=\\"hljs-keyword\\">if</span> (operator) {\\n      <span class=\\"hljs-comment\\">// 如果this是一个操作符时 执行operator.call ，这里的call是重写的（后面单独分析）</span>\\n        operator.call(sink, <span class=\\"hljs-keyword\\">this</span>.source);\\n    }\\n    <span class=\\"hljs-keyword\\">else</span> {\\n      <span class=\\"hljs-comment\\">// 如果this不是一个操作符，即链式调用到顶端，这里所做的大概是</span>\\n      <span class=\\"hljs-comment\\">// 1. 有source 说明它还有通过pipe绑定的操作符，继续从source.subscribe</span>\\n      <span class=\\"hljs-comment\\">// 2. 没有source 说明它是最顶层了，给它添加一个属性`observers`，用于绑定链式subscribe的结果</span>\\n        sink.add(<span class=\\"hljs-keyword\\">this</span>.source || (config.useDeprecatedSynchronousErrorHandling &amp;&amp; !sink.syncErrorThrowable) ?\\n            <span class=\\"hljs-keyword\\">this</span>._subscribe(sink) :\\n            <span class=\\"hljs-keyword\\">this</span>._trySubscribe(sink));\\n    }\\n    \\n    <span class=\\"hljs-comment\\">/*...*/</span>\\n    <span class=\\"hljs-keyword\\">return</span> sink;\\n};</code></pre>\\n</code></pre>\\n<p>这里就是<code>operator.call(sink, this.source);</code>，找了一个<code>mapTo</code>操作符的例子，每一个操作符的call都是不同的</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>MapToOperator.prototype.call = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">subscriber, source</span>) </span>{\\n        <span class=\\"hljs-keyword\\">return</span> source.subscribe(<span class=\\"hljs-keyword\\">new</span> MapToSubscriber(subscriber, <span class=\\"hljs-keyword\\">this</span>.value));\\n    };</code></pre>\\n</code></pre>\\n<p>其实这里就是用<code>source</code>再次subscribe，参数是一个当前操作符的<code>Subscriber</code>，这个<code>Subscriber</code>内部保存了当前操作符的具体操作，\\n通过再次subscribe，又回到了上面的<code>Observable.prototype.subscribe </code>，构成链式subscribe</p>\\n<p><code>subscribe</code>流程图</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.redux-observable/redux-observable-subscribe.png\\" alt=\\"\\"></p>\\n<hr>\\n<h3 id=\\"next\\">next</h3>\\n<p>最后是<code>next</code>，每一个结构的<code>next</code>都不太同，因此这里就说1个主要的，1个通用的</p>\\n<ul>\\n<li>Subject.next</li>\\n</ul>\\n<p>这里其实很好理解，就是一次调用它的observers上的数据的next，那它的observers存放了什么数据，也就是下一个要说的: Subscriber.next</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>Subject.prototype.next = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">value</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-keyword\\">this</span>.closed) {\\n        <span class=\\"hljs-keyword\\">throw</span> <span class=\\"hljs-keyword\\">new</span> ObjectUnsubscribedError();\\n    }\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>.isStopped) {\\n        <span class=\\"hljs-keyword\\">var</span> observers = <span class=\\"hljs-keyword\\">this</span>.observers;\\n        <span class=\\"hljs-keyword\\">var</span> len = observers.length;\\n        <span class=\\"hljs-keyword\\">var</span> copy = observers.slice();\\n        <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">var</span> i = <span class=\\"hljs-number\\">0</span>; i &lt; len; i++) {\\n            copy[i].next(value);\\n        }\\n    }\\n};</code></pre>\\n</code></pre>\\n<ul>\\n<li>Subscriber.next</li>\\n</ul>\\n<p>这里调用了<code>this._next</code>，这里的this是动态的，并不一定是<code>Subscriber</code>，也有可能是<code>FilterSubscriber</code>(这里举FilterSubscriber的例子)</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>Subscriber.prototype.next = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">value</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (!<span class=\\"hljs-keyword\\">this</span>.isStopped) {\\n        <span class=\\"hljs-keyword\\">this</span>._next(value);\\n    }\\n};</code></pre>\\n</code></pre>\\n<p>如果<code>this</code>是<code>Subscriber</code>，调用<code>this.destination.next</code></p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>Subscriber.prototype._next = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">value</span>) </span>{\\n    <span class=\\"hljs-keyword\\">this</span>.destination.next(value);\\n};</code></pre>\\n</code></pre>\\n<p>如果<code>this</code>是<code>FilterSubscriber</code>，首先会执行<code>predicate</code>，这个就是filter操作符的具体执行内容，也就是它的参数，\\n当result为true，才会调用<code>this.destination.next</code>，进行下一个操作符的执行</p>\\n<pre><code class=\\"language-js\\"><pre class=\\"hljs\\"><code>FilterSubscriber.prototype._next = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">value</span>) </span>{\\n        <span class=\\"hljs-keyword\\">var</span> result;\\n        <span class=\\"hljs-keyword\\">try</span> {\\n            result = <span class=\\"hljs-keyword\\">this</span>.predicate.call(<span class=\\"hljs-keyword\\">this</span>.thisArg, value, <span class=\\"hljs-keyword\\">this</span>.count++);\\n        }\\n        <span class=\\"hljs-keyword\\">catch</span> (err) {\\n            <span class=\\"hljs-keyword\\">this</span>.destination.error(err);\\n            <span class=\\"hljs-keyword\\">return</span>;\\n        }\\n        <span class=\\"hljs-keyword\\">if</span> (result) {\\n            <span class=\\"hljs-keyword\\">this</span>.destination.next(value);\\n        }\\n    };</code></pre>\\n</code></pre>\\n<p><code>next</code>就是这么样的流程，通过<code>destination</code>一层一层往下执行，到最后就执行之前<code>subscriber</code>的参数</p>\\n<blockquote>\\n<p>接着是<code>subscribe</code>，它的参数会转换成Subscriber类，作为最底层的执行操作</p>\\n</blockquote>\\n<p><code>next</code>流程图</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.redux-observable/redux-observable-next.png\\" alt=\\"\\"></p>\\n<p>理解了这3种方法，这个<code>redux-observable</code>脉络就十分清楚了，当然，这之中还会涉及<code>rxjs</code>中还有更多的属性，例如<code>_subscriptions</code>,<code>isClosed</code>,<code>scheduler</code>等，这里也不展开了。</p>\\n<h2 id=\\"zong-jie\\">总结</h2>\\n<p>最后一张完整的<code>redux-observable</code>导图</p>\\n<p><img src=\\"https://raw.githubusercontent.com/stonehank/sourcecode-analysis/master/source-code.redux-observable/redux-observable.png\\" alt=\\"\\"></p>\\n","toc":[{"anchor":"yue-du-qian-ti","level":2,"text":"阅读前提"},{"anchor":"mu-lu-jie-gou","level":2,"text":"目录结构"},{"anchor":"yuan-ma-fen-xi","level":2,"text":"源码分析"},{"anchor":"actionobservablejs","level":3,"text":"ActionObservable.js"},{"anchor":"combineepicsjs","level":3,"text":"combineEpics.js"},{"anchor":"createepicmiddlewarejs","level":3,"text":"createEpicMiddleware.js"},{"anchor":"operatorsjs","level":3,"text":"operators.js"},{"anchor":"stateobservablejs","level":3,"text":"StateObservable.js"},{"anchor":"liu-cheng-fen-xi","level":2,"text":"流程分析"},{"anchor":"pipe","level":3,"text":"pipe"},{"anchor":"subscribe","level":3,"text":"subscribe"},{"anchor":"next","level":3,"text":"next"},{"anchor":"zong-jie","level":2,"text":"总结"}],"relatedTags":["源码","redux","github"],"created_at":"2018-08-02","timeArr":[2018,7,2,18,41,14,0],"title":"源码阅读-redux-observable","uuid":"d7c0278bb7ed377e72b7b8f38c777e8da7e1cbac","summary":"<h4>阅读前提：</h4>\\n<ol>\\n<li>有rxjs基础，对<code>Observable</code>, <code>Subject</code>,<code>pipe</code>和一些操作符(例如<code>filter</code>,<code>map</code>,<code>merge</code>,<code>mergeMap</code>)执行流程有基本了解，最起码遇到不清楚有去查阅的动力</li>\\n<li>比较熟悉<code>redux</code>中间件的写法，否则像`createEpicMidd...</li>\\n</ol>","slug":"source-code-redux-observable","sha":"93bd88b16c7b9dfc51ce170d182382f0ecefdd78"}')}}]);