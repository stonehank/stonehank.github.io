(window.webpackJsonp=window.webpackJsonp||[]).push([[492],{1290:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{ListNode}</span> <span class=\\"hljs-variable\\">head</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{void}</span> </span>Do not return anything, modify head in-place instead.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> reorderList = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">head</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!head)<span class=\\"hljs-keyword\\">return</span>\\n  <span class=\\"hljs-keyword\\">let</span> len=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> node=head\\n  <span class=\\"hljs-keyword\\">while</span>(node){\\n    node=node.next\\n    len++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> t=<span class=\\"hljs-built_in\\">Math</span>.floor((len<span class=\\"hljs-number\\">-1</span>)/<span class=\\"hljs-number\\">2</span>),k=len-t\\n  <span class=\\"hljs-keyword\\">let</span> stack=[],lastNode=<span class=\\"hljs-literal\\">null</span>\\n  node=head\\n  <span class=\\"hljs-keyword\\">while</span>(node){\\n    <span class=\\"hljs-keyword\\">if</span>(t--&gt;<span class=\\"hljs-number\\">0</span>){\\n      stack.push(node)\\n    }\\n    <span class=\\"hljs-keyword\\">if</span>(k--&lt;=<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">let</span> startNode=stack.pop(),\\n          secondNode=startNode.next,\\n          nxt=node.next\\n      startNode.next=node\\n      node.next=secondNode\\n      lastNode.next=nxt\\n      node=nxt\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(k===<span class=\\"hljs-number\\">0</span>)lastNode=node\\n      node=node.next\\n    }\\n  }\\n};\\n</code></pre>\\n"],"querySlug":"reorder-list","created_at":"2019-04-20","timeArr":[2019,3,20,11,46,27,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>两种方法：</p>\\n<ol>\\n<li>计算出<code>head</code>的长度<code>len</code>和将要移动的节点的数量，<code>t=Math.floor((len-1)/2)</code>，使用<code>stack</code>保存<code>next</code>会发生改变的节点。</li>\\n</ol>\\n<p>在遍历到将要移动的节点上，执行<code>stack.pop</code>取出的节点作为头部，将当前节点插入到头部的<code>next</code>中。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */</span>\\n<span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{ListNode}</span> <span class=\\"hljs-variable\\">head</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{void}</span> </span>Do not return anything, modify head in-place instead.\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> reorderList = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">head</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!head)<span class=\\"hljs-keyword\\">return</span>\\n  <span class=\\"hljs-keyword\\">let</span> len=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">let</span> node=head\\n  <span class=\\"hljs-keyword\\">while</span>(node){\\n    node=node.next\\n    len++\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> t=<span class=\\"hljs-built_in\\">Math</span>.floor((len<span class=\\"hljs-number\\">-1</span>)/<span class=\\"hljs-number\\">2</span>),k=len-t\\n  <span class=\\"hljs-keyword\\">let</span> stack=[],lastNode=<span class=\\"hljs-literal\\">null</span>\\n  node=head\\n  <span class=\\"hljs-keyword\\">while</span>(node){\\n    <span class=\\"hljs-keyword\\">if</span>(t--&gt;<span class=\\"hljs-number\\">0</span>)stack.push(node)\\n    <span class=\\"hljs-keyword\\">if</span>(k--&lt;=<span class=\\"hljs-number\\">0</span>){\\n      <span class=\\"hljs-keyword\\">let</span> startNode=stack.pop(),\\n          secondNode=startNode.next,\\n          nxt=node.next\\n      startNode.next=node\\n      node.next=secondNode\\n      lastNode.next=nxt\\n      node=nxt\\n    }<span class=\\"hljs-keyword\\">else</span>{\\n      <span class=\\"hljs-keyword\\">if</span>(k===<span class=\\"hljs-number\\">0</span>)lastNode=node\\n      node=node.next\\n    }\\n  }\\n};\\n</code></pre>\\n<ol start=\\"2\\">\\n<li>使用快慢节点找出当前<code>head</code>的后半段，例如<code>[1,2,3,4,5]</code>后半段就是<code>[3,4,5]</code>，<code>[1,2,3,4]</code>后半段就是<code>[3,4]</code>。</li>\\n</ol>\\n<p>对后半段进行反转，然后依次插入到前半段每一个节点的<code>next</code>中。</p>\\n<p>例如：<code>[1,2,3,4,5,6,7]</code>，后半段是<code>[4,5,6,7]</code>，反转后是<code>[7,6,5,4]</code>，依次插入到<code>[1,2,3]</code>中，得到<code>[1,7,2,6,3,5,4]</code>。</p>\\n","content":"<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>\\n\\n<p><code> L<sub>0 </sub>→ L<sub>1 </sub>→ … → L<sub>n-1 </sub>→ L<sub>n </sub></code><br />\\n请将其重新排列后变为：</p>\\n\\n<p><code>L<sub>0 </sub>→ L<sub>n </sub>→ L<sub>1 </sub>→ L<sub>n-1 </sub>→ L<sub>2 </sub>→ L<sub>n-2 </sub>→ …</code></p>\\n\\n<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1:</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png\\" style=\\"width: 240px; \\" /></p>\\n\\n<pre>\\n<strong>输入: </strong>head = [1,2,3,4]\\n<strong>输出: </strong>[1,4,2,3]</pre>\\n\\n<p><strong>示例 2:</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://pic.leetcode-cn.com/1626420320-YUiulT-image.png\\" style=\\"width: 320px; \\" /></p>\\n\\n<pre>\\n<strong>输入: </strong>head = [1,2,3,4,5]\\n<strong>输出: </strong>[1,5,2,4,3]</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>\\n\\t<li><code>1 <= node.val <= 1000</code></li>\\n</ul>\\n","title":"143. 重排链表","relatedTags":["栈","递归","链表","双指针"],"difficult":"Middle","lang":["javascript"],"uniqueID":"143","slug":"143-Reorder-List"}')}}]);