(window.webpackJsonp=window.webpackJsonp||[]).push([[1090],{1888:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">S</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> countPalindromicSubsequences = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">S</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> N=S.length\\n  <span class=\\"hljs-keyword\\">let</span> MOD=<span class=\\"hljs-number\\">1e9</span>+<span class=\\"hljs-number\\">7</span>\\n  <span class=\\"hljs-keyword\\">let</span> dp=<span class=\\"hljs-built_in\\">Array</span>(N).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span>=&gt;</span><span class=\\"hljs-built_in\\">Array</span>(N).fill(<span class=\\"hljs-number\\">0</span>))\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;N;i++)dp[i][i]=<span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">1</span>;i&lt;N;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;N-i;j++){\\n      <span class=\\"hljs-keyword\\">let</span> k=j+i\\n      <span class=\\"hljs-keyword\\">if</span>(S[j]!==S[k]){\\n        dp[j][k]=dp[j+<span class=\\"hljs-number\\">1</span>][k]+dp[j][k<span class=\\"hljs-number\\">-1</span>]-dp[j+<span class=\\"hljs-number\\">1</span>][k<span class=\\"hljs-number\\">-1</span>]\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-keyword\\">let</span> innerStr=S.slice(j+<span class=\\"hljs-number\\">1</span>,k)\\n        <span class=\\"hljs-keyword\\">let</span> head=innerStr.indexOf(S[j]),\\n            tail=innerStr.lastIndexOf(S[j])\\n        <span class=\\"hljs-keyword\\">if</span>(head===<span class=\\"hljs-number\\">-1</span>){\\n          dp[j][k]=dp[j+<span class=\\"hljs-number\\">1</span>][k<span class=\\"hljs-number\\">-1</span>]*<span class=\\"hljs-number\\">2</span>+<span class=\\"hljs-number\\">2</span>\\n        }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(head===tail){\\n          dp[j][k]=dp[j+<span class=\\"hljs-number\\">1</span>][k<span class=\\"hljs-number\\">-1</span>]*<span class=\\"hljs-number\\">2</span>+<span class=\\"hljs-number\\">1</span>\\n        }<span class=\\"hljs-keyword\\">else</span>{\\n          <span class=\\"hljs-comment\\">// 此处要补充(j+1)</span>\\n          dp[j][k]=dp[j+<span class=\\"hljs-number\\">1</span>][k<span class=\\"hljs-number\\">-1</span>]*<span class=\\"hljs-number\\">2</span>-dp[head+<span class=\\"hljs-number\\">1</span>+(j+<span class=\\"hljs-number\\">1</span>)][tail<span class=\\"hljs-number\\">-1</span>+(j+<span class=\\"hljs-number\\">1</span>)]\\n        }\\n      }\\n      dp[j][k]=(dp[j][k]+MOD) % MOD\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> dp[<span class=\\"hljs-number\\">0</span>][N<span class=\\"hljs-number\\">-1</span>]\\n};\\n</code></pre>\\n"],"querySlug":"count-different-palindromic-subsequences","created_at":"2019-03-07","timeArr":[2019,2,7,13,40,51,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<p>这道题使用动态规划方法，<code>dp[i][j]</code>表示从<code>i</code>到<code>j</code>(包含)，存在多少不重复的回文子序列。</p>\\n<p>dp递推公式如下：</p>\\n<ul>\\n<li>\\n<p>当<code>S[i]!==S[j]</code>时，需要检查内部是否存在回文子序列</p>\\n<p><code>dp[i][j]=dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]</code></p>\\n</li>\\n<li>\\n<p>当<code>S[i]===S[j]</code>时，需要去找<code>i</code>往右找最近的与<code>S[i]</code>相等的索引<code>left</code>和<code>j</code>往左找最近的与<code>S[i]</code>相等的索引<code>right</code></p>\\n<ul>\\n<li>\\n<p>如果<code>left&gt;right</code>，说明内部不存在与<code>S[i]</code>重复的值</p>\\n<p><code>dp[i][j]=dp[i+1][j-1]*2+2</code>，<code>+2</code>是因为多了<code>S[i]</code>和<code>S[i]S[i]</code>这两种组合。</p>\\n</li>\\n<li>\\n<p>如果<code>left===right</code>，说明内部存在唯一一个与<code>S[i]</code>重复的值</p>\\n<p><code>dp[i][j]=dp[i+1][j-1]*2+1</code>，其中<code>+1</code>是因为<code>S[i]</code>这种组合已经存在，不能重复。</p>\\n</li>\\n<li>\\n<p>其余情况，说明内部存在多个与<code>S[i]</code>重复的值</p>\\n<p><code>dp[i][j]=dp[i+1][j-1]*2-dp[left+1][right-1]</code>，这里没有<code>+2</code>因为<code>S[i]</code>和<code>S[i]S[i]</code>这两种组合已经被使用了，另外<code>-dp[left+1][right-1]</code>因为它内部的组合不能再与<code>S[i]...S[i]</code>组合，因为重复了。</p>\\n<p>例如，<code>ababbaba</code>，这里<code>i</code>为0，<code>j</code>为7，<code>left</code>为2，<code>right</code>为5，在<code>[3,4]</code>即<code>bb</code>，因为存在<code>abba</code>这个子序列，因此最外层的\'a...a\'不能再与<code>bb</code>组合。</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n","content":"<p>给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并<strong>返回该数字与 <code>10^9 + 7 </code>的模。</strong></p>\\n\\n<p>通过从 S 中删除 0 个或多个字符来获得子序列。</p>\\n\\n<p>如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。</p>\\n\\n<p>如果对于某个&nbsp;&nbsp;<code>i</code>，<code>A_i != B_i</code>，那么&nbsp;<code>A_1, A_2, ...</code> 和&nbsp;<code>B_1, B_2, ...</code> 这两个字符序列是不同的。</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre><strong>输入：</strong>\\nS = &#39;bccb&#39;\\n<strong>输出：</strong>6\\n<strong>解释：</strong>\\n6 个不同的非空回文子字符序列分别为：&#39;b&#39;, &#39;c&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;bcb&#39;, &#39;bccb&#39;。\\n注意：&#39;bcb&#39; 虽然出现两次但仅计数一次。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre><strong>输入：</strong>\\nS = &#39;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&#39;\\n<strong>输出：</strong>104860361\\n<strong>解释：</strong>\\n共有 3104860382 个不同的非空回文子序列，对 10^9 + 7 取模为 104860361。\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li>字符串&nbsp;<code>S</code>&nbsp;的长度将在<code>[1, 1000]</code>范围内。</li>\\n\\t<li>每个字符&nbsp;<code>S[i]</code>&nbsp;将会是集合&nbsp;<code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}</code>&nbsp;中的某一个。</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n","title":"730. 统计不同回文子序列","relatedTags":["字符串","动态规划"],"difficult":"Hard","lang":["javascript"],"uniqueID":"730","slug":"730-Count-Different-Palindromic-Subsequences"}')}}]);