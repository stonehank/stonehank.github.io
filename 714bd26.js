(window.webpackJsonp=window.webpackJsonp||[]).push([[817],{1615:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[]}</span> <span class=\\"hljs-variable\\">stones</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{boolean}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> canCross = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">stones</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> hash={}\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;stones.length;i++)hash[stones[i]]=i\\n  <span class=\\"hljs-keyword\\">let</span> dp=<span class=\\"hljs-built_in\\">Array</span>(stones.length).fill().map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">n</span>=&gt;</span>[])\\n  <span class=\\"hljs-keyword\\">let</span> moves=[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>]\\n  dp[<span class=\\"hljs-number\\">0</span>].push(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;stones.length;i++){\\n    <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> j=<span class=\\"hljs-number\\">0</span>;j&lt;dp[i].length;j++){\\n      <span class=\\"hljs-keyword\\">let</span> curStep=dp[i][j]\\n      <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> m <span class=\\"hljs-keyword\\">of</span> moves){\\n        <span class=\\"hljs-keyword\\">if</span>(curStep+m&lt;=<span class=\\"hljs-number\\">0</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> nxtStep=curStep+m\\n        <span class=\\"hljs-keyword\\">let</span> nxtPos=stones[i]+nxtStep\\n        <span class=\\"hljs-keyword\\">if</span>(hash[nxtPos]==<span class=\\"hljs-literal\\">null</span>)<span class=\\"hljs-keyword\\">continue</span>\\n        <span class=\\"hljs-keyword\\">let</span> nxtId=hash[nxtPos]\\n        <span class=\\"hljs-keyword\\">if</span>(dp[nxtId].includes(nxtStep))<span class=\\"hljs-keyword\\">continue</span>\\n        dp[nxtId].push(nxtStep)\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> dp[dp.length<span class=\\"hljs-number\\">-1</span>].length&gt;<span class=\\"hljs-number\\">0</span>\\n};\\n</code></pre>\\n","<pre class=\\"hljs\\"><code><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Solution</span><span class=\\"hljs-params\\">(object)</span>:</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">canCross</span><span class=\\"hljs-params\\">(self, stones)</span>:</span>\\n        <span class=\\"hljs-string\\">\\"\\"\\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \\"\\"\\"</span>\\n        n=len(stones)\\n        mem={}\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(n):\\n          mem.setdefault(stones[i],i)\\n        dp=[[] <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(n)]\\n        moves=[<span class=\\"hljs-number\\">-1</span>,<span class=\\"hljs-number\\">0</span>,<span class=\\"hljs-number\\">1</span>]\\n        dp[<span class=\\"hljs-number\\">0</span>].append(<span class=\\"hljs-number\\">0</span>)\\n        <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> range(n):\\n          <span class=\\"hljs-keyword\\">for</span> j <span class=\\"hljs-keyword\\">in</span> range(len(dp[i])):\\n            curStep=dp[i][j]\\n            <span class=\\"hljs-keyword\\">for</span> m <span class=\\"hljs-keyword\\">in</span> moves:\\n              <span class=\\"hljs-keyword\\">if</span> curStep+m&lt;=<span class=\\"hljs-number\\">0</span>:<span class=\\"hljs-keyword\\">continue</span>\\n              nxtStep=curStep+m\\n              nxtPos=stones[i]+nxtStep\\n              <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">not</span> mem.has_key(nxtPos):<span class=\\"hljs-keyword\\">continue</span>\\n              nxtId=mem[nxtPos]\\n              <span class=\\"hljs-keyword\\">if</span> nxtStep <span class=\\"hljs-keyword\\">in</span> dp[nxtId]:<span class=\\"hljs-keyword\\">continue</span>\\n              dp[nxtId].append(nxtStep)\\n        <span class=\\"hljs-keyword\\">return</span> len(dp[<span class=\\"hljs-number\\">-1</span>])&gt;<span class=\\"hljs-number\\">0</span>\\n</code></pre>\\n"],"querySlug":"frog-jump","hasThinking":false,"content":"<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>\\n\\n<p>给你石子的位置列表 <code>stones</code>（用单元格序号 <strong>升序</strong> 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>\\n\\n<p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p>\\n\\n<p>如果青蛙上一步跳跃了 <code>k</code><em> </em>个单位，那么它接下来的跳跃距离只能选择为 <code>k - 1</code>、<code>k</code><em> </em>或 <code>k + 1</code> 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>stones = [0,1,3,5,6,8,12,17]\\n<strong>输出：</strong>true\\n<strong>解释：</strong>青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>stones = [0,1,2,3,4,8,9,11]\\n<strong>输出：</strong>false\\n<strong>解释：</strong>这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>2 <= stones.length <= 2000</code></li>\\n\\t<li><code>0 <= stones[i] <= 2<sup>31</sup> - 1</code></li>\\n\\t<li><code>stones[0] == 0</code></li>\\n</ul>\\n","title":"403. 青蛙过河","relatedTags":["数组","动态规划"],"difficult":"Hard","lang":["javascript","python"],"uniqueID":"403","slug":"403-Frog-Jump"}')}}]);