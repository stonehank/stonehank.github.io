(window.webpackJsonp=window.webpackJsonp||[]).push([[807],{1605:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> longestSubstring = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s, k</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> count\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> limit=<span class=\\"hljs-number\\">1</span>;limit&lt;=<span class=\\"hljs-number\\">26</span>;limit++){\\n    count=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-keyword\\">let</span> uniq=<span class=\\"hljs-number\\">0</span>, valid=<span class=\\"hljs-number\\">0</span>, i=<span class=\\"hljs-number\\">0</span>, j=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">while</span>(j&lt;s.length){\\n      <span class=\\"hljs-keyword\\">if</span>(uniq&lt;=limit){\\n        <span class=\\"hljs-keyword\\">let</span> code=s.charCodeAt(j)<span class=\\"hljs-number\\">-97</span>\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===<span class=\\"hljs-number\\">0</span>)uniq++\\n        count[code]++\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===k)valid++\\n        j++\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-keyword\\">let</span> code=s.charCodeAt(i)<span class=\\"hljs-number\\">-97</span>\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===k)valid--\\n        count[code]--\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===<span class=\\"hljs-number\\">0</span>)uniq--\\n        i++\\n      }\\n      <span class=\\"hljs-keyword\\">if</span>(uniq===limit &amp;&amp; uniq===valid){\\n        max=<span class=\\"hljs-built_in\\">Math</span>.max(j-i,max)\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> max\\n};\\n</code></pre>\\n"],"querySlug":"longest-substring-with-at-least-k-repeating-characters","created_at":"2019-04-27","timeArr":[2019,3,27,15,0,49,0],"hasThinking":true,"thinking":"<hr>\\n<p>思路：</p>\\n<ol>\\n<li><code>Window Slide</code></li>\\n</ol>\\n<p>每次只选取内部存在独立字母为<code>limit</code>子字符串，例如：<code>limit==1</code>，那么可以选取<code>abcdde</code>中的<code>a</code>，<code>b</code>，<code>c</code>，<code>dd</code>，<code>e</code>。</p>\\n<p><code>limit</code>的范围是<code>[1,26]</code>，因为最多26个字母。</p>\\n<p>每一都对<code>limit</code>长度的子字符串进行双指针检测，其中变量<code>uniq</code>表示当前子串里面独立的字母的个数，\\n变量<code>valid</code>表示子串内部有效(个数大于等于<code>k</code>)的字母的个数；</p>\\n<p>如果存在<code>uniq===limit &amp;&amp; uniq===valid</code>，说明子串存在<code>limit</code>个独立字母，并且每个字母出现次数不小于<code>k</code>，可以作为结果并且筛选最大值。</p>\\n<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{string}</span> <span class=\\"hljs-variable\\">s</span></span>\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number}</span> <span class=\\"hljs-variable\\">k</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> longestSubstring = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">s, k</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> count\\n  <span class=\\"hljs-keyword\\">let</span> max=<span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> limit=<span class=\\"hljs-number\\">1</span>;limit&lt;=<span class=\\"hljs-number\\">26</span>;limit++){\\n    count=<span class=\\"hljs-built_in\\">Array</span>(<span class=\\"hljs-number\\">26</span>).fill(<span class=\\"hljs-number\\">0</span>)\\n    <span class=\\"hljs-keyword\\">let</span> uniq=<span class=\\"hljs-number\\">0</span>, valid=<span class=\\"hljs-number\\">0</span>, i=<span class=\\"hljs-number\\">0</span>, j=<span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">while</span>(j&lt;s.length){\\n      <span class=\\"hljs-keyword\\">if</span>(uniq&lt;=limit){\\n        <span class=\\"hljs-keyword\\">let</span> code=s.charCodeAt(j)<span class=\\"hljs-number\\">-97</span>\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===<span class=\\"hljs-number\\">0</span>)uniq++\\n        count[code]++\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===k)valid++\\n        j++\\n      }<span class=\\"hljs-keyword\\">else</span>{\\n        <span class=\\"hljs-keyword\\">let</span> code=s.charCodeAt(i)<span class=\\"hljs-number\\">-97</span>\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===k)valid--\\n        count[code]--\\n        <span class=\\"hljs-keyword\\">if</span>(count[code]===<span class=\\"hljs-number\\">0</span>)uniq--\\n        i++\\n      }\\n      <span class=\\"hljs-keyword\\">if</span>(uniq===limit &amp;&amp; uniq===valid){\\n        max=<span class=\\"hljs-built_in\\">Math</span>.max(j-i,max)\\n      }\\n    }\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> max\\n};\\n</code></pre>\\n<ol start=\\"2\\">\\n<li><code>Recursion</code></li>\\n</ol>\\n<p>对一个字符串<code>s</code>，检查它内部每一个字母，如果发现某一个字母<code>s[i]</code>出现的次数小于<code>k</code>，那么说明包含这个字母的子串一定无效，通过<code>split</code>，以当前无效字母进行分割<code>s</code>，在递归处理每一个分割的子串。</p>\\n<p>一个小优化：可以通过<code>set</code>对字符串去重后再递归处理。</p>\\n","content":"<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"aaabb\\", k = 3\\n<strong>输出：</strong>3\\n<strong>解释：</strong>最长子串为 \\"aaa\\" ，其中 \'a\' 重复了 3 次。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>s = \\"ababbc\\", k = 2\\n<strong>输出：</strong>5\\n<strong>解释：</strong>最长子串为 \\"ababb\\" ，其中 \'a\' 重复了 2 次， \'b\' 重复了 3 次。</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\\n\\t<li><code>s</code> 仅由小写英文字母组成</li>\\n\\t<li><code>1 <= k <= 10<sup>5</sup></code></li>\\n</ul>\\n","title":"395. 至少有 K 个重复字符的最长子串","relatedTags":["哈希表","字符串","分治","滑动窗口"],"difficult":"Middle","lang":["javascript"],"uniqueID":"395","slug":"395-Longest-Substring-with-At-Least-K-Repeating-Characters"}')}}]);