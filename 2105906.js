(window.webpackJsonp=window.webpackJsonp||[]).push([[999],{1797:function(n){n.exports=JSON.parse('{"code":["<pre class=\\"hljs\\"><code><span class=\\"hljs-comment\\">/**\\n * <span class=\\"hljs-doctag\\">@param <span class=\\"hljs-type\\">{number[][]}</span> <span class=\\"hljs-variable\\">nums</span></span>\\n * <span class=\\"hljs-doctag\\">@return <span class=\\"hljs-type\\">{number[]}</span></span>\\n */</span>\\n<span class=\\"hljs-keyword\\">var</span> smallestRange = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">nums</span>) </span>{\\n  <span class=\\"hljs-keyword\\">let</span> N=nums.length\\n  <span class=\\"hljs-keyword\\">let</span> aux=<span class=\\"hljs-built_in\\">Array</span>(N).fill(<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">let</span> pqMin=<span class=\\"hljs-keyword\\">new</span> PriorityQueue(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">a,b</span>)=&gt;</span>a[<span class=\\"hljs-number\\">0</span>]-b[<span class=\\"hljs-number\\">0</span>]&lt;<span class=\\"hljs-number\\">0</span>)\\n  <span class=\\"hljs-keyword\\">let</span> max=-<span class=\\"hljs-literal\\">Infinity</span>\\n  <span class=\\"hljs-keyword\\">for</span>(<span class=\\"hljs-keyword\\">let</span> i=<span class=\\"hljs-number\\">0</span>;i&lt;aux.length;i++){\\n    max=<span class=\\"hljs-built_in\\">Math</span>.max(max,nums[i][aux[i]])\\n    pqMin.insert([nums[i][aux[i]],i])\\n  }\\n  <span class=\\"hljs-keyword\\">let</span> rangeLen=<span class=\\"hljs-literal\\">Infinity</span>,rangeStart=<span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">while</span>(!pqMin.isEmpty()){\\n    <span class=\\"hljs-keyword\\">let</span> [min,id]=pqMin.delMin()\\n    <span class=\\"hljs-keyword\\">if</span>(max-min&lt;rangeLen){\\n      rangeLen=max-min\\n      rangeStart=min\\n    }<span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(max-min===rangeLen){\\n      <span class=\\"hljs-keyword\\">if</span>(min&lt;rangeStart)rangeStart=min\\n    }\\n    aux[id]++\\n    <span class=\\"hljs-keyword\\">if</span>(aux[id]==nums[id].length)<span class=\\"hljs-keyword\\">break</span>\\n    max=<span class=\\"hljs-built_in\\">Math</span>.max(max,nums[id][aux[id]])\\n    pqMin.insert([nums[id][aux[id]],id])\\n   \\n  }\\n  <span class=\\"hljs-keyword\\">return</span> [rangeStart,rangeStart+rangeLen]\\n};\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">PriorityQueue</span>(<span class=\\"hljs-params\\">compareFunction</span>)</span>{\\n  <span class=\\"hljs-keyword\\">let</span> heap=[<span class=\\"hljs-literal\\">null</span>]\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">swim</span>(<span class=\\"hljs-params\\">idx</span>)</span>{\\n    <span class=\\"hljs-keyword\\">if</span>(idx&lt;<span class=\\"hljs-number\\">2</span>)<span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-built_in\\">Math</span>.floor(idx/<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">if</span>(compareFunction(heap[idx],heap[k])){\\n      swap(heap,idx,k)\\n      idx=k\\n      swim(idx)\\n    }\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">sink</span>(<span class=\\"hljs-params\\">idx</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> k=<span class=\\"hljs-built_in\\">Math</span>.floor(idx*<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">if</span>(k&gt;=heap.length)<span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">if</span>(k&lt;heap.length &amp;&amp; heap[k+<span class=\\"hljs-number\\">1</span>] &amp;&amp; compareFunction(heap[k+<span class=\\"hljs-number\\">1</span>],heap[k])) k++\\n    <span class=\\"hljs-keyword\\">if</span>(compareFunction(heap[k],heap[idx])){\\n      swap(heap,idx,k)\\n      idx=k\\n      sink(idx)\\n    }\\n  }\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">swap</span>(<span class=\\"hljs-params\\">arr,i,j</span>)</span>{\\n    <span class=\\"hljs-keyword\\">let</span> temp=arr[i]\\n    arr[i]=arr[j]\\n    arr[j]=temp\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.insert=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">v</span>) </span>{\\n    heap.push(v)\\n    swim(heap.length<span class=\\"hljs-number\\">-1</span>)\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.delMin=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    swap(heap,<span class=\\"hljs-number\\">1</span>,heap.length<span class=\\"hljs-number\\">-1</span>)\\n    <span class=\\"hljs-keyword\\">let</span> min=heap.pop()\\n    sink(<span class=\\"hljs-number\\">1</span>)\\n    <span class=\\"hljs-keyword\\">return</span> min\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.min=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> heap[<span class=\\"hljs-number\\">1</span>]\\n  }\\n  <span class=\\"hljs-keyword\\">this</span>.isEmpty=<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> heap.length===<span class=\\"hljs-number\\">1</span>\\n  }\\n}\\n</code></pre>\\n"],"querySlug":"smallest-range-covering-elements-from-k-lists","created_at":"2019-03-26","timeArr":[2019,2,26,12,11,52,0],"hasThinking":false,"content":"<p>你有 <code>k</code> 个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小 </strong>区间，使得 <code>k</code> 个列表中的每个列表至少有一个数包含在其中。</p>\\n\\n<p>我们定义如果 <code>b-a < d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a < c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>\\n\\n<p> </p>\\n\\n<p><strong>示例 1：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\\n<strong>输出：</strong>[20,24]\\n<strong>解释：</strong> \\n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\\n</pre>\\n\\n<p><strong>示例 2：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [[1,2,3],[1,2,3],[1,2,3]]\\n<strong>输出：</strong>[1,1]\\n</pre>\\n\\n<p><strong>示例 3：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [[10,10],[11,11]]\\n<strong>输出：</strong>[10,11]\\n</pre>\\n\\n<p><strong>示例 4：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [[10],[11]]\\n<strong>输出：</strong>[10,11]\\n</pre>\\n\\n<p><strong>示例 5：</strong></p>\\n\\n<pre>\\n<strong>输入：</strong>nums = [[1],[2],[3],[4],[5],[6],[7]]\\n<strong>输出：</strong>[1,7]\\n</pre>\\n\\n<p> </p>\\n\\n<p><strong>提示：</strong></p>\\n\\n<ul>\\n\\t<li><code>nums.length == k</code></li>\\n\\t<li><code>1 <= k <= 3500</code></li>\\n\\t<li><code>1 <= nums[i].length <= 50</code></li>\\n\\t<li><code>-10<sup>5</sup> <= nums[i][j] <= 10<sup>5</sup></code></li>\\n\\t<li><code>nums[i]</code> 按非递减顺序排列</li>\\n</ul>\\n","title":"632. 最小区间","relatedTags":["贪心","数组","哈希表","排序","滑动窗口","堆（优先队列）"],"difficult":"Hard","lang":["javascript"],"uniqueID":"632","slug":"632-Smallest-Range-Covering-Elements-from-K-Lists"}')}}]);